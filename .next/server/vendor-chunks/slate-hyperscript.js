"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-hyperscript";
exports.ids = ["vendor-chunks/slate-hyperscript"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate-hyperscript/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/slate-hyperscript/dist/index.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEditor: () => (/* binding */ createEditor),\n/* harmony export */   createHyperscript: () => (/* binding */ createHyperscript),\n/* harmony export */   createText: () => (/* binding */ createText),\n/* harmony export */   jsx: () => (/* binding */ jsx)\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n\n\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n/**\r\n * A weak map to hold anchor tokens.\r\n */ var ANCHOR = new WeakMap();\n/**\r\n * A weak map to hold focus tokens.\r\n */ var FOCUS = new WeakMap();\n/**\r\n * All tokens inherit from a single constructor for `instanceof` checking.\r\n */ class Token {\n}\n/**\r\n * Anchor tokens represent the selection's anchor point.\r\n */ class AnchorToken extends Token {\n    constructor(){\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super();\n        var { offset, path } = props;\n        this.offset = offset;\n        this.path = path;\n    }\n}\n/**\r\n * Focus tokens represent the selection's focus point.\r\n */ class FocusToken extends Token {\n    constructor(){\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super();\n        var { offset, path } = props;\n        this.offset = offset;\n        this.path = path;\n    }\n}\n/**\r\n * Add an anchor token to the end of a text node.\r\n */ var addAnchorToken = (text, token)=>{\n    var offset = text.text.length;\n    ANCHOR.set(text, [\n        offset,\n        token\n    ]);\n};\n/**\r\n * Get the offset if a text node has an associated anchor token.\r\n */ var getAnchorOffset = (text)=>{\n    return ANCHOR.get(text);\n};\n/**\r\n * Add a focus token to the end of a text node.\r\n */ var addFocusToken = (text, token)=>{\n    var offset = text.text.length;\n    FOCUS.set(text, [\n        offset,\n        token\n    ]);\n};\n/**\r\n * Get the offset if a text node has an associated focus token.\r\n */ var getFocusOffset = (text)=>{\n    return FOCUS.get(text);\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * Resolve the descedants of a node by normalizing the children that can be\r\n * passed into a hyperscript creator function.\r\n */ var STRINGS = new WeakSet();\nvar resolveDescendants = (children)=>{\n    var nodes = [];\n    var addChild = (child)=>{\n        if (child == null) {\n            return;\n        }\n        var prev = nodes[nodes.length - 1];\n        if (typeof child === \"string\") {\n            var text = {\n                text: child\n            };\n            STRINGS.add(text);\n            child = text;\n        }\n        if (slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(child)) {\n            var c = child; // HACK: fix typescript complaining\n            if (slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(prev) && STRINGS.has(prev) && STRINGS.has(c) && slate__WEBPACK_IMPORTED_MODULE_1__.Text.equals(prev, c, {\n                loose: true\n            })) {\n                prev.text += c.text;\n            } else {\n                nodes.push(c);\n            }\n        } else if (slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(child)) {\n            nodes.push(child);\n        } else if (child instanceof Token) {\n            var n = nodes[nodes.length - 1];\n            if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(n)) {\n                addChild(\"\");\n                n = nodes[nodes.length - 1];\n            }\n            if (child instanceof AnchorToken) {\n                addAnchorToken(n, child);\n            } else if (child instanceof FocusToken) {\n                addFocusToken(n, child);\n            }\n        } else {\n            throw new Error(\"Unexpected hyperscript child object: \".concat(child));\n        }\n    };\n    for (var child of children.flat(Infinity)){\n        addChild(child);\n    }\n    return nodes;\n};\n/**\r\n * Create an anchor token.\r\n */ function createAnchor(tagName, attributes, children) {\n    return new AnchorToken(attributes);\n}\n/**\r\n * Create an anchor and a focus token.\r\n */ function createCursor(tagName, attributes, children) {\n    return [\n        new AnchorToken(attributes),\n        new FocusToken(attributes)\n    ];\n}\n/**\r\n * Create an `Element` object.\r\n */ function createElement(tagName, attributes, children) {\n    return _objectSpread$1(_objectSpread$1({}, attributes), {}, {\n        children: resolveDescendants(children)\n    });\n}\n/**\r\n * Create a focus token.\r\n */ function createFocus(tagName, attributes, children) {\n    return new FocusToken(attributes);\n}\n/**\r\n * Create a fragment.\r\n */ function createFragment(tagName, attributes, children) {\n    return resolveDescendants(children);\n}\n/**\r\n * Create a `Selection` object.\r\n */ function createSelection(tagName, attributes, children) {\n    var anchor = children.find((c)=>c instanceof AnchorToken);\n    var focus = children.find((c)=>c instanceof FocusToken);\n    if (!anchor || anchor.offset == null || anchor.path == null) {\n        throw new Error(\"The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined.\");\n    }\n    if (!focus || focus.offset == null || focus.path == null) {\n        throw new Error(\"The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined.\");\n    }\n    return _objectSpread$1({\n        anchor: {\n            offset: anchor.offset,\n            path: anchor.path\n        },\n        focus: {\n            offset: focus.offset,\n            path: focus.path\n        }\n    }, attributes);\n}\n/**\r\n * Create a `Text` object.\r\n */ function createText(tagName, attributes, children) {\n    var nodes = resolveDescendants(children);\n    if (nodes.length > 1) {\n        throw new Error(\"The <text> hyperscript tag must only contain a single node's worth of children.\");\n    }\n    var [node] = nodes;\n    if (node == null) {\n        node = {\n            text: \"\"\n        };\n    }\n    if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(node)) {\n        throw new Error(\"\\n    The <text> hyperscript tag can only contain text content as children.\");\n    } // COMPAT: If they used the <text> tag we want to guarantee that it won't be\n    // merge with other string children.\n    STRINGS.delete(node);\n    Object.assign(node, attributes);\n    return node;\n}\n/**\r\n * Create a top-level `Editor` object.\r\n */ var createEditor = (makeEditor)=>(tagName, attributes, children)=>{\n        var otherChildren = [];\n        var selectionChild;\n        for (var child of children){\n            if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isRange(child)) {\n                selectionChild = child;\n            } else {\n                otherChildren.push(child);\n            }\n        }\n        var descendants = resolveDescendants(otherChildren);\n        var selection = {};\n        var editor = makeEditor();\n        Object.assign(editor, attributes);\n        editor.children = descendants; // Search the document's texts to see if any of them have tokens associated\n        // that need incorporated into the selection.\n        for (var [node, path] of slate__WEBPACK_IMPORTED_MODULE_1__.Node.texts(editor)){\n            var anchor = getAnchorOffset(node);\n            var focus = getFocusOffset(node);\n            if (anchor != null) {\n                var [offset] = anchor;\n                selection.anchor = {\n                    path,\n                    offset\n                };\n            }\n            if (focus != null) {\n                var [_offset] = focus;\n                selection.focus = {\n                    path,\n                    offset: _offset\n                };\n            }\n        }\n        if (selection.anchor && !selection.focus) {\n            throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead.\");\n        }\n        if (!selection.anchor && selection.focus) {\n            throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead.\");\n        }\n        if (selectionChild != null) {\n            editor.selection = selectionChild;\n        } else if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isRange(selection)) {\n            editor.selection = selection;\n        }\n        return editor;\n    };\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * The default creators for Slate objects.\r\n */ var DEFAULT_CREATORS = {\n    anchor: createAnchor,\n    cursor: createCursor,\n    editor: createEditor(slate__WEBPACK_IMPORTED_MODULE_1__.createEditor),\n    element: createElement,\n    focus: createFocus,\n    fragment: createFragment,\n    selection: createSelection,\n    text: createText\n};\n/**\r\n * Create a Slate hyperscript function with `options`.\r\n */ var createHyperscript = function createHyperscript() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var { elements = {} } = options;\n    var elementCreators = normalizeElements(elements);\n    var creators = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CREATORS), elementCreators), options.creators);\n    var jsx = createFactory(creators);\n    return jsx;\n};\n/**\r\n * Create a Slate hyperscript function with `options`.\r\n */ var createFactory = (creators)=>{\n    var jsx = function jsx(tagName, attributes) {\n        for(var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            children[_key - 2] = arguments[_key];\n        }\n        var creator = creators[tagName];\n        if (!creator) {\n            throw new Error(\"No hyperscript creator found for tag: <\".concat(tagName, \">\"));\n        }\n        if (attributes == null) {\n            attributes = {};\n        }\n        if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(attributes)) {\n            children = [\n                attributes\n            ].concat(children);\n            attributes = {};\n        }\n        children = children.filter((child)=>Boolean(child)).flat();\n        var ret = creator(tagName, attributes, children);\n        return ret;\n    };\n    return jsx;\n};\n/**\r\n * Normalize a dictionary of element shorthands into creator functions.\r\n */ var normalizeElements = (elements)=>{\n    var creators = {};\n    var _loop = function _loop(tagName) {\n        var props = elements[tagName];\n        if (typeof props !== \"object\") {\n            throw new Error(\"Properties specified for a hyperscript shorthand should be an object, but for the custom element <\".concat(tagName, \">  tag you passed: \").concat(props));\n        }\n        creators[tagName] = (tagName, attributes, children)=>{\n            return createElement(\"element\", _objectSpread(_objectSpread({}, props), attributes), children);\n        };\n    };\n    for(var tagName in elements){\n        _loop(tagName);\n    }\n    return creators;\n};\n/**\r\n * The default hyperscript factory that ships with Slate, without custom tags.\r\n */ var jsx = createHyperscript();\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtaHlwZXJzY3JpcHQvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0Q7QUFDbUM7QUFFbkYsU0FBU08sZ0JBQWdCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztJQUN0QyxJQUFJRCxPQUFPRCxLQUFLO1FBQ2RHLE9BQU9DLGNBQWMsQ0FBQ0osS0FBS0MsS0FBSztZQUM5QkMsT0FBT0E7WUFDUEcsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7UUFDWjtJQUNGLE9BQU87UUFDTFAsR0FBRyxDQUFDQyxJQUFJLEdBQUdDO0lBQ2I7SUFFQSxPQUFPRjtBQUNUO0FBRUE7O0NBRUMsR0FDRCxJQUFJUSxTQUFTLElBQUlDO0FBQ2pCOztDQUVDLEdBRUQsSUFBSUMsUUFBUSxJQUFJRDtBQUNoQjs7Q0FFQyxHQUVELE1BQU1FO0FBQU87QUFDYjs7Q0FFQyxHQUVELE1BQU1DLG9CQUFvQkQ7SUFDeEJFLGFBQWM7UUFDWixJQUFJQyxRQUFRQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ2pGLEtBQUs7UUFDTCxJQUFJLEVBQ0ZHLE1BQU0sRUFDTkMsSUFBSSxFQUNMLEdBQUdMO1FBQ0osSUFBSSxDQUFDSSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO0lBQ2Q7QUFFRjtBQUNBOztDQUVDLEdBRUQsTUFBTUMsbUJBQW1CVDtJQUN2QkUsYUFBYztRQUNaLElBQUlDLFFBQVFDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDakYsS0FBSztRQUNMLElBQUksRUFDRkcsTUFBTSxFQUNOQyxJQUFJLEVBQ0wsR0FBR0w7UUFDSixJQUFJLENBQUNJLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUND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QUNGO0lBRUEsSUFBSyxJQUFJa0IsV0FBVytCLFNBQVU7UUFDNUJZLE1BQU0zQztJQUNSO0lBRUEsT0FBT2tDO0FBQ1Q7QUFFQTs7Q0FFQyxHQUVELElBQUlDLE1BQU1OO0FBRWtELENBQzVELG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2JpZ2NvbW1lcmNlLy4vbm9kZV9tb2R1bGVzL3NsYXRlLWh5cGVyc2NyaXB0L2Rpc3QvaW5kZXguZXMuanM/OWFkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnaXMtcGxhaW4tb2JqZWN0JztcbmltcG9ydCB7IFRleHQsIFJhbmdlLCBOb2RlLCBFbGVtZW50LCBjcmVhdGVFZGl0b3IgYXMgY3JlYXRlRWRpdG9yJDEgfSBmcm9tICdzbGF0ZSc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcclxuICogQSB3ZWFrIG1hcCB0byBob2xkIGFuY2hvciB0b2tlbnMuXHJcbiAqL1xudmFyIEFOQ0hPUiA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogQSB3ZWFrIG1hcCB0byBob2xkIGZvY3VzIHRva2Vucy5cclxuICovXG5cbnZhciBGT0NVUyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogQWxsIHRva2VucyBpbmhlcml0IGZyb20gYSBzaW5nbGUgY29uc3RydWN0b3IgZm9yIGBpbnN0YW5jZW9mYCBjaGVja2luZy5cclxuICovXG5cbmNsYXNzIFRva2VuIHt9XG4vKipcclxuICogQW5jaG9yIHRva2VucyByZXByZXNlbnQgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBwb2ludC5cclxuICovXG5cbmNsYXNzIEFuY2hvclRva2VuIGV4dGVuZHMgVG9rZW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdmFyIHtcbiAgICAgIG9mZnNldCxcbiAgICAgIHBhdGhcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxuXG59XG4vKipcclxuICogRm9jdXMgdG9rZW5zIHJlcHJlc2VudCB0aGUgc2VsZWN0aW9uJ3MgZm9jdXMgcG9pbnQuXHJcbiAqL1xuXG5jbGFzcyBGb2N1c1Rva2VuIGV4dGVuZHMgVG9rZW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdmFyIHtcbiAgICAgIG9mZnNldCxcbiAgICAgIHBhdGhcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxuXG59XG4vKipcclxuICogQWRkIGFuIGFuY2hvciB0b2tlbiB0byB0aGUgZW5kIG9mIGEgdGV4dCBub2RlLlxyXG4gKi9cblxudmFyIGFkZEFuY2hvclRva2VuID0gKHRleHQsIHRva2VuKSA9PiB7XG4gIHZhciBvZmZzZXQgPSB0ZXh0LnRleHQubGVuZ3RoO1xuICBBTkNIT1Iuc2V0KHRleHQsIFtvZmZzZXQsIHRva2VuXSk7XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgb2Zmc2V0IGlmIGEgdGV4dCBub2RlIGhhcyBhbiBhc3NvY2lhdGVkIGFuY2hvciB0b2tlbi5cclxuICovXG5cbnZhciBnZXRBbmNob3JPZmZzZXQgPSB0ZXh0ID0+IHtcbiAgcmV0dXJuIEFOQ0hPUi5nZXQodGV4dCk7XG59O1xuLyoqXHJcbiAqIEFkZCBhIGZvY3VzIHRva2VuIHRvIHRoZSBlbmQgb2YgYSB0ZXh0IG5vZGUuXHJcbiAqL1xuXG52YXIgYWRkRm9jdXNUb2tlbiA9ICh0ZXh0LCB0b2tlbikgPT4ge1xuICB2YXIgb2Zmc2V0ID0gdGV4dC50ZXh0Lmxlbmd0aDtcbiAgRk9DVVMuc2V0KHRleHQsIFtvZmZzZXQsIHRva2VuXSk7XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgb2Zmc2V0IGlmIGEgdGV4dCBub2RlIGhhcyBhbiBhc3NvY2lhdGVkIGZvY3VzIHRva2VuLlxyXG4gKi9cblxudmFyIGdldEZvY3VzT2Zmc2V0ID0gdGV4dCA9PiB7XG4gIHJldHVybiBGT0NVUy5nZXQodGV4dCk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxyXG4gKiBSZXNvbHZlIHRoZSBkZXNjZWRhbnRzIG9mIGEgbm9kZSBieSBub3JtYWxpemluZyB0aGUgY2hpbGRyZW4gdGhhdCBjYW4gYmVcclxuICogcGFzc2VkIGludG8gYSBoeXBlcnNjcmlwdCBjcmVhdG9yIGZ1bmN0aW9uLlxyXG4gKi9cblxudmFyIFNUUklOR1MgPSBuZXcgV2Vha1NldCgpO1xuXG52YXIgcmVzb2x2ZURlc2NlbmRhbnRzID0gY2hpbGRyZW4gPT4ge1xuICB2YXIgbm9kZXMgPSBbXTtcblxuICB2YXIgYWRkQ2hpbGQgPSBjaGlsZCA9PiB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciB0ZXh0ID0ge1xuICAgICAgICB0ZXh0OiBjaGlsZFxuICAgICAgfTtcbiAgICAgIFNUUklOR1MuYWRkKHRleHQpO1xuICAgICAgY2hpbGQgPSB0ZXh0O1xuICAgIH1cblxuICAgIGlmIChUZXh0LmlzVGV4dChjaGlsZCkpIHtcbiAgICAgIHZhciBjID0gY2hpbGQ7IC8vIEhBQ0s6IGZpeCB0eXBlc2NyaXB0IGNvbXBsYWluaW5nXG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChwcmV2KSAmJiBTVFJJTkdTLmhhcyhwcmV2KSAmJiBTVFJJTkdTLmhhcyhjKSAmJiBUZXh0LmVxdWFscyhwcmV2LCBjLCB7XG4gICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICB9KSkge1xuICAgICAgICBwcmV2LnRleHQgKz0gYy50ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KGNoaWxkKSkge1xuICAgICAgbm9kZXMucHVzaChjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRva2VuKSB7XG4gICAgICB2YXIgbiA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG4pKSB7XG4gICAgICAgIGFkZENoaWxkKCcnKTtcbiAgICAgICAgbiA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBBbmNob3JUb2tlbikge1xuICAgICAgICBhZGRBbmNob3JUb2tlbihuLCBjaGlsZCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgRm9jdXNUb2tlbikge1xuICAgICAgICBhZGRGb2N1c1Rva2VuKG4sIGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBoeXBlcnNjcmlwdCBjaGlsZCBvYmplY3Q6IFwiLmNvbmNhdChjaGlsZCkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBjaGlsZCBvZiBjaGlsZHJlbi5mbGF0KEluZmluaXR5KSkge1xuICAgIGFkZENoaWxkKGNoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn07XG4vKipcclxuICogQ3JlYXRlIGFuIGFuY2hvciB0b2tlbi5cclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQW5jaG9yKHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSB7XG4gIHJldHVybiBuZXcgQW5jaG9yVG9rZW4oYXR0cmlidXRlcyk7XG59XG4vKipcclxuICogQ3JlYXRlIGFuIGFuY2hvciBhbmQgYSBmb2N1cyB0b2tlbi5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcih0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICByZXR1cm4gW25ldyBBbmNob3JUb2tlbihhdHRyaWJ1dGVzKSwgbmV3IEZvY3VzVG9rZW4oYXR0cmlidXRlcyldO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhbiBgRWxlbWVudGAgb2JqZWN0LlxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICByZXR1cm4gX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgYXR0cmlidXRlcyksIHt9LCB7XG4gICAgY2hpbGRyZW46IHJlc29sdmVEZXNjZW5kYW50cyhjaGlsZHJlbilcbiAgfSk7XG59XG4vKipcclxuICogQ3JlYXRlIGEgZm9jdXMgdG9rZW4uXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGb2N1cyh0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICByZXR1cm4gbmV3IEZvY3VzVG9rZW4oYXR0cmlidXRlcyk7XG59XG4vKipcclxuICogQ3JlYXRlIGEgZnJhZ21lbnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudCh0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICByZXR1cm4gcmVzb2x2ZURlc2NlbmRhbnRzKGNoaWxkcmVuKTtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb24odGFnTmFtZSwgYXR0cmlidXRlcywgY2hpbGRyZW4pIHtcbiAgdmFyIGFuY2hvciA9IGNoaWxkcmVuLmZpbmQoYyA9PiBjIGluc3RhbmNlb2YgQW5jaG9yVG9rZW4pO1xuICB2YXIgZm9jdXMgPSBjaGlsZHJlbi5maW5kKGMgPT4gYyBpbnN0YW5jZW9mIEZvY3VzVG9rZW4pO1xuXG4gIGlmICghYW5jaG9yIHx8IGFuY2hvci5vZmZzZXQgPT0gbnVsbCB8fCBhbmNob3IucGF0aCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIDxzZWxlY3Rpb24+IGh5cGVyc2NyaXB0IHRhZyBtdXN0IGhhdmUgYW4gPGFuY2hvcj4gdGFnIGFzIGEgY2hpbGQgd2l0aCBgcGF0aGAgYW5kIGBvZmZzZXRgIGF0dHJpYnV0ZXMgZGVmaW5lZC5cIik7XG4gIH1cblxuICBpZiAoIWZvY3VzIHx8IGZvY3VzLm9mZnNldCA9PSBudWxsIHx8IGZvY3VzLnBhdGggPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSA8c2VsZWN0aW9uPiBoeXBlcnNjcmlwdCB0YWcgbXVzdCBoYXZlIGEgPGZvY3VzPiB0YWcgYXMgYSBjaGlsZCB3aXRoIGBwYXRoYCBhbmQgYG9mZnNldGAgYXR0cmlidXRlcyBkZWZpbmVkLlwiKTtcbiAgfVxuXG4gIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoe1xuICAgIGFuY2hvcjoge1xuICAgICAgb2Zmc2V0OiBhbmNob3Iub2Zmc2V0LFxuICAgICAgcGF0aDogYW5jaG9yLnBhdGhcbiAgICB9LFxuICAgIGZvY3VzOiB7XG4gICAgICBvZmZzZXQ6IGZvY3VzLm9mZnNldCxcbiAgICAgIHBhdGg6IGZvY3VzLnBhdGhcbiAgICB9XG4gIH0sIGF0dHJpYnV0ZXMpO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIGBUZXh0YCBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0KHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSB7XG4gIHZhciBub2RlcyA9IHJlc29sdmVEZXNjZW5kYW50cyhjaGlsZHJlbik7XG5cbiAgaWYgKG5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgPHRleHQ+IGh5cGVyc2NyaXB0IHRhZyBtdXN0IG9ubHkgY29udGFpbiBhIHNpbmdsZSBub2RlJ3Mgd29ydGggb2YgY2hpbGRyZW4uXCIpO1xuICB9XG5cbiAgdmFyIFtub2RlXSA9IG5vZGVzO1xuXG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICBub2RlID0ge1xuICAgICAgdGV4dDogJydcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICBUaGUgPHRleHQ+IGh5cGVyc2NyaXB0IHRhZyBjYW4gb25seSBjb250YWluIHRleHQgY29udGVudCBhcyBjaGlsZHJlbi5cIik7XG4gIH0gLy8gQ09NUEFUOiBJZiB0aGV5IHVzZWQgdGhlIDx0ZXh0PiB0YWcgd2Ugd2FudCB0byBndWFyYW50ZWUgdGhhdCBpdCB3b24ndCBiZVxuICAvLyBtZXJnZSB3aXRoIG90aGVyIHN0cmluZyBjaGlsZHJlbi5cblxuXG4gIFNUUklOR1MuZGVsZXRlKG5vZGUpO1xuICBPYmplY3QuYXNzaWduKG5vZGUsIGF0dHJpYnV0ZXMpO1xuICByZXR1cm4gbm9kZTtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSB0b3AtbGV2ZWwgYEVkaXRvcmAgb2JqZWN0LlxyXG4gKi9cblxudmFyIGNyZWF0ZUVkaXRvciA9IG1ha2VFZGl0b3IgPT4gKHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSA9PiB7XG4gIHZhciBvdGhlckNoaWxkcmVuID0gW107XG4gIHZhciBzZWxlY3Rpb25DaGlsZDtcblxuICBmb3IgKHZhciBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKGNoaWxkKSkge1xuICAgICAgc2VsZWN0aW9uQ2hpbGQgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXJDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVzY2VuZGFudHMgPSByZXNvbHZlRGVzY2VuZGFudHMob3RoZXJDaGlsZHJlbik7XG4gIHZhciBzZWxlY3Rpb24gPSB7fTtcbiAgdmFyIGVkaXRvciA9IG1ha2VFZGl0b3IoKTtcbiAgT2JqZWN0LmFzc2lnbihlZGl0b3IsIGF0dHJpYnV0ZXMpO1xuICBlZGl0b3IuY2hpbGRyZW4gPSBkZXNjZW5kYW50czsgLy8gU2VhcmNoIHRoZSBkb2N1bWVudCdzIHRleHRzIHRvIHNlZSBpZiBhbnkgb2YgdGhlbSBoYXZlIHRva2VucyBhc3NvY2lhdGVkXG4gIC8vIHRoYXQgbmVlZCBpbmNvcnBvcmF0ZWQgaW50byB0aGUgc2VsZWN0aW9uLlxuXG4gIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBOb2RlLnRleHRzKGVkaXRvcikpIHtcbiAgICB2YXIgYW5jaG9yID0gZ2V0QW5jaG9yT2Zmc2V0KG5vZGUpO1xuICAgIHZhciBmb2N1cyA9IGdldEZvY3VzT2Zmc2V0KG5vZGUpO1xuXG4gICAgaWYgKGFuY2hvciAhPSBudWxsKSB7XG4gICAgICB2YXIgW29mZnNldF0gPSBhbmNob3I7XG4gICAgICBzZWxlY3Rpb24uYW5jaG9yID0ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGZvY3VzICE9IG51bGwpIHtcbiAgICAgIHZhciBbX29mZnNldF0gPSBmb2N1cztcbiAgICAgIHNlbGVjdGlvbi5mb2N1cyA9IHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxlY3Rpb24uYW5jaG9yICYmICFzZWxlY3Rpb24uZm9jdXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGF0ZSBoeXBlcnNjcmlwdCByYW5nZXMgbXVzdCBoYXZlIGJvdGggYDxhbmNob3IgLz5gIGFuZCBgPGZvY3VzIC8+YCBkZWZpbmVkIGlmIG9uZSBpcyBkZWZpbmVkLCBidXQgeW91IG9ubHkgZGVmaW5lZCBgPGFuY2hvciAvPmAuIEZvciBjb2xsYXBzZWQgc2VsZWN0aW9ucywgdXNlIGA8Y3Vyc29yIC8+YCBpbnN0ZWFkLlwiKTtcbiAgfVxuXG4gIGlmICghc2VsZWN0aW9uLmFuY2hvciAmJiBzZWxlY3Rpb24uZm9jdXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGF0ZSBoeXBlcnNjcmlwdCByYW5nZXMgbXVzdCBoYXZlIGJvdGggYDxhbmNob3IgLz5gIGFuZCBgPGZvY3VzIC8+YCBkZWZpbmVkIGlmIG9uZSBpcyBkZWZpbmVkLCBidXQgeW91IG9ubHkgZGVmaW5lZCBgPGZvY3VzIC8+YC4gRm9yIGNvbGxhcHNlZCBzZWxlY3Rpb25zLCB1c2UgYDxjdXJzb3IgLz5gIGluc3RlYWQuXCIpO1xuICB9XG5cbiAgaWYgKHNlbGVjdGlvbkNoaWxkICE9IG51bGwpIHtcbiAgICBlZGl0b3Iuc2VsZWN0aW9uID0gc2VsZWN0aW9uQ2hpbGQ7XG4gIH0gZWxzZSBpZiAoUmFuZ2UuaXNSYW5nZShzZWxlY3Rpb24pKSB7XG4gICAgZWRpdG9yLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcclxuICogVGhlIGRlZmF1bHQgY3JlYXRvcnMgZm9yIFNsYXRlIG9iamVjdHMuXHJcbiAqL1xuXG52YXIgREVGQVVMVF9DUkVBVE9SUyA9IHtcbiAgYW5jaG9yOiBjcmVhdGVBbmNob3IsXG4gIGN1cnNvcjogY3JlYXRlQ3Vyc29yLFxuICBlZGl0b3I6IGNyZWF0ZUVkaXRvcihjcmVhdGVFZGl0b3IkMSksXG4gIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGZvY3VzOiBjcmVhdGVGb2N1cyxcbiAgZnJhZ21lbnQ6IGNyZWF0ZUZyYWdtZW50LFxuICBzZWxlY3Rpb246IGNyZWF0ZVNlbGVjdGlvbixcbiAgdGV4dDogY3JlYXRlVGV4dFxufTtcbi8qKlxyXG4gKiBDcmVhdGUgYSBTbGF0ZSBoeXBlcnNjcmlwdCBmdW5jdGlvbiB3aXRoIGBvcHRpb25zYC5cclxuICovXG5cbnZhciBjcmVhdGVIeXBlcnNjcmlwdCA9IGZ1bmN0aW9uIGNyZWF0ZUh5cGVyc2NyaXB0KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciB7XG4gICAgZWxlbWVudHMgPSB7fVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIGVsZW1lbnRDcmVhdG9ycyA9IG5vcm1hbGl6ZUVsZW1lbnRzKGVsZW1lbnRzKTtcblxuICB2YXIgY3JlYXRvcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgREVGQVVMVF9DUkVBVE9SUyksIGVsZW1lbnRDcmVhdG9ycyksIG9wdGlvbnMuY3JlYXRvcnMpO1xuXG4gIHZhciBqc3ggPSBjcmVhdGVGYWN0b3J5KGNyZWF0b3JzKTtcbiAgcmV0dXJuIGpzeDtcbn07XG4vKipcclxuICogQ3JlYXRlIGEgU2xhdGUgaHlwZXJzY3JpcHQgZnVuY3Rpb24gd2l0aCBgb3B0aW9uc2AuXHJcbiAqL1xuXG5cbnZhciBjcmVhdGVGYWN0b3J5ID0gY3JlYXRvcnMgPT4ge1xuICB2YXIganN4ID0gZnVuY3Rpb24ganN4KHRhZ05hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgY2hpbGRyZW5bX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBjcmVhdG9yID0gY3JlYXRvcnNbdGFnTmFtZV07XG5cbiAgICBpZiAoIWNyZWF0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGh5cGVyc2NyaXB0IGNyZWF0b3IgZm91bmQgZm9yIHRhZzogPFwiLmNvbmNhdCh0YWdOYW1lLCBcIj5cIikpO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgIGNoaWxkcmVuID0gW2F0dHJpYnV0ZXNdLmNvbmNhdChjaGlsZHJlbik7XG4gICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgfVxuXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gQm9vbGVhbihjaGlsZCkpLmZsYXQoKTtcbiAgICB2YXIgcmV0ID0gY3JlYXRvcih0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbik7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4ganN4O1xufTtcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSBkaWN0aW9uYXJ5IG9mIGVsZW1lbnQgc2hvcnRoYW5kcyBpbnRvIGNyZWF0b3IgZnVuY3Rpb25zLlxyXG4gKi9cblxuXG52YXIgbm9ybWFsaXplRWxlbWVudHMgPSBlbGVtZW50cyA9PiB7XG4gIHZhciBjcmVhdG9ycyA9IHt9O1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHRhZ05hbWUpIHtcbiAgICB2YXIgcHJvcHMgPSBlbGVtZW50c1t0YWdOYW1lXTtcblxuICAgIGlmICh0eXBlb2YgcHJvcHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9wZXJ0aWVzIHNwZWNpZmllZCBmb3IgYSBoeXBlcnNjcmlwdCBzaG9ydGhhbmQgc2hvdWxkIGJlIGFuIG9iamVjdCwgYnV0IGZvciB0aGUgY3VzdG9tIGVsZW1lbnQgPFwiLmNvbmNhdCh0YWdOYW1lLCBcIj4gIHRhZyB5b3UgcGFzc2VkOiBcIikuY29uY2F0KHByb3BzKSk7XG4gICAgfVxuXG4gICAgY3JlYXRvcnNbdGFnTmFtZV0gPSAodGFnTmFtZSwgYXR0cmlidXRlcywgY2hpbGRyZW4pID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdlbGVtZW50JywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIGF0dHJpYnV0ZXMpLCBjaGlsZHJlbik7XG4gICAgfTtcbiAgfTtcblxuICBmb3IgKHZhciB0YWdOYW1lIGluIGVsZW1lbnRzKSB7XG4gICAgX2xvb3AodGFnTmFtZSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRvcnM7XG59O1xuXG4vKipcclxuICogVGhlIGRlZmF1bHQgaHlwZXJzY3JpcHQgZmFjdG9yeSB0aGF0IHNoaXBzIHdpdGggU2xhdGUsIHdpdGhvdXQgY3VzdG9tIHRhZ3MuXHJcbiAqL1xuXG52YXIganN4ID0gY3JlYXRlSHlwZXJzY3JpcHQoKTtcblxuZXhwb3J0IHsgY3JlYXRlRWRpdG9yLCBjcmVhdGVIeXBlcnNjcmlwdCwgY3JlYXRlVGV4dCwganN4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc1BsYWluT2JqZWN0IiwiVGV4dCIsIlJhbmdlIiwiTm9kZSIsIkVsZW1lbnQiLCJjcmVhdGVFZGl0b3IiLCJjcmVhdGVFZGl0b3IkMSIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJBTkNIT1IiLCJXZWFrTWFwIiwiRk9DVVMiLCJUb2tlbiIsIkFuY2hvclRva2VuIiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsIm9mZnNldCIsInBhdGgiLCJGb2N1c1Rva2VuIiwiYWRkQW5jaG9yVG9rZW4iLCJ0ZXh0IiwidG9rZW4iLCJzZXQiLCJnZXRBbmNob3JPZmZzZXQiLCJnZXQiLCJhZGRGb2N1c1Rva2VuIiwiZ2V0Rm9jdXNPZmZzZXQiLCJvd25LZXlzJDEiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCQxIiwidGFyZ2V0IiwiaSIsInNvdXJjZSIsImZvckVhY2giLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIlNUUklOR1MiLCJXZWFrU2V0IiwicmVzb2x2ZURlc2NlbmRhbnRzIiwiY2hpbGRyZW4iLCJub2RlcyIsImFkZENoaWxkIiwiY2hpbGQiLCJwcmV2IiwiYWRkIiwiaXNUZXh0IiwiYyIsImhhcyIsImVxdWFscyIsImxvb3NlIiwiaXNFbGVtZW50IiwibiIsIkVycm9yIiwiY29uY2F0IiwiZmxhdCIsIkluZmluaXR5IiwiY3JlYXRlQW5jaG9yIiwidGFnTmFtZSIsImF0dHJpYnV0ZXMiLCJjcmVhdGVDdXJzb3IiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlRm9jdXMiLCJjcmVhdGVGcmFnbWVudCIsImNyZWF0ZVNlbGVjdGlvbiIsImFuY2hvciIsImZpbmQiLCJmb2N1cyIsImNyZWF0ZVRleHQiLCJub2RlIiwiZGVsZXRlIiwiYXNzaWduIiwibWFrZUVkaXRvciIsIm90aGVyQ2hpbGRyZW4iLCJzZWxlY3Rpb25DaGlsZCIsImlzUmFuZ2UiLCJkZXNjZW5kYW50cyIsInNlbGVjdGlvbiIsImVkaXRvciIsInRleHRzIiwiX29mZnNldCIsIm93bktleXMiLCJfb2JqZWN0U3ByZWFkIiwiREVGQVVMVF9DUkVBVE9SUyIsImN1cnNvciIsImVsZW1lbnQiLCJmcmFnbWVudCIsImNyZWF0ZUh5cGVyc2NyaXB0Iiwib3B0aW9ucyIsImVsZW1lbnRzIiwiZWxlbWVudENyZWF0b3JzIiwibm9ybWFsaXplRWxlbWVudHMiLCJjcmVhdG9ycyIsImpzeCIsImNyZWF0ZUZhY3RvcnkiLCJfbGVuIiwiQXJyYXkiLCJfa2V5IiwiY3JlYXRvciIsIkJvb2xlYW4iLCJyZXQiLCJfbG9vcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-hyperscript/dist/index.es.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/slate-hyperscript/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/slate-hyperscript/dist/index.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEditor: () => (/* binding */ createEditor),\n/* harmony export */   createHyperscript: () => (/* binding */ createHyperscript),\n/* harmony export */   createText: () => (/* binding */ createText),\n/* harmony export */   jsx: () => (/* binding */ jsx)\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"(rsc)/./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"(rsc)/./node_modules/slate/dist/index.es.js\");\n\n\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n/**\r\n * A weak map to hold anchor tokens.\r\n */ var ANCHOR = new WeakMap();\n/**\r\n * A weak map to hold focus tokens.\r\n */ var FOCUS = new WeakMap();\n/**\r\n * All tokens inherit from a single constructor for `instanceof` checking.\r\n */ class Token {\n}\n/**\r\n * Anchor tokens represent the selection's anchor point.\r\n */ class AnchorToken extends Token {\n    constructor(){\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super();\n        var { offset, path } = props;\n        this.offset = offset;\n        this.path = path;\n    }\n}\n/**\r\n * Focus tokens represent the selection's focus point.\r\n */ class FocusToken extends Token {\n    constructor(){\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super();\n        var { offset, path } = props;\n        this.offset = offset;\n        this.path = path;\n    }\n}\n/**\r\n * Add an anchor token to the end of a text node.\r\n */ var addAnchorToken = (text, token)=>{\n    var offset = text.text.length;\n    ANCHOR.set(text, [\n        offset,\n        token\n    ]);\n};\n/**\r\n * Get the offset if a text node has an associated anchor token.\r\n */ var getAnchorOffset = (text)=>{\n    return ANCHOR.get(text);\n};\n/**\r\n * Add a focus token to the end of a text node.\r\n */ var addFocusToken = (text, token)=>{\n    var offset = text.text.length;\n    FOCUS.set(text, [\n        offset,\n        token\n    ]);\n};\n/**\r\n * Get the offset if a text node has an associated focus token.\r\n */ var getFocusOffset = (text)=>{\n    return FOCUS.get(text);\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * Resolve the descedants of a node by normalizing the children that can be\r\n * passed into a hyperscript creator function.\r\n */ var STRINGS = new WeakSet();\nvar resolveDescendants = (children)=>{\n    var nodes = [];\n    var addChild = (child)=>{\n        if (child == null) {\n            return;\n        }\n        var prev = nodes[nodes.length - 1];\n        if (typeof child === \"string\") {\n            var text = {\n                text: child\n            };\n            STRINGS.add(text);\n            child = text;\n        }\n        if (slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(child)) {\n            var c = child; // HACK: fix typescript complaining\n            if (slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(prev) && STRINGS.has(prev) && STRINGS.has(c) && slate__WEBPACK_IMPORTED_MODULE_1__.Text.equals(prev, c, {\n                loose: true\n            })) {\n                prev.text += c.text;\n            } else {\n                nodes.push(c);\n            }\n        } else if (slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(child)) {\n            nodes.push(child);\n        } else if (child instanceof Token) {\n            var n = nodes[nodes.length - 1];\n            if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(n)) {\n                addChild(\"\");\n                n = nodes[nodes.length - 1];\n            }\n            if (child instanceof AnchorToken) {\n                addAnchorToken(n, child);\n            } else if (child instanceof FocusToken) {\n                addFocusToken(n, child);\n            }\n        } else {\n            throw new Error(\"Unexpected hyperscript child object: \".concat(child));\n        }\n    };\n    for (var child of children.flat(Infinity)){\n        addChild(child);\n    }\n    return nodes;\n};\n/**\r\n * Create an anchor token.\r\n */ function createAnchor(tagName, attributes, children) {\n    return new AnchorToken(attributes);\n}\n/**\r\n * Create an anchor and a focus token.\r\n */ function createCursor(tagName, attributes, children) {\n    return [\n        new AnchorToken(attributes),\n        new FocusToken(attributes)\n    ];\n}\n/**\r\n * Create an `Element` object.\r\n */ function createElement(tagName, attributes, children) {\n    return _objectSpread$1(_objectSpread$1({}, attributes), {}, {\n        children: resolveDescendants(children)\n    });\n}\n/**\r\n * Create a focus token.\r\n */ function createFocus(tagName, attributes, children) {\n    return new FocusToken(attributes);\n}\n/**\r\n * Create a fragment.\r\n */ function createFragment(tagName, attributes, children) {\n    return resolveDescendants(children);\n}\n/**\r\n * Create a `Selection` object.\r\n */ function createSelection(tagName, attributes, children) {\n    var anchor = children.find((c)=>c instanceof AnchorToken);\n    var focus = children.find((c)=>c instanceof FocusToken);\n    if (!anchor || anchor.offset == null || anchor.path == null) {\n        throw new Error(\"The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined.\");\n    }\n    if (!focus || focus.offset == null || focus.path == null) {\n        throw new Error(\"The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined.\");\n    }\n    return _objectSpread$1({\n        anchor: {\n            offset: anchor.offset,\n            path: anchor.path\n        },\n        focus: {\n            offset: focus.offset,\n            path: focus.path\n        }\n    }, attributes);\n}\n/**\r\n * Create a `Text` object.\r\n */ function createText(tagName, attributes, children) {\n    var nodes = resolveDescendants(children);\n    if (nodes.length > 1) {\n        throw new Error(\"The <text> hyperscript tag must only contain a single node's worth of children.\");\n    }\n    var [node] = nodes;\n    if (node == null) {\n        node = {\n            text: \"\"\n        };\n    }\n    if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(node)) {\n        throw new Error(\"\\n    The <text> hyperscript tag can only contain text content as children.\");\n    } // COMPAT: If they used the <text> tag we want to guarantee that it won't be\n    // merge with other string children.\n    STRINGS.delete(node);\n    Object.assign(node, attributes);\n    return node;\n}\n/**\r\n * Create a top-level `Editor` object.\r\n */ var createEditor = (makeEditor)=>(tagName, attributes, children)=>{\n        var otherChildren = [];\n        var selectionChild;\n        for (var child of children){\n            if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isRange(child)) {\n                selectionChild = child;\n            } else {\n                otherChildren.push(child);\n            }\n        }\n        var descendants = resolveDescendants(otherChildren);\n        var selection = {};\n        var editor = makeEditor();\n        Object.assign(editor, attributes);\n        editor.children = descendants; // Search the document's texts to see if any of them have tokens associated\n        // that need incorporated into the selection.\n        for (var [node, path] of slate__WEBPACK_IMPORTED_MODULE_1__.Node.texts(editor)){\n            var anchor = getAnchorOffset(node);\n            var focus = getFocusOffset(node);\n            if (anchor != null) {\n                var [offset] = anchor;\n                selection.anchor = {\n                    path,\n                    offset\n                };\n            }\n            if (focus != null) {\n                var [_offset] = focus;\n                selection.focus = {\n                    path,\n                    offset: _offset\n                };\n            }\n        }\n        if (selection.anchor && !selection.focus) {\n            throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead.\");\n        }\n        if (!selection.anchor && selection.focus) {\n            throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead.\");\n        }\n        if (selectionChild != null) {\n            editor.selection = selectionChild;\n        } else if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isRange(selection)) {\n            editor.selection = selection;\n        }\n        return editor;\n    };\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * The default creators for Slate objects.\r\n */ var DEFAULT_CREATORS = {\n    anchor: createAnchor,\n    cursor: createCursor,\n    editor: createEditor(slate__WEBPACK_IMPORTED_MODULE_1__.createEditor),\n    element: createElement,\n    focus: createFocus,\n    fragment: createFragment,\n    selection: createSelection,\n    text: createText\n};\n/**\r\n * Create a Slate hyperscript function with `options`.\r\n */ var createHyperscript = function createHyperscript() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var { elements = {} } = options;\n    var elementCreators = normalizeElements(elements);\n    var creators = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CREATORS), elementCreators), options.creators);\n    var jsx = createFactory(creators);\n    return jsx;\n};\n/**\r\n * Create a Slate hyperscript function with `options`.\r\n */ var createFactory = (creators)=>{\n    var jsx = function jsx(tagName, attributes) {\n        for(var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            children[_key - 2] = arguments[_key];\n        }\n        var creator = creators[tagName];\n        if (!creator) {\n            throw new Error(\"No hyperscript creator found for tag: <\".concat(tagName, \">\"));\n        }\n        if (attributes == null) {\n            attributes = {};\n        }\n        if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(attributes)) {\n            children = [\n                attributes\n            ].concat(children);\n            attributes = {};\n        }\n        children = children.filter((child)=>Boolean(child)).flat();\n        var ret = creator(tagName, attributes, children);\n        return ret;\n    };\n    return jsx;\n};\n/**\r\n * Normalize a dictionary of element shorthands into creator functions.\r\n */ var normalizeElements = (elements)=>{\n    var creators = {};\n    var _loop = function _loop(tagName) {\n        var props = elements[tagName];\n        if (typeof props !== \"object\") {\n            throw new Error(\"Properties specified for a hyperscript shorthand should be an object, but for the custom element <\".concat(tagName, \">  tag you passed: \").concat(props));\n        }\n        creators[tagName] = (tagName, attributes, children)=>{\n            return createElement(\"element\", _objectSpread(_objectSpread({}, props), attributes), children);\n        };\n    };\n    for(var tagName in elements){\n        _loop(tagName);\n    }\n    return creators;\n};\n/**\r\n * The default hyperscript factory that ships with Slate, without custom tags.\r\n */ var jsx = createHyperscript();\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2xhdGUtaHlwZXJzY3JpcHQvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0Q7QUFDbUM7QUFFbkYsU0FBU08sZ0JBQWdCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztJQUN0QyxJQUFJRCxPQUFPRCxLQUFLO1FBQ2RHLE9BQU9DLGNBQWMsQ0FBQ0osS0FBS0MsS0FBSztZQUM5QkMsT0FBT0E7WUFDUEcsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7UUFDWjtJQUNGLE9BQU87UUFDTFAsR0FBRyxDQUFDQyxJQUFJLEdBQUdDO0lBQ2I7SUFFQSxPQUFPRjtBQUNUO0FBRUE7O0NBRUMsR0FDRCxJQUFJUSxTQUFTLElBQUlDO0FBQ2pCOztDQUVDLEdBRUQsSUFBSUMsUUFBUSxJQUFJRDtBQUNoQjs7Q0FFQyxHQUVELE1BQU1FO0FBQU87QUFDYjs7Q0FFQyxHQUVELE1BQU1DLG9CQUFvQkQ7SUFDeEJFLGFBQWM7UUFDWixJQUFJQyxRQUFRQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ2pGLEtBQUs7UUFDTCxJQUFJLEVBQ0ZHLE1BQU0sRUFDTkMsSUFBSSxFQUNMLEdBQUdMO1FBQ0osSUFBSSxDQUFDSSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO0lBQ2Q7QUFFRjtBQUNBOztDQUVDLEdBRUQsTUFBTUMsbUJBQW1CVDtJQUN2QkUsYUFBYztRQUNaLElBQUlDLFFBQVFDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDakYsS0FBSztRQUNMLElBQUksRUFDRkcsTUFBTSxFQUNOQyxJQUFJLEVBQ0wsR0FBR0w7UUFDSixJQUFJLENBQUNJLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUND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QUNGO0lBRUEsSUFBSyxJQUFJa0IsV0FBVytCLFNBQVU7UUFDNUJZLE1BQU0zQztJQUNSO0lBRUEsT0FBT2tDO0FBQ1Q7QUFFQTs7Q0FFQyxHQUVELElBQUlDLE1BQU1OO0FBRWtELENBQzVELG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2JpZ2NvbW1lcmNlLy4vbm9kZV9tb2R1bGVzL3NsYXRlLWh5cGVyc2NyaXB0L2Rpc3QvaW5kZXguZXMuanM/OWFkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnaXMtcGxhaW4tb2JqZWN0JztcbmltcG9ydCB7IFRleHQsIFJhbmdlLCBOb2RlLCBFbGVtZW50LCBjcmVhdGVFZGl0b3IgYXMgY3JlYXRlRWRpdG9yJDEgfSBmcm9tICdzbGF0ZSc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcclxuICogQSB3ZWFrIG1hcCB0byBob2xkIGFuY2hvciB0b2tlbnMuXHJcbiAqL1xudmFyIEFOQ0hPUiA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogQSB3ZWFrIG1hcCB0byBob2xkIGZvY3VzIHRva2Vucy5cclxuICovXG5cbnZhciBGT0NVUyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogQWxsIHRva2VucyBpbmhlcml0IGZyb20gYSBzaW5nbGUgY29uc3RydWN0b3IgZm9yIGBpbnN0YW5jZW9mYCBjaGVja2luZy5cclxuICovXG5cbmNsYXNzIFRva2VuIHt9XG4vKipcclxuICogQW5jaG9yIHRva2VucyByZXByZXNlbnQgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBwb2ludC5cclxuICovXG5cbmNsYXNzIEFuY2hvclRva2VuIGV4dGVuZHMgVG9rZW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdmFyIHtcbiAgICAgIG9mZnNldCxcbiAgICAgIHBhdGhcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxuXG59XG4vKipcclxuICogRm9jdXMgdG9rZW5zIHJlcHJlc2VudCB0aGUgc2VsZWN0aW9uJ3MgZm9jdXMgcG9pbnQuXHJcbiAqL1xuXG5jbGFzcyBGb2N1c1Rva2VuIGV4dGVuZHMgVG9rZW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdmFyIHtcbiAgICAgIG9mZnNldCxcbiAgICAgIHBhdGhcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxuXG59XG4vKipcclxuICogQWRkIGFuIGFuY2hvciB0b2tlbiB0byB0aGUgZW5kIG9mIGEgdGV4dCBub2RlLlxyXG4gKi9cblxudmFyIGFkZEFuY2hvclRva2VuID0gKHRleHQsIHRva2VuKSA9PiB7XG4gIHZhciBvZmZzZXQgPSB0ZXh0LnRleHQubGVuZ3RoO1xuICBBTkNIT1Iuc2V0KHRleHQsIFtvZmZzZXQsIHRva2VuXSk7XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgb2Zmc2V0IGlmIGEgdGV4dCBub2RlIGhhcyBhbiBhc3NvY2lhdGVkIGFuY2hvciB0b2tlbi5cclxuICovXG5cbnZhciBnZXRBbmNob3JPZmZzZXQgPSB0ZXh0ID0+IHtcbiAgcmV0dXJuIEFOQ0hPUi5nZXQodGV4dCk7XG59O1xuLyoqXHJcbiAqIEFkZCBhIGZvY3VzIHRva2VuIHRvIHRoZSBlbmQgb2YgYSB0ZXh0IG5vZGUuXHJcbiAqL1xuXG52YXIgYWRkRm9jdXNUb2tlbiA9ICh0ZXh0LCB0b2tlbikgPT4ge1xuICB2YXIgb2Zmc2V0ID0gdGV4dC50ZXh0Lmxlbmd0aDtcbiAgRk9DVVMuc2V0KHRleHQsIFtvZmZzZXQsIHRva2VuXSk7XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgb2Zmc2V0IGlmIGEgdGV4dCBub2RlIGhhcyBhbiBhc3NvY2lhdGVkIGZvY3VzIHRva2VuLlxyXG4gKi9cblxudmFyIGdldEZvY3VzT2Zmc2V0ID0gdGV4dCA9PiB7XG4gIHJldHVybiBGT0NVUy5nZXQodGV4dCk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxyXG4gKiBSZXNvbHZlIHRoZSBkZXNjZWRhbnRzIG9mIGEgbm9kZSBieSBub3JtYWxpemluZyB0aGUgY2hpbGRyZW4gdGhhdCBjYW4gYmVcclxuICogcGFzc2VkIGludG8gYSBoeXBlcnNjcmlwdCBjcmVhdG9yIGZ1bmN0aW9uLlxyXG4gKi9cblxudmFyIFNUUklOR1MgPSBuZXcgV2Vha1NldCgpO1xuXG52YXIgcmVzb2x2ZURlc2NlbmRhbnRzID0gY2hpbGRyZW4gPT4ge1xuICB2YXIgbm9kZXMgPSBbXTtcblxuICB2YXIgYWRkQ2hpbGQgPSBjaGlsZCA9PiB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciB0ZXh0ID0ge1xuICAgICAgICB0ZXh0OiBjaGlsZFxuICAgICAgfTtcbiAgICAgIFNUUklOR1MuYWRkKHRleHQpO1xuICAgICAgY2hpbGQgPSB0ZXh0O1xuICAgIH1cblxuICAgIGlmIChUZXh0LmlzVGV4dChjaGlsZCkpIHtcbiAgICAgIHZhciBjID0gY2hpbGQ7IC8vIEhBQ0s6IGZpeCB0eXBlc2NyaXB0IGNvbXBsYWluaW5nXG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChwcmV2KSAmJiBTVFJJTkdTLmhhcyhwcmV2KSAmJiBTVFJJTkdTLmhhcyhjKSAmJiBUZXh0LmVxdWFscyhwcmV2LCBjLCB7XG4gICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICB9KSkge1xuICAgICAgICBwcmV2LnRleHQgKz0gYy50ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KGNoaWxkKSkge1xuICAgICAgbm9kZXMucHVzaChjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRva2VuKSB7XG4gICAgICB2YXIgbiA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG4pKSB7XG4gICAgICAgIGFkZENoaWxkKCcnKTtcbiAgICAgICAgbiA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBBbmNob3JUb2tlbikge1xuICAgICAgICBhZGRBbmNob3JUb2tlbihuLCBjaGlsZCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgRm9jdXNUb2tlbikge1xuICAgICAgICBhZGRGb2N1c1Rva2VuKG4sIGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBoeXBlcnNjcmlwdCBjaGlsZCBvYmplY3Q6IFwiLmNvbmNhdChjaGlsZCkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBjaGlsZCBvZiBjaGlsZHJlbi5mbGF0KEluZmluaXR5KSkge1xuICAgIGFkZENoaWxkKGNoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn07XG4vKipcclxuICogQ3JlYXRlIGFuIGFuY2hvciB0b2tlbi5cclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQW5jaG9yKHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSB7XG4gIHJldHVybiBuZXcgQW5jaG9yVG9rZW4oYXR0cmlidXRlcyk7XG59XG4vKipcclxuICogQ3JlYXRlIGFuIGFuY2hvciBhbmQgYSBmb2N1cyB0b2tlbi5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcih0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICByZXR1cm4gW25ldyBBbmNob3JUb2tlbihhdHRyaWJ1dGVzKSwgbmV3IEZvY3VzVG9rZW4oYXR0cmlidXRlcyldO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhbiBgRWxlbWVudGAgb2JqZWN0LlxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICByZXR1cm4gX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgYXR0cmlidXRlcyksIHt9LCB7XG4gICAgY2hpbGRyZW46IHJlc29sdmVEZXNjZW5kYW50cyhjaGlsZHJlbilcbiAgfSk7XG59XG4vKipcclxuICogQ3JlYXRlIGEgZm9jdXMgdG9rZW4uXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGb2N1cyh0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICByZXR1cm4gbmV3IEZvY3VzVG9rZW4oYXR0cmlidXRlcyk7XG59XG4vKipcclxuICogQ3JlYXRlIGEgZnJhZ21lbnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudCh0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICByZXR1cm4gcmVzb2x2ZURlc2NlbmRhbnRzKGNoaWxkcmVuKTtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb24odGFnTmFtZSwgYXR0cmlidXRlcywgY2hpbGRyZW4pIHtcbiAgdmFyIGFuY2hvciA9IGNoaWxkcmVuLmZpbmQoYyA9PiBjIGluc3RhbmNlb2YgQW5jaG9yVG9rZW4pO1xuICB2YXIgZm9jdXMgPSBjaGlsZHJlbi5maW5kKGMgPT4gYyBpbnN0YW5jZW9mIEZvY3VzVG9rZW4pO1xuXG4gIGlmICghYW5jaG9yIHx8IGFuY2hvci5vZmZzZXQgPT0gbnVsbCB8fCBhbmNob3IucGF0aCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIDxzZWxlY3Rpb24+IGh5cGVyc2NyaXB0IHRhZyBtdXN0IGhhdmUgYW4gPGFuY2hvcj4gdGFnIGFzIGEgY2hpbGQgd2l0aCBgcGF0aGAgYW5kIGBvZmZzZXRgIGF0dHJpYnV0ZXMgZGVmaW5lZC5cIik7XG4gIH1cblxuICBpZiAoIWZvY3VzIHx8IGZvY3VzLm9mZnNldCA9PSBudWxsIHx8IGZvY3VzLnBhdGggPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSA8c2VsZWN0aW9uPiBoeXBlcnNjcmlwdCB0YWcgbXVzdCBoYXZlIGEgPGZvY3VzPiB0YWcgYXMgYSBjaGlsZCB3aXRoIGBwYXRoYCBhbmQgYG9mZnNldGAgYXR0cmlidXRlcyBkZWZpbmVkLlwiKTtcbiAgfVxuXG4gIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoe1xuICAgIGFuY2hvcjoge1xuICAgICAgb2Zmc2V0OiBhbmNob3Iub2Zmc2V0LFxuICAgICAgcGF0aDogYW5jaG9yLnBhdGhcbiAgICB9LFxuICAgIGZvY3VzOiB7XG4gICAgICBvZmZzZXQ6IGZvY3VzLm9mZnNldCxcbiAgICAgIHBhdGg6IGZvY3VzLnBhdGhcbiAgICB9XG4gIH0sIGF0dHJpYnV0ZXMpO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIGBUZXh0YCBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0KHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSB7XG4gIHZhciBub2RlcyA9IHJlc29sdmVEZXNjZW5kYW50cyhjaGlsZHJlbik7XG5cbiAgaWYgKG5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgPHRleHQ+IGh5cGVyc2NyaXB0IHRhZyBtdXN0IG9ubHkgY29udGFpbiBhIHNpbmdsZSBub2RlJ3Mgd29ydGggb2YgY2hpbGRyZW4uXCIpO1xuICB9XG5cbiAgdmFyIFtub2RlXSA9IG5vZGVzO1xuXG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICBub2RlID0ge1xuICAgICAgdGV4dDogJydcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICBUaGUgPHRleHQ+IGh5cGVyc2NyaXB0IHRhZyBjYW4gb25seSBjb250YWluIHRleHQgY29udGVudCBhcyBjaGlsZHJlbi5cIik7XG4gIH0gLy8gQ09NUEFUOiBJZiB0aGV5IHVzZWQgdGhlIDx0ZXh0PiB0YWcgd2Ugd2FudCB0byBndWFyYW50ZWUgdGhhdCBpdCB3b24ndCBiZVxuICAvLyBtZXJnZSB3aXRoIG90aGVyIHN0cmluZyBjaGlsZHJlbi5cblxuXG4gIFNUUklOR1MuZGVsZXRlKG5vZGUpO1xuICBPYmplY3QuYXNzaWduKG5vZGUsIGF0dHJpYnV0ZXMpO1xuICByZXR1cm4gbm9kZTtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSB0b3AtbGV2ZWwgYEVkaXRvcmAgb2JqZWN0LlxyXG4gKi9cblxudmFyIGNyZWF0ZUVkaXRvciA9IG1ha2VFZGl0b3IgPT4gKHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSA9PiB7XG4gIHZhciBvdGhlckNoaWxkcmVuID0gW107XG4gIHZhciBzZWxlY3Rpb25DaGlsZDtcblxuICBmb3IgKHZhciBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKGNoaWxkKSkge1xuICAgICAgc2VsZWN0aW9uQ2hpbGQgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXJDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVzY2VuZGFudHMgPSByZXNvbHZlRGVzY2VuZGFudHMob3RoZXJDaGlsZHJlbik7XG4gIHZhciBzZWxlY3Rpb24gPSB7fTtcbiAgdmFyIGVkaXRvciA9IG1ha2VFZGl0b3IoKTtcbiAgT2JqZWN0LmFzc2lnbihlZGl0b3IsIGF0dHJpYnV0ZXMpO1xuICBlZGl0b3IuY2hpbGRyZW4gPSBkZXNjZW5kYW50czsgLy8gU2VhcmNoIHRoZSBkb2N1bWVudCdzIHRleHRzIHRvIHNlZSBpZiBhbnkgb2YgdGhlbSBoYXZlIHRva2VucyBhc3NvY2lhdGVkXG4gIC8vIHRoYXQgbmVlZCBpbmNvcnBvcmF0ZWQgaW50byB0aGUgc2VsZWN0aW9uLlxuXG4gIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBOb2RlLnRleHRzKGVkaXRvcikpIHtcbiAgICB2YXIgYW5jaG9yID0gZ2V0QW5jaG9yT2Zmc2V0KG5vZGUpO1xuICAgIHZhciBmb2N1cyA9IGdldEZvY3VzT2Zmc2V0KG5vZGUpO1xuXG4gICAgaWYgKGFuY2hvciAhPSBudWxsKSB7XG4gICAgICB2YXIgW29mZnNldF0gPSBhbmNob3I7XG4gICAgICBzZWxlY3Rpb24uYW5jaG9yID0ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGZvY3VzICE9IG51bGwpIHtcbiAgICAgIHZhciBbX29mZnNldF0gPSBmb2N1cztcbiAgICAgIHNlbGVjdGlvbi5mb2N1cyA9IHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxlY3Rpb24uYW5jaG9yICYmICFzZWxlY3Rpb24uZm9jdXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGF0ZSBoeXBlcnNjcmlwdCByYW5nZXMgbXVzdCBoYXZlIGJvdGggYDxhbmNob3IgLz5gIGFuZCBgPGZvY3VzIC8+YCBkZWZpbmVkIGlmIG9uZSBpcyBkZWZpbmVkLCBidXQgeW91IG9ubHkgZGVmaW5lZCBgPGFuY2hvciAvPmAuIEZvciBjb2xsYXBzZWQgc2VsZWN0aW9ucywgdXNlIGA8Y3Vyc29yIC8+YCBpbnN0ZWFkLlwiKTtcbiAgfVxuXG4gIGlmICghc2VsZWN0aW9uLmFuY2hvciAmJiBzZWxlY3Rpb24uZm9jdXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGF0ZSBoeXBlcnNjcmlwdCByYW5nZXMgbXVzdCBoYXZlIGJvdGggYDxhbmNob3IgLz5gIGFuZCBgPGZvY3VzIC8+YCBkZWZpbmVkIGlmIG9uZSBpcyBkZWZpbmVkLCBidXQgeW91IG9ubHkgZGVmaW5lZCBgPGZvY3VzIC8+YC4gRm9yIGNvbGxhcHNlZCBzZWxlY3Rpb25zLCB1c2UgYDxjdXJzb3IgLz5gIGluc3RlYWQuXCIpO1xuICB9XG5cbiAgaWYgKHNlbGVjdGlvbkNoaWxkICE9IG51bGwpIHtcbiAgICBlZGl0b3Iuc2VsZWN0aW9uID0gc2VsZWN0aW9uQ2hpbGQ7XG4gIH0gZWxzZSBpZiAoUmFuZ2UuaXNSYW5nZShzZWxlY3Rpb24pKSB7XG4gICAgZWRpdG9yLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcclxuICogVGhlIGRlZmF1bHQgY3JlYXRvcnMgZm9yIFNsYXRlIG9iamVjdHMuXHJcbiAqL1xuXG52YXIgREVGQVVMVF9DUkVBVE9SUyA9IHtcbiAgYW5jaG9yOiBjcmVhdGVBbmNob3IsXG4gIGN1cnNvcjogY3JlYXRlQ3Vyc29yLFxuICBlZGl0b3I6IGNyZWF0ZUVkaXRvcihjcmVhdGVFZGl0b3IkMSksXG4gIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGZvY3VzOiBjcmVhdGVGb2N1cyxcbiAgZnJhZ21lbnQ6IGNyZWF0ZUZyYWdtZW50LFxuICBzZWxlY3Rpb246IGNyZWF0ZVNlbGVjdGlvbixcbiAgdGV4dDogY3JlYXRlVGV4dFxufTtcbi8qKlxyXG4gKiBDcmVhdGUgYSBTbGF0ZSBoeXBlcnNjcmlwdCBmdW5jdGlvbiB3aXRoIGBvcHRpb25zYC5cclxuICovXG5cbnZhciBjcmVhdGVIeXBlcnNjcmlwdCA9IGZ1bmN0aW9uIGNyZWF0ZUh5cGVyc2NyaXB0KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciB7XG4gICAgZWxlbWVudHMgPSB7fVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIGVsZW1lbnRDcmVhdG9ycyA9IG5vcm1hbGl6ZUVsZW1lbnRzKGVsZW1lbnRzKTtcblxuICB2YXIgY3JlYXRvcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgREVGQVVMVF9DUkVBVE9SUyksIGVsZW1lbnRDcmVhdG9ycyksIG9wdGlvbnMuY3JlYXRvcnMpO1xuXG4gIHZhciBqc3ggPSBjcmVhdGVGYWN0b3J5KGNyZWF0b3JzKTtcbiAgcmV0dXJuIGpzeDtcbn07XG4vKipcclxuICogQ3JlYXRlIGEgU2xhdGUgaHlwZXJzY3JpcHQgZnVuY3Rpb24gd2l0aCBgb3B0aW9uc2AuXHJcbiAqL1xuXG5cbnZhciBjcmVhdGVGYWN0b3J5ID0gY3JlYXRvcnMgPT4ge1xuICB2YXIganN4ID0gZnVuY3Rpb24ganN4KHRhZ05hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgY2hpbGRyZW5bX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBjcmVhdG9yID0gY3JlYXRvcnNbdGFnTmFtZV07XG5cbiAgICBpZiAoIWNyZWF0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGh5cGVyc2NyaXB0IGNyZWF0b3IgZm91bmQgZm9yIHRhZzogPFwiLmNvbmNhdCh0YWdOYW1lLCBcIj5cIikpO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgIGNoaWxkcmVuID0gW2F0dHJpYnV0ZXNdLmNvbmNhdChjaGlsZHJlbik7XG4gICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgfVxuXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gQm9vbGVhbihjaGlsZCkpLmZsYXQoKTtcbiAgICB2YXIgcmV0ID0gY3JlYXRvcih0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbik7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4ganN4O1xufTtcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSBkaWN0aW9uYXJ5IG9mIGVsZW1lbnQgc2hvcnRoYW5kcyBpbnRvIGNyZWF0b3IgZnVuY3Rpb25zLlxyXG4gKi9cblxuXG52YXIgbm9ybWFsaXplRWxlbWVudHMgPSBlbGVtZW50cyA9PiB7XG4gIHZhciBjcmVhdG9ycyA9IHt9O1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHRhZ05hbWUpIHtcbiAgICB2YXIgcHJvcHMgPSBlbGVtZW50c1t0YWdOYW1lXTtcblxuICAgIGlmICh0eXBlb2YgcHJvcHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9wZXJ0aWVzIHNwZWNpZmllZCBmb3IgYSBoeXBlcnNjcmlwdCBzaG9ydGhhbmQgc2hvdWxkIGJlIGFuIG9iamVjdCwgYnV0IGZvciB0aGUgY3VzdG9tIGVsZW1lbnQgPFwiLmNvbmNhdCh0YWdOYW1lLCBcIj4gIHRhZyB5b3UgcGFzc2VkOiBcIikuY29uY2F0KHByb3BzKSk7XG4gICAgfVxuXG4gICAgY3JlYXRvcnNbdGFnTmFtZV0gPSAodGFnTmFtZSwgYXR0cmlidXRlcywgY2hpbGRyZW4pID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdlbGVtZW50JywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIGF0dHJpYnV0ZXMpLCBjaGlsZHJlbik7XG4gICAgfTtcbiAgfTtcblxuICBmb3IgKHZhciB0YWdOYW1lIGluIGVsZW1lbnRzKSB7XG4gICAgX2xvb3AodGFnTmFtZSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRvcnM7XG59O1xuXG4vKipcclxuICogVGhlIGRlZmF1bHQgaHlwZXJzY3JpcHQgZmFjdG9yeSB0aGF0IHNoaXBzIHdpdGggU2xhdGUsIHdpdGhvdXQgY3VzdG9tIHRhZ3MuXHJcbiAqL1xuXG52YXIganN4ID0gY3JlYXRlSHlwZXJzY3JpcHQoKTtcblxuZXhwb3J0IHsgY3JlYXRlRWRpdG9yLCBjcmVhdGVIeXBlcnNjcmlwdCwgY3JlYXRlVGV4dCwganN4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc1BsYWluT2JqZWN0IiwiVGV4dCIsIlJhbmdlIiwiTm9kZSIsIkVsZW1lbnQiLCJjcmVhdGVFZGl0b3IiLCJjcmVhdGVFZGl0b3IkMSIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJBTkNIT1IiLCJXZWFrTWFwIiwiRk9DVVMiLCJUb2tlbiIsIkFuY2hvclRva2VuIiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsIm9mZnNldCIsInBhdGgiLCJGb2N1c1Rva2VuIiwiYWRkQW5jaG9yVG9rZW4iLCJ0ZXh0IiwidG9rZW4iLCJzZXQiLCJnZXRBbmNob3JPZmZzZXQiLCJnZXQiLCJhZGRGb2N1c1Rva2VuIiwiZ2V0Rm9jdXNPZmZzZXQiLCJvd25LZXlzJDEiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCQxIiwidGFyZ2V0IiwiaSIsInNvdXJjZSIsImZvckVhY2giLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIlNUUklOR1MiLCJXZWFrU2V0IiwicmVzb2x2ZURlc2NlbmRhbnRzIiwiY2hpbGRyZW4iLCJub2RlcyIsImFkZENoaWxkIiwiY2hpbGQiLCJwcmV2IiwiYWRkIiwiaXNUZXh0IiwiYyIsImhhcyIsImVxdWFscyIsImxvb3NlIiwiaXNFbGVtZW50IiwibiIsIkVycm9yIiwiY29uY2F0IiwiZmxhdCIsIkluZmluaXR5IiwiY3JlYXRlQW5jaG9yIiwidGFnTmFtZSIsImF0dHJpYnV0ZXMiLCJjcmVhdGVDdXJzb3IiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlRm9jdXMiLCJjcmVhdGVGcmFnbWVudCIsImNyZWF0ZVNlbGVjdGlvbiIsImFuY2hvciIsImZpbmQiLCJmb2N1cyIsImNyZWF0ZVRleHQiLCJub2RlIiwiZGVsZXRlIiwiYXNzaWduIiwibWFrZUVkaXRvciIsIm90aGVyQ2hpbGRyZW4iLCJzZWxlY3Rpb25DaGlsZCIsImlzUmFuZ2UiLCJkZXNjZW5kYW50cyIsInNlbGVjdGlvbiIsImVkaXRvciIsInRleHRzIiwiX29mZnNldCIsIm93bktleXMiLCJfb2JqZWN0U3ByZWFkIiwiREVGQVVMVF9DUkVBVE9SUyIsImN1cnNvciIsImVsZW1lbnQiLCJmcmFnbWVudCIsImNyZWF0ZUh5cGVyc2NyaXB0Iiwib3B0aW9ucyIsImVsZW1lbnRzIiwiZWxlbWVudENyZWF0b3JzIiwibm9ybWFsaXplRWxlbWVudHMiLCJjcmVhdG9ycyIsImpzeCIsImNyZWF0ZUZhY3RvcnkiLCJfbGVuIiwiQXJyYXkiLCJfa2V5IiwiY3JlYXRvciIsIkJvb2xlYW4iLCJyZXQiLCJfbG9vcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/slate-hyperscript/dist/index.es.js\n");

/***/ })

};
;