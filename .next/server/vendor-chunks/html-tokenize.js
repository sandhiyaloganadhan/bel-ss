/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/html-tokenize";
exports.ids = ["vendor-chunks/html-tokenize"];
exports.modules = {

/***/ "(ssr)/./node_modules/html-tokenize/index.js":
/*!*********************************************!*\
  !*** ./node_modules/html-tokenize/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar bufferFrom = __webpack_require__(/*! buffer-from */ \"(ssr)/./node_modules/buffer-from/index.js\");\nvar Transform = (__webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/readable.js\").Transform);\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\ninherits(Tokenize, Transform);\nmodule.exports = Tokenize;\nvar codes = {\n    lt: \"<\".charCodeAt(0),\n    gt: \">\".charCodeAt(0),\n    slash: \"/\".charCodeAt(0),\n    dquote: '\"'.charCodeAt(0),\n    squote: \"'\".charCodeAt(0),\n    equal: \"=\".charCodeAt(0)\n};\nvar strings = {\n    endScript: bufferFrom(\"</script\"),\n    endStyle: bufferFrom(\"</style\"),\n    endTitle: bufferFrom(\"</title\"),\n    comment: bufferFrom(\"<!--\"),\n    endComment: bufferFrom(\"-->\"),\n    cdata: bufferFrom(\"<![CDATA[\"),\n    endCdata: bufferFrom(\"]]>\")\n};\nvar states = {\n    \"TagNameState\": 1,\n    \"AttributeNameState\": 2,\n    \"BeforeAttributeValueState\": 3,\n    \"AttributeValueState\": 4\n};\nfunction Tokenize() {\n    if (!(this instanceof Tokenize)) return new Tokenize;\n    Transform.call(this);\n    this._readableState.objectMode = true;\n    this.state = \"text\";\n    this.tagState = null;\n    this.quoteState = null;\n    this.raw = null;\n    this.buffers = [];\n    this._last = [];\n}\nTokenize.prototype._transform = function(buf, enc, next) {\n    var i = 0;\n    var offset = 0;\n    if (this._prev) {\n        buf = Buffer.concat([\n            this._prev,\n            buf\n        ]);\n        i = this._prev.length - 1;\n        offset = this._offset;\n        this._prev = null;\n        this._offset = 0;\n    }\n    for(; i < buf.length; i++){\n        var b = buf[i];\n        this._last.push(b);\n        if (this._last.length > 9) this._last.shift();\n        // detect end of raw character mode (comment, script,..)\n        if (this.raw) {\n            var parts = this._testRaw(buf, offset, i);\n            if (parts) {\n                this.push([\n                    \"text\",\n                    parts[0]\n                ]);\n                if (this.raw === strings.endComment || this.raw === strings.endCdata) {\n                    this.state = \"text\";\n                    this.buffers = [];\n                    this.push([\n                        \"close\",\n                        parts[1]\n                    ]);\n                } else {\n                    this.state = \"open\";\n                    this.buffers = [\n                        parts[1]\n                    ];\n                }\n                this.raw = null;\n                offset = i + 1;\n            }\n        } else if (this.state === \"text\" && b === codes.lt && i === buf.length - 1) {\n            this._prev = buf;\n            this._offset = offset;\n            return next();\n        } else if (this.state === \"text\" && b === codes.lt && !isWhiteSpace(buf[i + 1])) {\n            if (i > 0 && i - offset > 0) {\n                this.buffers.push(buf.slice(offset, i));\n            }\n            offset = i;\n            this.state = \"open\";\n            this.tagState = states.TagNameState;\n            this._pushState(\"text\");\n        } else if (this.tagState === states.TagNameState && isWhiteSpace(b)) {\n            this.tagState = states.AttributeNameState;\n        } else if (this.tagState === states.AttributeNameState && b === codes.equal) {\n            this.tagState = states.BeforeAttributeValueState;\n        } else if (this.tagState === states.BeforeAttributeValueState && isWhiteSpace(b)) {} else if (this.tagState === states.BeforeAttributeValueState && b !== codes.gt) {\n            this.tagState = states.AttributeValueState;\n            if (b === codes.dquote) {\n                this.quoteState = \"double\";\n            } else if (b === codes.squote) {\n                this.quoteState = \"single\";\n            } else {\n                this.quoteState = null;\n            }\n        } else if (this.tagState === states.AttributeValueState && !this.quoteState && isWhiteSpace(b)) {\n            this.tagState = states.AttributeNameState;\n        } else if (this.tagState === states.AttributeValueState && this.quoteState === \"double\" && b === codes.dquote) {\n            this.quoteState = null;\n            this.tagState = states.AttributeNameState;\n        } else if (this.tagState === states.AttributeValueState && this.quoteState === \"single\" && b === codes.squote) {\n            this.quoteState = null;\n            this.tagState = states.AttributeNameState;\n        } else if (this.state === \"open\" && b === codes.gt && !this.quoteState) {\n            this.buffers.push(buf.slice(offset, i + 1));\n            offset = i + 1;\n            this.state = \"text\";\n            this.tagState = null;\n            if (this._getChar(1) === codes.slash) {\n                this._pushState(\"close\");\n            } else {\n                var tag = this._getTag();\n                if (tag === \"script\") this.raw = strings.endScript;\n                if (tag === \"style\") this.raw = strings.endStyle;\n                if (tag === \"title\") this.raw = strings.endTitle;\n                this._pushState(\"open\");\n            }\n        } else if (this.state === \"open\" && compare(this._last, strings.comment)) {\n            this.buffers.push(buf.slice(offset, i + 1));\n            offset = i + 1;\n            this.state = \"text\";\n            this.raw = strings.endComment;\n            this._pushState(\"open\");\n        } else if (this.state === \"open\" && compare(this._last, strings.cdata)) {\n            this.buffers.push(buf.slice(offset, i + 1));\n            offset = i + 1;\n            this.state = \"text\";\n            this.raw = strings.endCdata;\n            this._pushState(\"open\");\n        }\n    }\n    if (offset < buf.length) this.buffers.push(buf.slice(offset));\n    next();\n};\nTokenize.prototype._flush = function(next) {\n    if (this.state === \"text\") this._pushState(\"text\");\n    this.push(null);\n    next();\n};\nTokenize.prototype._pushState = function(ev) {\n    if (this.buffers.length === 0) return;\n    var buf = Buffer.concat(this.buffers);\n    this.buffers = [];\n    this.push([\n        ev,\n        buf\n    ]);\n};\nTokenize.prototype._getChar = function(i) {\n    var offset = 0;\n    for(var j = 0; j < this.buffers.length; j++){\n        var buf = this.buffers[j];\n        if (offset + buf.length > i) {\n            return buf[i - offset];\n        }\n        offset += buf;\n    }\n};\nTokenize.prototype._getTag = function() {\n    var offset = 0;\n    var tag = \"\";\n    for(var j = 0; j < this.buffers.length; j++){\n        var buf = this.buffers[j];\n        for(var k = 0; k < buf.length; k++){\n            if (offset === 0 && k === 0) continue;\n            var c = String.fromCharCode(buf[k]);\n            if (/[^\\w-!\\[\\]]/.test(c)) {\n                return tag.toLowerCase();\n            } else tag += c;\n        }\n        offset += buf.length;\n    }\n};\nTokenize.prototype._testRaw = function(buf, offset, index) {\n    var raw = this.raw, last = this._last;\n    if (!compare(last, raw)) return;\n    this.buffers.push(buf.slice(offset, index + 1));\n    var buf = Buffer.concat(this.buffers);\n    var k = buf.length - raw.length;\n    return [\n        buf.slice(0, k),\n        buf.slice(k)\n    ];\n};\nfunction compare(a, b) {\n    if (a.length < b.length) return false;\n    for(var i = a.length - 1, j = b.length - 1; i >= 0 && j >= 0; i--, j--){\n        if (lower(a[i]) !== lower(b[j])) return false;\n    }\n    return true;\n}\nfunction lower(n) {\n    if (n >= 65 && n <= 90) return n + 32;\n    return n;\n}\nfunction isWhiteSpace(b) {\n    return b === 0x20 || b === 0x09 || b === 0x0A || b === 0x0C || b === 0x0D;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbC10b2tlbml6ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsSUFBSUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDekIsSUFBSUMsWUFBWUQscUlBQW9DO0FBQ3BELElBQUlFLFdBQVdGLG1CQUFPQSxDQUFDO0FBRXZCRSxTQUFTQyxVQUFVRjtBQUNuQkcsT0FBT0MsT0FBTyxHQUFHRjtBQUVqQixJQUFJRyxRQUFRO0lBQ1JDLElBQUksSUFBSUMsVUFBVSxDQUFDO0lBQ25CQyxJQUFJLElBQUlELFVBQVUsQ0FBQztJQUNuQkUsT0FBTyxJQUFJRixVQUFVLENBQUM7SUFDdEJHLFFBQVEsSUFBSUgsVUFBVSxDQUFDO0lBQ3ZCSSxRQUFRLElBQUlKLFVBQVUsQ0FBQztJQUN2QkssT0FBTyxJQUFJTCxVQUFVLENBQUM7QUFDMUI7QUFFQSxJQUFJTSxVQUFVO0lBQ1ZDLFdBQVdoQixXQUFXO0lBQ3RCaUIsVUFBVWpCLFdBQVc7SUFDckJrQixVQUFVbEIsV0FBVztJQUNyQm1CLFNBQVNuQixXQUFXO0lBQ3BCb0IsWUFBWXBCLFdBQVc7SUFDdkJxQixPQUFPckIsV0FBVztJQUNsQnNCLFVBQVV0QixXQUFXO0FBQ3pCO0FBRUEsSUFBSXVCLFNBQVM7SUFDVCxnQkFBZ0I7SUFDaEIsc0JBQXNCO0lBQ3RCLDZCQUE2QjtJQUM3Qix1QkFBc0I7QUFDMUI7QUFFQSxTQUFTbkI7SUFDTCxJQUFJLENBQUUsS0FBSSxZQUFZQSxRQUFPLEdBQUksT0FBTyxJQUFJQTtJQUM1Q0YsVUFBVXNCLElBQUksQ0FBQyxJQUFJO0lBQ25CLElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxVQUFVLEdBQUc7SUFDakMsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNoQixJQUFJLENBQUNDLFVBQVUsR0FBRztJQUNsQixJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ0MsT0FBTyxHQUFHLEVBQUU7SUFDakIs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QUFDYTtLQUFJO0FBQzVDO0FBRUEsU0FBU0osUUFBU1ksQ0FBQyxFQUFFM0IsQ0FBQztJQUNsQixJQUFJMkIsRUFBRTdCLE1BQU0sR0FBR0UsRUFBRUYsTUFBTSxFQUFFLE9BQU87SUFDaEMsSUFBSyxJQUFJTCxJQUFFa0MsRUFBRTdCLE1BQU0sR0FBQyxHQUFHb0IsSUFBRWxCLEVBQUVGLE1BQU0sR0FBQyxHQUFHTCxLQUFLLEtBQUt5QixLQUFLLEdBQUd6QixLQUFLeUIsSUFBSztRQUM3RCxJQUFJVSxNQUFNRCxDQUFDLENBQUNsQyxFQUFFLE1BQU1tQyxNQUFNNUIsQ0FBQyxDQUFDa0IsRUFBRSxHQUFHLE9BQU87SUFDNUM7SUFDQSxPQUFPO0FBQ1g7QUFFQSxTQUFTVSxNQUFPQyxDQUFDO0lBQ2IsSUFBSUEsS0FBSyxNQUFNQSxLQUFLLElBQUksT0FBT0EsSUFBSTtJQUNuQyxPQUFPQTtBQUNYO0FBRUEsU0FBU3hCLGFBQWFMLENBQUM7SUFDckIsT0FBT0EsTUFBTSxRQUFRQSxNQUFNLFFBQVFBLE1BQU0sUUFBUUEsTUFBTSxRQUFRQSxNQUFNO0FBQ3ZFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UvLi9ub2RlX21vZHVsZXMvaHRtbC10b2tlbml6ZS9pbmRleC5qcz8zYWMyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBidWZmZXJGcm9tID0gcmVxdWlyZSgnYnVmZmVyLWZyb20nKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlRyYW5zZm9ybTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFRva2VuaXplLCBUcmFuc2Zvcm0pO1xubW9kdWxlLmV4cG9ydHMgPSBUb2tlbml6ZTtcblxudmFyIGNvZGVzID0ge1xuICAgIGx0OiAnPCcuY2hhckNvZGVBdCgwKSxcbiAgICBndDogJz4nLmNoYXJDb2RlQXQoMCksXG4gICAgc2xhc2g6ICcvJy5jaGFyQ29kZUF0KDApLFxuICAgIGRxdW90ZTogJ1wiJy5jaGFyQ29kZUF0KDApLFxuICAgIHNxdW90ZTogXCInXCIuY2hhckNvZGVBdCgwKSxcbiAgICBlcXVhbDogJz0nLmNoYXJDb2RlQXQoMClcbn07XG5cbnZhciBzdHJpbmdzID0ge1xuICAgIGVuZFNjcmlwdDogYnVmZmVyRnJvbSgnPC9zY3JpcHQnKSxcbiAgICBlbmRTdHlsZTogYnVmZmVyRnJvbSgnPC9zdHlsZScpLFxuICAgIGVuZFRpdGxlOiBidWZmZXJGcm9tKCc8L3RpdGxlJyksXG4gICAgY29tbWVudDogYnVmZmVyRnJvbSgnPCEtLScpLFxuICAgIGVuZENvbW1lbnQ6IGJ1ZmZlckZyb20oJy0tPicpLFxuICAgIGNkYXRhOiBidWZmZXJGcm9tKCc8IVtDREFUQVsnKSxcbiAgICBlbmRDZGF0YTogYnVmZmVyRnJvbSgnXV0+Jylcbn07XG5cbnZhciBzdGF0ZXMgPSB7XG4gICAgJ1RhZ05hbWVTdGF0ZSc6IDEsXG4gICAgJ0F0dHJpYnV0ZU5hbWVTdGF0ZSc6IDIsXG4gICAgJ0JlZm9yZUF0dHJpYnV0ZVZhbHVlU3RhdGUnOiAzLFxuICAgICdBdHRyaWJ1dGVWYWx1ZVN0YXRlJzo0XG59XG5cbmZ1bmN0aW9uIFRva2VuaXplICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVG9rZW5pemUpKSByZXR1cm4gbmV3IFRva2VuaXplO1xuICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSA9IHRydWU7XG4gICAgdGhpcy5zdGF0ZSA9ICd0ZXh0JztcbiAgICB0aGlzLnRhZ1N0YXRlID0gbnVsbDtcbiAgICB0aGlzLnF1b3RlU3RhdGUgPSBudWxsO1xuICAgIHRoaXMucmF3ID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICB0aGlzLl9sYXN0ID0gW107XG59XG5cblRva2VuaXplLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGJ1ZiwgZW5jLCBuZXh0KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIFxuICAgIGlmICh0aGlzLl9wcmV2KSB7XG4gICAgICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoWyB0aGlzLl9wcmV2LCBidWYgXSk7XG4gICAgICAgIGkgPSB0aGlzLl9wcmV2Lmxlbmd0aCAtIDE7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgfVxuICAgIFxuICAgIGZvciAoOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBiID0gYnVmW2ldO1xuICAgICAgICB0aGlzLl9sYXN0LnB1c2goYik7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0Lmxlbmd0aCA+IDkpIHRoaXMuX2xhc3Quc2hpZnQoKTtcbiAgICAgICAgLy8gZGV0ZWN0IGVuZCBvZiByYXcgY2hhcmFjdGVyIG1vZGUgKGNvbW1lbnQsIHNjcmlwdCwuLilcbiAgICAgICAgaWYgKHRoaXMucmF3KSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSB0aGlzLl90ZXN0UmF3KGJ1Ziwgb2Zmc2V0LCBpKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChbICd0ZXh0JywgcGFydHNbMF0gXSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmF3ID09PSBzdHJpbmdzLmVuZENvbW1lbnRcbiAgICAgICAgICAgICAgICB8fCB0aGlzLnJhdyA9PT0gc3RyaW5ncy5lbmRDZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3RleHQnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKFsgJ2Nsb3NlJywgcGFydHNbMV0gXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ29wZW4nO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbIHBhcnRzWzFdIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMucmF3ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhc2sgZm9yIG1vcmUgZGF0YSBpZiBsYXN0IGJ5dGUgaXMgJzwnIFxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAndGV4dCcgJiYgYiA9PT0gY29kZXMubHRcbiAgICAgICAgJiYgaSA9PT0gYnVmLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXYgPSBidWY7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRldGVjdCBhIHRhZyBvcGVuaW5nXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICd0ZXh0JyAmJiBiID09PSBjb2Rlcy5sdFxuICAgICAgICAmJiAhaXNXaGl0ZVNwYWNlKGJ1ZltpKzFdKSkge1xuICAgICAgICAgICAgaWYgKGkgPiAwICYmIGkgLSBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmLnNsaWNlKG9mZnNldCwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnb3Blbic7XG4gICAgICAgICAgICB0aGlzLnRhZ1N0YXRlID0gc3RhdGVzLlRhZ05hbWVTdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX3B1c2hTdGF0ZSgndGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgdGhpcy50YWdTdGF0ZSA9PT0gc3RhdGVzLlRhZ05hbWVTdGF0ZSAmJlxuICAgICAgICAgICAgaXNXaGl0ZVNwYWNlKGIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy50YWdTdGF0ZSA9IHN0YXRlcy5BdHRyaWJ1dGVOYW1lU3RhdGVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgIHRoaXMudGFnU3RhdGUgPT09IHN0YXRlcy5BdHRyaWJ1dGVOYW1lU3RhdGUgJiZcbiAgICAgICAgICAgIGIgPT09IGNvZGVzLmVxdWFsXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy50YWdTdGF0ZSA9IHN0YXRlcy5CZWZvcmVBdHRyaWJ1dGVWYWx1ZVN0YXRlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICB0aGlzLnRhZ1N0YXRlID09PSBzdGF0ZXMuQmVmb3JlQXR0cmlidXRlVmFsdWVTdGF0ZSAmJlxuICAgICAgICAgICAgaXNXaGl0ZVNwYWNlKGIpXG4gICAgICAgICkge31cbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICB0aGlzLnRhZ1N0YXRlID09PSBzdGF0ZXMuQmVmb3JlQXR0cmlidXRlVmFsdWVTdGF0ZVxuICAgICAgICAgICAgJiYgYiAhPT0gY29kZXMuZ3RcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnRhZ1N0YXRlID0gc3RhdGVzLkF0dHJpYnV0ZVZhbHVlU3RhdGU7XG4gICAgICAgICAgICBpZiAoYiA9PT0gY29kZXMuZHF1b3RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdW90ZVN0YXRlID0gJ2RvdWJsZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IGNvZGVzLnNxdW90ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVvdGVTdGF0ZSA9ICdzaW5nbGUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1b3RlU3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgdGhpcy50YWdTdGF0ZSA9PT0gc3RhdGVzLkF0dHJpYnV0ZVZhbHVlU3RhdGUgJiZcbiAgICAgICAgICAgICF0aGlzLnF1b3RlU3RhdGUgJiZcbiAgICAgICAgICAgIGlzV2hpdGVTcGFjZShiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMudGFnU3RhdGUgPSBzdGF0ZXMuQXR0cmlidXRlTmFtZVN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgdGhpcy50YWdTdGF0ZSA9PT0gc3RhdGVzLkF0dHJpYnV0ZVZhbHVlU3RhdGUgJiZcbiAgICAgICAgICAgIHRoaXMucXVvdGVTdGF0ZSA9PT0gJ2RvdWJsZScgJiZcbiAgICAgICAgICAgIGIgPT09IGNvZGVzLmRxdW90ZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMucXVvdGVTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnRhZ1N0YXRlID0gc3RhdGVzLkF0dHJpYnV0ZU5hbWVTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgIHRoaXMudGFnU3RhdGUgPT09IHN0YXRlcy5BdHRyaWJ1dGVWYWx1ZVN0YXRlICYmXG4gICAgICAgICAgICB0aGlzLnF1b3RlU3RhdGUgPT09ICdzaW5nbGUnICYmXG4gICAgICAgICAgICBiID09PSBjb2Rlcy5zcXVvdGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnF1b3RlU3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50YWdTdGF0ZSA9IHN0YXRlcy5BdHRyaWJ1dGVOYW1lU3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ29wZW4nICYmIGIgPT09IGNvZGVzLmd0ICYmICF0aGlzLnF1b3RlU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1Zi5zbGljZShvZmZzZXQsIGkgKyAxKSk7XG4gICAgICAgICAgICBvZmZzZXQgPSBpICsgMTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAndGV4dCc7XG4gICAgICAgICAgICB0aGlzLnRhZ1N0YXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRDaGFyKDEpID09PSBjb2Rlcy5zbGFzaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3B1c2hTdGF0ZSgnY2xvc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSB0aGlzLl9nZXRUYWcoKTtcbiAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnc2NyaXB0JykgdGhpcy5yYXcgPSBzdHJpbmdzLmVuZFNjcmlwdDtcbiAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnc3R5bGUnKSB0aGlzLnJhdyA9IHN0cmluZ3MuZW5kU3R5bGU7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ3RpdGxlJykgdGhpcy5yYXcgPSBzdHJpbmdzLmVuZFRpdGxlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3B1c2hTdGF0ZSgnb3BlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdvcGVuJyAmJiBjb21wYXJlKHRoaXMuX2xhc3QsIHN0cmluZ3MuY29tbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1Zi5zbGljZShvZmZzZXQsIGkgKyAxKSk7XG4gICAgICAgICAgICBvZmZzZXQgPSBpICsgMTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAndGV4dCc7XG4gICAgICAgICAgICB0aGlzLnJhdyA9IHN0cmluZ3MuZW5kQ29tbWVudDtcbiAgICAgICAgICAgIHRoaXMuX3B1c2hTdGF0ZSgnb3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdvcGVuJyAmJiBjb21wYXJlKHRoaXMuX2xhc3QsIHN0cmluZ3MuY2RhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChidWYuc2xpY2Uob2Zmc2V0LCBpICsgMSkpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gaSArIDE7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3RleHQnO1xuICAgICAgICAgICAgdGhpcy5yYXcgPSBzdHJpbmdzLmVuZENkYXRhO1xuICAgICAgICAgICAgdGhpcy5fcHVzaFN0YXRlKCdvcGVuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9mZnNldCA8IGJ1Zi5sZW5ndGgpIHRoaXMuYnVmZmVycy5wdXNoKGJ1Zi5zbGljZShvZmZzZXQpKTtcbiAgICBuZXh0KCk7XG59O1xuXG5Ub2tlbml6ZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3RleHQnKSB0aGlzLl9wdXNoU3RhdGUoJ3RleHQnKTtcbiAgICB0aGlzLnB1c2gobnVsbCk7XG4gICAgbmV4dCgpO1xufTtcblxuVG9rZW5pemUucHJvdG90eXBlLl9wdXNoU3RhdGUgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgdGhpcy5wdXNoKFsgZXYsIGJ1ZiBdKTtcbn07XG5cblRva2VuaXplLnByb3RvdHlwZS5fZ2V0Q2hhciA9IGZ1bmN0aW9uIChpKSB7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHRoaXMuYnVmZmVyc1tqXTtcbiAgICAgICAgaWYgKG9mZnNldCArIGJ1Zi5sZW5ndGggPiBpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmW2kgLSBvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBidWY7XG4gICAgfVxufTtcblxuVG9rZW5pemUucHJvdG90eXBlLl9nZXRUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIHRhZyA9ICcnO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5idWZmZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBidWYgPSB0aGlzLmJ1ZmZlcnNbal07XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYnVmLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSAwICYmIGsgPT09IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltrXSk7XG4gICAgICAgICAgICBpZiAoL1teXFx3LSFcXFtcXF1dLy50ZXN0KGMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB0YWcgKz0gYztcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgICB9XG59O1xuXG5Ub2tlbml6ZS5wcm90b3R5cGUuX3Rlc3RSYXcgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGluZGV4KSB7XG4gICAgdmFyIHJhdyA9IHRoaXMucmF3LCBsYXN0ID0gdGhpcy5fbGFzdDtcbiAgICBpZiAoIWNvbXBhcmUobGFzdCwgcmF3KSkgcmV0dXJuO1xuICAgIFxuICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1Zi5zbGljZShvZmZzZXQsIGluZGV4ICsgMSkpO1xuICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KHRoaXMuYnVmZmVycyk7XG4gICAgdmFyIGsgPSBidWYubGVuZ3RoIC0gcmF3Lmxlbmd0aDtcbiAgICByZXR1cm4gWyBidWYuc2xpY2UoMCwgayksIGJ1Zi5zbGljZShrKSBdO1xufTtcblxuZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCA8IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgaT1hLmxlbmd0aC0xLCBqPWIubGVuZ3RoLTE7IGkgPj0gMCAmJiBqID49IDA7IGktLSwgai0tKSB7XG4gICAgICAgIGlmIChsb3dlcihhW2ldKSAhPT0gbG93ZXIoYltqXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGxvd2VyIChuKSB7XG4gICAgaWYgKG4gPj0gNjUgJiYgbiA8PSA5MCkgcmV0dXJuIG4gKyAzMjtcbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGIpIHtcbiAgcmV0dXJuIGIgPT09IDB4MjAgfHwgYiA9PT0gMHgwOSB8fCBiID09PSAweDBBIHx8IGIgPT09IDB4MEMgfHwgYiA9PT0gMHgwRDtcbn1cbiJdLCJuYW1lcyI6WyJidWZmZXJGcm9tIiwicmVxdWlyZSIsIlRyYW5zZm9ybSIsImluaGVyaXRzIiwiVG9rZW5pemUiLCJtb2R1bGUiLCJleHBvcnRzIiwiY29kZXMiLCJsdCIsImNoYXJDb2RlQXQiLCJndCIsInNsYXNoIiwiZHF1b3RlIiwic3F1b3RlIiwiZXF1YWwiLCJzdHJpbmdzIiwiZW5kU2NyaXB0IiwiZW5kU3R5bGUiLCJlbmRUaXRsZSIsImNvbW1lbnQiLCJlbmRDb21tZW50IiwiY2RhdGEiLCJlbmRDZGF0YSIsInN0YXRlcyIsImNhbGwiLCJfcmVhZGFibGVTdGF0ZSIsIm9iamVjdE1vZGUiLCJzdGF0ZSIsInRhZ1N0YXRlIiwicXVvdGVTdGF0ZSIsInJhdyIsImJ1ZmZlcnMiLCJfbGFzdCIsInByb3RvdHlwZSIsIl90cmFuc2Zvcm0iLCJidWYiLCJlbmMiLCJuZXh0IiwiaSIsIm9mZnNldCIsIl9wcmV2IiwiQnVmZmVyIiwiY29uY2F0IiwibGVuZ3RoIiwiX29mZnNldCIsImIiLCJwdXNoIiwic2hpZnQiLCJwYXJ0cyIsIl90ZXN0UmF3IiwiaXNXaGl0ZVNwYWNlIiwic2xpY2UiLCJUYWdOYW1lU3RhdGUiLCJfcHVzaFN0YXRlIiwiQXR0cmlidXRlTmFtZVN0YXRlIiwiQmVmb3JlQXR0cmlidXRlVmFsdWVTdGF0ZSIsIkF0dHJpYnV0ZVZhbHVlU3RhdGUiLCJfZ2V0Q2hhciIsInRhZyIsIl9nZXRUYWciLCJjb21wYXJlIiwiX2ZsdXNoIiwiZXYiLCJqIiwiayIsImMiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ0ZXN0IiwidG9Mb3dlckNhc2UiLCJpbmRleCIsImxhc3QiLCJhIiwibG93ZXIiLCJuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html-tokenize/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html-tokenize/node_modules/isarray/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/html-tokenize/node_modules/isarray/index.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = Array.isArray || function(arr) {\n    return Object.prototype.toString.call(arr) == \"[object Array]\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbC10b2tlbml6ZS9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLE9BQU9DLE9BQU8sR0FBR0MsTUFBTUMsT0FBTyxJQUFJLFNBQVVDLEdBQUc7SUFDN0MsT0FBT0MsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0osUUFBUTtBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL2JpZ2NvbW1lcmNlLy4vbm9kZV9tb2R1bGVzL2h0bWwtdG9rZW5pemUvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanM/NzdiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkFycmF5IiwiaXNBcnJheSIsImFyciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html-tokenize/node_modules/isarray/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_duplex.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n/*<replacement>*/ var objectKeys = Object.keys || function(obj) {\n    var keys = [];\n    for(var key in obj)keys.push(key);\n    return keys;\n};\n/*</replacement>*/ /*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(ssr)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ var Readable = __webpack_require__(/*! ./_stream_readable */ \"(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_writable.js\");\nutil.inherits(Duplex, Readable);\nforEach(objectKeys(Writable.prototype), function(method) {\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n});\nfunction Duplex(options) {\n    if (!(this instanceof Duplex)) return new Duplex(options);\n    Readable.call(this, options);\n    Writable.call(this, options);\n    if (options && options.readable === false) this.readable = false;\n    if (options && options.writable === false) this.writable = false;\n    this.allowHalfOpen = true;\n    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n    this.once(\"end\", onend);\n}\n// the no-half-open enforcer\nfunction onend() {\n    // if we allow half-open state, or if the writable side ended,\n    // then we're ok.\n    if (this.allowHalfOpen || this._writableState.ended) return;\n    // no more data can be written.\n    // But allow more writes to happen in this tick.\n    process.nextTick(this.end.bind(this));\n}\nfunction forEach(xs, f) {\n    for(var i = 0, l = xs.length; i < l; i++){\n        f(xs[i], i);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbC10b2tlbml6ZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFDdEQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSxnRUFBZ0U7QUFDaEUsc0VBQXNFO0FBQ3RFLHNFQUFzRTtBQUN0RSw0RUFBNEU7QUFDNUUscUVBQXFFO0FBQ3JFLHdCQUF3QjtBQUN4QixFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlEQUF5RDtBQUN6RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLDZEQUE2RDtBQUM3RCw0RUFBNEU7QUFDNUUsMkVBQTJFO0FBQzNFLHdFQUF3RTtBQUN4RSw0RUFBNEU7QUFDNUUseUNBQXlDO0FBRXpDLHVFQUF1RTtBQUN2RSxvRUFBb0U7QUFDcEUsbUVBQW1FO0FBQ25FLFlBQVk7O0FBRVpBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsZUFBZSxHQUNmLElBQUlDLGFBQWFDLE9BQU9DLElBQUksSUFBSSxTQUFVQyxHQUFHO0lBQzNDLElBQUlELE9BQU8sRUFBRTtJQUNiLElBQUssSUFBSUUsT0FBT0QsSUFBS0QsS0FBS0csSUFBSSxDQUFDRDtJQUMvQixPQUFPRjtBQUNUO0FBQ0EsZ0JBQWdCLEdBR2hCLGVBQWUsR0FDZixJQUFJSSxPQUFPQyxtQkFBT0EsQ0FBQztBQUNuQkQsS0FBS0UsUUFBUSxHQUFHRCxtQkFBT0EsQ0FBQztBQUN4QixnQkFBZ0IsR0FFaEIsSUFBSUUsV0FBV0YsbUJBQU9BLENBQUM7QUFDdkIsSUFBSUcsV0FBV0gsbUJBQU9BLENBQUM7QUFFdkJELEtBQUtFLFFBQVEsQ0FBQ1QsUUFBUVU7QUFFdEJFLFFBQVFYLFdBQVdVLFNBQVNFLFNBQVMsR0FBRyxTQUFTQyxNQUFNO0lBQ3JELElBQUksQ0FBQ2QsT0FBT2EsU0FBUyxDQUFDQyxPQUFPLEVBQzNCZCxPQUFPYSxTQUFTLENBQUNDLE9BQU8sR0FBR0gsU0FBU0UsU0FBUyxDQUFDQyxPQUFPO0FBQ3pEO0FBRUEsU0FBU2QsT0FBT2UsT0FBTztJQUNyQixJQUFJLENBQUUsS0FBSSxZQUFZZixNQUFLLEdBQ3pCLE9BQU8sSUFBSUEsT0FBT2U7SUFFcEJMLFNBQVNNLElBQUksQ0FBQyxJQUFJLEVBQUVEO0lBQ3BCSixTQUFTSyxJQUFJLENBQUMsSUFBSSxFQUFFRDtJQUVwQixJQUFJQSxXQUFXQSxRQUFRRSxRQUFRLEtBQUssT0FDbEMsSUFBSSxDQUFDQSxRQUFRLEdBQUc7SUFFbEIsSUFBSUYsV0FBV0EsUUFBUUcsUUFBUSxLQUFLLE9BQ2xDLElBQUksQ0FBQ0EsUUFBUSxHQUFHO0lBRWxCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO0lBQ3JCLElBQUlKLFdBQVdBLFFBQVFJLGFBQWEsS0FBSyxPQUN2QyxJQUFJLENBQUNBLGFBQWEsR0FBRztJQUV2QixJQUFJLENBQUNDLElBQUksQ0FBQyxPQUFPQztBQUNuQjtBQUVBLDRCQUE0QjtBQUM1QixTQUFTQTtJQUNQLDhEQUE4RDtJQUM5RCxpQkFBaUI7SUFDakIsSUFBSSxJQUFJLENBQUNGLGFBQWEsSUFBSSxJQUFJLENBQUNHLGNBQWMsQ0FBQ0MsS0FBSyxFQUNqRDtJQUVGLCtCQUErQjtJQUMvQixnREFBZ0Q7SUFDaERDLFFBQVFDLFFBQVEsQ0FBQyxJQUFJLENBQUNDLEdBQUcsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7QUFDckM7QUFFQSxTQUFTZixRQUFTZ0IsRUFBRSxFQUFFQyxDQUFDO0lBQ3JCLElBQUssSUFBSUMsSUFBSSxHQUFHQyxJQUFJSCxHQUFHSSxNQUFNLEVBQUVGLElBQUlDLEdBQUdELElBQUs7UUFDekNELEVBQUVELEVBQUUsQ0FBQ0UsRUFBRSxFQUFFQTtJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWdjb21tZXJjZS8uL25vZGVfbW9kdWxlcy9odG1sLXRva2VuaXplL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzPzYyMzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSksIGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn0pO1xuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJEdXBsZXgiLCJvYmplY3RLZXlzIiwiT2JqZWN0Iiwia2V5cyIsIm9iaiIsImtleSIsInB1c2giLCJ1dGlsIiwicmVxdWlyZSIsImluaGVyaXRzIiwiUmVhZGFibGUiLCJXcml0YWJsZSIsImZvckVhY2giLCJwcm90b3R5cGUiLCJtZXRob2QiLCJvcHRpb25zIiwiY2FsbCIsInJlYWRhYmxlIiwid3JpdGFibGUiLCJhbGxvd0hhbGZPcGVuIiwib25jZSIsIm9uZW5kIiwiX3dyaXRhYmxlU3RhdGUiLCJlbmRlZCIsInByb2Nlc3MiLCJuZXh0VGljayIsImVuZCIsImJpbmQiLCJ4cyIsImYiLCJpIiwibCIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_duplex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_transform.js\");\n/*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(ssr)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ util.inherits(PassThrough, Transform);\nfunction PassThrough(options) {\n    if (!(this instanceof PassThrough)) return new PassThrough(options);\n    Transform.call(this, options);\n}\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n    cb(null, chunk);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbC10b2tlbml6ZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7QUFFekMsd0JBQXdCO0FBQ3hCLDREQUE0RDtBQUM1RCx5Q0FBeUM7O0FBRXpDQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLFlBQVlDLG1CQUFPQSxDQUFDO0FBRXhCLGVBQWUsR0FDZixJQUFJQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNuQkMsS0FBS0MsUUFBUSxHQUFHRixtQkFBT0EsQ0FBQztBQUN4QixnQkFBZ0IsR0FFaEJDLEtBQUtDLFFBQVEsQ0FBQ0osYUFBYUM7QUFFM0IsU0FBU0QsWUFBWUssT0FBTztJQUMxQixJQUFJLENBQUUsS0FBSSxZQUFZTCxXQUFVLEdBQzlCLE9BQU8sSUFBSUEsWUFBWUs7SUFFekJKLFVBQVVLLElBQUksQ0FBQyxJQUFJLEVBQUVEO0FBQ3ZCO0FBRUFMLFlBQVlPLFNBQVMsQ0FBQ0MsVUFBVSxHQUFHLFNBQVNDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxFQUFFO0lBQzdEQSxHQUFHLE1BQU1GO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWdjb21tZXJjZS8uL25vZGVfbW9kdWxlcy9odG1sLXRva2VuaXplL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanM/NTFkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJQYXNzVGhyb3VnaCIsIlRyYW5zZm9ybSIsInJlcXVpcmUiLCJ1dGlsIiwiaW5oZXJpdHMiLCJvcHRpb25zIiwiY2FsbCIsInByb3RvdHlwZSIsIl90cmFuc2Zvcm0iLCJjaHVuayIsImVuY29kaW5nIiwiY2IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_passthrough.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_readable.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_readable.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n/*<replacement>*/ var isArray = __webpack_require__(/*! isarray */ \"(ssr)/./node_modules/html-tokenize/node_modules/isarray/index.js\");\n/*</replacement>*/ /*<replacement>*/ var Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n/*</replacement>*/ Readable.ReadableState = ReadableState;\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n/*<replacement>*/ if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n    return emitter.listeners(type).length;\n};\n/*</replacement>*/ var Stream = __webpack_require__(/*! stream */ \"stream\");\n/*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(ssr)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ var StringDecoder;\nutil.inherits(Readable, Stream);\nfunction ReadableState(options, stream) {\n    options = options || {};\n    // the point at which it stops calling _read() to fill the buffer\n    // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n    var hwm = options.highWaterMark;\n    this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;\n    // cast to ints.\n    this.highWaterMark = ~~this.highWaterMark;\n    this.buffer = [];\n    this.length = 0;\n    this.pipes = null;\n    this.pipesCount = 0;\n    this.flowing = false;\n    this.ended = false;\n    this.endEmitted = false;\n    this.reading = false;\n    // In streams that never have any data, and do push(null) right away,\n    // the consumer can miss the 'end' event if they do some I/O before\n    // consuming the stream.  So, we don't emit('end') until some reading\n    // happens.\n    this.calledRead = false;\n    // a flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, becuase any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n    // whenever we return null, then we set a flag to say\n    // that we're awaiting a 'readable' event emission.\n    this.needReadable = false;\n    this.emittedReadable = false;\n    this.readableListening = false;\n    // object stream flag. Used to make read(n) ignore n and to\n    // make all the buffer merging and length checks go away\n    this.objectMode = !!options.objectMode;\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    // when piping, we only care about 'readable' events that happen\n    // after read()ing all the bytes and not getting any pushback.\n    this.ranOut = false;\n    // the number of writers that are awaiting a drain event in .pipe()s\n    this.awaitDrain = 0;\n    // if true, a maybeReadMore has been scheduled\n    this.readingMore = false;\n    this.decoder = null;\n    this.encoding = null;\n    if (options.encoding) {\n        if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(ssr)/./node_modules/html-tokenize/node_modules/string_decoder/index.js\").StringDecoder);\n        this.decoder = new StringDecoder(options.encoding);\n        this.encoding = options.encoding;\n    }\n}\nfunction Readable(options) {\n    if (!(this instanceof Readable)) return new Readable(options);\n    this._readableState = new ReadableState(options, this);\n    // legacy\n    this.readable = true;\n    Stream.call(this);\n}\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n    var state = this._readableState;\n    if (typeof chunk === \"string\" && !state.objectMode) {\n        encoding = encoding || state.defaultEncoding;\n        if (encoding !== state.encoding) {\n            chunk = new Buffer(chunk, encoding);\n            encoding = \"\";\n        }\n    }\n    return readableAddChunk(this, state, chunk, encoding, false);\n};\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n    var state = this._readableState;\n    return readableAddChunk(this, state, chunk, \"\", true);\n};\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n    var er = chunkInvalid(state, chunk);\n    if (er) {\n        stream.emit(\"error\", er);\n    } else if (chunk === null || chunk === undefined) {\n        state.reading = false;\n        if (!state.ended) onEofChunk(stream, state);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n        if (state.ended && !addToFront) {\n            var e = new Error(\"stream.push() after EOF\");\n            stream.emit(\"error\", e);\n        } else if (state.endEmitted && addToFront) {\n            var e = new Error(\"stream.unshift() after end event\");\n            stream.emit(\"error\", e);\n        } else {\n            if (state.decoder && !addToFront && !encoding) chunk = state.decoder.write(chunk);\n            // update the buffer info.\n            state.length += state.objectMode ? 1 : chunk.length;\n            if (addToFront) {\n                state.buffer.unshift(chunk);\n            } else {\n                state.reading = false;\n                state.buffer.push(chunk);\n            }\n            if (state.needReadable) emitReadable(stream);\n            maybeReadMore(stream, state);\n        }\n    } else if (!addToFront) {\n        state.reading = false;\n    }\n    return needMoreData(state);\n}\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(ssr)/./node_modules/html-tokenize/node_modules/string_decoder/index.js\").StringDecoder);\n    this._readableState.decoder = new StringDecoder(enc);\n    this._readableState.encoding = enc;\n};\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n    if (n >= MAX_HWM) {\n        n = MAX_HWM;\n    } else {\n        // Get the next highest power of 2\n        n--;\n        for(var p = 1; p < 32; p <<= 1)n |= n >> p;\n        n++;\n    }\n    return n;\n}\nfunction howMuchToRead(n, state) {\n    if (state.length === 0 && state.ended) return 0;\n    if (state.objectMode) return n === 0 ? 0 : 1;\n    if (n === null || isNaN(n)) {\n        // only flow one buffer at a time\n        if (state.flowing && state.buffer.length) return state.buffer[0].length;\n        else return state.length;\n    }\n    if (n <= 0) return 0;\n    // If we're asking for more than the target buffer level,\n    // then raise the water mark.  Bump up to the next highest\n    // power of 2, to prevent increasing it excessively in tiny\n    // amounts.\n    if (n > state.highWaterMark) state.highWaterMark = roundUpToNextPowerOf2(n);\n    // don't have that much.  return null, unless we've ended.\n    if (n > state.length) {\n        if (!state.ended) {\n            state.needReadable = true;\n            return 0;\n        } else return state.length;\n    }\n    return n;\n}\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n    var state = this._readableState;\n    state.calledRead = true;\n    var nOrig = n;\n    var ret;\n    if (typeof n !== \"number\" || n > 0) state.emittedReadable = false;\n    // if we're doing read(0) to trigger a readable event, but we\n    // already have a bunch of data in the buffer, then just trigger\n    // the 'readable' event and move on.\n    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n        emitReadable(this);\n        return null;\n    }\n    n = howMuchToRead(n, state);\n    // if we've ended, and we're now clear, then finish it up.\n    if (n === 0 && state.ended) {\n        ret = null;\n        // In cases where the decoder did not receive enough data\n        // to produce a full chunk, then immediately received an\n        // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].\n        // howMuchToRead will see this and coerce the amount to\n        // read to zero (because it's looking at the length of the\n        // first <Buffer > in state.buffer), and we'll end up here.\n        //\n        // This can only happen via state.decoder -- no other venue\n        // exists for pushing a zero-length chunk into state.buffer\n        // and triggering this behavior. In this case, we return our\n        // remaining data and end the stream, if appropriate.\n        if (state.length > 0 && state.decoder) {\n            ret = fromList(n, state);\n            state.length -= ret.length;\n        }\n        if (state.length === 0) endReadable(this);\n        return ret;\n    }\n    // All the actual chunk generation logic needs to be\n    // *below* the call to _read.  The reason is that in certain\n    // synthetic stream cases, such as passthrough streams, _read\n    // may be a completely synchronous operation which may change\n    // the state of the read buffer, providing enough data when\n    // before there was *not* enough.\n    //\n    // So, the steps are:\n    // 1. Figure out what the state of things will be after we do\n    // a read from the buffer.\n    //\n    // 2. If that resulting state will trigger a _read, then call _read.\n    // Note that this may be asynchronous, or synchronous.  Yes, it is\n    // deeply ugly to write APIs this way, but that still doesn't mean\n    // that the Readable class should behave improperly, as streams are\n    // designed to be sync/async agnostic.\n    // Take note if the _read call is sync or async (ie, if the read call\n    // has returned yet), so that we know whether or not it's safe to emit\n    // 'readable' etc.\n    //\n    // 3. Actually pull the requested chunks out of the buffer and return.\n    // if we need a readable event, then we need to do some reading.\n    var doRead = state.needReadable;\n    // if we currently have less than the highWaterMark, then also read some\n    if (state.length - n <= state.highWaterMark) doRead = true;\n    // however, if we've ended, then there's no point, and if we're already\n    // reading, then it's unnecessary.\n    if (state.ended || state.reading) doRead = false;\n    if (doRead) {\n        state.reading = true;\n        state.sync = true;\n        // if the length is currently zero, then we *need* a readable event.\n        if (state.length === 0) state.needReadable = true;\n        // call internal read method\n        this._read(state.highWaterMark);\n        state.sync = false;\n    }\n    // If _read called its callback synchronously, then `reading`\n    // will be false, and we need to re-evaluate how much data we\n    // can return to the user.\n    if (doRead && !state.reading) n = howMuchToRead(nOrig, state);\n    if (n > 0) ret = fromList(n, state);\n    else ret = null;\n    if (ret === null) {\n        state.needReadable = true;\n        n = 0;\n    }\n    state.length -= n;\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (state.length === 0 && !state.ended) state.needReadable = true;\n    // If we happened to read() exactly the remaining amount in the\n    // buffer, and the EOF has been seen at this point, then make sure\n    // that we emit 'end' on the very next tick.\n    if (state.ended && !state.endEmitted && state.length === 0) endReadable(this);\n    return ret;\n};\nfunction chunkInvalid(state, chunk) {\n    var er = null;\n    if (!Buffer.isBuffer(chunk) && \"string\" !== typeof chunk && chunk !== null && chunk !== undefined && !state.objectMode) {\n        er = new TypeError(\"Invalid non-string/buffer chunk\");\n    }\n    return er;\n}\nfunction onEofChunk(stream, state) {\n    if (state.decoder && !state.ended) {\n        var chunk = state.decoder.end();\n        if (chunk && chunk.length) {\n            state.buffer.push(chunk);\n            state.length += state.objectMode ? 1 : chunk.length;\n        }\n    }\n    state.ended = true;\n    // if we've ended and we have some data left, then emit\n    // 'readable' now to make sure it gets picked up.\n    if (state.length > 0) emitReadable(stream);\n    else endReadable(stream);\n}\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n    var state = stream._readableState;\n    state.needReadable = false;\n    if (state.emittedReadable) return;\n    state.emittedReadable = true;\n    if (state.sync) process.nextTick(function() {\n        emitReadable_(stream);\n    });\n    else emitReadable_(stream);\n}\nfunction emitReadable_(stream) {\n    stream.emit(\"readable\");\n}\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n    if (!state.readingMore) {\n        state.readingMore = true;\n        process.nextTick(function() {\n            maybeReadMore_(stream, state);\n        });\n    }\n}\nfunction maybeReadMore_(stream, state) {\n    var len = state.length;\n    while(!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark){\n        stream.read(0);\n        if (len === state.length) break;\n        else len = state.length;\n    }\n    state.readingMore = false;\n}\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n    this.emit(\"error\", new Error(\"not implemented\"));\n};\nReadable.prototype.pipe = function(dest, pipeOpts) {\n    var src = this;\n    var state = this._readableState;\n    switch(state.pipesCount){\n        case 0:\n            state.pipes = dest;\n            break;\n        case 1:\n            state.pipes = [\n                state.pipes,\n                dest\n            ];\n            break;\n        default:\n            state.pipes.push(dest);\n            break;\n    }\n    state.pipesCount += 1;\n    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n    var endFn = doEnd ? onend : cleanup;\n    if (state.endEmitted) process.nextTick(endFn);\n    else src.once(\"end\", endFn);\n    dest.on(\"unpipe\", onunpipe);\n    function onunpipe(readable) {\n        if (readable !== src) return;\n        cleanup();\n    }\n    function onend() {\n        dest.end();\n    }\n    // when the dest drains, it reduces the awaitDrain counter\n    // on the source.  This would be more elegant with a .once()\n    // handler in flow(), but adding and removing repeatedly is\n    // too slow.\n    var ondrain = pipeOnDrain(src);\n    dest.on(\"drain\", ondrain);\n    function cleanup() {\n        // cleanup event handlers once the pipe is broken\n        dest.removeListener(\"close\", onclose);\n        dest.removeListener(\"finish\", onfinish);\n        dest.removeListener(\"drain\", ondrain);\n        dest.removeListener(\"error\", onerror);\n        dest.removeListener(\"unpipe\", onunpipe);\n        src.removeListener(\"end\", onend);\n        src.removeListener(\"end\", cleanup);\n        // if the reader is waiting for a drain event from this\n        // specific writer, then it would cause it to never start\n        // flowing again.\n        // So, if this is awaiting a drain, then we just call it now.\n        // If we don't know, then assume that we are waiting for one.\n        if (!dest._writableState || dest._writableState.needDrain) ondrain();\n    }\n    // if the dest has an error, then stop piping into it.\n    // however, don't suppress the throwing behavior for this.\n    function onerror(er) {\n        unpipe();\n        dest.removeListener(\"error\", onerror);\n        if (EE.listenerCount(dest, \"error\") === 0) dest.emit(\"error\", er);\n    }\n    // This is a brutally ugly hack to make sure that our error handler\n    // is attached before any userland ones.  NEVER DO THIS.\n    if (!dest._events || !dest._events.error) dest.on(\"error\", onerror);\n    else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);\n    else dest._events.error = [\n        onerror,\n        dest._events.error\n    ];\n    // Both close and finish should trigger unpipe, but only once.\n    function onclose() {\n        dest.removeListener(\"finish\", onfinish);\n        unpipe();\n    }\n    dest.once(\"close\", onclose);\n    function onfinish() {\n        dest.removeListener(\"close\", onclose);\n        unpipe();\n    }\n    dest.once(\"finish\", onfinish);\n    function unpipe() {\n        src.unpipe(dest);\n    }\n    // tell the dest that it's being piped to\n    dest.emit(\"pipe\", src);\n    // start the flow if it hasn't been started already.\n    if (!state.flowing) {\n        // the handler that waits for readable events after all\n        // the data gets sucked out in flow.\n        // This would be easier to follow with a .once() handler\n        // in flow(), but that is too slow.\n        this.on(\"readable\", pipeOnReadable);\n        state.flowing = true;\n        process.nextTick(function() {\n            flow(src);\n        });\n    }\n    return dest;\n};\nfunction pipeOnDrain(src) {\n    return function() {\n        var dest = this;\n        var state = src._readableState;\n        state.awaitDrain--;\n        if (state.awaitDrain === 0) flow(src);\n    };\n}\nfunction flow(src) {\n    var state = src._readableState;\n    var chunk;\n    state.awaitDrain = 0;\n    function write(dest, i, list) {\n        var written = dest.write(chunk);\n        if (false === written) {\n            state.awaitDrain++;\n        }\n    }\n    while(state.pipesCount && null !== (chunk = src.read())){\n        if (state.pipesCount === 1) write(state.pipes, 0, null);\n        else forEach(state.pipes, write);\n        src.emit(\"data\", chunk);\n        // if anyone needs a drain, then we have to wait for that.\n        if (state.awaitDrain > 0) return;\n    }\n    // if every destination was unpiped, either before entering this\n    // function, or in the while loop, then stop flowing.\n    //\n    // NB: This is a pretty rare edge case.\n    if (state.pipesCount === 0) {\n        state.flowing = false;\n        // if there were data event listeners added, then switch to old mode.\n        if (EE.listenerCount(src, \"data\") > 0) emitDataEvents(src);\n        return;\n    }\n    // at this point, no one needed a drain, so we just ran out of data\n    // on the next readable event, start it over again.\n    state.ranOut = true;\n}\nfunction pipeOnReadable() {\n    if (this._readableState.ranOut) {\n        this._readableState.ranOut = false;\n        flow(this);\n    }\n}\nReadable.prototype.unpipe = function(dest) {\n    var state = this._readableState;\n    // if we're not piping anywhere, then do nothing.\n    if (state.pipesCount === 0) return this;\n    // just one destination.  most common case.\n    if (state.pipesCount === 1) {\n        // passed in one, but it's not the right one.\n        if (dest && dest !== state.pipes) return this;\n        if (!dest) dest = state.pipes;\n        // got a match.\n        state.pipes = null;\n        state.pipesCount = 0;\n        this.removeListener(\"readable\", pipeOnReadable);\n        state.flowing = false;\n        if (dest) dest.emit(\"unpipe\", this);\n        return this;\n    }\n    // slow case. multiple pipe destinations.\n    if (!dest) {\n        // remove all.\n        var dests = state.pipes;\n        var len = state.pipesCount;\n        state.pipes = null;\n        state.pipesCount = 0;\n        this.removeListener(\"readable\", pipeOnReadable);\n        state.flowing = false;\n        for(var i = 0; i < len; i++)dests[i].emit(\"unpipe\", this);\n        return this;\n    }\n    // try to find the right one.\n    var i = indexOf(state.pipes, dest);\n    if (i === -1) return this;\n    state.pipes.splice(i, 1);\n    state.pipesCount -= 1;\n    if (state.pipesCount === 1) state.pipes = state.pipes[0];\n    dest.emit(\"unpipe\", this);\n    return this;\n};\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n    var res = Stream.prototype.on.call(this, ev, fn);\n    if (ev === \"data\" && !this._readableState.flowing) emitDataEvents(this);\n    if (ev === \"readable\" && this.readable) {\n        var state = this._readableState;\n        if (!state.readableListening) {\n            state.readableListening = true;\n            state.emittedReadable = false;\n            state.needReadable = true;\n            if (!state.reading) {\n                this.read(0);\n            } else if (state.length) {\n                emitReadable(this, state);\n            }\n        }\n    }\n    return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n    emitDataEvents(this);\n    this.read(0);\n    this.emit(\"resume\");\n};\nReadable.prototype.pause = function() {\n    emitDataEvents(this, true);\n    this.emit(\"pause\");\n};\nfunction emitDataEvents(stream, startPaused) {\n    var state = stream._readableState;\n    if (state.flowing) {\n        // https://github.com/isaacs/readable-stream/issues/16\n        throw new Error(\"Cannot switch to old mode now.\");\n    }\n    var paused = startPaused || false;\n    var readable = false;\n    // convert to an old-style stream.\n    stream.readable = true;\n    stream.pipe = Stream.prototype.pipe;\n    stream.on = stream.addListener = Stream.prototype.on;\n    stream.on(\"readable\", function() {\n        readable = true;\n        var c;\n        while(!paused && null !== (c = stream.read()))stream.emit(\"data\", c);\n        if (c === null) {\n            readable = false;\n            stream._readableState.needReadable = true;\n        }\n    });\n    stream.pause = function() {\n        paused = true;\n        this.emit(\"pause\");\n    };\n    stream.resume = function() {\n        paused = false;\n        if (readable) process.nextTick(function() {\n            stream.emit(\"readable\");\n        });\n        else this.read(0);\n        this.emit(\"resume\");\n    };\n    // now make it start, just in case it hadn't already.\n    stream.emit(\"readable\");\n}\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n    var state = this._readableState;\n    var paused = false;\n    var self = this;\n    stream.on(\"end\", function() {\n        if (state.decoder && !state.ended) {\n            var chunk = state.decoder.end();\n            if (chunk && chunk.length) self.push(chunk);\n        }\n        self.push(null);\n    });\n    stream.on(\"data\", function(chunk) {\n        if (state.decoder) chunk = state.decoder.write(chunk);\n        // don't skip over falsy values in objectMode\n        //if (state.objectMode && util.isNullOrUndefined(chunk))\n        if (state.objectMode && (chunk === null || chunk === undefined)) return;\n        else if (!state.objectMode && (!chunk || !chunk.length)) return;\n        var ret = self.push(chunk);\n        if (!ret) {\n            paused = true;\n            stream.pause();\n        }\n    });\n    // proxy all the other methods.\n    // important when wrapping filters and duplexes.\n    for(var i in stream){\n        if (typeof stream[i] === \"function\" && typeof this[i] === \"undefined\") {\n            this[i] = function(method) {\n                return function() {\n                    return stream[method].apply(stream, arguments);\n                };\n            }(i);\n        }\n    }\n    // proxy certain important events.\n    var events = [\n        \"error\",\n        \"close\",\n        \"destroy\",\n        \"pause\",\n        \"resume\"\n    ];\n    forEach(events, function(ev) {\n        stream.on(ev, self.emit.bind(self, ev));\n    });\n    // when we try to consume some more bytes, simply unpause the\n    // underlying stream.\n    self._read = function(n) {\n        if (paused) {\n            paused = false;\n            stream.resume();\n        }\n    };\n    return self;\n};\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n    var list = state.buffer;\n    var length = state.length;\n    var stringMode = !!state.decoder;\n    var objectMode = !!state.objectMode;\n    var ret;\n    // nothing in the list, definitely empty.\n    if (list.length === 0) return null;\n    if (length === 0) ret = null;\n    else if (objectMode) ret = list.shift();\n    else if (!n || n >= length) {\n        // read it all, truncate the array.\n        if (stringMode) ret = list.join(\"\");\n        else ret = Buffer.concat(list, length);\n        list.length = 0;\n    } else {\n        // read just some of it.\n        if (n < list[0].length) {\n            // just take a part of the first list item.\n            // slice is the same for buffers and strings.\n            var buf = list[0];\n            ret = buf.slice(0, n);\n            list[0] = buf.slice(n);\n        } else if (n === list[0].length) {\n            // first list is a perfect match\n            ret = list.shift();\n        } else {\n            // complex case.\n            // we have enough to cover it, but it spans past the first buffer.\n            if (stringMode) ret = \"\";\n            else ret = new Buffer(n);\n            var c = 0;\n            for(var i = 0, l = list.length; i < l && c < n; i++){\n                var buf = list[0];\n                var cpy = Math.min(n - c, buf.length);\n                if (stringMode) ret += buf.slice(0, cpy);\n                else buf.copy(ret, c, 0, cpy);\n                if (cpy < buf.length) list[0] = buf.slice(cpy);\n                else list.shift();\n                c += cpy;\n            }\n        }\n    }\n    return ret;\n}\nfunction endReadable(stream) {\n    var state = stream._readableState;\n    // If we get here before consuming all the bytes, then that is a\n    // bug in node.  Should never happen.\n    if (state.length > 0) throw new Error(\"endReadable called on non-empty stream\");\n    if (!state.endEmitted && state.calledRead) {\n        state.ended = true;\n        process.nextTick(function() {\n            // Check that we didn't get one last unshift.\n            if (!state.endEmitted && state.length === 0) {\n                state.endEmitted = true;\n                stream.readable = false;\n                stream.emit(\"end\");\n            }\n        });\n    }\n}\nfunction forEach(xs, f) {\n    for(var i = 0, l = xs.length; i < l; i++){\n        f(xs[i], i);\n    }\n}\nfunction indexOf(xs, x) {\n    for(var i = 0, l = xs.length; i < l; i++){\n        if (xs[i] === x) return i;\n    }\n    return -1;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbC10b2tlbml6ZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7O0FBRXpDQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLGVBQWUsR0FDZixJQUFJQyxVQUFVQyxtQkFBT0EsQ0FBQztBQUN0QixnQkFBZ0IsR0FHaEIsZUFBZSxHQUNmLElBQUlDLFNBQVNELG9EQUF3QjtBQUNyQyxnQkFBZ0IsR0FFaEJGLFNBQVNJLGFBQWEsR0FBR0E7QUFFekIsSUFBSUMsS0FBS0gsMERBQThCO0FBRXZDLGVBQWUsR0FDZixJQUFJLENBQUNHLEdBQUdFLGFBQWEsRUFBRUYsR0FBR0UsYUFBYSxHQUFHLFNBQVNDLE9BQU8sRUFBRUMsSUFBSTtJQUM5RCxPQUFPRCxRQUFRRSxTQUFTLENBQUNELE1BQU1FLE1BQU07QUFDdkM7QUFDQSxnQkFBZ0IsR0FFaEIsSUFBSUMsU0FBU1YsbUJBQU9BLENBQUM7QUFFckIsZUFBZSxHQUNmLElBQUlXLE9BQU9YLG1CQUFPQSxDQUFDO0FBQ25CVyxLQUFLQyxRQUFRLEdBQUdaLG1CQUFPQSxDQUFDO0FBQ3hCLGdCQUFnQixHQUVoQixJQUFJYTtBQUVKRixLQUFLQyxRQUFRLENBQUNkLFVBQVVZO0FBRXhCLFNBQVNSLGNBQWNZLE9BQU8sRUFBRUMsTUFBTTtJQUNwQ0QsVUFBVUEsV0FBVyxDQUFDO0lBRXRCLGlFQUFpRTtJQUNqRSx1RUFBdUU7SUFDdkUsSUFBSUUsTUFBTUYsUUFBUUcsYUFBYTtJQUMvQixJQUFJLENBQUNBLGFBQWEsR0FBRyxPQUFRRCxRQUFRLElBQUtBLE1BQU0sS0FBSztJQUVyRCxnQkFBZ0I7SUFDaEIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQ0EsYUFBYTtJQUV6QyxJQUFJLENBQUNDLE1BQU0sR0FBRyxFQUFFO0lBQ2hCLElBQUksQ0FBQ1QsTUFBTSxHQUFHO0lBQ2QsSUFBSSxDQUFDVSxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLFVBQVUsR0FBRztJQUNsQixJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNmLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0lBQ2IsSUFBSSxDQUFDQyxVQUFVLEdBQUc7SUFDbEIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFFZixxRUFBcUU7SUFDckUsbUVBQW1FO0lBQ25FLHFFQUFxRTtJQUNyRSxXQUFXO0lBQ1gsSUFBSSxDQUFDQyxVQUFVLEdBQUc7SUFFbEIscUVBQXFFO0lBQ3JFLGlFQUFpRTtJQUNqRSxvRUFBb0U7SUFDcEUsMENBQTBDO0lBQzFDLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBRVoscURBQXFEO0lBQ3JELG1EQUFtRDtJQUNuRCxJQUFJLENBQUNDLFlBQVksR0FBRztJQUNwQixJQUFJLENBQUNDLGVBQWUsR0FBRztJQUN2QixJQUFJLENBQUNDLGlCQUFpQixHQUFHO0lBR3pCLDJEQUEyRDtJQUMzRCx3REFBd0Q7SUFDeEQsSUFBSSxDQUFDQyxVQUFVLEdBQUcsQ0FBQyxDQUFDaEIsUUFBUWdCLFVBQVU7SUFFdEMsc0VBQXNFO0lBQ3RFLDZEQUE2RDtJQUM3RCx1REFBdUQ7SUFDdkQsSUFBSSxDQUFDQyxlQUFlLEdBQUdqQixRQUFRaUIsZUFBZSxJQUFJO0lBRWxELGdFQUFnRTtJQUNoRSw4REFBOEQ7SUFDOUQsSUFBSSxDQUFDQyxNQUFNLEdBQUc7SUFFZCxvRUFBb0U7SUFDcEUsSUFBSSxDQUFDQyxVQUFVLEdBQUc7SUFFbEIsOENBQThDO0lBQzlDLElBQUksQ0FBQ0MsV0FBVyxHQUFHO0lBRW5CLElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBQ2YsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDaEIsSUFBSXRCLFFBQVFzQixRQUFRLEVBQUU7UUFDcEIsSUFBSSxDQUFDdkIsZUFDSEEsZ0JBQWdCYixxSUFBd0M7UUFDMUQsSUFBSSxDQUFDbUMsT0FBTyxHQUFHLElBQUl0QixjQUFjQyxRQUFRc0IsUUFBUTtRQUNqRCxJQUFJLENBQUNBLFFBQVEsR0FBR3RCLFFBQVFzQixRQUFRO0lBQ2xDO0FBQ0Y7QUFFQSxTQUFTdEMsU0FBU2dCLE9BQU87SUFDdkIsSUFBSSxDQUFFLEtBQUksWUFBWWhCLFFBQU8sR0FDM0IsT0FBTyxJQUFJQSxTQUFTZ0I7SUFFdEIsSUFBSSxDQUFDdUIsY0FBYyxHQUFHLElBQUluQyxjQUFjWSxTQUFTLElBQUk7SUFFckQsU0FBUztJQUNULElBQUksQ0FBQ3dCLFFBQVEsR0FBRztJQUVoQjVCLE9BQU82QixJQUFJLENBQUMsSUFBSTtBQUNsQjtBQUVBLG1EQUFtRDtBQUNuRCwrREFBK0Q7QUFDL0QsNkRBQTZEO0FBQzdELHFCQUFxQjtBQUNyQnpDLFNBQVMwQyxTQUFTLENBQUNDLElBQUksR0FBRyxTQUFTQyxLQUFLLEVBQUVOLFFBQVE7SUFDaEQsSUFBSU8sUUFBUSxJQUFJLENBQUNOLGNBQWM7SUFFL0IsSUFBSSxPQUFPSyxVQUFVLFlBQVksQ0FBQ0MsTUFBTWIsVUFBVSxFQUFFO1FBQ2xETSxXQUFXQSxZQUFZTyxNQUFNWixlQUFlO1FBQzVDLElBQUlLLGFBQWFPLE1BQU1QLFFBQVEsRUFBRTtZQUMvQk0sUUFBUSxJQUFJekMsT0FBT3lDLE9BQU9OO1lBQzFCQSxXQUFXO1FBQ2I7SUFDRjtJQUVBLE9BQU9RLGlCQUFpQixJQUFJLEVBQUVELE9BQU9ELE9BQU9OLFVBQVU7QUFDeEQ7QUFFQSw4REFBOEQ7QUFDOUR0QyxTQUFTMEMsU0FBUyxDQUFDSyxPQUFPLEdBQUcsU0FBU0gsS0FBSztJQUN6QyxJQUFJQyxRQUFRLElBQUksQ0FBQ04sY0FBYztJQUMvQixPQUFPTyxpQkFBaUIsSUFBSSxFQUFFRCxPQUFPRCxPQUFPLElBQUk7QUFDbEQ7QUFFQSxTQUFTRSxpQkFBaUI3QixNQUFNLEVBQUU0QixLQUFLLEVBQUVELEtBQUssRUFBRU4sUUFBUSxFQUFFVSxVQUFVO0lBQ2xFLElBQUlDLEtBQUtDLGFBQWFMLE9BQU9EO0lBQzdCLElBQUlLLElBQUk7UUFDTmhDLE9BQU9rQyxJQUFJLENBQUMsU0FBU0Y7SUFDdkIsT0FBTyxJQUFJTCxVQUFVLFFBQVFBLFVBQVVRLFdBQVc7UUFDaERQLE1BQU1uQixPQUFPLEdBQUc7UUFDaEIsSUFBSSxDQUFDbUIsTUFBTXJCLEtBQUssRUFDZDZCLFdBQVdwQyxRQUFRNEI7SUFDdkIsT0FBTyxJQUFJQSxNQUFNYixVQUFVLElBQUlZLFNBQVNBLE1BQU1qQyxNQUFNLEdBQUcsR0FBRztRQUN4RCxJQUFJa0MsTUFBTXJCLEtBQUssSUFBSSxDQUFDd0IsWUFBWTtZQUM5QixJQUFJTSxJQUFJLElBQUlDLE1BQU07WUFDbEJ0QyxPQUFPa0MsSUFBSSxDQUFDLFNBQVNHO1FBQ3ZCLE9BQU8sSUFBSVQsTUFBTXBCLFVBQVUsSUFBSXVCLFlBQVk7WUFDekMsSUFBSU0sSUFBSSxJQUFJQyxNQUFNO1lBQ2xCdEMsT0FBT2tDLElBQUksQ0FBQyxTQUFTRztRQUN2QixPQUFPO1lBQ0wsSUFBSVQsTUFBTVIsT0FBTyxJQUFJLENBQUNXLGNBQWMsQ0FBQ1YsVUFDbkNNLFFBQVFDLE1BQU1SLE9BQU8sQ0FBQ21CLEtBQUssQ0FBQ1o7WUFFOUIsMEJBQTBCO1lBQzFCQyxNQUFNbEMsTUFBTSxJQUFJa0MsTUFBTWIsVUFBVSxHQUFHLElBQUlZLE1BQU1qQyxNQUFNO1lBQ25ELElBQUlxQyxZQUFZO2dCQUNkSCxNQUFNekIsTUFBTSxDQUFDMkIsT0FBTyxDQUFDSDtZQUN2QixPQUFPO2dCQUNMQyxNQUFNbkIsT0FBTyxHQUFHO2dCQUNoQm1CLE1BQU16QixNQUFNLENBQUN1QixJQUFJLENBQUNDO1lBQ3BCO1lBRUEsSUFBSUMsTUFBTWhCLFlBQVksRUFDcEI0QixhQUFheEM7WUFFZnlDLGNBQWN6QyxRQUFRNEI7UUFDeEI7SUFDRixPQUFPLElBQUksQ0FBQ0csWUFBWTtRQUN0QkgsTUFBTW5CLE9BQU8sR0FBRztJQUNsQjtJQUVBLE9BQU9pQyxhQUFhZDtBQUN0QjtBQUlBLDhEQUE4RDtBQUM5RCxrREFBa0Q7QUFDbEQseURBQXlEO0FBQ3pELHFEQUFxRDtBQUNyRCxrRUFBa0U7QUFDbEUsb0VBQW9FO0FBQ3BFLHNDQUFzQztBQUN0QyxTQUFTYyxhQUFhZCxLQUFLO0lBQ3pCLE9BQU8sQ0FBQ0EsTUFBTXJCLEtBQUssSUFDWHFCLENBQUFBLE1BQU1oQixZQUFZLElBQ2xCZ0IsTUFBTWxDLE1BQU0sR0FBR2tDLE1BQU0xQixhQUFhLElBQ2xDMEIsTUFBTWxDLE1BQU0sS0FBSztBQUMzQjtBQUVBLDJCQUEyQjtBQUMzQlgsU0FBUzBDLFNBQVMsQ0FBQ2tCLFdBQVcsR0FBRyxTQUFTQyxHQUFHO0lBQzNDLElBQUksQ0FBQzlDLGVBQ0hBLGdCQUFnQmIscUlBQXdDO0lBQzFELElBQUksQ0FBQ3FDLGNBQWMsQ0FBQ0YsT0FBTyxHQUFHLElBQUl0QixjQUFjOEM7SUFDaEQsSUFBSSxDQUFDdEIsY0FBYyxDQUFDRCxRQUFRLEdBQUd1QjtBQUNqQztBQUVBLDhCQUE4QjtBQUM5QixJQUFJQyxVQUFVO0FBQ2QsU0FBU0Msc0JBQXNCQyxDQUFDO0lBQzlCLElBQUlBLEtBQUtGLFNBQVM7UUFDaEJFLElBQUlGO0lBQ04sT0FBTztRQUNMLGtDQUFrQztRQUNsQ0U7UUFDQSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxNQUFNLEVBQUdELEtBQUtBLEtBQUtDO1FBQzNDRDtJQUNGO0lBQ0EsT0FBT0E7QUFDVDtBQUVBLFNBQVNFLGNBQWNGLENBQUMsRUFBRW5CLEtBQUs7SUFDN0IsSUFBSUEsTUFBTWxDLE1BQU0sS0FBSyxLQUFLa0MsTUFBTXJCLEtBQUssRUFDbkMsT0FBTztJQUVULElBQUlxQixNQUFNYixVQUFVLEVBQ2xCLE9BQU9nQyxNQUFNLElBQUksSUFBSTtJQUV2QixJQUFJQSxNQUFNLFFBQVFHLE1BQU1ILElBQUk7UUFDMUIsaUNBQWlDO1FBQ2pDLElBQUluQixNQUFNdEIsT0FBTyxJQUFJc0IsTUFBTXpCLE1BQU0sQ0FBQ1QsTUFBTSxFQUN0QyxPQUFPa0MsTUFBTXpCLE1BQU0sQ0FBQyxFQUFFLENBQUNULE1BQU07YUFFN0IsT0FBT2tDLE1BQU1sQyxNQUFNO0lBQ3ZCO0lBRUEsSUFBSXFELEtBQUssR0FDUCxPQUFPO0lBRVQseURBQXlEO0lBQ3pELDBEQUEwRDtJQUMxRCwyREFBMkQ7SUFDM0QsV0FBVztJQUNYLElBQUlBLElBQUluQixNQUFNMUIsYUFBYSxFQUN6QjBCLE1BQU0xQixhQUFhLEdBQUc0QyxzQkFBc0JDO0lBRTlDLDBEQUEwRDtJQUMxRCxJQUFJQSxJQUFJbkIsTUFBTWxDLE1BQU0sRUFBRTtRQUNwQixJQUFJLENBQUNrQyxNQUFNckIsS0FBSyxFQUFFO1lBQ2hCcUIsTUFBTWhCLFlBQVksR0FBRztZQUNyQixPQUFPO1FBQ1QsT0FDRSxPQUFPZ0IsTUFBTWxDLE1BQU07SUFDdkI7SUFFQSxPQUFPcUQ7QUFDVDtBQUVBLG9FQUFvRTtBQUNwRWhFLFNBQVMwQyxTQUFTLENBQUMwQixJQUFJLEdBQUcsU0FBU0osQ0FBQztJQUNsQyxJQUFJbkIsUUFBUSxJQUFJLENBQUNOLGNBQWM7SUFDL0JNLE1BQU1sQixVQUFVLEdBQUc7SUFDbkIsSUFBSTBDLFFBQVFMO0lBQ1osSUFBSU07SUFFSixJQUFJLE9BQU9OLE1BQU0sWUFBWUEsSUFBSSxHQUMvQm5CLE1BQU1mLGVBQWUsR0FBRztJQUUxQiw2REFBNkQ7SUFDN0QsZ0VBQWdFO0lBQ2hFLG9DQUFvQztJQUNwQyxJQUFJa0MsTUFBTSxLQUNObkIsTUFBTWhCLFlBQVksSUFDakJnQixDQUFBQSxNQUFNbEMsTUFBTSxJQUFJa0MsTUFBTTFCLGFBQWEsSUFBSTBCLE1BQU1yQixLQUFLLEdBQUc7UUFDeERpQyxhQUFhLElBQUk7UUFDakIsT0FBTztJQUNUO0lBRUFPLElBQUlFLGNBQWNGLEdBQUduQjtJQUVyQiwwREFBMEQ7SUFDMUQsSUFBSW1CLE1BQU0sS0FBS25CLE1BQU1yQixLQUFLLEVBQUU7UUFDMUI4QyxNQUFNO1FBRU4seURBQXlEO1FBQ3pELHdEQUF3RDtRQUN4RCwrREFBK0Q7UUFDL0QsdURBQXVEO1FBQ3ZELDBEQUEwRDtRQUMxRCwyREFBMkQ7UUFDM0QsRUFBRTtRQUNGLDJEQUEyRDtRQUMzRCwyREFBMkQ7UUFDM0QsNERBQTREO1FBQzVELHFEQUFxRDtRQUNyRCxJQUFJekIsTUFBTWxDLE1BQU0sR0FBRyxLQUFLa0MsTUFBTVIsT0FBTyxFQUFFO1lBQ3JDaUMsTUFBTUMsU0FBU1AsR0FBR25CO1lBQ2xCQSxNQUFNbEMsTUFBTSxJQUFJMkQsSUFBSTNELE1BQU07UUFDNUI7UUFFQSxJQUFJa0MsTUFBTWxDLE1BQU0sS0FBSyxHQUNuQjZELFlBQVksSUFBSTtRQUVsQixPQUFPRjtJQUNUO0lBRUEsb0RBQW9EO0lBQ3BELDREQUE0RDtJQUM1RCw2REFBNkQ7SUFDN0QsNkRBQTZEO0lBQzdELDJEQUEyRDtJQUMzRCxpQ0FBaUM7SUFDakMsRUFBRTtJQUNGLHFCQUFxQjtJQUNyQiw2REFBNkQ7SUFDN0QsMEJBQTBCO0lBQzFCLEVBQUU7SUFDRixvRUFBb0U7SUFDcEUsa0VBQWtFO0lBQ2xFLGtFQUFrRTtJQUNsRSxtRUFBbUU7SUFDbkUsc0NBQXNDO0lBQ3RDLHFFQUFxRTtJQUNyRSxzRUFBc0U7SUFDdEUsa0JBQWtCO0lBQ2xCLEVBQUU7SUFDRixzRUFBc0U7SUFFdEUsZ0VBQWdFO0lBQ2hFLElBQUlHLFNBQVM1QixNQUFNaEIsWUFBWTtJQUUvQix3RUFBd0U7SUFDeEUsSUFBSWdCLE1BQU1sQyxNQUFNLEdBQUdxRCxLQUFLbkIsTUFBTTFCLGFBQWEsRUFDekNzRCxTQUFTO0lBRVgsdUVBQXVFO0lBQ3ZFLGtDQUFrQztJQUNsQyxJQUFJNUIsTUFBTXJCLEtBQUssSUFBSXFCLE1BQU1uQixPQUFPLEVBQzlCK0MsU0FBUztJQUVYLElBQUlBLFFBQVE7UUFDVjVCLE1BQU1uQixPQUFPLEdBQUc7UUFDaEJtQixNQUFNakIsSUFBSSxHQUFHO1FBQ2Isb0VBQW9FO1FBQ3BFLElBQUlpQixNQUFNbEMsTUFBTSxLQUFLLEdBQ25Ca0MsTUFBTWhCLFlBQVksR0FBRztRQUN2Qiw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDNkMsS0FBSyxDQUFDN0IsTUFBTTFCLGFBQWE7UUFDOUIwQixNQUFNakIsSUFBSSxHQUFHO0lBQ2Y7SUFFQSw2REFBNkQ7SUFDN0QsNkRBQTZEO0lBQzdELDBCQUEwQjtJQUMxQixJQUFJNkMsVUFBVSxDQUFDNUIsTUFBTW5CLE9BQU8sRUFDMUJzQyxJQUFJRSxjQUFjRyxPQUFPeEI7SUFFM0IsSUFBSW1CLElBQUksR0FDTk0sTUFBTUMsU0FBU1AsR0FBR25CO1NBRWxCeUIsTUFBTTtJQUVSLElBQUlBLFFBQVEsTUFBTTtRQUNoQnpCLE1BQU1oQixZQUFZLEdBQUc7UUFDckJtQyxJQUFJO0lBQ047SUFFQW5CLE1BQU1sQyxNQUFNLElBQUlxRDtJQUVoQix5REFBeUQ7SUFDekQsb0RBQW9EO0lBQ3BELElBQUluQixNQUFNbEMsTUFBTSxLQUFLLEtBQUssQ0FBQ2tDLE1BQU1yQixLQUFLLEVBQ3BDcUIsTUFBTWhCLFlBQVksR0FBRztJQUV2QiwrREFBK0Q7SUFDL0Qsa0VBQWtFO0lBQ2xFLDRDQUE0QztJQUM1QyxJQUFJZ0IsTUFBTXJCLEtBQUssSUFBSSxDQUFDcUIsTUFBTXBCLFVBQVUsSUFBSW9CLE1BQU1sQyxNQUFNLEtBQUssR0FDdkQ2RCxZQUFZLElBQUk7SUFFbEIsT0FBT0Y7QUFDVDtBQUVBLFNBQVNwQixhQUFhTCxLQUFLLEVBQUVELEtBQUs7SUFDaEMsSUFBSUssS0FBSztJQUNULElBQUksQ0FBQzlDLE9BQU93RSxRQUFRLENBQUMvQixVQUNqQixhQUFhLE9BQU9BLFNBQ3BCQSxVQUFVLFFBQ1ZBLFVBQVVRLGFBQ1YsQ0FBQ1AsTUFBTWIsVUFBVSxFQUFFO1FBQ3JCaUIsS0FBSyxJQUFJMkIsVUFBVTtJQUNyQjtJQUNBLE9BQU8zQjtBQUNUO0FBR0EsU0FBU0ksV0FBV3BDLE1BQU0sRUFBRTRCLEtBQUs7SUFDL0IsSUFBSUEsTUFBTVIsT0FBTyxJQUFJLENBQUNRLE1BQU1yQixLQUFLLEVBQUU7UUFDakMsSUFBSW9CLFFBQVFDLE1BQU1SLE9BQU8sQ0FBQ3dDLEdBQUc7UUFDN0IsSUFBSWpDLFNBQVNBLE1BQU1qQyxNQUFNLEVBQUU7WUFDekJrQyxNQUFNekIsTUFBTSxDQUFDdUIsSUFBSSxDQUFDQztZQUNsQkMsTUFBTWxDLE1BQU0sSUFBSWtDLE1BQU1iLFVBQVUsR0FBRyxJQUFJWSxNQUFNakMsTUFBTTtRQUNyRDtJQUNGO0lBQ0FrQyxNQUFNckIsS0FBSyxHQUFHO0lBRWQsdURBQXVEO0lBQ3ZELGlEQUFpRDtJQUNqRCxJQUFJcUIsTUFBTWxDLE1BQU0sR0FBRyxHQUNqQjhDLGFBQWF4QztTQUVidUQsWUFBWXZEO0FBQ2hCO0FBRUEsd0VBQXdFO0FBQ3hFLHFFQUFxRTtBQUNyRSx1REFBdUQ7QUFDdkQsU0FBU3dDLGFBQWF4QyxNQUFNO0lBQzFCLElBQUk0QixRQUFRNUIsT0FBT3NCLGNBQWM7SUFDakNNLE1BQU1oQixZQUFZLEdBQUc7SUFDckIsSUFBSWdCLE1BQU1mLGVBQWUsRUFDdkI7SUFFRmUsTUFBTWYsZUFBZSxHQUFHO0lBQ3hCLElBQUllLE1BQU1qQixJQUFJLEVBQ1prRCxRQUFRQyxRQUFRLENBQUM7UUFDZkMsY0FBYy9EO0lBQ2hCO1NBRUErRCxjQUFjL0Q7QUFDbEI7QUFFQSxTQUFTK0QsY0FBYy9ELE1BQU07SUFDM0JBLE9BQU9rQyxJQUFJLENBQUM7QUFDZDtBQUdBLG9FQUFvRTtBQUNwRSxtRUFBbUU7QUFDbkUsaUVBQWlFO0FBQ2pFLG9CQUFvQjtBQUNwQixpRUFBaUU7QUFDakUsd0RBQXdEO0FBQ3hELFNBQVNPLGNBQWN6QyxNQUFNLEVBQUU0QixLQUFLO0lBQ2xDLElBQUksQ0FBQ0EsTUFBTVQsV0FBVyxFQUFFO1FBQ3RCUyxNQUFNVCxXQUFXLEdBQUc7UUFDcEIwQyxRQUFRQyxRQUFRLENBQUM7WUFDZkUsZUFBZWhFLFFBQVE0QjtRQUN6QjtJQUNGO0FBQ0Y7QUFFQSxTQUFTb0MsZUFBZWhFLE1BQU0sRUFBRTRCLEtBQUs7SUFDbkMsSUFBSXFDLE1BQU1yQyxNQUFNbEMsTUFBTTtJQUN0QixNQUFPLENBQUNrQyxNQUFNbkIsT0FBTyxJQUFJLENBQUNtQixNQUFNdEIsT0FBTyxJQUFJLENBQUNzQixNQUFNckIsS0FBSyxJQUNoRHFCLE1BQU1sQyxNQUFNLEdBQUdrQyxNQUFNMUIsYUFBYSxDQUFFO1FBQ3pDRixPQUFPbUQsSUFBSSxDQUFDO1FBQ1osSUFBSWMsUUFBUXJDLE1BQU1sQyxNQUFNLEVBRXRCO2FBRUF1RSxNQUFNckMsTUFBTWxDLE1BQU07SUFDdEI7SUFDQWtDLE1BQU1ULFdBQVcsR0FBRztBQUN0QjtBQUVBLHlFQUF5RTtBQUN6RSxrREFBa0Q7QUFDbEQscUVBQXFFO0FBQ3JFLDhDQUE4QztBQUM5Q3BDLFNBQVMwQyxTQUFTLENBQUNnQyxLQUFLLEdBQUcsU0FBU1YsQ0FBQztJQUNuQyxJQUFJLENBQUNiLElBQUksQ0FBQyxTQUFTLElBQUlJLE1BQU07QUFDL0I7QUFFQXZELFNBQVMwQyxTQUFTLENBQUN5QyxJQUFJLEdBQUcsU0FBU0MsSUFBSSxFQUFFQyxRQUFRO0lBQy9DLElBQUlDLE1BQU0sSUFBSTtJQUNkLElBQUl6QyxRQUFRLElBQUksQ0FBQ04sY0FBYztJQUUvQixPQUFRTSxNQUFNdkIsVUFBVTtRQUN0QixLQUFLO1lBQ0h1QixNQUFNeEIsS0FBSyxHQUFHK0Q7WUFDZDtRQUNGLEtBQUs7WUFDSHZDLE1BQU14QixLQUFLLEdBQUc7Z0JBQUN3QixNQUFNeEIsS0FBSztnQkFBRStEO2FBQUs7WUFDakM7UUFDRjtZQUNFdkMsTUFBTXhCLEtBQUssQ0FBQ3NCLElBQUksQ0FBQ3lDO1lBQ2pCO0lBQ0o7SUFDQXZDLE1BQU12QixVQUFVLElBQUk7SUFFcEIsSUFBSWlFLFFBQVEsQ0FBQyxDQUFDRixZQUFZQSxTQUFTUixHQUFHLEtBQUssS0FBSSxLQUNuQ08sU0FBU04sUUFBUVUsTUFBTSxJQUN2QkosU0FBU04sUUFBUVcsTUFBTTtJQUVuQyxJQUFJQyxRQUFRSCxRQUFRSSxRQUFRQztJQUM1QixJQUFJL0MsTUFBTXBCLFVBQVUsRUFDbEJxRCxRQUFRQyxRQUFRLENBQUNXO1NBRWpCSixJQUFJTyxJQUFJLENBQUMsT0FBT0g7SUFFbEJOLEtBQUtVLEVBQUUsQ0FBQyxVQUFVQztJQUNsQixTQUFTQSxTQUFTdkQsUUFBUTtRQUN4QixJQUFJQSxhQUFhOEMsS0FBSztRQUN0Qk07SUFDRjtJQUVBLFNBQVNEO1FBQ1BQLEtBQUtQLEdBQUc7SUFDVjtJQUVBLDBEQUEwRDtJQUMxRCw0REFBNEQ7SUFDNUQsMkRBQTJEO0lBQzNELFlBQVk7SUFDWixJQUFJbUIsVUFBVUMsWUFBWVg7SUFDMUJGLEtBQUtVLEVBQUUsQ0FBQyxTQUFTRTtJQUVqQixTQUFTSjtRQUNQLGlEQUFpRDtRQUNqRFIsS0FBS2MsY0FBYyxDQUFDLFNBQVNDO1FBQzdCZixLQUFLYyxjQUFjLENBQUMsVUFBVUU7UUFDOUJoQixLQUFLYyxjQUFjLENBQUMsU0FBU0Y7UUFDN0JaLEtBQUtjLGNBQWMsQ0FBQyxTQUFTRztRQUM3QmpCLEtBQUtjLGNBQWMsQ0FBQyxVQUFVSDtRQUM5QlQsSUFBSVksY0FBYyxDQUFDLE9BQU9QO1FBQzFCTCxJQUFJWSxjQUFjLENBQUMsT0FBT047UUFFMUIsdURBQXVEO1FBQ3ZELHlEQUF5RDtRQUN6RCxpQkFBaUI7UUFDakIsNkRBQTZEO1FBQzdELDZEQUE2RDtRQUM3RCxJQUFJLENBQUNSLEtBQUtrQixjQUFjLElBQUlsQixLQUFLa0IsY0FBYyxDQUFDQyxTQUFTLEVBQ3ZEUDtJQUNKO0lBRUEsc0RBQXNEO0lBQ3RELDBEQUEwRDtJQUMxRCxTQUFTSyxRQUFRcEQsRUFBRTtRQUNqQnVEO1FBQ0FwQixLQUFLYyxjQUFjLENBQUMsU0FBU0c7UUFDN0IsSUFBSWhHLEdBQUdFLGFBQWEsQ0FBQzZFLE1BQU0sYUFBYSxHQUN0Q0EsS0FBS2pDLElBQUksQ0FBQyxTQUFTRjtJQUN2QjtJQUNBLG1FQUFtRTtJQUNuRSx3REFBd0Q7SUFDeEQsSUFBSSxDQUFDbUMsS0FBS3FCLE9BQU8sSUFBSSxDQUFDckIsS0FBS3FCLE9BQU8sQ0FBQ0MsS0FBSyxFQUN0Q3RCLEtBQUtVLEVBQUUsQ0FBQyxTQUFTTztTQUNkLElBQUlwRyxRQUFRbUYsS0FBS3FCLE9BQU8sQ0FBQ0MsS0FBSyxHQUNqQ3RCLEtBQUtxQixPQUFPLENBQUNDLEtBQUssQ0FBQzNELE9BQU8sQ0FBQ3NEO1NBRTNCakIsS0FBS3FCLE9BQU8sQ0FBQ0MsS0FBSyxHQUFHO1FBQUNMO1FBQVNqQixLQUFLcUIsT0FBTyxDQUFDQyxLQUFLO0tBQUM7SUFJcEQsOERBQThEO0lBQzlELFNBQVNQO1FBQ1BmLEtBQUtjLGNBQWMsQ0FBQyxVQUFVRTtRQUM5Qkk7SUFDRjtJQUNBcEIsS0FBS1MsSUFBSSxDQUFDLFNBQVNNO0lBQ25CLFNBQVNDO1FBQ1BoQixLQUFLYyxjQUFjLENBQUMsU0FBU0M7UUFDN0JLO0lBQ0Y7SUFDQXBCLEtBQUtTLElBQUksQ0FBQyxVQUFVTztJQUVwQixTQUFTSTtRQUNQbEIsSUFBSWtCLE1BQU0sQ0FBQ3BCO0lBQ2I7SUFFQSx5Q0FBeUM7SUFDekNBLEtBQUtqQyxJQUFJLENBQUMsUUFBUW1DO0lBRWxCLG9EQUFvRDtJQUNwRCxJQUFJLENBQUN6QyxNQUFNdEIsT0FBTyxFQUFFO1FBQ2xCLHVEQUF1RDtRQUN2RCxvQ0FBb0M7UUFDcEMsd0RBQXdEO1FBQ3hELG1DQUFtQztRQUNuQyxJQUFJLENBQUN1RSxFQUFFLENBQUMsWUFBWWE7UUFFcEI5RCxNQUFNdEIsT0FBTyxHQUFHO1FBQ2hCdUQsUUFBUUMsUUFBUSxDQUFDO1lBQ2Y2QixLQUFLdEI7UUFDUDtJQUNGO0lBRUEsT0FBT0Y7QUFDVDtBQUVBLFNBQVNhLFlBQVlYLEdBQUc7SUFDdEIsT0FBTztRQUNMLElBQUlGLE9BQU8sSUFBSTtRQUNmLElBQUl2QyxRQUFReUMsSUFBSS9DLGNBQWM7UUFDOUJNLE1BQU1WLFVBQVU7UUFDaEIsSUFBSVUsTUFBTVYsVUFBVSxLQUFLLEdBQ3ZCeUUsS0FBS3RCO0lBQ1Q7QUFDRjtBQUVBLFNBQVNzQixLQUFLdEIsR0FBRztJQUNmLElBQUl6QyxRQUFReUMsSUFBSS9DLGNBQWM7SUFDOUIsSUFBSUs7SUFDSkMsTUFBTVYsVUFBVSxHQUFHO0lBRW5CLFNBQVNxQixNQUFNNEIsSUFBSSxFQUFFeUIsQ0FBQyxFQUFFQyxJQUFJO1FBQzFCLElBQUlDLFVBQVUzQixLQUFLNUIsS0FBSyxDQUFDWjtRQUN6QixJQUFJLFVBQVVtRSxTQUFTO1lBQ3JCbEUsTUFBTVYsVUFBVTtRQUNsQjtJQUNGO0lBRUEsTUFBT1UsTUFBTXZCLFVBQVUsSUFBSSxTQUFVc0IsQ0FBQUEsUUFBUTBDLElBQUlsQixJQUFJLEVBQUMsRUFBSTtRQUV4RCxJQUFJdkIsTUFBTXZCLFVBQVUsS0FBSyxHQUN2QmtDLE1BQU1YLE1BQU14QixLQUFLLEVBQUUsR0FBRzthQUV0QjJGLFFBQVFuRSxNQUFNeEIsS0FBSyxFQUFFbUM7UUFFdkI4QixJQUFJbkMsSUFBSSxDQUFDLFFBQVFQO1FBRWpCLDBEQUEwRDtRQUMxRCxJQUFJQyxNQUFNVixVQUFVLEdBQUcsR0FDckI7SUFDSjtJQUVBLGdFQUFnRTtJQUNoRSxxREFBcUQ7SUFDckQsRUFBRTtJQUNGLHVDQUF1QztJQUN2QyxJQUFJVSxNQUFNdkIsVUFBVSxLQUFLLEdBQUc7UUFDMUJ1QixNQUFNdEIsT0FBTyxHQUFHO1FBRWhCLHFFQUFxRTtRQUNyRSxJQUFJbEIsR0FBR0UsYUFBYSxDQUFDK0UsS0FBSyxVQUFVLEdBQ2xDMkIsZUFBZTNCO1FBQ2pCO0lBQ0Y7SUFFQSxtRUFBbUU7SUFDbkUsbURBQW1EO0lBQ25EekMsTUFBTVgsTUFBTSxHQUFHO0FBQ2pCO0FBRUEsU0FBU3lFO0lBQ1AsSUFBSSxJQUFJLENBQUNwRSxjQUFjLENBQUNMLE1BQU0sRUFBRTtRQUM5QixJQUFJLENBQUNLLGNBQWMsQ0FBQ0wsTUFBTSxHQUFHO1FBQzdCMEUsS0FBSyxJQUFJO0lBQ1g7QUFDRjtBQUdBNUcsU0FBUzBDLFNBQVMsQ0FBQzhELE1BQU0sR0FBRyxTQUFTcEIsSUFBSTtJQUN2QyxJQUFJdkMsUUFBUSxJQUFJLENBQUNOLGNBQWM7SUFFL0IsaURBQWlEO0lBQ2pELElBQUlNLE1BQU12QixVQUFVLEtBQUssR0FDdkIsT0FBTyxJQUFJO0lBRWIsMkNBQTJDO0lBQzNDLElBQUl1QixNQUFNdkIsVUFBVSxLQUFLLEdBQUc7UUFDMUIsNkNBQTZDO1FBQzdDLElBQUk4RCxRQUFRQSxTQUFTdkMsTUFBTXhCLEtBQUssRUFDOUIsT0FBTyxJQUFJO1FBRWIsSUFBSSxDQUFDK0QsTUFDSEEsT0FBT3ZDLE1BQU14QixLQUFLO1FBRXBCLGVBQWU7UUFDZndCLE1BQU14QixLQUFLLEdBQUc7UUFDZHdCLE1BQU12QixVQUFVLEdBQUc7UUFDbkIsSUFBSSxDQUFDNEUsY0FBYyxDQUFDLFlBQVlTO1FBQ2hDOUQsTUFBTXRCLE9BQU8sR0FBRztRQUNoQixJQUFJNkQsTUFDRkEsS0FBS2pDLElBQUksQ0FBQyxVQUFVLElBQUk7UUFDMUIsT0FBTyxJQUFJO0lBQ2I7SUFFQSx5Q0FBeUM7SUFFekMsSUFBSSxDQUFDaUMsTUFBTTtRQUNULGNBQWM7UUFDZCxJQUFJOEIsUUFBUXJFLE1BQU14QixLQUFLO1FBQ3ZCLElBQUk2RCxNQUFNckMsTUFBTXZCLFVBQVU7UUFDMUJ1QixNQUFNeEIsS0FBSyxHQUFHO1FBQ2R3QixNQUFNdkIsVUFBVSxHQUFHO1FBQ25CLElBQUksQ0FBQzRFLGNBQWMsQ0FBQyxZQUFZUztRQUNoQzlELE1BQU10QixPQUFPLEdBQUc7UUFFaEIsSUFBSyxJQUFJc0YsSUFBSSxHQUFHQSxJQUFJM0IsS0FBSzJCLElBQ3ZCSyxLQUFLLENBQUNMLEVBQUUsQ0FBQzFELElBQUksQ0FBQyxVQUFVLElBQUk7UUFDOUIsT0FBTyxJQUFJO0lBQ2I7SUFFQSw2QkFBNkI7SUFDN0IsSUFBSTBELElBQUlNLFFBQVF0RSxNQUFNeEIsS0FBSyxFQUFFK0Q7SUFDN0IsSUFBSXlCLE1BQU0sQ0FBQyxHQUNULE9BQU8sSUFBSTtJQUViaEUsTUFBTXhCLEtBQUssQ0FBQytGLE1BQU0sQ0FBQ1AsR0FBRztJQUN0QmhFLE1BQU12QixVQUFVLElBQUk7SUFDcEIsSUFBSXVCLE1BQU12QixVQUFVLEtBQUssR0FDdkJ1QixNQUFNeEIsS0FBSyxHQUFHd0IsTUFBTXhCLEtBQUssQ0FBQyxFQUFFO0lBRTlCK0QsS0FBS2pDLElBQUksQ0FBQyxVQUFVLElBQUk7SUFFeEIsT0FBTyxJQUFJO0FBQ2I7QUFFQSwyQ0FBMkM7QUFDM0MscURBQXFEO0FBQ3JEbkQsU0FBUzBDLFNBQVMsQ0FBQ29ELEVBQUUsR0FBRyxTQUFTdUIsRUFBRSxFQUFFQyxFQUFFO0lBQ3JDLElBQUlDLE1BQU0zRyxPQUFPOEIsU0FBUyxDQUFDb0QsRUFBRSxDQUFDckQsSUFBSSxDQUFDLElBQUksRUFBRTRFLElBQUlDO0lBRTdDLElBQUlELE9BQU8sVUFBVSxDQUFDLElBQUksQ0FBQzlFLGNBQWMsQ0FBQ2hCLE9BQU8sRUFDL0MwRixlQUFlLElBQUk7SUFFckIsSUFBSUksT0FBTyxjQUFjLElBQUksQ0FBQzdFLFFBQVEsRUFBRTtRQUN0QyxJQUFJSyxRQUFRLElBQUksQ0FBQ04sY0FBYztRQUMvQixJQUFJLENBQUNNLE1BQU1kLGlCQUFpQixFQUFFO1lBQzVCYyxNQUFNZCxpQkFBaUIsR0FBRztZQUMxQmMsTUFBTWYsZUFBZSxHQUFHO1lBQ3hCZSxNQUFNaEIsWUFBWSxHQUFHO1lBQ3JCLElBQUksQ0FBQ2dCLE1BQU1uQixPQUFPLEVBQUU7Z0JBQ2xCLElBQUksQ0FBQzBDLElBQUksQ0FBQztZQUNaLE9BQU8sSUFBSXZCLE1BQU1sQyxNQUFNLEVBQUU7Z0JBQ3ZCOEMsYUFBYSxJQUFJLEVBQUVaO1lBQ3JCO1FBQ0Y7SUFDRjtJQUVBLE9BQU8wRTtBQUNUO0FBQ0F2SCxTQUFTMEMsU0FBUyxDQUFDOEUsV0FBVyxHQUFHeEgsU0FBUzBDLFNBQVMsQ0FBQ29ELEVBQUU7QUFFdEQsc0VBQXNFO0FBQ3RFLG9EQUFvRDtBQUNwRDlGLFNBQVMwQyxTQUFTLENBQUMrRSxNQUFNLEdBQUc7SUFDMUJSLGVBQWUsSUFBSTtJQUNuQixJQUFJLENBQUM3QyxJQUFJLENBQUM7SUFDVixJQUFJLENBQUNqQixJQUFJLENBQUM7QUFDWjtBQUVBbkQsU0FBUzBDLFNBQVMsQ0FBQ2dGLEtBQUssR0FBRztJQUN6QlQsZUFBZSxJQUFJLEVBQUU7SUFDckIsSUFBSSxDQUFDOUQsSUFBSSxDQUFDO0FBQ1o7QUFFQSxTQUFTOEQsZUFBZWhHLE1BQU0sRUFBRTBHLFdBQVc7SUFDekMsSUFBSTlFLFFBQVE1QixPQUFPc0IsY0FBYztJQUVqQyxJQUFJTSxNQUFNdEIsT0FBTyxFQUFFO1FBQ2pCLHNEQUFzRDtRQUN0RCxNQUFNLElBQUlnQyxNQUFNO0lBQ2xCO0lBRUEsSUFBSXFFLFNBQVNELGVBQWU7SUFDNUIsSUFBSW5GLFdBQVc7SUFFZixrQ0FBa0M7SUFDbEN2QixPQUFPdUIsUUFBUSxHQUFHO0lBQ2xCdkIsT0FBT2tFLElBQUksR0FBR3ZFLE9BQU84QixTQUFTLENBQUN5QyxJQUFJO0lBQ25DbEUsT0FBTzZFLEVBQUUsR0FBRzdFLE9BQU91RyxXQUFXLEdBQUc1RyxPQUFPOEIsU0FBUyxDQUFDb0QsRUFBRTtJQUVwRDdFLE9BQU82RSxFQUFFLENBQUMsWUFBWTtRQUNwQnRELFdBQVc7UUFFWCxJQUFJcUY7UUFDSixNQUFPLENBQUNELFVBQVcsU0FBVUMsQ0FBQUEsSUFBSTVHLE9BQU9tRCxJQUFJLEVBQUMsRUFDM0NuRCxPQUFPa0MsSUFBSSxDQUFDLFFBQVEwRTtRQUV0QixJQUFJQSxNQUFNLE1BQU07WUFDZHJGLFdBQVc7WUFDWHZCLE9BQU9zQixjQUFjLENBQUNWLFlBQVksR0FBRztRQUN2QztJQUNGO0lBRUFaLE9BQU95RyxLQUFLLEdBQUc7UUFDYkUsU0FBUztRQUNULElBQUksQ0FBQ3pFLElBQUksQ0FBQztJQUNaO0lBRUFsQyxPQUFPd0csTUFBTSxHQUFHO1FBQ2RHLFNBQVM7UUFDVCxJQUFJcEYsVUFDRnNDLFFBQVFDLFFBQVEsQ0FBQztZQUNmOUQsT0FBT2tDLElBQUksQ0FBQztRQUNkO2FBRUEsSUFBSSxDQUFDaUIsSUFBSSxDQUFDO1FBQ1osSUFBSSxDQUFDakIsSUFBSSxDQUFDO0lBQ1o7SUFFQSxxREFBcUQ7SUFDckRsQyxPQUFPa0MsSUFBSSxDQUFDO0FBQ2Q7QUFFQSxxREFBcUQ7QUFDckQsdURBQXVEO0FBQ3ZELDZDQUE2QztBQUM3Q25ELFNBQVMwQyxTQUFTLENBQUNvRixJQUFJLEdBQUcsU0FBUzdHLE1BQU07SUFDdkMsSUFBSTRCLFFBQVEsSUFBSSxDQUFDTixjQUFjO0lBQy9CLElBQUlxRixTQUFTO0lBRWIsSUFBSUcsT0FBTyxJQUFJO0lBQ2Y5RyxPQUFPNkUsRUFBRSxDQUFDLE9BQU87UUFDZixJQUFJakQsTUFBTVIsT0FBTyxJQUFJLENBQUNRLE1BQU1yQixLQUFLLEVBQUU7WUFDakMsSUFBSW9CLFFBQVFDLE1BQU1SLE9BQU8sQ0FBQ3dDLEdBQUc7WUFDN0IsSUFBSWpDLFNBQVNBLE1BQU1qQyxNQUFNLEVBQ3ZCb0gsS0FBS3BGLElBQUksQ0FBQ0M7UUFDZDtRQUVBbUYsS0FBS3BGLElBQUksQ0FBQztJQUNaO0lBRUExQixPQUFPNkUsRUFBRSxDQUFDLFFBQVEsU0FBU2xELEtBQUs7UUFDOUIsSUFBSUMsTUFBTVIsT0FBTyxFQUNmTyxRQUFRQyxNQUFNUixPQUFPLENBQUNtQixLQUFLLENBQUNaO1FBRTlCLDZDQUE2QztRQUM3Qyx3REFBd0Q7UUFDeEQsSUFBSUMsTUFBTWIsVUFBVSxJQUFLWSxDQUFBQSxVQUFVLFFBQVFBLFVBQVVRLFNBQVEsR0FDM0Q7YUFDRyxJQUFJLENBQUNQLE1BQU1iLFVBQVUsSUFBSyxFQUFDWSxTQUFTLENBQUNBLE1BQU1qQyxNQUFNLEdBQ3BEO1FBRUYsSUFBSTJELE1BQU15RCxLQUFLcEYsSUFBSSxDQUFDQztRQUNwQixJQUFJLENBQUMwQixLQUFLO1lBQ1JzRCxTQUFTO1lBQ1QzRyxPQUFPeUcsS0FBSztRQUNkO0lBQ0Y7SUFFQSwrQkFBK0I7SUFDL0IsZ0RBQWdEO0lBQ2hELElBQUssSUFBSWIsS0FBSzVGLE9BQVE7UUFDcEIsSUFBSSxPQUFPQSxNQUFNLENBQUM0RixFQUFFLEtBQUssY0FDckIsT0FBTyxJQUFJLENBQUNBLEVBQUUsS0FBSyxhQUFhO1lBQ2xDLElBQUksQ0FBQ0EsRUFBRSxHQUFHLFNBQVNtQixNQUFNO2dCQUFJLE9BQU87b0JBQ2xDLE9BQU8vRyxNQUFNLENBQUMrRyxPQUFPLENBQUNDLEtBQUssQ0FBQ2hILFFBQVFpSDtnQkFDdEM7WUFBQyxFQUFFckI7UUFDTDtJQUNGO0lBRUEsa0NBQWtDO0lBQ2xDLElBQUlzQixTQUFTO1FBQUM7UUFBUztRQUFTO1FBQVc7UUFBUztLQUFTO0lBQzdEbkIsUUFBUW1CLFFBQVEsU0FBU2QsRUFBRTtRQUN6QnBHLE9BQU82RSxFQUFFLENBQUN1QixJQUFJVSxLQUFLNUUsSUFBSSxDQUFDaUYsSUFBSSxDQUFDTCxNQUFNVjtJQUNyQztJQUVBLDZEQUE2RDtJQUM3RCxxQkFBcUI7SUFDckJVLEtBQUtyRCxLQUFLLEdBQUcsU0FBU1YsQ0FBQztRQUNyQixJQUFJNEQsUUFBUTtZQUNWQSxTQUFTO1lBQ1QzRyxPQUFPd0csTUFBTTtRQUNmO0lBQ0Y7SUFFQSxPQUFPTTtBQUNUO0FBSUEscUNBQXFDO0FBQ3JDL0gsU0FBU3FJLFNBQVMsR0FBRzlEO0FBRXJCLDhDQUE4QztBQUM5QyxpRUFBaUU7QUFDakUsU0FBU0EsU0FBU1AsQ0FBQyxFQUFFbkIsS0FBSztJQUN4QixJQUFJaUUsT0FBT2pFLE1BQU16QixNQUFNO0lBQ3ZCLElBQUlULFNBQVNrQyxNQUFNbEMsTUFBTTtJQUN6QixJQUFJMkgsYUFBYSxDQUFDLENBQUN6RixNQUFNUixPQUFPO0lBQ2hDLElBQUlMLGFBQWEsQ0FBQyxDQUFDYSxNQUFNYixVQUFVO0lBQ25DLElBQUlzQztJQUVKLHlDQUF5QztJQUN6QyxJQUFJd0MsS0FBS25HLE1BQU0sS0FBSyxHQUNsQixPQUFPO0lBRVQsSUFBSUEsV0FBVyxHQUNiMkQsTUFBTTtTQUNILElBQUl0QyxZQUNQc0MsTUFBTXdDLEtBQUt5QixLQUFLO1NBQ2IsSUFBSSxDQUFDdkUsS0FBS0EsS0FBS3JELFFBQVE7UUFDMUIsbUNBQW1DO1FBQ25DLElBQUkySCxZQUNGaEUsTUFBTXdDLEtBQUswQixJQUFJLENBQUM7YUFFaEJsRSxNQUFNbkUsT0FBT3NJLE1BQU0sQ0FBQzNCLE1BQU1uRztRQUM1Qm1HLEtBQUtuRyxNQUFNLEdBQUc7SUFDaEIsT0FBTztRQUNMLHdCQUF3QjtRQUN4QixJQUFJcUQsSUFBSThDLElBQUksQ0FBQyxFQUFFLENBQUNuRyxNQUFNLEVBQUU7WUFDdEIsMkNBQTJDO1lBQzNDLDZDQUE2QztZQUM3QyxJQUFJK0gsTUFBTTVCLElBQUksQ0FBQyxFQUFFO1lBQ2pCeEMsTUFBTW9FLElBQUlDLEtBQUssQ0FBQyxHQUFHM0U7WUFDbkI4QyxJQUFJLENBQUMsRUFBRSxHQUFHNEIsSUFBSUMsS0FBSyxDQUFDM0U7UUFDdEIsT0FBTyxJQUFJQSxNQUFNOEMsSUFBSSxDQUFDLEVBQUUsQ0FBQ25HLE1BQU0sRUFBRTtZQUMvQixnQ0FBZ0M7WUFDaEMyRCxNQUFNd0MsS0FBS3lCLEtBQUs7UUFDbEIsT0FBTztZQUNMLGdCQUFnQjtZQUNoQixrRUFBa0U7WUFDbEUsSUFBSUQsWUFDRmhFLE1BQU07aUJBRU5BLE1BQU0sSUFBSW5FLE9BQU82RDtZQUVuQixJQUFJNkQsSUFBSTtZQUNSLElBQUssSUFBSWhCLElBQUksR0FBRytCLElBQUk5QixLQUFLbkcsTUFBTSxFQUFFa0csSUFBSStCLEtBQUtmLElBQUk3RCxHQUFHNkMsSUFBSztnQkFDcEQsSUFBSTZCLE1BQU01QixJQUFJLENBQUMsRUFBRTtnQkFDakIsSUFBSStCLE1BQU1DLEtBQUtDLEdBQUcsQ0FBQy9FLElBQUk2RCxHQUFHYSxJQUFJL0gsTUFBTTtnQkFFcEMsSUFBSTJILFlBQ0ZoRSxPQUFPb0UsSUFBSUMsS0FBSyxDQUFDLEdBQUdFO3FCQUVwQkgsSUFBSU0sSUFBSSxDQUFDMUUsS0FBS3VELEdBQUcsR0FBR2dCO2dCQUV0QixJQUFJQSxNQUFNSCxJQUFJL0gsTUFBTSxFQUNsQm1HLElBQUksQ0FBQyxFQUFFLEdBQUc0QixJQUFJQyxLQUFLLENBQUNFO3FCQUVwQi9CLEtBQUt5QixLQUFLO2dCQUVaVixLQUFLZ0I7WUFDUDtRQUNGO0lBQ0Y7SUFFQSxPQUFPdkU7QUFDVDtBQUVBLFNBQVNFLFlBQVl2RCxNQUFNO0lBQ3pCLElBQUk0QixRQUFRNUIsT0FBT3NCLGNBQWM7SUFFakMsZ0VBQWdFO0lBQ2hFLHFDQUFxQztJQUNyQyxJQUFJTSxNQUFNbEMsTUFBTSxHQUFHLEdBQ2pCLE1BQU0sSUFBSTRDLE1BQU07SUFFbEIsSUFBSSxDQUFDVixNQUFNcEIsVUFBVSxJQUFJb0IsTUFBTWxCLFVBQVUsRUFBRTtRQUN6Q2tCLE1BQU1yQixLQUFLLEdBQUc7UUFDZHNELFFBQVFDLFFBQVEsQ0FBQztZQUNmLDZDQUE2QztZQUM3QyxJQUFJLENBQUNsQyxNQUFNcEIsVUFBVSxJQUFJb0IsTUFBTWxDLE1BQU0sS0FBSyxHQUFHO2dCQUMzQ2tDLE1BQU1wQixVQUFVLEdBQUc7Z0JBQ25CUixPQUFPdUIsUUFBUSxHQUFHO2dCQUNsQnZCLE9BQU9rQyxJQUFJLENBQUM7WUFDZDtRQUNGO0lBQ0Y7QUFDRjtBQUVBLFNBQVM2RCxRQUFTaUMsRUFBRSxFQUFFQyxDQUFDO0lBQ3JCLElBQUssSUFBSXJDLElBQUksR0FBRytCLElBQUlLLEdBQUd0SSxNQUFNLEVBQUVrRyxJQUFJK0IsR0FBRy9CLElBQUs7UUFDekNxQyxFQUFFRCxFQUFFLENBQUNwQyxFQUFFLEVBQUVBO0lBQ1g7QUFDRjtBQUVBLFNBQVNNLFFBQVM4QixFQUFFLEVBQUVFLENBQUM7SUFDckIsSUFBSyxJQUFJdEMsSUFBSSxHQUFHK0IsSUFBSUssR0FBR3RJLE1BQU0sRUFBRWtHLElBQUkrQixHQUFHL0IsSUFBSztRQUN6QyxJQUFJb0MsRUFBRSxDQUFDcEMsRUFBRSxLQUFLc0MsR0FBRyxPQUFPdEM7SUFDMUI7SUFDQSxPQUFPLENBQUM7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL2JpZ2NvbW1lcmNlLy4vbm9kZV9tb2R1bGVzL2h0bWwtdG9rZW5pemUvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcz8xY2M2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuaWYgKCFFRS5saXN0ZW5lckNvdW50KSBFRS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gZmFsc2U7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIEluIHN0cmVhbXMgdGhhdCBuZXZlciBoYXZlIGFueSBkYXRhLCBhbmQgZG8gcHVzaChudWxsKSByaWdodCBhd2F5LFxuICAvLyB0aGUgY29uc3VtZXIgY2FuIG1pc3MgdGhlICdlbmQnIGV2ZW50IGlmIHRoZXkgZG8gc29tZSBJL08gYmVmb3JlXG4gIC8vIGNvbnN1bWluZyB0aGUgc3RyZWFtLiAgU28sIHdlIGRvbid0IGVtaXQoJ2VuZCcpIHVudGlsIHNvbWUgcmVhZGluZ1xuICAvLyBoYXBwZW5zLlxuICB0aGlzLmNhbGxlZFJlYWQgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjdWFzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuXG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKVxuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKVxuICAgICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKVxuICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKG4gPT09IG51bGwgfHwgaXNOYU4obikpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5jYWxsZWRSZWFkID0gdHJ1ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgdmFyIHJldDtcblxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgcmV0ID0gbnVsbDtcblxuICAgIC8vIEluIGNhc2VzIHdoZXJlIHRoZSBkZWNvZGVyIGRpZCBub3QgcmVjZWl2ZSBlbm91Z2ggZGF0YVxuICAgIC8vIHRvIHByb2R1Y2UgYSBmdWxsIGNodW5rLCB0aGVuIGltbWVkaWF0ZWx5IHJlY2VpdmVkIGFuXG4gICAgLy8gRU9GLCBzdGF0ZS5idWZmZXIgd2lsbCBjb250YWluIFs8QnVmZmVyID4sIDxCdWZmZXIgMDAgLi4uPl0uXG4gICAgLy8gaG93TXVjaFRvUmVhZCB3aWxsIHNlZSB0aGlzIGFuZCBjb2VyY2UgdGhlIGFtb3VudCB0b1xuICAgIC8vIHJlYWQgdG8gemVybyAoYmVjYXVzZSBpdCdzIGxvb2tpbmcgYXQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAvLyBmaXJzdCA8QnVmZmVyID4gaW4gc3RhdGUuYnVmZmVyKSwgYW5kIHdlJ2xsIGVuZCB1cCBoZXJlLlxuICAgIC8vXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gdmlhIHN0YXRlLmRlY29kZXIgLS0gbm8gb3RoZXIgdmVudWVcbiAgICAvLyBleGlzdHMgZm9yIHB1c2hpbmcgYSB6ZXJvLWxlbmd0aCBjaHVuayBpbnRvIHN0YXRlLmJ1ZmZlclxuICAgIC8vIGFuZCB0cmlnZ2VyaW5nIHRoaXMgYmVoYXZpb3IuIEluIHRoaXMgY2FzZSwgd2UgcmV0dXJuIG91clxuICAgIC8vIHJlbWFpbmluZyBkYXRhIGFuZCBlbmQgdGhlIHN0cmVhbSwgaWYgYXBwcm9wcmlhdGUuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA+IDAgJiYgc3RhdGUuZGVjb2Rlcikge1xuICAgICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICAgICAgc3RhdGUubGVuZ3RoIC09IHJldC5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoIC0gbiA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIGRvUmVhZCA9IHRydWU7XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZylcbiAgICBkb1JlYWQgPSBmYWxzZTtcblxuICBpZiAoZG9SZWFkKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBjYWxsZWQgaXRzIGNhbGxiYWNrIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgXG4gIC8vIHdpbGwgYmUgZmFsc2UsIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2VcbiAgLy8gY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZylcbiAgICBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuXG4gIGlmIChuID4gMClcbiAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gIGVsc2VcbiAgICByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBJZiB3ZSBoYXBwZW5lZCB0byByZWFkKCkgZXhhY3RseSB0aGUgcmVtYWluaW5nIGFtb3VudCBpbiB0aGVcbiAgLy8gYnVmZmVyLCBhbmQgdGhlIEVPRiBoYXMgYmVlbiBzZWVuIGF0IHRoaXMgcG9pbnQsIHRoZW4gbWFrZSBzdXJlXG4gIC8vIHRoYXQgd2UgZW1pdCAnZW5kJyBvbiB0aGUgdmVyeSBuZXh0IHRpY2suXG4gIGlmIChzdGF0ZS5lbmRlZCAmJiAhc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIGNodW5rICYmXG4gICAgICBjaHVuayAhPT0gbnVsbCAmJlxuICAgICAgY2h1bmsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQgYW5kIHdlIGhhdmUgc29tZSBkYXRhIGxlZnQsIHRoZW4gZW1pdFxuICAvLyAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICBlbHNlXG4gICAgZW5kUmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSlcbiAgICByZXR1cm47XG5cbiAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLnN5bmMpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9KTtcbiAgZWxzZVxuICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZClcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtcbiAgZWxzZVxuICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGlmIChyZWFkYWJsZSAhPT0gc3JjKSByZXR1cm47XG4gICAgY2xlYW51cCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxuICAvLyBpcyBhdHRhY2hlZCBiZWZvcmUgYW55IHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLlxuICBpZiAoIWRlc3QuX2V2ZW50cyB8fCAhZGVzdC5fZXZlbnRzLmVycm9yKVxuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGVsc2UgaWYgKGlzQXJyYXkoZGVzdC5fZXZlbnRzLmVycm9yKSlcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IudW5zaGlmdChvbmVycm9yKTtcbiAgZWxzZVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvciA9IFtvbmVycm9yLCBkZXN0Ll9ldmVudHMuZXJyb3JdO1xuXG5cblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gdGhlIGhhbmRsZXIgdGhhdCB3YWl0cyBmb3IgcmVhZGFibGUgZXZlbnRzIGFmdGVyIGFsbFxuICAgIC8vIHRoZSBkYXRhIGdldHMgc3Vja2VkIG91dCBpbiBmbG93LlxuICAgIC8vIFRoaXMgd291bGQgYmUgZWFzaWVyIHRvIGZvbGxvdyB3aXRoIGEgLm9uY2UoKSBoYW5kbGVyXG4gICAgLy8gaW4gZmxvdygpLCBidXQgdGhhdCBpcyB0b28gc2xvdy5cbiAgICB0aGlzLm9uKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcblxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlc3QgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDApXG4gICAgICBmbG93KHNyYyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb3coc3JjKSB7XG4gIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIGNodW5rO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcblxuICBmdW5jdGlvbiB3cml0ZShkZXN0LCBpLCBsaXN0KSB7XG4gICAgdmFyIHdyaXR0ZW4gPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHdyaXR0ZW4pIHtcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucGlwZXNDb3VudCAmJiBudWxsICE9PSAoY2h1bmsgPSBzcmMucmVhZCgpKSkge1xuXG4gICAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgICB3cml0ZShzdGF0ZS5waXBlcywgMCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgZm9yRWFjaChzdGF0ZS5waXBlcywgd3JpdGUpO1xuXG4gICAgc3JjLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG5cbiAgICAvLyBpZiBhbnlvbmUgbmVlZHMgYSBkcmFpbiwgdGhlbiB3ZSBoYXZlIHRvIHdhaXQgZm9yIHRoYXQuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPiAwKVxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaWYgZXZlcnkgZGVzdGluYXRpb24gd2FzIHVucGlwZWQsIGVpdGhlciBiZWZvcmUgZW50ZXJpbmcgdGhpc1xuICAvLyBmdW5jdGlvbiwgb3IgaW4gdGhlIHdoaWxlIGxvb3AsIHRoZW4gc3RvcCBmbG93aW5nLlxuICAvL1xuICAvLyBOQjogVGhpcyBpcyBhIHByZXR0eSByYXJlIGVkZ2UgY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICAvLyBpZiB0aGVyZSB3ZXJlIGRhdGEgZXZlbnQgbGlzdGVuZXJzIGFkZGVkLCB0aGVuIHN3aXRjaCB0byBvbGQgbW9kZS5cbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykgPiAwKVxuICAgICAgZW1pdERhdGFFdmVudHMoc3JjKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50LCBubyBvbmUgbmVlZGVkIGEgZHJhaW4sIHNvIHdlIGp1c3QgcmFuIG91dCBvZiBkYXRhXG4gIC8vIG9uIHRoZSBuZXh0IHJlYWRhYmxlIGV2ZW50LCBzdGFydCBpdCBvdmVyIGFnYWluLlxuICBzdGF0ZS5yYW5PdXQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBwaXBlT25SZWFkYWJsZSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUucmFuT3V0KSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQgPSBmYWxzZTtcbiAgICBmbG93KHRoaXMpO1xuICB9XG59XG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcylcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KVxuICAgICAgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdClcbiAgICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSlcbiAgICByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZylcbiAgICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpcy5yZWFkYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHRoaXMucmVhZCgwKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgZW1pdERhdGFFdmVudHModGhpcyk7XG4gIHRoaXMucmVhZCgwKTtcbiAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzLCB0cnVlKTtcbiAgdGhpcy5lbWl0KCdwYXVzZScpO1xufTtcblxuZnVuY3Rpb24gZW1pdERhdGFFdmVudHMoc3RyZWFtLCBzdGFydFBhdXNlZCkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL3JlYWRhYmxlLXN0cmVhbS9pc3N1ZXMvMTZcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzd2l0Y2ggdG8gb2xkIG1vZGUgbm93LicpO1xuICB9XG5cbiAgdmFyIHBhdXNlZCA9IHN0YXJ0UGF1c2VkIHx8IGZhbHNlO1xuICB2YXIgcmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBjb252ZXJ0IHRvIGFuIG9sZC1zdHlsZSBzdHJlYW0uXG4gIHN0cmVhbS5yZWFkYWJsZSA9IHRydWU7XG4gIHN0cmVhbS5waXBlID0gU3RyZWFtLnByb3RvdHlwZS5waXBlO1xuICBzdHJlYW0ub24gPSBzdHJlYW0uYWRkTGlzdGVuZXIgPSBTdHJlYW0ucHJvdG90eXBlLm9uO1xuXG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBmdW5jdGlvbigpIHtcbiAgICByZWFkYWJsZSA9IHRydWU7XG5cbiAgICB2YXIgYztcbiAgICB3aGlsZSAoIXBhdXNlZCAmJiAobnVsbCAhPT0gKGMgPSBzdHJlYW0ucmVhZCgpKSkpXG4gICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGMpO1xuXG4gICAgaWYgKGMgPT09IG51bGwpIHtcbiAgICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdHJlYW0uX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHN0cmVhbS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9O1xuXG4gIHN0cmVhbS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICBpZiAocmVhZGFibGUpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIHRoaXMucmVhZCgwKTtcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xuICB9O1xuXG4gIC8vIG5vdyBtYWtlIGl0IHN0YXJ0LCBqdXN0IGluIGNhc2UgaXQgaGFkbid0IGFscmVhZHkuXG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpXG4gICAgICAgIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKVxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIC8vaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGVsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdGhpc1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfX0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5jYWxsZWRSZWFkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJSZWFkYWJsZSIsImlzQXJyYXkiLCJyZXF1aXJlIiwiQnVmZmVyIiwiUmVhZGFibGVTdGF0ZSIsIkVFIiwiRXZlbnRFbWl0dGVyIiwibGlzdGVuZXJDb3VudCIsImVtaXR0ZXIiLCJ0eXBlIiwibGlzdGVuZXJzIiwibGVuZ3RoIiwiU3RyZWFtIiwidXRpbCIsImluaGVyaXRzIiwiU3RyaW5nRGVjb2RlciIsIm9wdGlvbnMiLCJzdHJlYW0iLCJod20iLCJoaWdoV2F0ZXJNYXJrIiwiYnVmZmVyIiwicGlwZXMiLCJwaXBlc0NvdW50IiwiZmxvd2luZyIsImVuZGVkIiwiZW5kRW1pdHRlZCIsInJlYWRpbmciLCJjYWxsZWRSZWFkIiwic3luYyIsIm5lZWRSZWFkYWJsZSIsImVtaXR0ZWRSZWFkYWJsZSIsInJlYWRhYmxlTGlzdGVuaW5nIiwib2JqZWN0TW9kZSIsImRlZmF1bHRFbmNvZGluZyIsInJhbk91dCIsImF3YWl0RHJhaW4iLCJyZWFkaW5nTW9yZSIsImRlY29kZXIiLCJlbmNvZGluZyIsIl9yZWFkYWJsZVN0YXRlIiwicmVhZGFibGUiLCJjYWxsIiwicHJvdG90eXBlIiwicHVzaCIsImNodW5rIiwic3RhdGUiLCJyZWFkYWJsZUFkZENodW5rIiwidW5zaGlmdCIsImFkZFRvRnJvbnQiLCJlciIsImNodW5rSW52YWxpZCIsImVtaXQiLCJ1bmRlZmluZWQiLCJvbkVvZkNodW5rIiwiZSIsIkVycm9yIiwid3JpdGUiLCJlbWl0UmVhZGFibGUiLCJtYXliZVJlYWRNb3JlIiwibmVlZE1vcmVEYXRhIiwic2V0RW5jb2RpbmciLCJlbmMiLCJNQVhfSFdNIiwicm91bmRVcFRvTmV4dFBvd2VyT2YyIiwibiIsInAiLCJob3dNdWNoVG9SZWFkIiwiaXNOYU4iLCJyZWFkIiwibk9yaWciLCJyZXQiLCJmcm9tTGlzdCIsImVuZFJlYWRhYmxlIiwiZG9SZWFkIiwiX3JlYWQiLCJpc0J1ZmZlciIsIlR5cGVFcnJvciIsImVuZCIsInByb2Nlc3MiLCJuZXh0VGljayIsImVtaXRSZWFkYWJsZV8iLCJtYXliZVJlYWRNb3JlXyIsImxlbiIsInBpcGUiLCJkZXN0IiwicGlwZU9wdHMiLCJzcmMiLCJkb0VuZCIsInN0ZG91dCIsInN0ZGVyciIsImVuZEZuIiwib25lbmQiLCJjbGVhbnVwIiwib25jZSIsIm9uIiwib251bnBpcGUiLCJvbmRyYWluIiwicGlwZU9uRHJhaW4iLCJyZW1vdmVMaXN0ZW5lciIsIm9uY2xvc2UiLCJvbmZpbmlzaCIsIm9uZXJyb3IiLCJfd3JpdGFibGVTdGF0ZSIsIm5lZWREcmFpbiIsInVucGlwZSIsIl9ldmVudHMiLCJlcnJvciIsInBpcGVPblJlYWRhYmxlIiwiZmxvdyIsImkiLCJsaXN0Iiwid3JpdHRlbiIsImZvckVhY2giLCJlbWl0RGF0YUV2ZW50cyIsImRlc3RzIiwiaW5kZXhPZiIsInNwbGljZSIsImV2IiwiZm4iLCJyZXMiLCJhZGRMaXN0ZW5lciIsInJlc3VtZSIsInBhdXNlIiwic3RhcnRQYXVzZWQiLCJwYXVzZWQiLCJjIiwid3JhcCIsInNlbGYiLCJtZXRob2QiLCJhcHBseSIsImFyZ3VtZW50cyIsImV2ZW50cyIsImJpbmQiLCJfZnJvbUxpc3QiLCJzdHJpbmdNb2RlIiwic2hpZnQiLCJqb2luIiwiY29uY2F0IiwiYnVmIiwic2xpY2UiLCJsIiwiY3B5IiwiTWF0aCIsIm1pbiIsImNvcHkiLCJ4cyIsImYiLCJ4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_readable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_transform.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_transform.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_duplex.js\");\n/*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(ssr)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ util.inherits(Transform, Duplex);\nfunction TransformState(options, stream) {\n    this.afterTransform = function(er, data) {\n        return afterTransform(stream, er, data);\n    };\n    this.needTransform = false;\n    this.transforming = false;\n    this.writecb = null;\n    this.writechunk = null;\n}\nfunction afterTransform(stream, er, data) {\n    var ts = stream._transformState;\n    ts.transforming = false;\n    var cb = ts.writecb;\n    if (!cb) return stream.emit(\"error\", new Error(\"no writecb in Transform class\"));\n    ts.writechunk = null;\n    ts.writecb = null;\n    if (data !== null && data !== undefined) stream.push(data);\n    if (cb) cb(er);\n    var rs = stream._readableState;\n    rs.reading = false;\n    if (rs.needReadable || rs.length < rs.highWaterMark) {\n        stream._read(rs.highWaterMark);\n    }\n}\nfunction Transform(options) {\n    if (!(this instanceof Transform)) return new Transform(options);\n    Duplex.call(this, options);\n    var ts = this._transformState = new TransformState(options, this);\n    // when the writable side finishes, then flush out anything remaining.\n    var stream = this;\n    // start out asking for a readable event once data is transformed.\n    this._readableState.needReadable = true;\n    // we have implemented the _read method, and done the other things\n    // that Readable wants before the first _read call, so unset the\n    // sync guard flag.\n    this._readableState.sync = false;\n    this.once(\"finish\", function() {\n        if (\"function\" === typeof this._flush) this._flush(function(er) {\n            done(stream, er);\n        });\n        else done(stream);\n    });\n}\nTransform.prototype.push = function(chunk, encoding) {\n    this._transformState.needTransform = false;\n    return Duplex.prototype.push.call(this, chunk, encoding);\n};\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n    throw new Error(\"not implemented\");\n};\nTransform.prototype._write = function(chunk, encoding, cb) {\n    var ts = this._transformState;\n    ts.writecb = cb;\n    ts.writechunk = chunk;\n    ts.writeencoding = encoding;\n    if (!ts.transforming) {\n        var rs = this._readableState;\n        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n    }\n};\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n    var ts = this._transformState;\n    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n        ts.transforming = true;\n        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n    } else {\n        // mark that we need a transform, so that any data that comes in\n        // will get processed, now that we've asked for it.\n        ts.needTransform = true;\n    }\n};\nfunction done(stream, er) {\n    if (er) return stream.emit(\"error\", er);\n    // if there's nothing in the write buffer, then that means\n    // that nothing more will ever be provided\n    var ws = stream._writableState;\n    var rs = stream._readableState;\n    var ts = stream._transformState;\n    if (ws.length) throw new Error(\"calling transform done when ws.length != 0\");\n    if (ts.transforming) throw new Error(\"calling transform done when still transforming\");\n    return stream.push(null);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbC10b2tlbml6ZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFDdEQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSxnRUFBZ0U7QUFDaEUsc0VBQXNFO0FBQ3RFLHNFQUFzRTtBQUN0RSw0RUFBNEU7QUFDNUUscUVBQXFFO0FBQ3JFLHdCQUF3QjtBQUN4QixFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlEQUF5RDtBQUN6RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLDZEQUE2RDtBQUM3RCw0RUFBNEU7QUFDNUUsMkVBQTJFO0FBQzNFLHdFQUF3RTtBQUN4RSw0RUFBNEU7QUFDNUUseUNBQXlDO0FBR3pDLGdFQUFnRTtBQUNoRSw4REFBOEQ7QUFDOUQsdUVBQXVFO0FBQ3ZFLHNFQUFzRTtBQUN0RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLGdFQUFnRTtBQUNoRSxxRUFBcUU7QUFDckUsa0VBQWtFO0FBQ2xFLDBEQUEwRDtBQUMxRCxFQUFFO0FBQ0YseUJBQXlCO0FBQ3pCLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUsc0VBQXNFO0FBQ3RFLG1FQUFtRTtBQUNuRSxnRUFBZ0U7QUFDaEUsb0RBQW9EO0FBQ3BELEVBQUU7QUFDRix1RUFBdUU7QUFDdkUsb0VBQW9FO0FBQ3BFLHFFQUFxRTtBQUNyRSx1RUFBdUU7QUFDdkUscUVBQXFFO0FBQ3JFLHNFQUFzRTtBQUN0RSxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsb0VBQW9FO0FBQ3BFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsd0VBQXdFO0FBQ3hFLHNFQUFzRTtBQUN0RSxxRUFBcUU7QUFDckUsb0VBQW9FO0FBQ3BFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0YseUVBQXlFO0FBQ3pFLHlFQUF5RTtBQUN6RSwrREFBK0Q7O0FBRS9EQSxPQUFP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WCxNQUFNLElBQUlQLE1BQU07SUFFbEIsSUFBSUosR0FBR0gsWUFBWSxFQUNqQixNQUFNLElBQUlPLE1BQU07SUFFbEIsT0FBT1osT0FBT2MsSUFBSSxDQUFDO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UvLi9ub2RlX21vZHVsZXMvaHRtbC10b2tlbml6ZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcz82NDI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbihlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZClcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBpZiAoY2IpXG4gICAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSlcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5fZmx1c2gpXG4gICAgICB0aGlzLl9mbHVzaChmdW5jdGlvbihlcikge1xuICAgICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHxcbiAgICAgICAgcnMubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgIHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspXG4gICAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlRyYW5zZm9ybSIsIkR1cGxleCIsInJlcXVpcmUiLCJ1dGlsIiwiaW5oZXJpdHMiLCJUcmFuc2Zvcm1TdGF0ZSIsIm9wdGlvbnMiLCJzdHJlYW0iLCJhZnRlclRyYW5zZm9ybSIsImVyIiwiZGF0YSIsIm5lZWRUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1pbmciLCJ3cml0ZWNiIiwid3JpdGVjaHVuayIsInRzIiwiX3RyYW5zZm9ybVN0YXRlIiwiY2IiLCJlbWl0IiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJwdXNoIiwicnMiLCJfcmVhZGFibGVTdGF0ZSIsInJlYWRpbmciLCJuZWVkUmVhZGFibGUiLCJsZW5ndGgiLCJoaWdoV2F0ZXJNYXJrIiwiX3JlYWQiLCJjYWxsIiwic3luYyIsIm9uY2UiLCJfZmx1c2giLCJkb25lIiwicHJvdG90eXBlIiwiY2h1bmsiLCJlbmNvZGluZyIsIl90cmFuc2Zvcm0iLCJfd3JpdGUiLCJ3cml0ZWVuY29kaW5nIiwibiIsIndzIiwiX3dyaXRhYmxlU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_transform.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_writable.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_writable.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n/*<replacement>*/ var Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n/*</replacement>*/ Writable.WritableState = WritableState;\n/*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(ssr)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ var Stream = __webpack_require__(/*! stream */ \"stream\");\nutil.inherits(Writable, Stream);\nfunction WriteReq(chunk, encoding, cb) {\n    this.chunk = chunk;\n    this.encoding = encoding;\n    this.callback = cb;\n}\nfunction WritableState(options, stream) {\n    options = options || {};\n    // the point at which write() starts returning false\n    // Note: 0 is a valid value, means that we always return false if\n    // the entire buffer is not flushed immediately on write()\n    var hwm = options.highWaterMark;\n    this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;\n    // object stream flag to indicate whether or not this stream\n    // contains buffers or objects.\n    this.objectMode = !!options.objectMode;\n    // cast to ints.\n    this.highWaterMark = ~~this.highWaterMark;\n    this.needDrain = false;\n    // at the start of calling end()\n    this.ending = false;\n    // when end() has been called, and returned\n    this.ended = false;\n    // when 'finish' is emitted\n    this.finished = false;\n    // should we decode strings into buffers before passing to _write?\n    // this is here so that some node-core streams can optimize string\n    // handling at a lower level.\n    var noDecode = options.decodeStrings === false;\n    this.decodeStrings = !noDecode;\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    // not an actual buffer we keep track of, but a measurement\n    // of how much we're waiting to get pushed to some underlying\n    // socket or file.\n    this.length = 0;\n    // a flag to see when we're in the middle of a write.\n    this.writing = false;\n    // a flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, becuase any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n    // a flag to know if we're processing previously buffered items, which\n    // may call the _write() callback in the same tick, so that we don't\n    // end up in an overlapped onwrite situation.\n    this.bufferProcessing = false;\n    // the callback that's passed to _write(chunk,cb)\n    this.onwrite = function(er) {\n        onwrite(stream, er);\n    };\n    // the callback that the user supplies to write(chunk,encoding,cb)\n    this.writecb = null;\n    // the amount that is being written when _write is called.\n    this.writelen = 0;\n    this.buffer = [];\n    // True if the error was already emitted and should not be thrown again\n    this.errorEmitted = false;\n}\nfunction Writable(options) {\n    var Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_duplex.js\");\n    // Writable ctor is applied to Duplexes, though they're not\n    // instanceof Writable, they're instanceof Readable.\n    if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n    this._writableState = new WritableState(options, this);\n    // legacy.\n    this.writable = true;\n    Stream.call(this);\n}\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n    this.emit(\"error\", new Error(\"Cannot pipe. Not readable.\"));\n};\nfunction writeAfterEnd(stream, state, cb) {\n    var er = new Error(\"write after end\");\n    // TODO: defer error events consistently everywhere, not just the cb\n    stream.emit(\"error\", er);\n    process.nextTick(function() {\n        cb(er);\n    });\n}\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n    var valid = true;\n    if (!Buffer.isBuffer(chunk) && \"string\" !== typeof chunk && chunk !== null && chunk !== undefined && !state.objectMode) {\n        var er = new TypeError(\"Invalid non-string/buffer chunk\");\n        stream.emit(\"error\", er);\n        process.nextTick(function() {\n            cb(er);\n        });\n        valid = false;\n    }\n    return valid;\n}\nWritable.prototype.write = function(chunk, encoding, cb) {\n    var state = this._writableState;\n    var ret = false;\n    if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = null;\n    }\n    if (Buffer.isBuffer(chunk)) encoding = \"buffer\";\n    else if (!encoding) encoding = state.defaultEncoding;\n    if (typeof cb !== \"function\") cb = function() {};\n    if (state.ended) writeAfterEnd(this, state, cb);\n    else if (validChunk(this, state, chunk, cb)) ret = writeOrBuffer(this, state, chunk, encoding, cb);\n    return ret;\n};\nfunction decodeChunk(state, chunk, encoding) {\n    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === \"string\") {\n        chunk = new Buffer(chunk, encoding);\n    }\n    return chunk;\n}\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n    chunk = decodeChunk(state, chunk, encoding);\n    if (Buffer.isBuffer(chunk)) encoding = \"buffer\";\n    var len = state.objectMode ? 1 : chunk.length;\n    state.length += len;\n    var ret = state.length < state.highWaterMark;\n    // we must ensure that previous needDrain will not be reset to false.\n    if (!ret) state.needDrain = true;\n    if (state.writing) state.buffer.push(new WriteReq(chunk, encoding, cb));\n    else doWrite(stream, state, len, chunk, encoding, cb);\n    return ret;\n}\nfunction doWrite(stream, state, len, chunk, encoding, cb) {\n    state.writelen = len;\n    state.writecb = cb;\n    state.writing = true;\n    state.sync = true;\n    stream._write(chunk, encoding, state.onwrite);\n    state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n    if (sync) process.nextTick(function() {\n        cb(er);\n    });\n    else cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit(\"error\", er);\n}\nfunction onwriteStateUpdate(state) {\n    state.writing = false;\n    state.writecb = null;\n    state.length -= state.writelen;\n    state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n    var state = stream._writableState;\n    var sync = state.sync;\n    var cb = state.writecb;\n    onwriteStateUpdate(state);\n    if (er) onwriteError(stream, state, sync, er, cb);\n    else {\n        // Check if we're actually ready to finish, but don't emit yet\n        var finished = needFinish(stream, state);\n        if (!finished && !state.bufferProcessing && state.buffer.length) clearBuffer(stream, state);\n        if (sync) {\n            process.nextTick(function() {\n                afterWrite(stream, state, finished, cb);\n            });\n        } else {\n            afterWrite(stream, state, finished, cb);\n        }\n    }\n}\nfunction afterWrite(stream, state, finished, cb) {\n    if (!finished) onwriteDrain(stream, state);\n    cb();\n    if (finished) finishMaybe(stream, state);\n}\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n    if (state.length === 0 && state.needDrain) {\n        state.needDrain = false;\n        stream.emit(\"drain\");\n    }\n}\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n    state.bufferProcessing = true;\n    for(var c = 0; c < state.buffer.length; c++){\n        var entry = state.buffer[c];\n        var chunk = entry.chunk;\n        var encoding = entry.encoding;\n        var cb = entry.callback;\n        var len = state.objectMode ? 1 : chunk.length;\n        doWrite(stream, state, len, chunk, encoding, cb);\n        // if we didn't call the onwrite immediately, then\n        // it means that we need to wait until it does.\n        // also, that means that the chunk and cb are currently\n        // being processed, so move the buffer counter past them.\n        if (state.writing) {\n            c++;\n            break;\n        }\n    }\n    state.bufferProcessing = false;\n    if (c < state.buffer.length) state.buffer = state.buffer.slice(c);\n    else state.buffer.length = 0;\n}\nWritable.prototype._write = function(chunk, encoding, cb) {\n    cb(new Error(\"not implemented\"));\n};\nWritable.prototype.end = function(chunk, encoding, cb) {\n    var state = this._writableState;\n    if (typeof chunk === \"function\") {\n        cb = chunk;\n        chunk = null;\n        encoding = null;\n    } else if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = null;\n    }\n    if (typeof chunk !== \"undefined\" && chunk !== null) this.write(chunk, encoding);\n    // ignore unnecessary end() calls.\n    if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\nfunction needFinish(stream, state) {\n    return state.ending && state.length === 0 && !state.finished && !state.writing;\n}\nfunction finishMaybe(stream, state) {\n    var need = needFinish(stream, state);\n    if (need) {\n        state.finished = true;\n        stream.emit(\"finish\");\n    }\n    return need;\n}\nfunction endWritable(stream, state, cb) {\n    state.ending = true;\n    finishMaybe(stream, state);\n    if (cb) {\n        if (state.finished) process.nextTick(cb);\n        else stream.once(\"finish\", cb);\n    }\n    state.ended = true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbC10b2tlbml6ZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7QUFFekMsdUNBQXVDO0FBQ3ZDLDhEQUE4RDtBQUM5RCwwQ0FBMEM7O0FBRTFDQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLGVBQWUsR0FDZixJQUFJQyxTQUFTQyxvREFBd0I7QUFDckMsZ0JBQWdCLEdBRWhCRixTQUFTRyxhQUFhLEdBQUdBO0FBR3pCLGVBQWUsR0FDZixJQUFJQyxPQUFPRixtQkFBT0EsQ0FBQztBQUNuQkUsS0FBS0MsUUFBUSxHQUFHSCxtQkFBT0EsQ0FBQztBQUN4QixnQkFBZ0IsR0FFaEIsSUFBSUksU0FBU0osbUJBQU9BLENBQUM7QUFFckJFLEtBQUtDLFFBQVEsQ0FBQ0wsVUFBVU07QUFFeEIsU0FBU0MsU0FBU0MsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLEVBQUU7SUFDbkMsSUFBSSxDQUFDRixLQUFLLEdBQUdBO0lBQ2IsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO0lBQ2hCLElBQUksQ0FBQ0UsUUFBUSxHQUFHRDtBQUNsQjtBQUVBLFNBQVNQLGNBQWNTLE9BQU8sRUFBRUMsTUFBTTtJQUNwQ0QsVUFBVUEsV0FBVyxDQUFDO0lBRXRCLG9EQUFvRDtJQUNwRCxpRUFBaUU7SUFDakUsMERBQTBEO0lBQzFELElBQUlFLE1B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L0IsSUFBSSxPQUFPM0IsVUFBVSxZQUFZO1FBQy9CRSxLQUFLRjtRQUNMQSxRQUFRO1FBQ1JDLFdBQVc7SUFDYixPQUFPLElBQUksT0FBT0EsYUFBYSxZQUFZO1FBQ3pDQyxLQUFLRDtRQUNMQSxXQUFXO0lBQ2I7SUFFQSxJQUFJLE9BQU9ELFVBQVUsZUFBZUEsVUFBVSxNQUM1QyxJQUFJLENBQUMyQyxLQUFLLENBQUMzQyxPQUFPQztJQUVwQixrQ0FBa0M7SUFDbEMsSUFBSSxDQUFDa0MsTUFBTXpCLE1BQU0sSUFBSSxDQUFDeUIsTUFBTXZCLFFBQVEsRUFDbENrRCxZQUFZLElBQUksRUFBRTNCLE9BQU9qQztBQUM3QjtBQUdBLFNBQVNtRCxXQUFXaEQsTUFBTSxFQUFFOEIsS0FBSztJQUMvQixPQUFRQSxNQUFNekIsTUFBTSxJQUNaeUIsTUFBTW5CLE1BQU0sS0FBSyxLQUNqQixDQUFDbUIsTUFBTXZCLFFBQVEsSUFDZixDQUFDdUIsTUFBTWxCLE9BQU87QUFDeEI7QUFFQSxTQUFTd0MsWUFBWXBELE1BQU0sRUFBRThCLEtBQUs7SUFDaEMsSUFBSTRCLE9BQU9WLFdBQVdoRCxRQUFROEI7SUFDOUIsSUFBSTRCLE1BQU07UUFDUjVCLE1BQU12QixRQUFRLEdBQUc7UUFDakJQLE9BQU8yQixJQUFJLENBQUM7SUFDZDtJQUNBLE9BQU8rQjtBQUNUO0FBRUEsU0FBU0QsWUFBWXpELE1BQU0sRUFBRThCLEtBQUssRUFBRWpDLEVBQUU7SUFDcENpQyxNQUFNekIsTUFBTSxHQUFHO0lBQ2YrQyxZQUFZcEQsUUFBUThCO0lBQ3BCLElBQUlqQyxJQUFJO1FBQ04sSUFBSWlDLE1BQU12QixRQUFRLEVBQ2hCd0IsUUFBUUMsUUFBUSxDQUFDbkM7YUFFakJHLE9BQU8yRCxJQUFJLENBQUMsVUFBVTlEO0lBQzFCO0lBQ0FpQyxNQUFNeEIsS0FBSyxHQUFHO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UvLi9ub2RlX21vZHVsZXMvaHRtbC10b2tlbml6ZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzPzlkOGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGNiKGVyKTtcbiAgfSk7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIGNodW5rICYmXG4gICAgICBjaHVuayAhPT0gbnVsbCAmJlxuICAgICAgY2h1bmsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIGVsc2UgaWYgKCFlbmNvZGluZylcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKVxuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlXG4gICAgY2IoZXIpO1xuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgY2IoKTtcbiAgaWYgKGZpbmlzaGVkKVxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICBjKys7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG4gIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gIGVsc2VcbiAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNodW5rICE9PSAndW5kZWZpbmVkJyAmJiBjaHVuayAhPT0gbnVsbClcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIldyaXRhYmxlIiwiQnVmZmVyIiwicmVxdWlyZSIsIldyaXRhYmxlU3RhdGUiLCJ1dGlsIiwiaW5oZXJpdHMiLCJTdHJlYW0iLCJXcml0ZVJlcSIsImNodW5rIiwiZW5jb2RpbmciLCJjYiIsImNhbGxiYWNrIiwib3B0aW9ucyIsInN0cmVhbSIsImh3bSIsImhpZ2hXYXRlck1hcmsiLCJvYmplY3RNb2RlIiwibmVlZERyYWluIiwiZW5kaW5nIiwiZW5kZWQiLCJmaW5pc2hlZCIsIm5vRGVjb2RlIiwiZGVjb2RlU3RyaW5ncyIsImRlZmF1bHRFbmNvZGluZyIsImxlbmd0aCIsIndyaXRpbmciLCJzeW5jIiwiYnVmZmVyUHJvY2Vzc2luZyIsIm9ud3JpdGUiLCJlciIsIndyaXRlY2IiLCJ3cml0ZWxlbiIsImJ1ZmZlciIsImVycm9yRW1pdHRlZCIsIkR1cGxleCIsIl93cml0YWJsZVN0YXRlIiwid3JpdGFibGUiLCJjYWxsIiwicHJvdG90eXBlIiwicGlwZSIsImVtaXQiLCJFcnJvciIsIndyaXRlQWZ0ZXJFbmQiLCJzdGF0ZSIsInByb2Nlc3MiLCJuZXh0VGljayIsInZhbGlkQ2h1bmsiLCJ2YWxpZCIsImlzQnVmZmVyIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwid3JpdGUiLCJyZXQiLCJ3cml0ZU9yQnVmZmVyIiwiZGVjb2RlQ2h1bmsiLCJsZW4iLCJwdXNoIiwiZG9Xcml0ZSIsIl93cml0ZSIsIm9ud3JpdGVFcnJvciIsIm9ud3JpdGVTdGF0ZVVwZGF0ZSIsIm5lZWRGaW5pc2giLCJjbGVhckJ1ZmZlciIsImFmdGVyV3JpdGUiLCJvbndyaXRlRHJhaW4iLCJmaW5pc2hNYXliZSIsImMiLCJlbnRyeSIsInNsaWNlIiwiZW5kIiwiZW5kV3JpdGFibGUiLCJuZWVkIiwib25jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_writable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/readable.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/html-tokenize/node_modules/readable-stream/readable.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nvar Stream = __webpack_require__(/*! stream */ \"stream\"); // hack to fix a circular dependency issue when used with browserify\nexports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = Stream;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/lib/_stream_passthrough.js\");\nif ( true && process.env.READABLE_STREAM === \"disable\") {\n    module.exports = __webpack_require__(/*! stream */ \"stream\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbC10b2tlbml6ZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQyx5QkFBVyxvRUFBb0U7QUFDcEdDLFVBQVVDLGdLQUF5QjtBQUNuQ0QsY0FBYyxHQUFHRjtBQUNqQkUsZ0JBQWdCLEdBQUdBO0FBQ25CQSxrS0FBMkI7QUFDM0JBLDRKQUF5QjtBQUN6QkEscUtBQTRCO0FBQzVCQSwyS0FBOEI7QUFDOUIsSUFBSSxLQUFnQixJQUFJTyxRQUFRRSxHQUFHLENBQUNDLGVBQWUsS0FBSyxXQUFXO0lBQ2pFVCw0REFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWdjb21tZXJjZS8uL25vZGVfbW9kdWxlcy9odG1sLXRva2VuaXplL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanM/OTQ3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7IC8vIGhhY2sgdG8gZml4IGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBpc3N1ZSB3aGVuIHVzZWQgd2l0aCBicm93c2VyaWZ5XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbTtcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5pZiAoIXByb2Nlc3MuYnJvd3NlciAmJiBwcm9jZXNzLmVudi5SRUFEQUJMRV9TVFJFQU0gPT09ICdkaXNhYmxlJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3N0cmVhbScpO1xufVxuIl0sIm5hbWVzIjpbIlN0cmVhbSIsInJlcXVpcmUiLCJleHBvcnRzIiwibW9kdWxlIiwiUmVhZGFibGUiLCJXcml0YWJsZSIsIkR1cGxleCIsIlRyYW5zZm9ybSIsIlBhc3NUaHJvdWdoIiwicHJvY2VzcyIsImJyb3dzZXIiLCJlbnYiLCJSRUFEQUJMRV9TVFJFQU0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html-tokenize/node_modules/readable-stream/readable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/html-tokenize/node_modules/string_decoder/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/html-tokenize/node_modules/string_decoder/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar isBufferEncoding = Buffer.isEncoding || function(encoding) {\n    switch(encoding && encoding.toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n        case \"raw\":\n            return true;\n        default:\n            return false;\n    }\n};\nfunction assertEncoding(encoding) {\n    if (encoding && !isBufferEncoding(encoding)) {\n        throw new Error(\"Unknown encoding: \" + encoding);\n    }\n}\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n    this.encoding = (encoding || \"utf8\").toLowerCase().replace(/[-_]/, \"\");\n    assertEncoding(encoding);\n    switch(this.encoding){\n        case \"utf8\":\n            // CESU-8 represents each of Surrogate Pair by 3-bytes\n            this.surrogateSize = 3;\n            break;\n        case \"ucs2\":\n        case \"utf16le\":\n            // UTF-16 represents each of Surrogate Pair by 2-bytes\n            this.surrogateSize = 2;\n            this.detectIncompleteChar = utf16DetectIncompleteChar;\n            break;\n        case \"base64\":\n            // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n            this.surrogateSize = 3;\n            this.detectIncompleteChar = base64DetectIncompleteChar;\n            break;\n        default:\n            this.write = passThroughWrite;\n            return;\n    }\n    // Enough space to store all bytes of a single character. UTF-8 needs 4\n    // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n    this.charBuffer = new Buffer(6);\n    // Number of bytes received for the current incomplete multi-byte character.\n    this.charReceived = 0;\n    // Number of bytes expected for the current incomplete multi-byte character.\n    this.charLength = 0;\n};\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n    var charStr = \"\";\n    // if our last write ended with an incomplete multibyte character\n    while(this.charLength){\n        // determine how many remaining bytes this buffer has to offer for this char\n        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;\n        // add the new bytes to the char buffer\n        buffer.copy(this.charBuffer, this.charReceived, 0, available);\n        this.charReceived += available;\n        if (this.charReceived < this.charLength) {\n            // still not enough chars in this buffer? wait for more ...\n            return \"\";\n        }\n        // remove bytes belonging to the current character from the buffer\n        buffer = buffer.slice(available, buffer.length);\n        // get the character that was split\n        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n        var charCode = charStr.charCodeAt(charStr.length - 1);\n        if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n            this.charLength += this.surrogateSize;\n            charStr = \"\";\n            continue;\n        }\n        this.charReceived = this.charLength = 0;\n        // if there are no more bytes in this buffer, just emit our char\n        if (buffer.length === 0) {\n            return charStr;\n        }\n        break;\n    }\n    // determine and set charLength / charReceived\n    this.detectIncompleteChar(buffer);\n    var end = buffer.length;\n    if (this.charLength) {\n        // buffer the incomplete character bytes we got\n        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n        end -= this.charReceived;\n    }\n    charStr += buffer.toString(this.encoding, 0, end);\n    var end = charStr.length - 1;\n    var charCode = charStr.charCodeAt(end);\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n        var size = this.surrogateSize;\n        this.charLength += size;\n        this.charReceived += size;\n        this.charBuffer.copy(this.charBuffer, size, 0, size);\n        buffer.copy(this.charBuffer, 0, 0, size);\n        return charStr.substring(0, end);\n    }\n    // or just emit the charStr\n    return charStr;\n};\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n    // determine how many bytes we have to check at the end of this buffer\n    var i = buffer.length >= 3 ? 3 : buffer.length;\n    // Figure out if one of the last i bytes of our buffer announces an\n    // incomplete char.\n    for(; i > 0; i--){\n        var c = buffer[buffer.length - i];\n        // See http://en.wikipedia.org/wiki/UTF-8#Description\n        // 110XXXXX\n        if (i == 1 && c >> 5 == 0x06) {\n            this.charLength = 2;\n            break;\n        }\n        // 1110XXXX\n        if (i <= 2 && c >> 4 == 0x0E) {\n            this.charLength = 3;\n            break;\n        }\n        // 11110XXX\n        if (i <= 3 && c >> 3 == 0x1E) {\n            this.charLength = 4;\n            break;\n        }\n    }\n    this.charReceived = i;\n};\nStringDecoder.prototype.end = function(buffer) {\n    var res = \"\";\n    if (buffer && buffer.length) res = this.write(buffer);\n    if (this.charReceived) {\n        var cr = this.charReceived;\n        var buf = this.charBuffer;\n        var enc = this.encoding;\n        res += buf.slice(0, cr).toString(enc);\n    }\n    return res;\n};\nfunction passThroughWrite(buffer) {\n    return buffer.toString(this.encoding);\n}\nfunction utf16DetectIncompleteChar(buffer) {\n    this.charReceived = buffer.length % 2;\n    this.charLength = this.charReceived ? 2 : 0;\n}\nfunction base64DetectIncompleteChar(buffer) {\n    this.charReceived = buffer.length % 3;\n    this.charLength = this.charReceived ? 3 : 0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbC10b2tlbml6ZS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5QztBQUV6QyxJQUFJQSxTQUFTQyxvREFBd0I7QUFFckMsSUFBSUMsbUJBQW1CRixPQUFPRyxVQUFVLElBQ25DLFNBQVNDLFFBQVE7SUFDZixPQUFRQSxZQUFZQSxTQUFTQyxXQUFXO1FBQ3RDLEtBQUs7UUFBTyxLQUFLO1FBQVEsS0FBSztRQUFTLEtBQUs7UUFBUyxLQUFLO1FBQVUsS0FBSztRQUFVLEtBQUs7UUFBUSxLQUFLO1FBQVMsS0FBSztRQUFXLEtBQUs7UUFBWSxLQUFLO1lBQU8sT0FBTztRQUNsSztZQUFTLE9BQU87SUFDbEI7QUFDRjtBQUdMLFNBQVNDLGVBQWVGLFFBQVE7SUFDOUIsSUFBSUEsWUFBWSxDQUFDRixpQkFBaUJFLFdBQVc7UUFDM0MsTUFBTSxJQUFJRyxNQUFNLHVCQUF1Qkg7SUFDekM7QUFDRjtBQUVBLDRFQUE0RTtBQUM1RSx3RUFBd0U7QUFDeEUsK0RBQStEO0FBQy9ELEVBQUU7QUFDRiw4RUFBOEU7QUFDOUUscUVBQXFFO0FBQ3JFLCtFQUErRTtBQUMvRSw0QkFBNEI7QUFDNUIsSUFBSUksZ0JBQWdCQyxxQkFBcUIsR0FBRyxTQUFTTCxRQUFRO0lBQzNELElBQUksQ0FBQ0EsUUFBUSxHQUFHLENBQUNBLFlBQVksTUFBSyxFQUFHQyxXQUFX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NUIsSUFBSSxDQUFDZixVQUFVLEdBQUc7WUFDbEI7UUFDRjtJQUNGO0lBQ0EsSUFBSSxDQUFDRCxZQUFZLEdBQUdlO0FBQ3RCO0FBRUF6QixjQUFjWSxTQUFTLENBQUNVLEdBQUcsR0FBRyxTQUFTVCxNQUFNO0lBQzNDLElBQUljLE1BQU07SUFDVixJQUFJZCxVQUFVQSxPQUFPRyxNQUFNLEVBQ3pCVyxNQUFNLElBQUksQ0FBQ3BCLEtBQUssQ0FBQ007SUFFbkIsSUFBSSxJQUFJLENBQUNILFlBQVksRUFBRTtRQUNyQixJQUFJa0IsS0FBSyxJQUFJLENBQUNsQixZQUFZO1FBQzFCLElBQUltQixNQUFNLElBQUksQ0FBQ3BCLFVBQVU7UUFDekIsSUFBSXFCLE1BQU0sSUFBSSxDQUFDbEMsUUFBUTtRQUN2QitCLE9BQU9FLElBQUlYLEtBQUssQ0FBQyxHQUFHVSxJQUFJVCxRQUFRLENBQUNXO0lBQ25DO0lBRUEsT0FBT0g7QUFDVDtBQUVBLFNBQVNuQixpQkFBaUJLLE1BQU07SUFDOUIsT0FBT0EsT0FBT00sUUFBUSxDQUFDLElBQUksQ0FBQ3ZCLFFBQVE7QUFDdEM7QUFFQSxTQUFTUywwQkFBMEJRLE1BQU07SUFDdkMsSUFBSSxDQUFDSCxZQUFZLEdBQUdHLE9BQU9HLE1BQU0sR0FBRztJQUNwQyxJQUFJLENBQUNMLFVBQVUsR0FBRyxJQUFJLENBQUNELFlBQVksR0FBRyxJQUFJO0FBQzVDO0FBRUEsU0FBU0osMkJBQTJCTyxNQUFNO0lBQ3hDLElBQUksQ0FBQ0gsWUFBWSxHQUFHRyxPQUFPRyxNQUFNLEdBQUc7SUFDcEMsSUFBSSxDQUFDTCxVQUFVLEdBQUcsSUFBSSxDQUFDRCxZQUFZLEdBQUcsSUFBSTtBQUM1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2JpZ2NvbW1lcmNlLy4vbm9kZV9tb2R1bGVzL2h0bWwtdG9rZW5pemUvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzPzVlYzYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iXSwibmFtZXMiOlsiQnVmZmVyIiwicmVxdWlyZSIsImlzQnVmZmVyRW5jb2RpbmciLCJpc0VuY29kaW5nIiwiZW5jb2RpbmciLCJ0b0xvd2VyQ2FzZSIsImFzc2VydEVuY29kaW5nIiwiRXJyb3IiLCJTdHJpbmdEZWNvZGVyIiwiZXhwb3J0cyIsInJlcGxhY2UiLCJzdXJyb2dhdGVTaXplIiwiZGV0ZWN0SW5jb21wbGV0ZUNoYXIiLCJ1dGYxNkRldGVjdEluY29tcGxldGVDaGFyIiwiYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIiLCJ3cml0ZSIsInBhc3NUaHJvdWdoV3JpdGUiLCJjaGFyQnVmZmVyIiwiY2hhclJlY2VpdmVkIiwiY2hhckxlbmd0aCIsInByb3RvdHlwZSIsImJ1ZmZlciIsImNoYXJTdHIiLCJhdmFpbGFibGUiLCJsZW5ndGgiLCJjb3B5Iiwic2xpY2UiLCJ0b1N0cmluZyIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsImVuZCIsInNpemUiLCJzdWJzdHJpbmciLCJpIiwiYyIsInJlcyIsImNyIiwiYnVmIiwiZW5jIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html-tokenize/node_modules/string_decoder/index.js\n");

/***/ })

};
;