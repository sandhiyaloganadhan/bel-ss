"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-react";
exports.ids = ["vendor-chunks/slate-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate-react/dist/index.es.js":
/*!***************************************************!*\
  !*** ./node_modules/slate-react/dist/index.es.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultElement: () => (/* binding */ DefaultElement),\n/* harmony export */   DefaultLeaf: () => (/* binding */ DefaultLeaf),\n/* harmony export */   DefaultPlaceholder: () => (/* binding */ DefaultPlaceholder),\n/* harmony export */   Editable: () => (/* binding */ Editable),\n/* harmony export */   ReactEditor: () => (/* binding */ ReactEditor),\n/* harmony export */   Slate: () => (/* binding */ Slate),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useFocused: () => (/* binding */ useFocused),\n/* harmony export */   useReadOnly: () => (/* binding */ useReadOnly),\n/* harmony export */   useSelected: () => (/* binding */ useSelected),\n/* harmony export */   useSlate: () => (/* binding */ useSlate),\n/* harmony export */   useSlateSelection: () => (/* binding */ useSlateSelection),\n/* harmony export */   useSlateSelector: () => (/* binding */ useSlateSelector),\n/* harmony export */   useSlateStatic: () => (/* binding */ useSlateStatic),\n/* harmony export */   useSlateWithV: () => (/* binding */ useSlateWithV),\n/* harmony export */   withReact: () => (/* binding */ withReact)\n/* harmony export */ });\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! direction */ \"(ssr)/./node_modules/direction/index.js\");\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(direction__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce */ \"(ssr)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/throttle */ \"(ssr)/./node_modules/lodash/throttle.js\");\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! scroll-into-view-if-needed */ \"(ssr)/./node_modules/scroll-into-view-if-needed/es/index.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @juggle/resize-observer */ \"(ssr)/./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\");\n/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! is-hotkey */ \"(ssr)/./node_modules/is-hotkey/lib/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\n\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n/**\r\n * An auto-incrementing identifier for keys.\r\n */ var n = 0;\n/**\r\n * A class that keeps track of a key string. We use a full class here because we\r\n * want to be able to use them as keys in `WeakMap` objects.\r\n */ class Key {\n    constructor(){\n        this.id = \"\".concat(n++);\n    }\n}\n/**\r\n * Two weak maps that allow us rebuild a path given a node. They are populated\r\n * at render time such that after a render occurs we can always backtrack.\r\n */ var NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\r\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\r\n * are used to resolve DOM event-related logic into Slate actions.\r\n */ var EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\r\n * Weak maps for storing editor-related state.\r\n */ var IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\r\n * Weak map for associating the context `onChange` context with the plugin.\r\n */ var EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\r\n * Weak maps for saving pending state on composition stage.\r\n */ var EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\r\n * Android input handling specific weak-maps\r\n */ var EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\r\n * Symbols.\r\n */ var PLACEHOLDER_SYMBOL = Symbol(\"placeholder\");\nvar MARK_PLACEHOLDER_SYMBOL = Symbol(\"mark-placeholder\");\n/**\r\n * Types.\r\n */ var DOMText = globalThis.Text;\n/**\r\n * Returns the host window of a DOM node\r\n */ var getDefaultView = (value)=>{\n    return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\r\n * Check if a DOM node is a comment node.\r\n */ var isDOMComment = (value)=>{\n    return isDOMNode(value) && value.nodeType === 8;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */ var isDOMElement = (value)=>{\n    return isDOMNode(value) && value.nodeType === 1;\n};\n/**\r\n * Check if a value is a DOM node.\r\n */ var isDOMNode = (value)=>{\n    var window1 = getDefaultView(value);\n    return !!window1 && value instanceof window1.Node;\n};\n/**\r\n * Check if a value is a DOM selection.\r\n */ var isDOMSelection = (value)=>{\n    var window1 = value && value.anchorNode && getDefaultView(value.anchorNode);\n    return !!window1 && value instanceof window1.Selection;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */ var isDOMText = (value)=>{\n    return isDOMNode(value) && value.nodeType === 3;\n};\n/**\r\n * Checks whether a paste event is a plaintext-only event.\r\n */ var isPlainTextOnlyPaste = (event)=>{\n    return event.clipboardData && event.clipboardData.getData(\"text/plain\") !== \"\" && event.clipboardData.types.length === 1;\n};\n/**\r\n * Normalize a DOM point so that it always refers to a text node.\r\n */ var normalizeDOMPoint = (domPoint)=>{\n    var [node, offset] = domPoint; // If it's an element node, its offset refers to the index of its children\n    // including comment nodes, so try to find the right text child node.\n    if (isDOMElement(node) && node.childNodes.length) {\n        var isLast = offset === node.childNodes.length;\n        var index = isLast ? offset - 1 : offset;\n        [node, index] = getEditableChildAndIndex(node, index, isLast ? \"backward\" : \"forward\"); // If the editable child found is in front of input offset, we instead seek to its end\n        isLast = index < offset; // If the node has children, traverse until we have a leaf node. Leaf nodes\n        // can be either text nodes, or other void DOM nodes.\n        while(isDOMElement(node) && node.childNodes.length){\n            var i = isLast ? node.childNodes.length - 1 : 0;\n            node = getEditableChild(node, i, isLast ? \"backward\" : \"forward\");\n        } // Determine the new offset inside the text node.\n        offset = isLast && node.textContent != null ? node.textContent.length : 0;\n    } // Return the node and offset.\n    return [\n        node,\n        offset\n    ];\n};\n/**\r\n * Determines wether the active element is nested within a shadowRoot\r\n */ var hasShadowRoot = (node)=>{\n    var parent = node && node.parentNode;\n    while(parent){\n        if (parent.toString() === \"[object ShadowRoot]\") {\n            return true;\n        }\n        parent = parent.parentNode;\n    }\n    return false;\n};\n/**\r\n * Get the nearest editable child and index at `index` in a `parent`, preferring\r\n * `direction`.\r\n */ var getEditableChildAndIndex = (parent, index, direction)=>{\n    var { childNodes } = parent;\n    var child = childNodes[index];\n    var i = index;\n    var triedForward = false;\n    var triedBackward = false; // While the child is a comment node, or an element node with no children,\n    // keep iterating to find a sibling non-void, non-comment node.\n    while(isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute(\"contenteditable\") === \"false\"){\n        if (triedForward && triedBackward) {\n            break;\n        }\n        if (i >= childNodes.length) {\n            triedForward = true;\n            i = index - 1;\n            direction = \"backward\";\n            continue;\n        }\n        if (i < 0) {\n            triedBackward = true;\n            i = index + 1;\n            direction = \"forward\";\n            continue;\n        }\n        child = childNodes[i];\n        index = i;\n        i += direction === \"forward\" ? 1 : -1;\n    }\n    return [\n        child,\n        index\n    ];\n};\n/**\r\n * Get the nearest editable child at `index` in a `parent`, preferring\r\n * `direction`.\r\n */ var getEditableChild = (parent, index, direction)=>{\n    var [child] = getEditableChildAndIndex(parent, index, direction);\n    return child;\n};\n/**\r\n * Get a plaintext representation of the content of a node, accounting for block\r\n * elements which get a newline appended.\r\n *\r\n * The domNode must be attached to the DOM.\r\n */ var getPlainText = (domNode)=>{\n    var text = \"\";\n    if (isDOMText(domNode) && domNode.nodeValue) {\n        return domNode.nodeValue;\n    }\n    if (isDOMElement(domNode)) {\n        for (var childNode of Array.from(domNode.childNodes)){\n            text += getPlainText(childNode);\n        }\n        var display = getComputedStyle(domNode).getPropertyValue(\"display\");\n        if (display === \"block\" || display === \"list\" || domNode.tagName === \"BR\") {\n            text += \"\\n\";\n        }\n    }\n    return text;\n};\n/**\r\n * Get x-slate-fragment attribute from data-slate-fragment\r\n */ var catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = (dataTransfer)=>{\n    var htmlData = dataTransfer.getData(\"text/html\");\n    var [, fragment] = htmlData.match(catchSlateFragment) || [];\n    return fragment;\n};\n/**\r\n * Check whether a mutation originates from a editable element inside the editor.\r\n */ var isTrackedMutation = (editor, mutation, batch)=>{\n    var { target } = mutation;\n    if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n        return false;\n    }\n    var { document: document1 } = ReactEditor.getWindow(editor);\n    if (document1.contains(target)) {\n        return ReactEditor.hasDOMNode(editor, target, {\n            editable: true\n        });\n    }\n    var parentMutation = batch.find((_ref)=>{\n        var { addedNodes, removedNodes } = _ref;\n        for (var node of addedNodes){\n            if (node === target || node.contains(target)) {\n                return true;\n            }\n        }\n        for (var _node of removedNodes){\n            if (_node === target || _node.contains(target)) {\n                return true;\n            }\n        }\n    });\n    if (!parentMutation || parentMutation === mutation) {\n        return false;\n    } // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n    return isTrackedMutation(editor, parentMutation, batch);\n};\nvar IS_REACT_VERSION_17_OR_ABOVE = parseInt(react__WEBPACK_IMPORTED_MODULE_3___default().version.split(\".\")[0], 10) >= 17;\nvar IS_IOS = typeof navigator !== \"undefined\" && \"undefined\" !== \"undefined\" && 0 && 0;\nvar IS_APPLE = typeof navigator !== \"undefined\" && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== \"undefined\" && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== \"undefined\" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_SAFARI = typeof navigator !== \"undefined\" && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent); // \"modern\" Edge was released at 79.x\nvar IS_EDGE_LEGACY = typeof navigator !== \"undefined\" && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== \"undefined\" && /Chrome/i.test(navigator.userAgent); // Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nvar IS_CHROME_LEGACY = typeof navigator !== \"undefined\" && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== \"undefined\" && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent); // Firefox did not support `beforeInput` until `v87`.\nvar IS_FIREFOX_LEGACY = typeof navigator !== \"undefined\" && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent); // UC mobile browser\nvar IS_UC_MOBILE = typeof navigator !== \"undefined\" && /.*UCBrowser/.test(navigator.userAgent); // Wechat browser\nvar IS_WECHATBROWSER = typeof navigator !== \"undefined\" && /.*Wechat/.test(navigator.userAgent); // Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nvar CAN_USE_DOM = !!( false && 0); // COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers\ntypeof globalThis !== \"undefined\" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === \"function\";\nvar ReactEditor = {\n    /**\r\n   * Check if the user is currently composing inside the editor.\r\n   */ isComposing (editor) {\n        return !!IS_COMPOSING.get(editor);\n    },\n    /**\r\n   * Return the host window of the current editor.\r\n   */ getWindow (editor) {\n        var window1 = EDITOR_TO_WINDOW.get(editor);\n        if (!window1) {\n            throw new Error(\"Unable to find a host window element for this editor\");\n        }\n        return window1;\n    },\n    /**\r\n   * Find a key for a Slate node.\r\n   */ findKey (editor, node) {\n        var key = NODE_TO_KEY.get(node);\n        if (!key) {\n            key = new Key();\n            NODE_TO_KEY.set(node, key);\n        }\n        return key;\n    },\n    /**\r\n   * Find the path of Slate node.\r\n   */ findPath (editor, node) {\n        var path = [];\n        var child = node;\n        while(true){\n            var parent = NODE_TO_PARENT.get(child);\n            if (parent == null) {\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(child)) {\n                    return path;\n                } else {\n                    break;\n                }\n            }\n            var i = NODE_TO_INDEX.get(child);\n            if (i == null) {\n                break;\n            }\n            path.unshift(i);\n            child = parent;\n        }\n        throw new Error(\"Unable to find the path for Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(node)));\n    },\n    /**\r\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\r\n   */ findDocumentOrShadowRoot (editor) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = el.getRootNode();\n        if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {\n            return root;\n        }\n        return el.ownerDocument;\n    },\n    /**\r\n   * Check if the editor is focused.\r\n   */ isFocused (editor) {\n        return !!IS_FOCUSED.get(editor);\n    },\n    /**\r\n   * Check if the editor is in read-only mode.\r\n   */ isReadOnly (editor) {\n        return !!IS_READ_ONLY.get(editor);\n    },\n    /**\r\n   * Blur the editor.\r\n   */ blur (editor) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        IS_FOCUSED.set(editor, false);\n        if (root.activeElement === el) {\n            el.blur();\n        }\n    },\n    /**\r\n   * Focus the editor.\r\n   */ focus (editor) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        IS_FOCUSED.set(editor, true);\n        if (root.activeElement !== el) {\n            el.focus({\n                preventScroll: true\n            });\n        }\n    },\n    /**\r\n   * Deselect the editor.\r\n   */ deselect (editor) {\n        var { selection } = editor;\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        var domSelection = root.getSelection();\n        if (domSelection && domSelection.rangeCount > 0) {\n            domSelection.removeAllRanges();\n        }\n        if (selection) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n        }\n    },\n    /**\r\n   * Check if a DOM node is within the editor.\r\n   */ hasDOMNode (editor, target) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { editable = false } = options;\n        var editorEl = ReactEditor.toDOMNode(editor, editor);\n        var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n        // target is originating from an internal \"restricted\" element (e.g. a\n        // stepper arrow on a number input). (2018/05/04)\n        // https://github.com/ianstormtaylor/slate/issues/1819\n        try {\n            targetEl = isDOMElement(target) ? target : target.parentElement;\n        } catch (err) {\n            if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n                throw err;\n            }\n        }\n        if (!targetEl) {\n            return false;\n        }\n        return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === \"boolean\" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n        // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n        targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute(\"data-slate-zero-width\"));\n    },\n    /**\r\n   * Insert data from a `DataTransfer` into the editor.\r\n   */ insertData (editor, data) {\n        editor.insertData(data);\n    },\n    /**\r\n   * Insert fragment data from a `DataTransfer` into the editor.\r\n   */ insertFragmentData (editor, data) {\n        return editor.insertFragmentData(data);\n    },\n    /**\r\n   * Insert text data from a `DataTransfer` into the editor.\r\n   */ insertTextData (editor, data) {\n        return editor.insertTextData(data);\n    },\n    /**\r\n   * Sets data from the currently selected fragment on a `DataTransfer`.\r\n   */ setFragmentData (editor, data, originEvent) {\n        editor.setFragmentData(data, originEvent);\n    },\n    /**\r\n   * Find the native DOM element from a Slate node.\r\n   */ toDOMNode (editor, node) {\n        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n        var domNode = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));\n        if (!domNode) {\n            throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(node)));\n        }\n        return domNode;\n    },\n    /**\r\n   * Find a native DOM selection point from a Slate point.\r\n   */ toDOMPoint (editor, point) {\n        var [node] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.node(editor, point.path);\n        var el = ReactEditor.toDOMNode(editor, node);\n        var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero\n        // width spacing character will result in an incorrect offset of 1\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n            at: point\n        })) {\n            point = {\n                path: point.path,\n                offset: 0\n            };\n        } // For each leaf, we need to isolate its content, which means filtering\n        // to its direct text and zero-width spans. (We have to filter out any\n        // other siblings that may have been rendered alongside them.)\n        var selector = \"[data-slate-string], [data-slate-zero-width]\";\n        var texts = Array.from(el.querySelectorAll(selector));\n        var start = 0;\n        for(var i = 0; i < texts.length; i++){\n            var text = texts[i];\n            var domNode = text.childNodes[0];\n            if (domNode == null || domNode.textContent == null) {\n                continue;\n            }\n            var { length } = domNode.textContent;\n            var attr = text.getAttribute(\"data-slate-length\");\n            var trueLength = attr == null ? length : parseInt(attr, 10);\n            var end = start + trueLength; // Prefer putting the selection inside the mark placeholder to ensure\n            // composed text is displayed with the correct marks.\n            var nextText = texts[i + 1];\n            if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute(\"data-slate-mark-placeholder\")) {\n                var _nextText$textContent;\n                var domText = nextText.childNodes[0];\n                domPoint = [\n                    // dom text element, chrome will put the selection behind the actual dom\n                    // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n                    // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n                    // which will cause issues when scrolling to it.\n                    domText instanceof DOMText ? domText : nextText,\n                    (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith(\"\\uFEFF\") ? 1 : 0\n                ];\n                break;\n            }\n            if (point.offset <= end) {\n                var offset = Math.min(length, Math.max(0, point.offset - start));\n                domPoint = [\n                    domNode,\n                    offset\n                ];\n                break;\n            }\n            start = end;\n        }\n        if (!domPoint) {\n            throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(point)));\n        }\n        return domPoint;\n    },\n    /**\r\n   * Find a native DOM range from a Slate `range`.\r\n   *\r\n   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.\r\n   *\r\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\r\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\r\n   */ toDOMRange (editor, range) {\n        var { anchor, focus } = range;\n        var isBackward = slate__WEBPACK_IMPORTED_MODULE_7__.Range.isBackward(range);\n        var domAnchor = ReactEditor.toDOMPoint(editor, anchor);\n        var domFocus = slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);\n        var window1 = ReactEditor.getWindow(editor);\n        var domRange = window1.document.createRange();\n        var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n        var [endNode, endOffset] = isBackward ? domAnchor : domFocus; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n        // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n        // adjust the offset accordingly.\n        var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n        var isStartAtZeroWidth = !!startEl.getAttribute(\"data-slate-zero-width\");\n        var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n        var isEndAtZeroWidth = !!endEl.getAttribute(\"data-slate-zero-width\");\n        domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n        domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n        return domRange;\n    },\n    /**\r\n   * Find a Slate node from a native DOM `element`.\r\n   */ toSlateNode (editor, domNode) {\n        var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n        if (domEl && !domEl.hasAttribute(\"data-slate-node\")) {\n            domEl = domEl.closest(\"[data-slate-node]\");\n        }\n        var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n        if (!node) {\n            throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n        }\n        return node;\n    },\n    /**\r\n   * Get the target range from a DOM `event`.\r\n   */ findEventRange (editor, event) {\n        if (\"nativeEvent\" in event) {\n            event = event.nativeEvent;\n        }\n        var { clientX: x, clientY: y, target } = event;\n        if (x == null || y == null) {\n            throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n        }\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the\n        // next or previous node, depending on which side the `x` and `y`\n        // coordinates are closest to.\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n            var rect = target.getBoundingClientRect();\n            var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n            var edge = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.point(editor, path, {\n                edge: isPrev ? \"start\" : \"end\"\n            });\n            var point = isPrev ? slate__WEBPACK_IMPORTED_MODULE_7__.Editor.before(editor, edge) : slate__WEBPACK_IMPORTED_MODULE_7__.Editor.after(editor, edge);\n            if (point) {\n                var _range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, point);\n                return _range;\n            }\n        } // Else resolve a range from the caret position where the drop occured.\n        var domRange;\n        var { document: document1 } = ReactEditor.getWindow(editor); // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n        if (document1.caretRangeFromPoint) {\n            domRange = document1.caretRangeFromPoint(x, y);\n        } else {\n            var position = document1.caretPositionFromPoint(x, y);\n            if (position) {\n                domRange = document1.createRange();\n                domRange.setStart(position.offsetNode, position.offset);\n                domRange.setEnd(position.offsetNode, position.offset);\n            }\n        }\n        if (!domRange) {\n            throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n        } // Resolve a Slate range from the DOM range.\n        var range = ReactEditor.toSlateRange(editor, domRange, {\n            exactMatch: false,\n            suppressThrow: false\n        });\n        return range;\n    },\n    /**\r\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\r\n   */ toSlatePoint (editor, domPoint, options) {\n        var { exactMatch, suppressThrow } = options;\n        var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n        var parentNode = nearestNode.parentNode;\n        var textNode = null;\n        var offset = 0;\n        if (parentNode) {\n            var _domNode$textContent, _domNode$textContent2;\n            var editorEl = ReactEditor.toDOMNode(editor, editor);\n            var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]'); // Need to ensure that the closest void node is actually a void node\n            // within this editor, and not a void node within some parent editor. This can happen\n            // if this editor is within a void node of another editor (\"nested editors\", like in\n            // the \"Editable Voids\" example on the docs site).\n            var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n            var leafNode = parentNode.closest(\"[data-slate-leaf]\");\n            var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we\n            // can determine what the offset relative to the text node is.\n            if (leafNode) {\n                textNode = leafNode.closest('[data-slate-node=\"text\"]');\n                if (textNode) {\n                    var window1 = ReactEditor.getWindow(editor);\n                    var range = window1.document.createRange();\n                    range.setStart(textNode, 0);\n                    range.setEnd(nearestNode, nearestOffset);\n                    var contents = range.cloneContents();\n                    var removals = [\n                        ...Array.prototype.slice.call(contents.querySelectorAll(\"[data-slate-zero-width]\")),\n                        ...Array.prototype.slice.call(contents.querySelectorAll(\"[contenteditable=false]\"))\n                    ];\n                    removals.forEach((el)=>{\n                        // COMPAT: While composing at the start of a text node, some keyboards put\n                        // the text content inside the zero width space.\n                        if (IS_ANDROID && !exactMatch && el.hasAttribute(\"data-slate-zero-width\") && el.textContent.length > 0 && el.textContext !== \"\\uFEFF\") {\n                            if (el.textContent.startsWith(\"\\uFEFF\")) {\n                                el.textContent = el.textContent.slice(1);\n                            }\n                            return;\n                        }\n                        el.parentNode.removeChild(el);\n                    }); // COMPAT: Edge has a bug where Range.prototype.toString() will\n                    // convert \\n into \\r\\n. The bug causes a loop when slate-react\n                    // attempts to reposition its cursor to match the native position. Use\n                    // textContent.length instead.\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n                    offset = contents.textContent.length;\n                    domNode = textNode;\n                }\n            } else if (voidNode) {\n                // For void nodes, the element with the offset key will be a cousin, not an\n                // ancestor, so find it by going down from the nearest void parent and taking the\n                // first one that isn't inside a nested editor.\n                var leafNodes = voidNode.querySelectorAll(\"[data-slate-leaf]\");\n                for(var index = 0; index < leafNodes.length; index++){\n                    var current = leafNodes[index];\n                    if (ReactEditor.hasDOMNode(editor, current)) {\n                        leafNode = current;\n                        break;\n                    }\n                } // COMPAT: In read-only editors the leaf is not rendered.\n                if (!leafNode) {\n                    offset = 1;\n                } else {\n                    textNode = leafNode.closest('[data-slate-node=\"text\"]');\n                    domNode = leafNode;\n                    offset = domNode.textContent.length;\n                    domNode.querySelectorAll(\"[data-slate-zero-width]\").forEach((el)=>{\n                        offset -= el.textContent.length;\n                    });\n                }\n            }\n            if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,\n            // and we don't add it for line-breaks.\n            IS_ANDROID && domNode.getAttribute(\"data-slate-zero-width\") === \"z\" && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith(\"\\uFEFF\") && (parentNode.hasAttribute(\"data-slate-zero-width\") || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith(\"\\n\\n\"))) {\n                offset--;\n            }\n        }\n        if (IS_ANDROID && !textNode && !exactMatch) {\n            var node = parentNode.hasAttribute(\"data-slate-node\") ? parentNode : parentNode.closest(\"[data-slate-node]\");\n            if (node && ReactEditor.hasDOMNode(editor, node, {\n                editable: true\n            })) {\n                var _slateNode = ReactEditor.toSlateNode(editor, node);\n                var { path: _path, offset: _offset } = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, ReactEditor.findPath(editor, _slateNode));\n                if (!node.querySelector(\"[data-slate-leaf]\")) {\n                    _offset = nearestOffset;\n                }\n                return {\n                    path: _path,\n                    offset: _offset\n                };\n            }\n        }\n        if (!textNode) {\n            if (suppressThrow) {\n                return null;\n            }\n            throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n        } // COMPAT: If someone is clicking from one Slate editor into another,\n        // the select event fires twice, once for the old editor's `element`\n        // first, and then afterwards for the correct `element`. (2017/03/03)\n        var slateNode = ReactEditor.toSlateNode(editor, textNode);\n        var path = ReactEditor.findPath(editor, slateNode);\n        return {\n            path,\n            offset\n        };\n    },\n    /**\r\n   * Find a Slate range from a DOM range or selection.\r\n   */ toSlateRange (editor, domRange, options) {\n        var { exactMatch, suppressThrow } = options;\n        var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n        var anchorNode;\n        var anchorOffset;\n        var focusNode;\n        var focusOffset;\n        var isCollapsed;\n        if (el) {\n            if (isDOMSelection(domRange)) {\n                anchorNode = domRange.anchorNode;\n                anchorOffset = domRange.anchorOffset;\n                focusNode = domRange.focusNode;\n                focusOffset = domRange.focusOffset; // COMPAT: There's a bug in chrome that always returns `true` for\n                // `isCollapsed` for a Selection that comes from a ShadowRoot.\n                // (2020/08/08)\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n                if (IS_CHROME && hasShadowRoot(anchorNode)) {\n                    isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n                } else {\n                    isCollapsed = domRange.isCollapsed;\n                }\n            } else {\n                anchorNode = domRange.startContainer;\n                anchorOffset = domRange.startOffset;\n                focusNode = domRange.endContainer;\n                focusOffset = domRange.endOffset;\n                isCollapsed = domRange.collapsed;\n            }\n        }\n        if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n            throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n        } // COMPAT: Triple-clicking a word in chrome will sometimes place the focus\n        // inside a `contenteditable=\"false\"` DOM node following the word, which\n        // will cause `toSlatePoint` to throw an error. (2023/03/07)\n        if (\"getAttribute\" in focusNode && focusNode.getAttribute(\"contenteditable\") === \"false\") {\n            var _anchorNode$textConte;\n            focusNode = anchorNode;\n            focusOffset = ((_anchorNode$textConte = anchorNode.textContent) === null || _anchorNode$textConte === void 0 ? void 0 : _anchorNode$textConte.length) || 0;\n        }\n        var anchor = ReactEditor.toSlatePoint(editor, [\n            anchorNode,\n            anchorOffset\n        ], {\n            exactMatch,\n            suppressThrow\n        });\n        if (!anchor) {\n            return null;\n        }\n        var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [\n            focusNode,\n            focusOffset\n        ], {\n            exactMatch,\n            suppressThrow\n        });\n        if (!focus) {\n            return null;\n        }\n        /**\r\n     * suppose we have this document:\r\n     *\r\n     * { type: 'paragraph',\r\n     *   children: [\r\n     *     { text: 'foo ' },\r\n     *     { text: 'bar' },\r\n     *     { text: ' baz' }\r\n     *   ]\r\n     * }\r\n     *\r\n     * a double click on \"bar\" on chrome will create this range:\r\n     *\r\n     * anchor -> [0,1] offset 0\r\n     * focus  -> [0,1] offset 3\r\n     *\r\n     * while on firefox will create this range:\r\n     *\r\n     * anchor -> [0,0] offset 4\r\n     * focus  -> [0,2] offset 0\r\n     *\r\n     * let's try to fix it...\r\n     */ if (IS_FIREFOX && !isCollapsed && anchorNode !== focusNode) {\n            var isEnd = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEnd(editor, anchor, anchor.path);\n            var isStart = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isStart(editor, focus, focus.path);\n            if (isEnd) {\n                var after = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.after(editor, anchor); // Editor.after() might return undefined\n                anchor = after || anchor;\n            }\n            if (isStart) {\n                var before = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.before(editor, focus);\n                focus = before || focus;\n            }\n        }\n        var range = {\n            anchor: anchor,\n            focus: focus\n        }; // if the selection is a hanging range that ends in a void\n        // and the DOM focus is an Element\n        // (meaning that the selection ends before the element)\n        // unhang the range to avoid mistakenly including the void\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(range) && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isForward(range) && isDOMElement(focusNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n            at: range.focus,\n            mode: \"highest\"\n        })) {\n            range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.unhangRange(editor, range, {\n                voids: true\n            });\n        }\n        return range;\n    },\n    hasRange (editor, range) {\n        var { anchor, focus } = range;\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, anchor.path) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, focus.path);\n    },\n    /**\r\n   * Check if the target is in the editor.\r\n   */ hasTarget (editor, target) {\n        return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);\n    },\n    /**\r\n   * Check if the target is editable and in the editor.\r\n   */ hasEditableTarget (editor, target) {\n        return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {\n            editable: true\n        });\n    },\n    /**\r\n   * Check if the target can be selectable\r\n   */ hasSelectableTarget (editor, target) {\n        return ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target);\n    },\n    /**\r\n   * Check if the target is inside void and in an non-readonly editor.\r\n   */ isTargetInsideNonReadonlyVoid (editor, target) {\n        if (IS_READ_ONLY.get(editor)) return false;\n        var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(slateNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, slateNode);\n    },\n    /**\r\n   * Experimental and android specific: Flush all pending diffs and cancel composition at the next possible time.\r\n   */ androidScheduleFlush (editor) {\n        var _EDITOR_TO_SCHEDULE_F;\n        (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n    },\n    /**\r\n   * Experimental and android specific: Get pending diffs\r\n   */ androidPendingDiffs (editor) {\n        return EDITOR_TO_PENDING_DIFFS.get(editor);\n    }\n};\nvar _excluded$3 = [\n    \"anchor\",\n    \"focus\"\n], _excluded2$1 = [\n    \"anchor\",\n    \"focus\"\n];\nvar shallowCompare = (obj1, obj2)=>Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key)=>obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\nvar isDecorationFlagsEqual = (range, other)=>{\n    var rangeOwnProps = _objectWithoutProperties(range, _excluded$3);\n    var otherOwnProps = _objectWithoutProperties(other, _excluded2$1);\n    return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */ var isElementDecorationsEqual = (list, another)=>{\n    if (list.length !== another.length) {\n        return false;\n    }\n    for(var i = 0; i < list.length; i++){\n        var range = list[i];\n        var other = another[i];\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */ var isTextDecorationsEqual = (list, another)=>{\n    if (list.length !== another.length) {\n        return false;\n    }\n    for(var i = 0; i < list.length; i++){\n        var range = list[i];\n        var other = another[i]; // compare only offsets because paths doesn't matter for text\n        if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\r\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\r\n */ var useIsomorphicLayoutEffect = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\n/**\r\n * Leaf content strings.\r\n */ var String = (props)=>{\n    var { isLast, leaf, parent, text } = props;\n    var editor = useSlateStatic();\n    var path = ReactEditor.findPath(editor, text);\n    var parentPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(path);\n    var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true; // COMPAT: Render text inside void nodes with a zero-width space.\n    // So the node can contain selection but the text is not visible.\n    if (editor.isVoid(parent)) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n            length: slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(parent).length\n        });\n    } // COMPAT: If this is the last text node in an empty block, render a zero-\n    // width space that will convert into a line break when copying and pasting\n    // to support expected plain text.\n    if (leaf.text === \"\" && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.string(editor, parentPath) === \"\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n            isLineBreak: true,\n            isMarkPlaceholder: isMarkPlaceholder\n        });\n    } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n    // node, so we render a zero-width space so that the selection can be\n    // inserted next to it still.\n    if (leaf.text === \"\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n            isMarkPlaceholder: isMarkPlaceholder\n        });\n    } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n    // so we need to add an extra trailing new lines to prevent that.\n    if (isLast && leaf.text.slice(-1) === \"\\n\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n            isTrailing: true,\n            text: leaf.text\n        });\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n        text: leaf.text\n    });\n};\n/**\r\n * Leaf strings with text in them.\r\n */ var TextString = (props)=>{\n    var { text, isTrailing = false } = props;\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var getTextContent = ()=>{\n        return \"\".concat(text !== null && text !== void 0 ? text : \"\").concat(isTrailing ? \"\\n\" : \"\");\n    };\n    var [initialText] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(getTextContent); // This is the actual text rendering boundary where we interface with the DOM\n    // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n    // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n    // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n    // exactly if and only if its current content does not match our current virtual DOM.\n    // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n    // eg makes native spellcheck opt out from checking the text node.\n    // useLayoutEffect: updating our span before browser paint\n    useIsomorphicLayoutEffect(()=>{\n        // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n        var textWithTrailing = getTextContent();\n        if (ref.current && ref.current.textContent !== textWithTrailing) {\n            ref.current.textContent = textWithTrailing;\n        } // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n    }); // We intentionally render a memoized <span> that only receives the initial text content when the component is mounted.\n    // We defer to the layout effect above to update the `textContent` of the span element when needed.\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText$1, {\n        ref: ref\n    }, initialText);\n};\nvar MemoizedText$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)((props, ref)=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n        \"data-slate-string\": true,\n        ref: ref\n    }, props.children);\n}));\n/**\r\n * Leaf strings without text, render as zero-width strings.\r\n */ var ZeroWidthString = (props)=>{\n    var { length = 0, isLineBreak = false, isMarkPlaceholder = false } = props;\n    var attributes = {\n        \"data-slate-zero-width\": isLineBreak ? \"n\" : \"z\",\n        \"data-slate-length\": length\n    };\n    if (isMarkPlaceholder) {\n        attributes[\"data-slate-mark-placeholder\"] = true;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? \"\\uFEFF\" : null, isLineBreak ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null) : null);\n};\n/**\r\n * A React context for sharing the editor object.\r\n */ var EditorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\r\n * Get the current editor object from the React context.\r\n */ var useSlateStatic = ()=>{\n    var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n    if (!editor) {\n        throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n    }\n    return editor;\n};\n/**\r\n * Individual leaves in a text node with unique formatting.\r\n */ var Leaf = (props)=>{\n    var { leaf, isLast, text, parent, renderPlaceholder, renderLeaf = (props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultLeaf, Object.assign({}, props)) } = props;\n    var lastPlaceholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var editor = useSlateStatic();\n    var placeholderResizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        return ()=>{\n            if (placeholderResizeObserver.current) {\n                placeholderResizeObserver.current.disconnect();\n            }\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        var placeholderEl = placeholderRef === null || placeholderRef === void 0 ? void 0 : placeholderRef.current;\n        if (placeholderEl) {\n            EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n        } else {\n            EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n        }\n        if (placeholderResizeObserver.current) {\n            // Update existing observer.\n            placeholderResizeObserver.current.disconnect();\n            if (placeholderEl) placeholderResizeObserver.current.observe(placeholderEl);\n        } else if (placeholderEl) {\n            // Create a new observer and observe the placeholder element.\n            var ResizeObserver$1 = window.ResizeObserver || _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_4__.ResizeObserver;\n            placeholderResizeObserver.current = new ResizeObserver$1(()=>{\n                // Force a re-render of the editor so its min-height can be updated\n                // to the new height of the placeholder.\n                var forceRender = EDITOR_TO_FORCE_RENDER.get(editor);\n                forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n            });\n            placeholderResizeObserver.current.observe(placeholderEl);\n        }\n        if (!placeholderEl && lastPlaceholderRef.current) {\n            // No placeholder element, so no need for a resize observer.\n            // Force a re-render of the editor so its min-height can be reset.\n            var forceRender = EDITOR_TO_FORCE_RENDER.get(editor);\n            forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n        }\n        lastPlaceholderRef.current = placeholderRef.current;\n        return ()=>{\n            EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n        };\n    }, [\n        placeholderRef,\n        leaf\n    ]);\n    var children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(String, {\n        isLast: isLast,\n        leaf: leaf,\n        parent: parent,\n        text: text\n    });\n    if (leaf[PLACEHOLDER_SYMBOL]) {\n        var placeholderProps = {\n            children: leaf.placeholder,\n            attributes: {\n                \"data-slate-placeholder\": true,\n                style: {\n                    position: \"absolute\",\n                    pointerEvents: \"none\",\n                    width: \"100%\",\n                    maxWidth: \"100%\",\n                    display: \"block\",\n                    opacity: \"0.333\",\n                    userSelect: \"none\",\n                    textDecoration: \"none\"\n                },\n                contentEditable: false,\n                ref: placeholderRef\n            }\n        };\n        children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, renderPlaceholder(placeholderProps), children);\n    } // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n    // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n    // contenteditable behaviors. (2019/05/08)\n    var attributes = {\n        \"data-slate-leaf\": true\n    };\n    return renderLeaf({\n        attributes,\n        children,\n        leaf,\n        text\n    });\n};\nvar MemoizedLeaf = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().memo(Leaf, (prev, next)=>{\n    return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = (props)=>{\n    var { attributes, children } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", Object.assign({}, attributes), children);\n};\n/**\r\n * Text.\r\n */ var Text = (props)=>{\n    var { decorations, isLast, parent, renderPlaceholder, renderLeaf, text } = props;\n    var editor = useSlateStatic();\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var leaves = slate__WEBPACK_IMPORTED_MODULE_7__.Text.decorations(text, decorations);\n    var key = ReactEditor.findKey(editor, text);\n    var children = [];\n    for(var i = 0; i < leaves.length; i++){\n        var leaf = leaves[i];\n        children.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedLeaf, {\n            isLast: isLast && i === leaves.length - 1,\n            key: \"\".concat(key.id, \"-\").concat(i),\n            renderPlaceholder: renderPlaceholder,\n            leaf: leaf,\n            text: text,\n            parent: parent,\n            renderLeaf: renderLeaf\n        }));\n    } // Update element-related weak maps with the DOM element ref.\n    var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((span)=>{\n        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n        if (span) {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, span);\n            NODE_TO_ELEMENT.set(text, span);\n            ELEMENT_TO_NODE.set(span, text);\n        } else {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n            NODE_TO_ELEMENT.delete(text);\n            if (ref.current) {\n                ELEMENT_TO_NODE.delete(ref.current);\n            }\n        }\n        ref.current = span;\n    }, [\n        ref,\n        editor,\n        key,\n        text\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n        \"data-slate-node\": \"text\",\n        ref: callbackRef\n    }, children);\n};\nvar MemoizedText = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().memo(Text, (prev, next)=>{\n    return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && isTextDecorationsEqual(next.decorations, prev.decorations);\n});\n/**\r\n * Element.\r\n */ var Element = (props)=>{\n    var { decorations, element, renderElement = (p)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultElement, Object.assign({}, p)), renderPlaceholder, renderLeaf, selection } = props;\n    var editor = useSlateStatic();\n    var readOnly = useReadOnly();\n    var isInline = editor.isInline(element);\n    var key = ReactEditor.findKey(editor, element);\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((ref)=>{\n        // Update element-related weak maps with the DOM element ref.\n        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n        if (ref) {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref);\n            NODE_TO_ELEMENT.set(element, ref);\n            ELEMENT_TO_NODE.set(ref, element);\n        } else {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n            NODE_TO_ELEMENT.delete(element);\n        }\n    }, [\n        editor,\n        key,\n        element\n    ]);\n    var children = useChildren({\n        decorations,\n        node: element,\n        renderElement,\n        renderPlaceholder,\n        renderLeaf,\n        selection\n    }); // Attributes that the developer must mix into the element in their\n    // custom node renderer component.\n    var attributes = {\n        \"data-slate-node\": \"element\",\n        ref\n    };\n    if (isInline) {\n        attributes[\"data-slate-inline\"] = true;\n    } // If it's a block node with inline children, add the proper `dir` attribute\n    // for text direction.\n    if (!isInline && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, element)) {\n        var text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element);\n        var dir = direction__WEBPACK_IMPORTED_MODULE_0___default()(text);\n        if (dir === \"rtl\") {\n            attributes.dir = dir;\n        }\n    } // If it's a void node, wrap the children in extra void-specific elements.\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, element)) {\n        attributes[\"data-slate-void\"] = true;\n        if (!readOnly && isInline) {\n            attributes.contentEditable = false;\n        }\n        var Tag = isInline ? \"span\" : \"div\";\n        var [[_text]] = slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(element);\n        children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, {\n            \"data-slate-spacer\": true,\n            style: {\n                height: \"0\",\n                color: \"transparent\",\n                outline: \"none\",\n                position: \"absolute\"\n            }\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n            renderPlaceholder: renderPlaceholder,\n            decorations: [],\n            isLast: false,\n            parent: element,\n            text: _text\n        }));\n        NODE_TO_INDEX.set(_text, 0);\n        NODE_TO_PARENT.set(_text, element);\n    }\n    return renderElement({\n        attributes,\n        children,\n        element\n    });\n};\nvar MemoizedElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().memo(Element, (prev, next)=>{\n    return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && prev.renderPlaceholder === next.renderPlaceholder && isElementDecorationsEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(prev.selection, next.selection));\n});\n/**\r\n * The default element renderer.\r\n */ var DefaultElement = (props)=>{\n    var { attributes, children, element } = props;\n    var editor = useSlateStatic();\n    var Tag = editor.isInline(element) ? \"span\" : \"div\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, Object.assign({}, attributes, {\n        style: {\n            position: \"relative\"\n        }\n    }), children);\n};\n/**\r\n * A React context for sharing the `decorate` prop of the editable.\r\n */ var DecorateContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(()=>[]);\n/**\r\n * Get the current `decorate` prop of the editable.\r\n */ var useDecorate = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(DecorateContext);\n};\n/**\r\n * A React context for sharing the `selected` state of an element.\r\n */ var SelectedContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\r\n * Get the current `selected` state of an element.\r\n */ var useSelected = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SelectedContext);\n};\n/**\r\n * Children.\r\n */ var useChildren = (props)=>{\n    var { decorations, node, renderElement, renderPlaceholder, renderLeaf, selection } = props;\n    var decorate = useDecorate();\n    var editor = useSlateStatic();\n    var path = ReactEditor.findPath(editor, node);\n    var children = [];\n    var isLeafBlock = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isInline(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, node);\n    for(var i = 0; i < node.children.length; i++){\n        var p = path.concat(i);\n        var n = node.children[i];\n        var key = ReactEditor.findKey(editor, n);\n        var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, p);\n        var sel = selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(range, selection);\n        var ds = decorate([\n            n,\n            p\n        ]);\n        for (var dec of decorations){\n            var d = slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(dec, range);\n            if (d) {\n                ds.push(d);\n            }\n        }\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n)) {\n            children.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SelectedContext.Provider, {\n                key: \"provider-\".concat(key.id),\n                value: !!sel\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedElement, {\n                decorations: ds,\n                element: n,\n                key: key.id,\n                renderElement: renderElement,\n                renderPlaceholder: renderPlaceholder,\n                renderLeaf: renderLeaf,\n                selection: sel\n            })));\n        } else {\n            children.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n                decorations: ds,\n                key: key.id,\n                isLast: isLeafBlock && i === node.children.length - 1,\n                parent: node,\n                renderPlaceholder: renderPlaceholder,\n                renderLeaf: renderLeaf,\n                text: n\n            }));\n        }\n        NODE_TO_INDEX.set(n, i);\n        NODE_TO_PARENT.set(n, node);\n    }\n    return children;\n};\n/**\r\n * A React context for sharing the `readOnly` state of the editor.\r\n */ var ReadOnlyContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\r\n * Get the current `readOnly` state of the editor.\r\n */ var useReadOnly = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ReadOnlyContext);\n};\nvar SlateContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\r\n * Get the current editor object from the React context.\r\n */ var useSlate = ()=>{\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateContext);\n    if (!context) {\n        throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n    }\n    var { editor } = context;\n    return editor;\n};\nvar useSlateWithV = ()=>{\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateContext);\n    if (!context) {\n        throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n    }\n    return context;\n};\nvar TRIPLE_CLICK = 3;\n/**\r\n * Hotkey mappings for each platform.\r\n */ var HOTKEYS = {\n    bold: \"mod+b\",\n    compose: [\n        \"down\",\n        \"left\",\n        \"right\",\n        \"up\",\n        \"backspace\",\n        \"enter\"\n    ],\n    moveBackward: \"left\",\n    moveForward: \"right\",\n    moveWordBackward: \"ctrl+left\",\n    moveWordForward: \"ctrl+right\",\n    deleteBackward: \"shift?+backspace\",\n    deleteForward: \"shift?+delete\",\n    extendBackward: \"shift+left\",\n    extendForward: \"shift+right\",\n    italic: \"mod+i\",\n    insertSoftBreak: \"shift+enter\",\n    splitBlock: \"enter\",\n    undo: \"mod+z\"\n};\nvar APPLE_HOTKEYS = {\n    moveLineBackward: \"opt+up\",\n    moveLineForward: \"opt+down\",\n    moveWordBackward: \"opt+left\",\n    moveWordForward: \"opt+right\",\n    deleteBackward: [\n        \"ctrl+backspace\",\n        \"ctrl+h\"\n    ],\n    deleteForward: [\n        \"ctrl+delete\",\n        \"ctrl+d\"\n    ],\n    deleteLineBackward: \"cmd+shift?+backspace\",\n    deleteLineForward: [\n        \"cmd+shift?+delete\",\n        \"ctrl+k\"\n    ],\n    deleteWordBackward: \"opt+shift?+backspace\",\n    deleteWordForward: \"opt+shift?+delete\",\n    extendLineBackward: \"opt+shift+up\",\n    extendLineForward: \"opt+shift+down\",\n    redo: \"cmd+shift+z\",\n    transposeCharacter: \"ctrl+t\"\n};\nvar WINDOWS_HOTKEYS = {\n    deleteWordBackward: \"ctrl+shift?+backspace\",\n    deleteWordForward: \"ctrl+shift?+delete\",\n    redo: [\n        \"ctrl+y\",\n        \"ctrl+shift+z\"\n    ]\n};\n/**\r\n * Create a platform-aware hotkey checker.\r\n */ var create = (key)=>{\n    var generic = HOTKEYS[key];\n    var apple = APPLE_HOTKEYS[key];\n    var windows = WINDOWS_HOTKEYS[key];\n    var isGeneric = generic && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_5__.isKeyHotkey)(generic);\n    var isApple = apple && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_5__.isKeyHotkey)(apple);\n    var isWindows = windows && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_5__.isKeyHotkey)(windows);\n    return (event)=>{\n        if (isGeneric && isGeneric(event)) return true;\n        if (IS_APPLE && isApple && isApple(event)) return true;\n        if (!IS_APPLE && isWindows && isWindows(event)) return true;\n        return false;\n    };\n};\n/**\r\n * Hotkeys.\r\n */ var Hotkeys = {\n    isBold: create(\"bold\"),\n    isCompose: create(\"compose\"),\n    isMoveBackward: create(\"moveBackward\"),\n    isMoveForward: create(\"moveForward\"),\n    isDeleteBackward: create(\"deleteBackward\"),\n    isDeleteForward: create(\"deleteForward\"),\n    isDeleteLineBackward: create(\"deleteLineBackward\"),\n    isDeleteLineForward: create(\"deleteLineForward\"),\n    isDeleteWordBackward: create(\"deleteWordBackward\"),\n    isDeleteWordForward: create(\"deleteWordForward\"),\n    isExtendBackward: create(\"extendBackward\"),\n    isExtendForward: create(\"extendForward\"),\n    isExtendLineBackward: create(\"extendLineBackward\"),\n    isExtendLineForward: create(\"extendLineForward\"),\n    isItalic: create(\"italic\"),\n    isMoveLineBackward: create(\"moveLineBackward\"),\n    isMoveLineForward: create(\"moveLineForward\"),\n    isMoveWordBackward: create(\"moveWordBackward\"),\n    isMoveWordForward: create(\"moveWordForward\"),\n    isRedo: create(\"redo\"),\n    isSoftBreak: create(\"insertSoftBreak\"),\n    isSplitBlock: create(\"splitBlock\"),\n    isTransposeCharacter: create(\"transposeCharacter\"),\n    isUndo: create(\"undo\")\n};\nvar createRestoreDomManager = (editor, receivedUserInput)=>{\n    var bufferedMutations = [];\n    var clear = ()=>{\n        bufferedMutations = [];\n    };\n    var registerMutations = (mutations)=>{\n        if (!receivedUserInput.current) {\n            return;\n        }\n        var trackedMutations = mutations.filter((mutation)=>isTrackedMutation(editor, mutation, mutations));\n        bufferedMutations.push(...trackedMutations);\n    };\n    function restoreDOM() {\n        if (bufferedMutations.length > 0) {\n            bufferedMutations.reverse().forEach((mutation)=>{\n                if (mutation.type === \"characterData\") {\n                    // We don't want to restore the DOM for characterData mutations\n                    // because this interrupts the composition.\n                    return;\n                }\n                mutation.removedNodes.forEach((node)=>{\n                    mutation.target.insertBefore(node, mutation.nextSibling);\n                });\n                mutation.addedNodes.forEach((node)=>{\n                    mutation.target.removeChild(node);\n                });\n            }); // Clear buffered mutations to ensure we don't undo them twice\n            clear();\n        }\n    }\n    return {\n        registerMutations,\n        restoreDOM,\n        clear\n    };\n};\nvar MUTATION_OBSERVER_CONFIG$1 = {\n    subtree: true,\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true\n}; // We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\nclass RestoreDOMComponent extends react__WEBPACK_IMPORTED_MODULE_3__.Component {\n    constructor(){\n        super(...arguments);\n        this.context = null;\n        this.manager = null;\n        this.mutationObserver = null;\n    }\n    observe() {\n        var _this$mutationObserve;\n        var { node } = this.props;\n        if (!node.current) {\n            throw new Error(\"Failed to attach MutationObserver, `node` is undefined\");\n        }\n        (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG$1);\n    }\n    componentDidMount() {\n        var { receivedUserInput } = this.props;\n        var editor = this.context;\n        this.manager = createRestoreDomManager(editor, receivedUserInput);\n        this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n        this.observe();\n    }\n    getSnapshotBeforeUpdate() {\n        var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n        var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n        if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n            var _this$manager;\n            (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);\n        }\n        (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();\n        (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();\n        return null;\n    }\n    componentDidUpdate() {\n        var _this$manager3;\n        (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();\n        this.observe();\n    }\n    componentWillUnmount() {\n        var _this$mutationObserve4;\n        (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();\n    }\n    render() {\n        return this.props.children;\n    }\n}\nRestoreDOMComponent.contextType = EditorContext;\nvar RestoreDOM = IS_ANDROID ? RestoreDOMComponent : (_ref)=>{\n    var { children } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, children);\n};\n/**\r\n * Check whether a text diff was applied in a way we can perform the pending action on /\r\n * recover the pending selection.\r\n */ function verifyDiffState(editor, textDiff) {\n    var { path, diff } = textDiff;\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path)) {\n        return false;\n    }\n    var node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path);\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(node)) {\n        return false;\n    }\n    if (diff.start !== node.text.length || diff.text.length === 0) {\n        return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n    }\n    var nextPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(path);\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, nextPath)) {\n        return false;\n    }\n    var nextNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, nextPath);\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n    for(var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        diffs[_key - 1] = arguments[_key];\n    }\n    return diffs.reduce((text, diff)=>text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\nfunction longestCommonPrefixLength(str, another) {\n    var length = Math.min(str.length, another.length);\n    for(var i = 0; i < length; i++){\n        if (str.charAt(i) !== another.charAt(i)) {\n            return i;\n        }\n    }\n    return length;\n}\nfunction longestCommonSuffixLength(str, another, max) {\n    var length = Math.min(str.length, another.length, max);\n    for(var i = 0; i < length; i++){\n        if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n            return i;\n        }\n    }\n    return length;\n}\n/**\r\n * Remove redundant changes from the diff so that it spans the minimal possible range\r\n */ function normalizeStringDiff(targetText, diff) {\n    var { start, end, text } = diff;\n    var removedText = targetText.slice(start, end);\n    var prefixLength = longestCommonPrefixLength(removedText, text);\n    var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n    var suffixLength = longestCommonSuffixLength(removedText, text, max);\n    var normalized = {\n        start: start + prefixLength,\n        end: end - suffixLength,\n        text: text.slice(prefixLength, text.length - suffixLength)\n    };\n    if (normalized.start === normalized.end && normalized.text.length === 0) {\n        return null;\n    }\n    return normalized;\n}\n/**\r\n * Return a string diff that is equivalent to applying b after a spanning the range of\r\n * both changes\r\n */ function mergeStringDiffs(targetText, a, b) {\n    var start = Math.min(a.start, b.start);\n    var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n    var applied = applyStringDiff(targetText, a, b);\n    var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n    var text = applied.slice(start, sliceEnd);\n    var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n    return normalizeStringDiff(targetText, {\n        start,\n        end,\n        text\n    });\n}\n/**\r\n * Get the slate range the text diff spans.\r\n */ function targetRange(textDiff) {\n    var { path, diff } = textDiff;\n    return {\n        anchor: {\n            path,\n            offset: diff.start\n        },\n        focus: {\n            path,\n            offset: diff.end\n        }\n    };\n}\n/**\r\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\r\n * the pending diffs. Since the pending diffs might have been inserted with different\r\n * marks we have to 'walk' the offset from the starting position to ensure we still\r\n * have a valid point inside the document\r\n */ function normalizePoint(editor, point) {\n    var { path, offset } = point;\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path)) {\n        return null;\n    }\n    var leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path);\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(leaf)) {\n        return null;\n    }\n    var parentBlock = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n        match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n),\n        at: path\n    });\n    if (!parentBlock) {\n        return null;\n    }\n    while(offset > leaf.text.length){\n        var entry = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.next(editor, {\n            at: path,\n            match: slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText\n        });\n        if (!entry || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.isDescendant(entry[1], parentBlock[1])) {\n            return null;\n        }\n        offset -= leaf.text.length;\n        leaf = entry[0];\n        path = entry[1];\n    }\n    return {\n        path,\n        offset\n    };\n}\n/**\r\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\r\n */ function normalizeRange(editor, range) {\n    var anchor = normalizePoint(editor, range.anchor);\n    if (!anchor) {\n        return null;\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(range)) {\n        return {\n            anchor,\n            focus: anchor\n        };\n    }\n    var focus = normalizePoint(editor, range.focus);\n    if (!focus) {\n        return null;\n    }\n    return {\n        anchor,\n        focus\n    };\n}\nfunction transformPendingPoint(editor, point, op) {\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n    var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((_ref)=>{\n        var { path } = _ref;\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(path, point.path);\n    });\n    if (!textDiff || point.offset <= textDiff.diff.start) {\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Point.transform(point, op, {\n            affinity: \"backward\"\n        });\n    }\n    var { diff } = textDiff; // Point references location inside the diff => transform the point based on the location\n    // the diff will be applied to and add the offset inside the diff.\n    if (point.offset <= diff.start + diff.text.length) {\n        var _anchor = {\n            path: point.path,\n            offset: diff.start\n        };\n        var _transformed = slate__WEBPACK_IMPORTED_MODULE_7__.Point.transform(_anchor, op, {\n            affinity: \"backward\"\n        });\n        if (!_transformed) {\n            return null;\n        }\n        return {\n            path: _transformed.path,\n            offset: _transformed.offset + point.offset - diff.start\n        };\n    } // Point references location after the diff\n    var anchor = {\n        path: point.path,\n        offset: point.offset - diff.text.length + diff.end - diff.start\n    };\n    var transformed = slate__WEBPACK_IMPORTED_MODULE_7__.Point.transform(anchor, op, {\n        affinity: \"backward\"\n    });\n    if (!transformed) {\n        return null;\n    }\n    if (op.type === \"split_node\" && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n        return transformed;\n    }\n    return {\n        path: transformed.path,\n        offset: transformed.offset + diff.text.length - diff.end + diff.start\n    };\n}\nfunction transformPendingRange(editor, range, op) {\n    var anchor = transformPendingPoint(editor, range.anchor, op);\n    if (!anchor) {\n        return null;\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(range)) {\n        return {\n            anchor,\n            focus: anchor\n        };\n    }\n    var focus = transformPendingPoint(editor, range.focus, op);\n    if (!focus) {\n        return null;\n    }\n    return {\n        anchor,\n        focus\n    };\n}\nfunction transformTextDiff(textDiff, op) {\n    var { path, diff, id } = textDiff;\n    switch(op.type){\n        case \"insert_text\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path) || op.offset >= diff.end) {\n                    return textDiff;\n                }\n                if (op.offset <= diff.start) {\n                    return {\n                        diff: {\n                            start: op.text.length + diff.start,\n                            end: op.text.length + diff.end,\n                            text: diff.text\n                        },\n                        id,\n                        path\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start,\n                        end: diff.end + op.text.length,\n                        text: diff.text\n                    },\n                    id,\n                    path\n                };\n            }\n        case \"remove_text\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path) || op.offset >= diff.end) {\n                    return textDiff;\n                }\n                if (op.offset + op.text.length <= diff.start) {\n                    return {\n                        diff: {\n                            start: diff.start - op.text.length,\n                            end: diff.end - op.text.length,\n                            text: diff.text\n                        },\n                        id,\n                        path\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start,\n                        end: diff.end - op.text.length,\n                        text: diff.text\n                    },\n                    id,\n                    path\n                };\n            }\n        case \"split_node\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path) || op.position >= diff.end) {\n                    return {\n                        diff,\n                        id,\n                        path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op, {\n                            affinity: \"backward\"\n                        })\n                    };\n                }\n                if (op.position > diff.start) {\n                    return {\n                        diff: {\n                            start: diff.start,\n                            end: Math.min(op.position, diff.end),\n                            text: diff.text\n                        },\n                        id,\n                        path\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start - op.position,\n                        end: diff.end - op.position,\n                        text: diff.text\n                    },\n                    id,\n                    path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op, {\n                        affinity: \"forward\"\n                    })\n                };\n            }\n        case \"merge_node\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path)) {\n                    return {\n                        diff,\n                        id,\n                        path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op)\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start + op.position,\n                        end: diff.end + op.position,\n                        text: diff.text\n                    },\n                    id,\n                    path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op)\n                };\n            }\n    }\n    var newPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op);\n    if (!newPath) {\n        return null;\n    }\n    return {\n        diff,\n        path: newPath,\n        id\n    };\n}\nfunction ownKeys$3(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$3(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$3(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$3(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\nvar RESOLVE_DELAY = 25; // Time with no user interaction before the current user action is considered as done.\nvar FLUSH_DELAY = 200; // Replace with `const debug = console.log` to debug\nvar debug = function debug() {}; // Type guard to check if a value is a DataTransfer\nvar isDataTransfer = (value)=>(value === null || value === void 0 ? void 0 : value.constructor.name) === \"DataTransfer\";\nfunction createAndroidInputManager(_ref) {\n    var { editor, scheduleOnDOMSelectionChange, onDOMSelectionChange } = _ref;\n    var flushing = false;\n    var compositionEndTimeoutId = null;\n    var flushTimeoutId = null;\n    var actionTimeoutId = null;\n    var idCounter = 0;\n    var insertPositionHint = false;\n    var applyPendingSelection = ()=>{\n        var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        if (pendingSelection) {\n            var { selection } = editor;\n            var normalized = normalizeRange(editor, pendingSelection);\n            if (normalized && (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(normalized, selection))) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, normalized);\n            }\n        }\n    };\n    var performAction = ()=>{\n        var action = EDITOR_TO_PENDING_ACTION.get(editor);\n        EDITOR_TO_PENDING_ACTION.delete(editor);\n        if (!action) {\n            return;\n        }\n        if (action.at) {\n            var target = slate__WEBPACK_IMPORTED_MODULE_7__.Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);\n            if (!target) {\n                return;\n            }\n            var _targetRange = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, target);\n            if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, _targetRange)) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, target);\n            }\n        }\n        action.run();\n    };\n    var flush = ()=>{\n        if (flushTimeoutId) {\n            clearTimeout(flushTimeoutId);\n            flushTimeoutId = null;\n        }\n        if (actionTimeoutId) {\n            clearTimeout(actionTimeoutId);\n            actionTimeoutId = null;\n        }\n        if (!hasPendingDiffs() && !hasPendingAction()) {\n            applyPendingSelection();\n            return;\n        }\n        if (!flushing) {\n            flushing = true;\n            setTimeout(()=>flushing = false);\n        }\n        if (hasPendingAction()) {\n            flushing = \"action\";\n        }\n        var selectionRef = editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection, {\n            affinity: \"forward\"\n        });\n        EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n        debug(\"flush\", EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));\n        var scheduleSelectionChange = hasPendingDiffs();\n        var diff;\n        while(diff = (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]){\n            var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;\n            var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n            if (pendingMarks !== undefined) {\n                EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n                editor.marks = pendingMarks;\n            }\n            if (pendingMarks && insertPositionHint === false) {\n                insertPositionHint = null;\n            }\n            var range = targetRange(diff);\n            if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, range)) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n            }\n            if (diff.diff.text) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, diff.diff.text);\n            } else {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n            } // Remove diff only after we have applied it to account for it when transforming\n            // pending ranges.\n            EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter((_ref2)=>{\n                var { id } = _ref2;\n                return id !== diff.id;\n            }));\n            if (!verifyDiffState(editor, diff)) {\n                scheduleSelectionChange = false;\n                EDITOR_TO_PENDING_ACTION.delete(editor);\n                EDITOR_TO_USER_MARKS.delete(editor);\n                flushing = \"action\"; // Ensure we don't restore the pending user (dom) selection\n                // since the document and dom state do not match.\n                EDITOR_TO_PENDING_SELECTION.delete(editor);\n                scheduleOnDOMSelectionChange.cancel();\n                onDOMSelectionChange.cancel();\n                selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n            }\n        }\n        var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n        if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, editor.selection))) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, selection);\n        }\n        if (hasPendingAction()) {\n            performAction();\n            return;\n        } // COMPAT: The selectionChange event is fired after the action is performed,\n        // so we have to manually schedule it to ensure we don't 'throw away' the selection\n        // while rendering if we have pending changes.\n        if (scheduleSelectionChange) {\n            scheduleOnDOMSelectionChange();\n        }\n        scheduleOnDOMSelectionChange.flush();\n        onDOMSelectionChange.flush();\n        applyPendingSelection();\n        var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n        EDITOR_TO_USER_MARKS.delete(editor);\n        if (userMarks !== undefined) {\n            editor.marks = userMarks;\n            editor.onChange();\n        }\n    };\n    var handleCompositionEnd = (_event)=>{\n        if (compositionEndTimeoutId) {\n            clearTimeout(compositionEndTimeoutId);\n        }\n        compositionEndTimeoutId = setTimeout(()=>{\n            IS_COMPOSING.set(editor, false);\n            flush();\n        }, RESOLVE_DELAY);\n    };\n    var handleCompositionStart = (_event)=>{\n        IS_COMPOSING.set(editor, true);\n        if (compositionEndTimeoutId) {\n            clearTimeout(compositionEndTimeoutId);\n            compositionEndTimeoutId = null;\n        }\n    };\n    var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n        var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n        if (!placeholderElement) {\n            return;\n        }\n        if (hasPendingDiffs() || forceHide) {\n            placeholderElement.style.display = \"none\";\n            return;\n        }\n        placeholderElement.style.removeProperty(\"display\");\n    };\n    var storeDiff = (path, diff)=>{\n        var _EDITOR_TO_PENDING_DI3;\n        var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];\n        EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n        var target = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, path);\n        var idx = pendingDiffs.findIndex((change)=>slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n        if (idx < 0) {\n            var normalized = normalizeStringDiff(target.text, diff);\n            if (normalized) {\n                pendingDiffs.push({\n                    path,\n                    diff,\n                    id: idCounter++\n                });\n            }\n            updatePlaceholderVisibility();\n            return;\n        }\n        var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);\n        if (!merged) {\n            pendingDiffs.splice(idx, 1);\n            updatePlaceholderVisibility();\n            return;\n        }\n        pendingDiffs[idx] = _objectSpread$3(_objectSpread$3({}, pendingDiffs[idx]), {}, {\n            diff: merged\n        });\n    };\n    var scheduleAction = function scheduleAction(run) {\n        var { at } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        insertPositionHint = false;\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        if (hasPendingAction()) {\n            flush();\n        }\n        EDITOR_TO_PENDING_ACTION.set(editor, {\n            at,\n            run\n        }); // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n        // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n        // in this case and thus never actually perform the action.\n        actionTimeoutId = setTimeout(flush);\n    };\n    var handleDOMBeforeInput = (event)=>{\n        var _targetRange2;\n        if (flushTimeoutId) {\n            clearTimeout(flushTimeoutId);\n            flushTimeoutId = null;\n        }\n        var { inputType: type } = event;\n        var targetRange = null;\n        var data = event.dataTransfer || event.data || undefined;\n        if (insertPositionHint !== false && type !== \"insertText\" && type !== \"insertCompositionText\") {\n            insertPositionHint = false;\n        }\n        var [nativeTargetRange] = event.getTargetRanges();\n        if (nativeTargetRange) {\n            targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n                exactMatch: false,\n                suppressThrow: true\n            });\n        } // COMPAT: SelectionChange event is fired after the action is performed, so we\n        // have to manually get the selection here to ensure it's up-to-date.\n        var window1 = ReactEditor.getWindow(editor);\n        var domSelection = window1.getSelection();\n        if (!targetRange && domSelection) {\n            nativeTargetRange = domSelection;\n            targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n                exactMatch: false,\n                suppressThrow: true\n            });\n        }\n        targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n        if (!targetRange) {\n            return;\n        } // By default, the input manager tries to store text diffs so that we can\n        // defer flushing them at a later point in time. We don't want to flush\n        // for every input event as this can be expensive. However, there are some\n        // scenarios where we cannot safely store the text diff and must instead\n        // schedule an action to let Slate normalize the editor state.\n        var canStoreDiff = true;\n        if (type.startsWith(\"delete\")) {\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n                var [_start, _end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n                var _leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _start.path);\n                if (_leaf.text.length === _start.offset && _end.offset === 0) {\n                    var next = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.next(editor, {\n                        at: _start.path,\n                        match: slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText\n                    });\n                    if (next && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(next[1], _end.path)) {\n                        targetRange = {\n                            anchor: _end,\n                            focus: _end\n                        };\n                    }\n                }\n            }\n            var direction = type.endsWith(\"Backward\") ? \"backward\" : \"forward\";\n            var [start, end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n            var [leaf, path] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.leaf(editor, start.path);\n            var diff = {\n                text: \"\",\n                start: start.offset,\n                end: end.offset\n            };\n            var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n            var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((change)=>slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n            var diffs = relevantPendingDiffs ? [\n                relevantPendingDiffs.diff,\n                diff\n            ] : [\n                diff\n            ];\n            var text = applyStringDiff(leaf.text, ...diffs);\n            if (text.length === 0) {\n                // Text leaf will be removed, so we need to schedule an\n                // action to remove it so that Slate can normalize instead\n                // of storing as a diff\n                canStoreDiff = false;\n            }\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n                if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n                    var point = {\n                        path: targetRange.anchor.path,\n                        offset: start.offset\n                    };\n                    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, point, point);\n                    handleUserSelect(range);\n                    return storeDiff(targetRange.anchor.path, {\n                        text: \"\",\n                        end: end.offset,\n                        start: start.offset\n                    });\n                }\n                return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                        direction\n                    }), {\n                    at: targetRange\n                });\n            }\n        }\n        switch(type){\n            case \"deleteByComposition\":\n            case \"deleteByCut\":\n            case \"deleteByDrag\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteContent\":\n            case \"deleteContentForward\":\n                {\n                    var { anchor } = targetRange;\n                    if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange)) {\n                        var targetNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n                        if (anchor.offset < targetNode.text.length) {\n                            return storeDiff(anchor.path, {\n                                text: \"\",\n                                start: anchor.offset,\n                                end: anchor.offset + 1\n                            });\n                        }\n                    }\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteContentBackward\":\n                {\n                    var _nativeTargetRange;\n                    var { anchor: _anchor } = targetRange; // If we have a mismatch between the native and slate selection being collapsed\n                    // we are most likely deleting a zero-width placeholder and thus should perform it\n                    // as an action to ensure correct behavior (mostly happens with mark placeholders)\n                    var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n                    if (canStoreDiff && nativeCollapsed && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n                        return storeDiff(_anchor.path, {\n                            text: \"\",\n                            start: _anchor.offset - 1,\n                            end: _anchor.offset\n                        });\n                    }\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteEntireSoftLine\":\n                {\n                    return scheduleAction(()=>{\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        });\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        });\n                    }, {\n                        at: targetRange\n                    });\n                }\n            case \"deleteHardLineBackward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"block\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteSoftLineBackward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteHardLineForward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"block\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteSoftLineForward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteWordBackward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"word\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteWordForward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"word\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"insertLineBreak\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"insertParagraph\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"insertCompositionText\":\n            case \"deleteCompositionText\":\n            case \"insertFromComposition\":\n            case \"insertFromDrop\":\n            case \"insertFromPaste\":\n            case \"insertFromYank\":\n            case \"insertReplacementText\":\n            case \"insertText\":\n                {\n                    if (isDataTransfer(data)) {\n                        return scheduleAction(()=>ReactEditor.insertData(editor, data), {\n                            at: targetRange\n                        });\n                    }\n                    var _text = data !== null && data !== void 0 ? data : \"\"; // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n                    // the placeholder itself and thus includes the zero-width space inside edit events.\n                    if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n                        _text = _text.replace(\"\\uFEFF\", \"\");\n                    } // Pastes from the Android clipboard will generate `insertText` events.\n                    // If the copied text contains any newlines, Android will append an\n                    // extra newline to the end of the copied text.\n                    if (type === \"insertText\" && /.*\\n.*\\n$/.test(_text)) {\n                        _text = _text.slice(0, -1);\n                    } // If the text includes a newline, split it at newlines and paste each component\n                    // string, with soft breaks in between each.\n                    if (_text.includes(\"\\n\")) {\n                        return scheduleAction(()=>{\n                            var parts = _text.split(\"\\n\");\n                            parts.forEach((line, i)=>{\n                                if (line) {\n                                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, line);\n                                }\n                                if (i !== parts.length - 1) {\n                                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                                }\n                            });\n                        }, {\n                            at: targetRange\n                        });\n                    }\n                    if (slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n                        var [_start2, _end2] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n                        var _diff = {\n                            start: _start2.offset,\n                            end: _end2.offset,\n                            text: _text\n                        }; // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n                        // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n                        // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n                        // text events are fired with the correct target ranges, only the final 'insertComposition'\n                        // isn't, so we can adjust the target range start offset if we are confident this is the\n                        // swiftkey insert causing the issue.\n                        if (_text && insertPositionHint && type === \"insertCompositionText\") {\n                            var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n                            var diffPosition = _diff.start + _diff.text.search(/\\S|$/);\n                            if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                                _diff.start -= 1;\n                                insertPositionHint = null;\n                                scheduleFlush();\n                            } else {\n                                insertPositionHint = false;\n                            }\n                        } else if (type === \"insertText\") {\n                            if (insertPositionHint === null) {\n                                insertPositionHint = _diff;\n                            } else if (insertPositionHint && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {\n                                insertPositionHint = _objectSpread$3(_objectSpread$3({}, insertPositionHint), {}, {\n                                    text: insertPositionHint.text + _text\n                                });\n                            } else {\n                                insertPositionHint = false;\n                            }\n                        } else {\n                            insertPositionHint = false;\n                        }\n                        if (canStoreDiff) {\n                            storeDiff(_start2.path, _diff);\n                            return;\n                        }\n                    }\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text), {\n                        at: targetRange\n                    });\n                }\n        }\n    };\n    var hasPendingAction = ()=>{\n        return !!EDITOR_TO_PENDING_ACTION.get(editor);\n    };\n    var hasPendingDiffs = ()=>{\n        var _EDITOR_TO_PENDING_DI4;\n        return !!((_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);\n    };\n    var hasPendingChanges = ()=>{\n        return hasPendingAction() || hasPendingDiffs();\n    };\n    var isFlushing = ()=>{\n        return flushing;\n    };\n    var handleUserSelect = (range)=>{\n        EDITOR_TO_PENDING_SELECTION.set(editor, range);\n        if (flushTimeoutId) {\n            clearTimeout(flushTimeoutId);\n            flushTimeoutId = null;\n        }\n        var { selection } = editor;\n        if (!range) {\n            return;\n        }\n        var pathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path, range.anchor.path);\n        var parentPathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n        if (pathChanged && insertPositionHint || parentPathChanged) {\n            insertPositionHint = false;\n        }\n        if (pathChanged || hasPendingDiffs()) {\n            flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n        }\n    };\n    var handleInput = ()=>{\n        if (hasPendingAction() || !hasPendingDiffs()) {\n            flush();\n        }\n    };\n    var handleKeyDown = (_)=>{\n        // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n        // directly next to a non-contenteditable element (= the placeholder).\n        // The only event fired soon enough for us to allow hiding the placeholder\n        // without swiftkey picking it up is the keydown event, so we have to hide it\n        // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n        if (!hasPendingDiffs()) {\n            updatePlaceholderVisibility(true);\n            setTimeout(updatePlaceholderVisibility);\n        }\n    };\n    var scheduleFlush = ()=>{\n        if (!hasPendingAction()) {\n            actionTimeoutId = setTimeout(flush);\n        }\n    };\n    var handleDomMutations = (mutations)=>{\n        if (hasPendingDiffs() || hasPendingAction()) {\n            return;\n        }\n        if (mutations.some((mutation)=>isTrackedMutation(editor, mutation, mutations))) {\n            var _EDITOR_TO_FORCE_REND;\n            // Cause a re-render to restore the dom state if we encounter tracked mutations without\n            // a corresponding pending action.\n            (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();\n        }\n    };\n    return {\n        flush,\n        scheduleFlush,\n        hasPendingDiffs,\n        hasPendingAction,\n        hasPendingChanges,\n        isFlushing,\n        handleUserSelect,\n        handleCompositionEnd,\n        handleCompositionStart,\n        handleDOMBeforeInput,\n        handleKeyDown,\n        handleDomMutations,\n        handleInput\n    };\n}\nfunction useIsMounted() {\n    var isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        isMountedRef.current = true;\n        return ()=>{\n            isMountedRef.current = false;\n        };\n    }, []);\n    return isMountedRef.current;\n}\nfunction useMutationObserver(node, callback, options) {\n    var [mutationObserver] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(()=>new MutationObserver(callback));\n    useIsomorphicLayoutEffect(()=>{\n        // Discard mutations caused during render phase. This works due to react calling\n        // useLayoutEffect synchronously after the render phase before the next tick.\n        mutationObserver.takeRecords();\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (!node.current) {\n            throw new Error(\"Failed to attach MutationObserver, `node` is undefined\");\n        }\n        mutationObserver.observe(node.current, options);\n        return ()=>mutationObserver.disconnect();\n    }, []);\n}\nvar _excluded$2 = [\n    \"node\"\n];\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar MUTATION_OBSERVER_CONFIG = {\n    subtree: true,\n    childList: true,\n    characterData: true\n};\nfunction useAndroidInputManager(_ref) {\n    var { node } = _ref, options = _objectWithoutProperties(_ref, _excluded$2);\n    if (!IS_ANDROID) {\n        return null;\n    }\n    var editor = useSlateStatic();\n    var isMounted = useIsMounted();\n    var [inputManager] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(()=>createAndroidInputManager(_objectSpread$2({\n            editor\n        }, options)));\n    useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG);\n    EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n    if (isMounted) {\n        inputManager.flush();\n    }\n    return inputManager;\n}\nfunction useTrackUserInput() {\n    var editor = useSlateStatic();\n    var receivedUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    var animationFrameIdRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);\n    var onUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(()=>{\n        if (receivedUserInput.current) {\n            return;\n        }\n        receivedUserInput.current = true;\n        var window1 = ReactEditor.getWindow(editor);\n        window1.cancelAnimationFrame(animationFrameIdRef.current);\n        animationFrameIdRef.current = window1.requestAnimationFrame(()=>{\n            receivedUserInput.current = false;\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>()=>cancelAnimationFrame(animationFrameIdRef.current), []);\n    return {\n        receivedUserInput,\n        onUserInput\n    };\n}\nvar _excluded$1 = [\n    \"autoFocus\",\n    \"decorate\",\n    \"onDOMBeforeInput\",\n    \"placeholder\",\n    \"readOnly\",\n    \"renderElement\",\n    \"renderLeaf\",\n    \"renderPlaceholder\",\n    \"scrollSelectionIntoView\",\n    \"style\",\n    \"as\",\n    \"disableDefaultStyles\"\n], _excluded2 = [\n    \"text\"\n];\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Children = (props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, useChildren(props));\n/**\r\n * Editable.\r\n */ var Editable = (props)=>{\n    var _EDITOR_TO_PLACEHOLDE, _EDITOR_TO_PLACEHOLDE2;\n    var defaultRenderPlaceholder = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultPlaceholder, Object.assign({}, props)), []);\n    var { autoFocus, decorate = defaultDecorate, onDOMBeforeInput: propsOnDOMBeforeInput, placeholder, readOnly = false, renderElement, renderLeaf, renderPlaceholder = defaultRenderPlaceholder, scrollSelectionIntoView = defaultScrollSelectionIntoView, style: userStyle = {}, as: Component = \"div\", disableDefaultStyles = false } = props, attributes = _objectWithoutProperties(props, _excluded$1);\n    var editor = useSlate(); // Rerender editor when composition status changed\n    var [isComposing, setIsComposing] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var deferredOperations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n    var { onUserInput, receivedUserInput } = useTrackUserInput();\n    var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)((s)=>s + 1, 0);\n    EDITOR_TO_FORCE_RENDER.set(editor, forceRender); // Update internal state on each render.\n    IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.\n    var state = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>({\n            isDraggingInternally: false,\n            isUpdatingSelection: false,\n            latestElement: null,\n            hasMarkPlaceholder: false\n        }), []); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n    // needs to be manually focused.\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (ref.current && autoFocus) {\n            ref.current.focus();\n        }\n    }, [\n        autoFocus\n    ]); // Listen on the native `selectionchange` event to be able to update any time\n    // the selection changes. This is required because React's `onSelect` is leaky\n    // and non-standard so it doesn't fire until after a selection has been\n    // released. This causes issues in situations where another change happens\n    // while a selection is being dragged.\n    var onDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default()(()=>{\n        if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n            var root = ReactEditor.findDocumentOrShadowRoot(editor);\n            var { activeElement } = root;\n            var el = ReactEditor.toDOMNode(editor, editor);\n            var domSelection = root.getSelection();\n            if (activeElement === el) {\n                state.latestElement = activeElement;\n                IS_FOCUSED.set(editor, true);\n            } else {\n                IS_FOCUSED.delete(editor);\n            }\n            if (!domSelection) {\n                return slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n            }\n            var { anchorNode, focusNode } = domSelection;\n            var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n            var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);\n            if (anchorNodeSelectable && focusNodeSelectable) {\n                var range = ReactEditor.toSlateRange(editor, domSelection, {\n                    exactMatch: false,\n                    suppressThrow: true\n                });\n                if (range) {\n                    if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                    } else {\n                        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);\n                    }\n                }\n            } // Deselect the editor if the dom selection is not selectable in readonly mode\n            if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n            }\n        }\n    }, 100), [\n        readOnly\n    ]);\n    var scheduleOnDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(onDOMSelectionChange, 0), [\n        onDOMSelectionChange\n    ]);\n    var androidInputManager = useAndroidInputManager({\n        node: ref,\n        onDOMSelectionChange,\n        scheduleOnDOMSelectionChange\n    });\n    useIsomorphicLayoutEffect(()=>{\n        // Update element-related weak maps with the DOM element ref.\n        var window1;\n        if (ref.current && (window1 = getDefaultView(ref.current))) {\n            EDITOR_TO_WINDOW.set(editor, window1);\n            EDITOR_TO_ELEMENT.set(editor, ref.current);\n            NODE_TO_ELEMENT.set(editor, ref.current);\n            ELEMENT_TO_NODE.set(ref.current, editor);\n        } else {\n            NODE_TO_ELEMENT.delete(editor);\n        } // Make sure the DOM selection state is in sync.\n        var { selection } = editor;\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        var domSelection = root.getSelection();\n        if (!domSelection || !ReactEditor.isFocused(editor) || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingAction()) {\n            return;\n        }\n        var setDomSelection = (forceChange)=>{\n            var hasDomSelection = domSelection.type !== \"None\"; // If the DOM selection is properly unset, we're done.\n            if (!selection && !hasDomSelection) {\n                return;\n            } // verify that the dom selection is in the editor\n            var editorElement = EDITOR_TO_ELEMENT.get(editor);\n            var hasDomSelectionInEditor = false;\n            if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {\n                hasDomSelectionInEditor = true;\n            } // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n            if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n                var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n                    exactMatch: true,\n                    // domSelection is not necessarily a valid Slate range\n                    // (e.g. when clicking on contentEditable:false element)\n                    suppressThrow: true\n                });\n                if (slateRange && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(slateRange, selection)) {\n                    var _anchorNode$parentEle;\n                    if (!state.hasMarkPlaceholder) {\n                        return;\n                    } // Ensure selection is inside the mark placeholder\n                    var { anchorNode } = domSelection;\n                    if (anchorNode !== null && anchorNode !== void 0 && (_anchorNode$parentEle = anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute(\"data-slate-mark-placeholder\")) {\n                        return;\n                    }\n                }\n            } // when <Editable/> is being controlled through external value\n            // then its children might just change - DOM responds to it on its own\n            // but Slate's value is not being updated through any operation\n            // and thus it doesn't transform selection on its own\n            if (selection && !ReactEditor.hasRange(editor, selection)) {\n                editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n                    exactMatch: false,\n                    suppressThrow: true\n                });\n                return;\n            } // Otherwise the DOM selection is out of sync, so update it.\n            state.isUpdatingSelection = true;\n            var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n            if (newDomRange) {\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isBackward(selection)) {\n                    domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n                } else {\n                    domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n                }\n                scrollSelectionIntoView(editor, newDomRange);\n            } else {\n                domSelection.removeAllRanges();\n            }\n            return newDomRange;\n        };\n        var newDomRange = setDomSelection();\n        var ensureSelection = (androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.isFlushing()) === \"action\";\n        if (!IS_ANDROID || !ensureSelection) {\n            setTimeout(()=>{\n                // COMPAT: In Firefox, it's not enough to create a range, you also need\n                // to focus the contenteditable element too. (2016/11/16)\n                if (newDomRange && IS_FIREFOX) {\n                    var el = ReactEditor.toDOMNode(editor, editor);\n                    el.focus();\n                }\n                state.isUpdatingSelection = false;\n            });\n            return;\n        }\n        var timeoutId = null;\n        var animationFrameId = requestAnimationFrame(()=>{\n            if (ensureSelection) {\n                var ensureDomSelection = (forceChange)=>{\n                    try {\n                        var el = ReactEditor.toDOMNode(editor, editor);\n                        el.focus();\n                        setDomSelection(forceChange);\n                    } catch (e) {}\n                }; // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n                // This essentially would make setting the slate selection during an update meaningless, so we force it\n                // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n                // visible flicker.\n                ensureDomSelection();\n                timeoutId = setTimeout(()=>{\n                    // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n                    // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n                    // the animation frame to ensure it displays the correct state.\n                    ensureDomSelection(true);\n                    state.isUpdatingSelection = false;\n                });\n            }\n        });\n        return ()=>{\n            cancelAnimationFrame(animationFrameId);\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n            }\n        };\n    }); // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n    // is required because React's `beforeinput` is fake and never really attaches\n    // to the real event sadly. (2019/11/01)\n    // https://github.com/facebook/react/issues/11211\n    var onDOMBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n        onUserInput();\n        if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n            var _EDITOR_TO_USER_SELEC;\n            // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n            if (androidInputManager) {\n                return androidInputManager.handleDOMBeforeInput(event);\n            } // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n            // triggering a `beforeinput` expecting the change to be applied to the immediately before\n            // set selection.\n            scheduleOnDOMSelectionChange.flush();\n            onDOMSelectionChange.flush();\n            var { selection } = editor;\n            var { inputType: type } = event;\n            var data = event.dataTransfer || event.data || undefined;\n            var isCompositionChange = type === \"insertCompositionText\" || type === \"deleteCompositionText\"; // COMPAT: use composition change events as a hint to where we should insert\n            // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n            if (isCompositionChange && ReactEditor.isComposing(editor)) {\n                return;\n            }\n            var native = false;\n            if (type === \"insertText\" && selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.\n            // Long-press events (hold a + press 4 = ) to choose a special character otherwise\n            // causes duplicate inserts.\n            event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n            // When there is an inline element, e.g. a link, and you select\n            // right after it (the start of the next node).\n            selection.anchor.offset !== 0) {\n                var _node$parentElement, _window$getComputedSt;\n                native = true; // Skip native if there are marks, as\n                // `insertText` will insert a node, not just text.\n                if (editor.marks) {\n                    native = false;\n                } // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n                // Therefore we don't allow native events to insert text at the end of anchor nodes.\n                var { anchor } = selection;\n                var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);\n                var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest(\"a\");\n                var window1 = ReactEditor.getWindow(editor);\n                if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n                    var _lastText$textContent;\n                    // Find the last text node inside the anchor.\n                    var lastText = window1 === null || window1 === void 0 ? void 0 : window1.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n                    if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n                        native = false;\n                    }\n                } // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n                // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n                if (native && node.parentElement && (window1 === null || window1 === void 0 ? void 0 : (_window$getComputedSt = window1.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === \"pre\") {\n                    var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                        at: anchor.path,\n                        match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n)\n                    });\n                    if (block && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(block[0]).includes(\"\t\")) {\n                        native = false;\n                    }\n                }\n            } // COMPAT: For the deleting forward/backward input types we don't want\n            // to change the selection because it is the range that will be deleted,\n            // and those commands determine that for themselves.\n            if (!type.startsWith(\"delete\") || type.startsWith(\"deleteBy\")) {\n                var [targetRange] = event.getTargetRanges();\n                if (targetRange) {\n                    var range = ReactEditor.toSlateRange(editor, targetRange, {\n                        exactMatch: false,\n                        suppressThrow: false\n                    });\n                    if (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, range)) {\n                        native = false;\n                        var selectionRef = !isCompositionChange && editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection);\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                        if (selectionRef) {\n                            EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n                        }\n                    }\n                }\n            } // Composition change types occur while a user is composing text and can't be\n            // cancelled. Let them through and wait for the composition to end.\n            if (isCompositionChange) {\n                return;\n            }\n            if (!native) {\n                event.preventDefault();\n            } // COMPAT: If the selection is expanded, even if the command seems like\n            // a delete forward/backward command it should delete the selection.\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection) && type.startsWith(\"delete\")) {\n                var direction = type.endsWith(\"Backward\") ? \"backward\" : \"forward\";\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                    direction\n                });\n                return;\n            }\n            switch(type){\n                case \"deleteByComposition\":\n                case \"deleteByCut\":\n                case \"deleteByDrag\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n                        break;\n                    }\n                case \"deleteContent\":\n                case \"deleteContentForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n                        break;\n                    }\n                case \"deleteContentBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n                        break;\n                    }\n                case \"deleteEntireSoftLine\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        });\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        });\n                        break;\n                    }\n                case \"deleteHardLineBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"block\"\n                        });\n                        break;\n                    }\n                case \"deleteSoftLineBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        });\n                        break;\n                    }\n                case \"deleteHardLineForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"block\"\n                        });\n                        break;\n                    }\n                case \"deleteSoftLineForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        });\n                        break;\n                    }\n                case \"deleteWordBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"word\"\n                        });\n                        break;\n                    }\n                case \"deleteWordForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"word\"\n                        });\n                        break;\n                    }\n                case \"insertLineBreak\":\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                    break;\n                case \"insertParagraph\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n                        break;\n                    }\n                case \"insertFromComposition\":\n                case \"insertFromDrop\":\n                case \"insertFromPaste\":\n                case \"insertFromYank\":\n                case \"insertReplacementText\":\n                case \"insertText\":\n                    {\n                        if (type === \"insertFromComposition\") {\n                            // COMPAT: in Safari, `compositionend` is dispatched after the\n                            // `beforeinput` for \"insertFromComposition\". But if we wait for it\n                            // then we will abort because we're still composing and the selection\n                            // won't be updated properly.\n                            // https://www.w3.org/TR/input-events-2/\n                            if (ReactEditor.isComposing(editor)) {\n                                setIsComposing(false);\n                                IS_COMPOSING.set(editor, false);\n                            }\n                        } // use a weak comparison instead of 'instanceof' to allow\n                        // programmatic access of paste events coming from external windows\n                        // like cypress where cy.window does not work realibly\n                        if ((data === null || data === void 0 ? void 0 : data.constructor.name) === \"DataTransfer\") {\n                            ReactEditor.insertData(editor, data);\n                        } else if (typeof data === \"string\") {\n                            // Only insertText operations use the native functionality, for now.\n                            // Potentially expand to single character deletes, as well.\n                            if (native) {\n                                deferredOperations.current.push(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data));\n                            } else {\n                                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data);\n                            }\n                        }\n                        break;\n                    }\n            } // Restore the actual user section if nothing manually set it.\n            var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n            EDITOR_TO_USER_SELECTION.delete(editor);\n            if (toRestore && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, toRestore))) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, toRestore);\n            }\n        }\n    }, [\n        readOnly,\n        propsOnDOMBeforeInput\n    ]);\n    var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((node)=>{\n        if (node == null) {\n            onDOMSelectionChange.cancel();\n            scheduleOnDOMSelectionChange.cancel();\n            EDITOR_TO_ELEMENT.delete(editor);\n            NODE_TO_ELEMENT.delete(editor);\n            if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n                // @ts-ignore The `beforeinput` event isn't recognized.\n                ref.current.removeEventListener(\"beforeinput\", onDOMBeforeInput);\n            }\n        } else {\n            // Attach a native DOM event handler for `beforeinput` events, because React's\n            // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n            // real `beforeinput` events sadly... (2019/11/04)\n            // https://github.com/facebook/react/issues/11211\n            if (HAS_BEFORE_INPUT_SUPPORT) {\n                // @ts-ignore The `beforeinput` event isn't recognized.\n                node.addEventListener(\"beforeinput\", onDOMBeforeInput);\n            }\n        }\n        ref.current = node;\n    }, [\n        ref,\n        onDOMBeforeInput,\n        onDOMSelectionChange,\n        scheduleOnDOMSelectionChange\n    ]); // Attach a native DOM event handler for `selectionchange`, because React's\n    // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n    // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n    // fire for any change to the selection inside the editor. (2019/11/04)\n    // https://github.com/facebook/react/issues/5785\n    useIsomorphicLayoutEffect(()=>{\n        var window1 = ReactEditor.getWindow(editor);\n        window1.document.addEventListener(\"selectionchange\", scheduleOnDOMSelectionChange);\n        return ()=>{\n            window1.document.removeEventListener(\"selectionchange\", scheduleOnDOMSelectionChange);\n        };\n    }, [\n        scheduleOnDOMSelectionChange\n    ]);\n    var decorations = decorate([\n        editor,\n        []\n    ]);\n    if (placeholder && editor.children.length === 1 && Array.from(slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(editor)).length === 1 && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(editor) === \"\" && !isComposing) {\n        var start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, []);\n        decorations.push({\n            [PLACEHOLDER_SYMBOL]: true,\n            placeholder,\n            anchor: start,\n            focus: start\n        });\n    }\n    var { marks } = editor;\n    state.hasMarkPlaceholder = false;\n    if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && marks) {\n        var { anchor } = editor.selection;\n        var leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n        var rest = _objectWithoutProperties(leaf, _excluded2); // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(leaf, marks, {\n            loose: true\n        })) {\n            state.hasMarkPlaceholder = true;\n            var unset = Object.fromEntries(Object.keys(rest).map((mark)=>[\n                    mark,\n                    null\n                ]));\n            decorations.push(_objectSpread$1(_objectSpread$1(_objectSpread$1({\n                [MARK_PLACEHOLDER_SYMBOL]: true\n            }, unset), marks), {}, {\n                anchor,\n                focus: anchor\n            }));\n        }\n    } // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n    // before we receive the composition end event.\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        setTimeout(()=>{\n            var { selection } = editor;\n            if (selection) {\n                var { anchor: _anchor } = selection;\n                var _text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _anchor.path); // While marks isn't a 'complete' text, we can still use loose Text.equals\n                // here which only compares marks anyway.\n                if (marks && !slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(_text, marks, {\n                    loose: true\n                })) {\n                    EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n                    return;\n                }\n            }\n            EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        });\n    });\n    var placeholderHeight = (_EDITOR_TO_PLACEHOLDE = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor)) === null || _EDITOR_TO_PLACEHOLDE === void 0 ? void 0 : (_EDITOR_TO_PLACEHOLDE2 = _EDITOR_TO_PLACEHOLDE.getBoundingClientRect()) === null || _EDITOR_TO_PLACEHOLDE2 === void 0 ? void 0 : _EDITOR_TO_PLACEHOLDE2.height;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ReadOnlyContext.Provider, {\n        value: readOnly\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DecorateContext.Provider, {\n        value: decorate\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(RestoreDOM, {\n        node: ref,\n        receivedUserInput: receivedUserInput\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Component, Object.assign({\n        role: readOnly ? undefined : \"textbox\",\n        \"aria-multiline\": readOnly ? undefined : true\n    }, attributes, {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n        // have to use hacks to make these replacement-based features work.\n        // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n        // mismatch warning app moves to browser. Pass-through consumer props when\n        // not CAN_USE_DOM (SSR) and default to falsy value\n        spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,\n        autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : \"false\",\n        autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : \"false\",\n        \"data-slate-editor\": true,\n        \"data-slate-node\": \"value\",\n        // explicitly set this\n        contentEditable: !readOnly,\n        // in some cases, a decoration needs access to the range / selection to decorate a text node,\n        // then you will select the whole text node when you select part the of text\n        // this magic zIndex=\"-1\" will fix it\n        zindex: -1,\n        suppressContentEditableWarning: true,\n        ref: callbackRef,\n        style: _objectSpread$1(_objectSpread$1({}, disableDefaultStyles ? {} : _objectSpread$1({\n            // Allow positioning relative to the editable element.\n            position: \"relative\",\n            // Prevent the default outline styles.\n            outline: \"none\",\n            // Preserve adjacent whitespace and new lines.\n            whiteSpace: \"pre-wrap\",\n            // Allow words to break if they are too long.\n            wordWrap: \"break-word\"\n        }, placeholderHeight ? {\n            minHeight: placeholderHeight\n        } : {})), userStyle),\n        onBeforeInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n            // fall back to React's leaky polyfill instead just for it. It\n            // only works for the `insertText` input type.\n            if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n                event.preventDefault();\n                if (!ReactEditor.isComposing(editor)) {\n                    var _text2 = event.data;\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text2);\n                }\n            }\n        }, [\n            readOnly\n        ]),\n        onInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (isEventHandled(event, attributes.onInput)) {\n                return;\n            }\n            if (androidInputManager) {\n                androidInputManager.handleInput();\n                return;\n            } // Flush native operations, as native events will have propogated\n            // and we can correctly compare DOM text values in components\n            // to stop rendering, so that browser functions like autocorrect\n            // and spellcheck work as expected.\n            for (var op of deferredOperations.current){\n                op();\n            }\n            deferredOperations.current = [];\n        }, []),\n        onBlur: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n                return;\n            } // COMPAT: If the current `activeElement` is still the previous\n            // one, this is due to the window being blurred when the tab\n            // itself becomes unfocused, so we want to abort early to allow to\n            // editor to stay focused when the tab becomes focused again.\n            var root = ReactEditor.findDocumentOrShadowRoot(editor);\n            if (state.latestElement === root.activeElement) {\n                return;\n            }\n            var { relatedTarget } = event;\n            var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning\n            // to the editor from an embedded editable element (eg. an <input>\n            // element inside a void node).\n            if (relatedTarget === el) {\n                return;\n            } // COMPAT: The event should be ignored if the focus is moving from\n            // the editor to inside a void node's spacer element.\n            if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute(\"data-slate-spacer\")) {\n                return;\n            } // COMPAT: The event should be ignored if the focus is moving to a\n            // non- editable section of an element that isn't a void node (eg.\n            // a list item of the check list example).\n            if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n                var node = ReactEditor.toSlateNode(editor, relatedTarget);\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isVoid(node)) {\n                    return;\n                }\n            } // COMPAT: Safari doesn't always remove the selection even if the content-\n            // editable element no longer has focus. Refer to:\n            // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n            if (IS_SAFARI) {\n                var domSelection = root.getSelection();\n                domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();\n            }\n            IS_FOCUSED.delete(editor);\n        }, [\n            readOnly,\n            attributes.onBlur\n        ]),\n        onClick: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n                var node = ReactEditor.toSlateNode(editor, event.target);\n                var path = ReactEditor.findPath(editor, node); // At this time, the Slate document may be arbitrarily different,\n                // because onClick handlers can change the document before we get here.\n                // Therefore we must check that this path actually exists,\n                // and that it still refers to the same node.\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path) || slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path) !== node) {\n                    return;\n                }\n                if (event.detail === TRIPLE_CLICK && path.length >= 1) {\n                    var blockPath = path;\n                    if (!(slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, node))) {\n                        var _block$;\n                        var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                            match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n),\n                            at: path\n                        });\n                        blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n                    }\n                    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, blockPath);\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                    return;\n                }\n                if (readOnly) {\n                    return;\n                }\n                var _start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, path);\n                var end = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.end(editor, path);\n                var startVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                    at: _start\n                });\n                var endVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                    at: end\n                });\n                if (startVoid && endVoid && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(startVoid[1], endVoid[1])) {\n                    var _range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, _start);\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, _range);\n                }\n            }\n        }, [\n            readOnly,\n            attributes.onClick\n        ]),\n        onCompositionEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n                if (ReactEditor.isComposing(editor)) {\n                    setIsComposing(false);\n                    IS_COMPOSING.set(editor, false);\n                }\n                androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionEnd(event);\n                if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {\n                    return;\n                } // COMPAT: In Chrome, `beforeinput` events for compositions\n                // aren't correct and never fire the \"insertFromComposition\"\n                // type that we need. So instead, insert whenever a composition\n                // ends since it will already have been committed to the DOM.\n                if (!IS_SAFARI && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {\n                    var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n                    EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor); // Ensure we insert text with the marks the user was actually seeing\n                    if (placeholderMarks !== undefined) {\n                        EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n                        editor.marks = placeholderMarks;\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, event.data);\n                    var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n                    EDITOR_TO_USER_MARKS.delete(editor);\n                    if (userMarks !== undefined) {\n                        editor.marks = userMarks;\n                    }\n                }\n            }\n        }, [\n            attributes.onCompositionEnd\n        ]),\n        onCompositionUpdate: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n                if (!ReactEditor.isComposing(editor)) {\n                    setIsComposing(true);\n                    IS_COMPOSING.set(editor, true);\n                }\n            }\n        }, [\n            attributes.onCompositionUpdate\n        ]),\n        onCompositionStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n                androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionStart(event);\n                if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {\n                    return;\n                }\n                setIsComposing(true);\n                var { selection } = editor;\n                if (selection) {\n                    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n                        return;\n                    }\n                    var inline = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                        match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isInline(editor, n),\n                        mode: \"highest\"\n                    });\n                    if (inline) {\n                        var [, inlinePath] = inline;\n                        if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEnd(editor, selection.anchor, inlinePath)) {\n                            var point = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.after(editor, inlinePath);\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.setSelection(editor, {\n                                anchor: point,\n                                focus: point\n                            });\n                        }\n                    }\n                }\n            }\n        }, [\n            attributes.onCompositionStart\n        ]),\n        onCopy: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {\n                event.preventDefault();\n                ReactEditor.setFragmentData(editor, event.clipboardData, \"copy\");\n            }\n        }, [\n            attributes.onCopy\n        ]),\n        onCut: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {\n                event.preventDefault();\n                ReactEditor.setFragmentData(editor, event.clipboardData, \"cut\");\n                var { selection } = editor;\n                if (selection) {\n                    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n                    } else {\n                        var node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n                        if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor);\n                        }\n                    }\n                }\n            }\n        }, [\n            readOnly,\n            attributes.onCut\n        ]),\n        onDragOver: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n                // Only when the target is void, call `preventDefault` to signal\n                // that drops are allowed. Editable content is droppable by\n                // default, and calling `preventDefault` hides the cursor.\n                var node = ReactEditor.toSlateNode(editor, event.target);\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n                    event.preventDefault();\n                }\n            }\n        }, [\n            attributes.onDragOver\n        ]),\n        onDragStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n                var node = ReactEditor.toSlateNode(editor, event.target);\n                var path = ReactEditor.findPath(editor, node);\n                var voidMatch = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                    at: path,\n                    voids: true\n                }); // If starting a drag on a void node, make sure it is selected\n                // so that it shows up in the selection's fragment.\n                if (voidMatch) {\n                    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, path);\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                }\n                state.isDraggingInternally = true;\n                ReactEditor.setFragmentData(editor, event.dataTransfer, \"drag\");\n            }\n        }, [\n            readOnly,\n            attributes.onDragStart\n        ]),\n        onDrop: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n                event.preventDefault(); // Keep a reference to the dragged range before updating selection\n                var draggedRange = editor.selection; // Find the range where the drop happened\n                var range = ReactEditor.findEventRange(editor, event);\n                var data = event.dataTransfer;\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                if (state.isDraggingInternally) {\n                    if (draggedRange && !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(draggedRange, range) && !slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                        at: range,\n                        voids: true\n                    })) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor, {\n                            at: draggedRange\n                        });\n                    }\n                }\n                ReactEditor.insertData(editor, data); // When dragging from another source into the editor, it's possible\n                // that the current editor does not have focus.\n                if (!ReactEditor.isFocused(editor)) {\n                    ReactEditor.focus(editor);\n                }\n            }\n            state.isDraggingInternally = false;\n        }, [\n            readOnly,\n            attributes.onDrop\n        ]),\n        onDragEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n                attributes.onDragEnd(event);\n            } // When dropping on a different droppable element than the current editor,\n            // `onDrop` is not called. So we need to clean up in `onDragEnd` instead.\n            // Note: `onDragEnd` is only called when `onDrop` is not called\n            state.isDraggingInternally = false;\n        }, [\n            readOnly,\n            attributes.onDragEnd\n        ]),\n        onFocus: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n                var el = ReactEditor.toDOMNode(editor, editor);\n                var root = ReactEditor.findDocumentOrShadowRoot(editor);\n                state.latestElement = root.activeElement; // COMPAT: If the editor has nested editable elements, the focus\n                // can go to them. In Firefox, this must be prevented because it\n                // results in issues with keyboard navigation. (2017/03/30)\n                if (IS_FIREFOX && event.target !== el) {\n                    el.focus();\n                    return;\n                }\n                IS_FOCUSED.set(editor, true);\n            }\n        }, [\n            readOnly,\n            attributes.onFocus\n        ]),\n        onKeyDown: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n                androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleKeyDown(event);\n                var { nativeEvent } = event; // COMPAT: The composition end event isn't fired reliably in all browsers,\n                // so we sometimes might end up stuck in a composition state even though we\n                // aren't composing any more.\n                if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n                    IS_COMPOSING.set(editor, false);\n                    setIsComposing(false);\n                }\n                if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n                    return;\n                }\n                var { selection } = editor;\n                var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n                var isRTL = direction__WEBPACK_IMPORTED_MODULE_0___default()(slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element)) === \"rtl\"; // COMPAT: Since we prevent the default behavior on\n                // `beforeinput` events, the browser doesn't think there's ever\n                // any history stack to undo or redo, so we have to manage these\n                // hotkeys ourselves. (2019/11/06)\n                if (Hotkeys.isRedo(nativeEvent)) {\n                    event.preventDefault();\n                    var maybeHistoryEditor = editor;\n                    if (typeof maybeHistoryEditor.redo === \"function\") {\n                        maybeHistoryEditor.redo();\n                    }\n                    return;\n                }\n                if (Hotkeys.isUndo(nativeEvent)) {\n                    event.preventDefault();\n                    var _maybeHistoryEditor = editor;\n                    if (typeof _maybeHistoryEditor.undo === \"function\") {\n                        _maybeHistoryEditor.undo();\n                    }\n                    return;\n                } // COMPAT: Certain browsers don't handle the selection updates\n                // properly. In Chrome, the selection isn't properly extended.\n                // And in Firefox, the selection isn't properly collapsed.\n                // (2017/10/17)\n                if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\",\n                        reverse: true\n                    });\n                    return;\n                }\n                if (Hotkeys.isMoveLineForward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\"\n                    });\n                    return;\n                }\n                if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\",\n                        edge: \"focus\",\n                        reverse: true\n                    });\n                    return;\n                }\n                if (Hotkeys.isExtendLineForward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\",\n                        edge: \"focus\"\n                    });\n                    return;\n                } // COMPAT: If a void node is selected, or a zero-width text node\n                // adjacent to an inline is selected, we need to handle these\n                // hotkeys manually because browsers won't be able to skip over\n                // the void node with the zero-width space not being an empty\n                // string.\n                if (Hotkeys.isMoveBackward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                            reverse: !isRTL\n                        });\n                    } else {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"start\"\n                        });\n                    }\n                    return;\n                }\n                if (Hotkeys.isMoveForward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                            reverse: isRTL\n                        });\n                    } else {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"end\"\n                        });\n                    }\n                    return;\n                }\n                if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"focus\"\n                        });\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"word\",\n                        reverse: !isRTL\n                    });\n                    return;\n                }\n                if (Hotkeys.isMoveWordForward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"focus\"\n                        });\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"word\",\n                        reverse: isRTL\n                    });\n                    return;\n                } // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                // fall back to guessing at the input intention for hotkeys.\n                // COMPAT: In iOS, some of these hotkeys are handled in the\n                if (!HAS_BEFORE_INPUT_SUPPORT) {\n                    // We don't have a core behavior for these, but they change the\n                    // DOM if we don't prevent them, so we have to.\n                    if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n                        event.preventDefault();\n                        return;\n                    }\n                    if (Hotkeys.isSoftBreak(nativeEvent)) {\n                        event.preventDefault();\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                        return;\n                    }\n                    if (Hotkeys.isSplitBlock(nativeEvent)) {\n                        event.preventDefault();\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n                        return;\n                    }\n                    if (Hotkeys.isDeleteBackward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"backward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteForward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"forward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"backward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                                unit: \"line\"\n                            });\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"forward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                                unit: \"line\"\n                            });\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"backward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                                unit: \"word\"\n                            });\n                        }\n                        return;\n                    }\n                    if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"forward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                                unit: \"word\"\n                            });\n                        }\n                        return;\n                    }\n                } else {\n                    if (IS_CHROME || IS_SAFARI) {\n                        // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n                        // an event when deleting backwards in a selected void inline node\n                        if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n                            var currentNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n                            if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(currentNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, currentNode) && (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isInline(editor, currentNode) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, currentNode))) {\n                                event.preventDefault();\n                                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                                    unit: \"block\"\n                                });\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        }, [\n            readOnly,\n            attributes.onKeyDown\n        ]),\n        onPaste: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n                // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                // fall back to React's `onPaste` here instead.\n                // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n                // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n                // COMPAT: Safari InputEvents generated by pasting won't include\n                // application/x-slate-fragment items, so use the\n                // ClipboardEvent here. (2023/03/15)\n                if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent) || IS_SAFARI) {\n                    event.preventDefault();\n                    ReactEditor.insertData(editor, event.clipboardData);\n                }\n            }\n        }, [\n            readOnly,\n            attributes.onPaste\n        ])\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Children, {\n        decorations: decorations,\n        node: editor,\n        renderElement: renderElement,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        selection: editor.selection\n    })))));\n};\n/**\r\n * The default placeholder element\r\n */ var DefaultPlaceholder = (_ref)=>{\n    var { attributes, children } = _ref;\n    return(/*#__PURE__*/ // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", Object.assign({}, attributes), children, IS_ANDROID && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null)));\n};\n/**\r\n * A default memoized decorate function.\r\n */ var defaultDecorate = ()=>[];\n/**\r\n * A default implement to scroll dom range into view.\r\n */ var defaultScrollSelectionIntoView = (editor, domRange)=>{\n    // This was affecting the selection of multiple blocks and dragging behavior,\n    // so enabled only if the selection has been collapsed.\n    if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection))) {\n        var leafEl = domRange.startContainer.parentElement;\n        leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n        (0,scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(leafEl, {\n            scrollMode: \"if-needed\"\n        }); // @ts-expect-error an unorthodox delete D:\n        delete leafEl.getBoundingClientRect;\n    }\n};\n/**\r\n * Check if an event is overrided by a handler.\r\n */ var isEventHandled = (event, handler)=>{\n    if (!handler) {\n        return false;\n    } // The custom event handler may return a boolean to specify whether the event\n    // shall be treated as being handled or not.\n    var shouldTreatEventAsHandled = handler(event);\n    if (shouldTreatEventAsHandled != null) {\n        return shouldTreatEventAsHandled;\n    }\n    return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\r\n * Check if a DOM event is overrided by a handler.\r\n */ var isDOMEventHandled = (event, handler)=>{\n    if (!handler) {\n        return false;\n    } // The custom event handler may return a boolean to specify whether the event\n    // shall be treated as being handled or not.\n    var shouldTreatEventAsHandled = handler(event);\n    if (shouldTreatEventAsHandled != null) {\n        return shouldTreatEventAsHandled;\n    }\n    return event.defaultPrevented;\n};\n/**\r\n * A React context for sharing the `focused` state of the editor.\r\n */ var FocusedContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\r\n * Get the current `focused` state of the editor.\r\n */ var useFocused = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(FocusedContext);\n};\nfunction isError(error) {\n    return error instanceof Error;\n}\n/**\r\n * A React context for sharing the editor selector context in a way to control rerenders\r\n */ var SlateSelectorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\nvar refEquality = (a, b)=>a === b;\n/**\r\n * use redux style selectors to prevent rerendering on every keystroke.\r\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\r\n *\r\n * Example:\r\n * ```\r\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\r\n * ```\r\n */ function useSlateSelector(selector) {\n    var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n    var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)((s)=>s + 1, 0);\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateSelectorContext);\n    if (!context) {\n        throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n    }\n    var { getSlate, addEventListener } = context;\n    var latestSubscriptionCallbackError = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    var latestSelector = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(()=>null);\n    var latestSelectedState = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var selectedState;\n    try {\n        if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n            selectedState = selector(getSlate());\n        } else {\n            selectedState = latestSelectedState.current;\n        }\n    } catch (err) {\n        if (latestSubscriptionCallbackError.current && isError(err)) {\n            err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n        }\n        throw err;\n    }\n    useIsomorphicLayoutEffect(()=>{\n        latestSelector.current = selector;\n        latestSelectedState.current = selectedState;\n        latestSubscriptionCallbackError.current = undefined;\n    });\n    useIsomorphicLayoutEffect(()=>{\n        function checkForUpdates() {\n            try {\n                var newSelectedState = latestSelector.current(getSlate());\n                if (equalityFn(newSelectedState, latestSelectedState.current)) {\n                    return;\n                }\n                latestSelectedState.current = newSelectedState;\n            } catch (err) {\n                // we ignore all errors here, since when the component\n                // is re-rendered, the selectors are called again, and\n                // will throw again, if neither props nor store state\n                // changed\n                latestSubscriptionCallbackError.current = err;\n            }\n            forceRender();\n        }\n        var unsubscribe = addEventListener(checkForUpdates);\n        checkForUpdates();\n        return ()=>unsubscribe();\n    }, [\n        addEventListener,\n        getSlate\n    ]);\n    return selectedState;\n}\n/**\r\n * Create selector context with editor updating on every editor change\r\n */ function getSelectorContext(editor) {\n    var eventListeners = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]).current;\n    var slateRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)({\n        editor\n    }).current;\n    var onChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((editor)=>{\n        slateRef.editor = editor;\n        eventListeners.forEach((listener)=>listener(editor));\n    }, []);\n    var selectorContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>{\n        return {\n            getSlate: ()=>slateRef.editor,\n            addEventListener: (callback)=>{\n                eventListeners.push(callback);\n                return ()=>{\n                    eventListeners.splice(eventListeners.indexOf(callback), 1);\n                };\n            }\n        };\n    }, [\n        eventListeners,\n        slateRef\n    ]);\n    return {\n        selectorContext,\n        onChange\n    };\n}\nvar _excluded = [\n    \"editor\",\n    \"children\",\n    \"onChange\",\n    \"value\"\n];\n/**\r\n * A wrapper around the provider to handle `onChange` events, because the editor\r\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\r\n */ var Slate = (props)=>{\n    var { editor, children, onChange, value } = props, rest = _objectWithoutProperties(props, _excluded);\n    var unmountRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    var [context, setContext] = react__WEBPACK_IMPORTED_MODULE_3___default().useState(()=>{\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Node.isNodeList(value)) {\n            throw new Error(\"[Slate] value is invalid! Expected a list of elements but got: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(value)));\n        }\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(editor)) {\n            throw new Error(\"[Slate] editor is invalid! You passed: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(editor)));\n        }\n        editor.children = value;\n        Object.assign(editor, rest);\n        return {\n            v: 0,\n            editor\n        };\n    });\n    var { selectorContext, onChange: handleSelectorChange } = getSelectorContext(editor);\n    var onContextChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(()=>{\n        if (onChange) {\n            onChange(editor.children);\n        }\n        setContext((prevContext)=>({\n                v: prevContext.v + 1,\n                editor\n            }));\n        handleSelectorChange(editor);\n    }, [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n        return ()=>{\n            EDITOR_TO_ON_CHANGE.set(editor, ()=>{});\n            unmountRef.current = true;\n        };\n    }, [\n        onContextChange\n    ]);\n    var [isFocused, setIsFocused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(ReactEditor.isFocused(editor));\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        setIsFocused(ReactEditor.isFocused(editor));\n    });\n    useIsomorphicLayoutEffect(()=>{\n        var fn = ()=>setIsFocused(ReactEditor.isFocused(editor));\n        if (IS_REACT_VERSION_17_OR_ABOVE) {\n            // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n            // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n            // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n            document.addEventListener(\"focusin\", fn);\n            document.addEventListener(\"focusout\", fn);\n            return ()=>{\n                document.removeEventListener(\"focusin\", fn);\n                document.removeEventListener(\"focusout\", fn);\n            };\n        } else {\n            document.addEventListener(\"focus\", fn, true);\n            document.addEventListener(\"blur\", fn, true);\n            return ()=>{\n                document.removeEventListener(\"focus\", fn, true);\n                document.removeEventListener(\"blur\", fn, true);\n            };\n        }\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateSelectorContext.Provider, {\n        value: selectorContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateContext.Provider, {\n        value: context\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(EditorContext.Provider, {\n        value: context.editor\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(FocusedContext.Provider, {\n        value: isFocused\n    }, children))));\n};\n/**\r\n * Get the current editor object from the React context.\r\n * @deprecated Use useSlateStatic instead.\r\n */ var useEditor = ()=>{\n    var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n    if (!editor) {\n        throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n    }\n    return editor;\n};\n/**\r\n * Get the current slate selection.\r\n * Only triggers a rerender when the selection actually changes\r\n */ var useSlateSelection = ()=>{\n    return useSlateSelector((editor)=>editor.selection, isSelectionEqual);\n};\nvar isSelectionEqual = (a, b)=>{\n    if (!a && !b) return true;\n    if (!a || !b) return false;\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(a, b);\n};\n/**\r\n * Utilities for single-line deletion\r\n */ var doRectsIntersect = (rect, compareRect)=>{\n    var middle = (compareRect.top + compareRect.bottom) / 2;\n    return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = (editor, range1, range2)=>{\n    var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();\n    var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();\n    return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\r\n * A helper utility that returns the end portion of a `Range`\r\n * which is located on a single line.\r\n *\r\n * @param {Editor} editor The editor object to compare against\r\n * @param {Range} parentRange The parent range to compare against\r\n * @returns {Range} A valid portion of the parentRange which is one a single line\r\n */ var findCurrentLineRange = (editor, parentRange)=>{\n    var parentRangeBoundary = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Range.end(parentRange));\n    var positions = Array.from(slate__WEBPACK_IMPORTED_MODULE_7__.Editor.positions(editor, {\n        at: parentRange\n    }));\n    var left = 0;\n    var right = positions.length;\n    var middle = Math.floor(right / 2);\n    if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[left]), parentRangeBoundary)) {\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[left], parentRangeBoundary);\n    }\n    if (positions.length < 2) {\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n    }\n    while(middle !== positions.length && middle !== left){\n        if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n            right = middle;\n        } else {\n            left = middle;\n        }\n        middle = Math.floor((left + right) / 2);\n    }\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[right], parentRangeBoundary);\n};\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * `withReact` adds React and DOM specific behaviors to the editor.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */ var withReact = function withReact(editor) {\n    var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"x-slate-fragment\";\n    var e = editor;\n    var { apply, onChange, deleteBackward, addMark, removeMark } = e; // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n    // avoid collisions between editors in the DOM that share the same value.\n    EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n    e.addMark = (key, value)=>{\n        var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n        (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n        if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n            // Ensure the current pending diffs originating from changes before the addMark\n            // are applied with the current formatting\n            EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n        }\n        EDITOR_TO_USER_MARKS.delete(e);\n        addMark(key, value);\n    };\n    e.removeMark = (key)=>{\n        var _EDITOR_TO_PENDING_DI2;\n        if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n            // Ensure the current pending diffs originating from changes before the addMark\n            // are applied with the current formatting\n            EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n        }\n        EDITOR_TO_USER_MARKS.delete(e);\n        removeMark(key);\n    };\n    e.deleteBackward = (unit)=>{\n        if (unit !== \"line\") {\n            return deleteBackward(unit);\n        }\n        if (e.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(e.selection)) {\n            var parentBlockEntry = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(e, {\n                match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(e, n),\n                at: e.selection\n            });\n            if (parentBlockEntry) {\n                var [, parentBlockPath] = parentBlockEntry;\n                var parentElementRange = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(e, parentBlockPath, e.selection.anchor);\n                var currentLineRange = findCurrentLineRange(e, parentElementRange);\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(currentLineRange)) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(e, {\n                        at: currentLineRange\n                    });\n                }\n            }\n        }\n    }; // This attempts to reset the NODE_TO_KEY entry to the correct value\n    // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n    e.apply = (op)=>{\n        var matches = [];\n        var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n        if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n            var transformed = pendingDiffs.map((textDiff)=>transformTextDiff(textDiff, op)).filter(Boolean);\n            EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n        }\n        var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n        if (pendingSelection) {\n            EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n        }\n        var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n        if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n            var at = slate__WEBPACK_IMPORTED_MODULE_7__.Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n            EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n                at\n            }) : null);\n        }\n        switch(op.type){\n            case \"insert_text\":\n            case \"remove_text\":\n            case \"set_node\":\n            case \"split_node\":\n                {\n                    matches.push(...getMatches(e, op.path));\n                    break;\n                }\n            case \"set_selection\":\n                {\n                    var _EDITOR_TO_USER_SELEC;\n                    // Selection was manually set, don't restore the user selection after the change.\n                    (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n                    EDITOR_TO_USER_SELECTION.delete(e);\n                    break;\n                }\n            case \"insert_node\":\n            case \"remove_node\":\n                {\n                    matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.path)));\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    var prevPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.previous(op.path);\n                    matches.push(...getMatches(e, prevPath));\n                    break;\n                }\n            case \"move_node\":\n                {\n                    var commonPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.common(slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.path), slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.newPath));\n                    matches.push(...getMatches(e, commonPath));\n                    break;\n                }\n        }\n        apply(op);\n        for (var [path, key] of matches){\n            var [node] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.node(e, path);\n            NODE_TO_KEY.set(node, key);\n        }\n    };\n    e.setFragmentData = (data)=>{\n        var { selection } = e;\n        if (!selection) {\n            return;\n        }\n        var [start, end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(selection);\n        var startVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(e, {\n            at: start.path\n        });\n        var endVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(e, {\n            at: end.path\n        });\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection) && !startVoid) {\n            return;\n        } // Create a fake selection so that we can add a Base64-encoded copy of the\n        // fragment to the HTML, to decode on future pastes.\n        var domRange = ReactEditor.toDOMRange(e, selection);\n        var contents = domRange.cloneContents();\n        var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.\n        contents.childNodes.forEach((node)=>{\n            if (node.textContent && node.textContent.trim() !== \"\") {\n                attach = node;\n            }\n        }); // COMPAT: If the end node is a void node, we need to move the end of the\n        // range from the void node's spacer span, to the end of the void node's\n        // content, since the spacer is before void's content in the DOM.\n        if (endVoid) {\n            var [voidNode] = endVoid;\n            var r = domRange.cloneRange();\n            var domNode = ReactEditor.toDOMNode(e, voidNode);\n            r.setEndAfter(domNode);\n            contents = r.cloneContents();\n        } // COMPAT: If the start node is a void node, we need to attach the encoded\n        // fragment to the void node's content node instead of the spacer, because\n        // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n        // most browsers. (2018/04/27)\n        if (startVoid) {\n            attach = contents.querySelector(\"[data-slate-spacer]\");\n        } // Remove any zero-width space spans from the cloned DOM so that they don't\n        // show up elsewhere when pasted.\n        Array.from(contents.querySelectorAll(\"[data-slate-zero-width]\")).forEach((zw)=>{\n            var isNewline = zw.getAttribute(\"data-slate-zero-width\") === \"n\";\n            zw.textContent = isNewline ? \"\\n\" : \"\";\n        }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n        // in the HTML, and can be used for intra-Slate pasting. If it's a text\n        // node, wrap it in a `<span>` so we have something to set an attribute on.\n        if (isDOMText(attach)) {\n            var span = attach.ownerDocument.createElement(\"span\"); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n            // then leading and trailing spaces will be ignored. (2017/09/21)\n            span.style.whiteSpace = \"pre\";\n            span.appendChild(attach);\n            contents.appendChild(span);\n            attach = span;\n        }\n        var fragment = e.getFragment();\n        var string = JSON.stringify(fragment);\n        var encoded = window.btoa(encodeURIComponent(string));\n        attach.setAttribute(\"data-slate-fragment\", encoded);\n        data.setData(\"application/\".concat(clipboardFormatKey), encoded); // Add the content to a <div> so that we can get its inner HTML.\n        var div = contents.ownerDocument.createElement(\"div\");\n        div.appendChild(contents);\n        div.setAttribute(\"hidden\", \"true\");\n        contents.ownerDocument.body.appendChild(div);\n        data.setData(\"text/html\", div.innerHTML);\n        data.setData(\"text/plain\", getPlainText(div));\n        contents.ownerDocument.body.removeChild(div);\n        return data;\n    };\n    e.insertData = (data)=>{\n        if (!e.insertFragmentData(data)) {\n            e.insertTextData(data);\n        }\n    };\n    e.insertFragmentData = (data)=>{\n        /**\r\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\r\n     */ var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n        if (fragment) {\n            var decoded = decodeURIComponent(window.atob(fragment));\n            var parsed = JSON.parse(decoded);\n            e.insertFragment(parsed);\n            return true;\n        }\n        return false;\n    };\n    e.insertTextData = (data)=>{\n        var text = data.getData(\"text/plain\");\n        if (text) {\n            var lines = text.split(/\\r\\n|\\r|\\n/);\n            var split = false;\n            for (var line of lines){\n                if (split) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.splitNodes(e, {\n                        always: true\n                    });\n                }\n                e.insertText(line);\n                split = true;\n            }\n            return true;\n        }\n        return false;\n    };\n    e.onChange = (options)=>{\n        // COMPAT: React doesn't batch `setState` hook calls, which means that the\n        // children and selection can get out of sync for one render pass. So we\n        // have to use this unstable API to ensure it batches them. (2019/12/03)\n        // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n        react_dom__WEBPACK_IMPORTED_MODULE_6___default().unstable_batchedUpdates(()=>{\n            var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n            if (onContextChange) {\n                onContextChange();\n            }\n            onChange(options);\n        });\n    };\n    return e;\n};\nvar getMatches = (e, path)=>{\n    var matches = [];\n    for (var [n, p] of slate__WEBPACK_IMPORTED_MODULE_7__.Editor.levels(e, {\n        at: path\n    })){\n        var key = ReactEditor.findKey(e, n);\n        matches.push([\n            p,\n            key\n        ]);\n    }\n    return matches;\n};\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3QvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDRTtBQUNBO0FBQytIO0FBQzlHO0FBQzZEO0FBQzVEO0FBQ2pCO0FBQ1A7QUFFakMsU0FBUytCLGdCQUFnQkMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEtBQUs7SUFDdEMsSUFBSUQsT0FBT0QsS0FBSztRQUNkRyxPQUFPQyxjQUFjLENBQUNKLEtBQUtDLEtBQUs7WUFDOUJDLE9BQU9BO1lBQ1BHLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1FBQ1o7SUFDRixPQUFPO1FBQ0xQLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztJQUNiO0lBRUEsT0FBT0Y7QUFDVDtBQUVBLFNBQVNRLDhCQUE4QkMsTUFBTSxFQUFFQyxRQUFRO0lBQ3JELElBQUlELFVBQVUsTUFBTSxPQUFPLENBQUM7SUFDNUIsSUFBSUUsU0FBUyxDQUFDO0lBQ2QsSUFBSUMsYUFBYVQsT0FBT1UsSUFBSSxDQUFDSjtJQUM3QixJQUFJUixLQUFLYTtJQUVULElBQUtBLElBQUksR0FBR0EsSUFBSUYsV0FBV0csTUFBTSxFQUFFRCxJQUFLO1FBQ3RDYixNQUFNVyxVQUFVLENBQUNFLEVBQUU7UUFDbkIsSUFBSUosU0FBU00sT0FBTyxDQUFDZixRQUFRLEdBQUc7UUFDaENVLE1BQU0sQ0FBQ1YsSUFBSSxHQUFHUSxNQUFNLENBQUNSLElBQUk7SUFDM0I7SUFFQSxPQUFPVTtBQUNUO0FBRUEsU0FBU00seUJBQXlCUixNQUFNLEVBQUVDLFFBQVE7SUFDaEQsSUFBSUQsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUM1QixJQUFJRSxTQUFTSCw4QkFBOEJDLFFBQVFDO0lBQ25ELElBQUlULEtBQUthO0lBRVQsSUFBSVgsT0FBT2UscUJBQXFCLEVBQUU7UUFDaEMsSUFBSUMsbUJBQW1CaEIsT0FBT2UscUJBQXFCLENBQUNUO1FBRXBELElBQUtLLElBQUksR0FBR0EsSUFBSUssaUJBQWlCSixNQUFNLEVBQUVELElBQUs7WUFDNUNiLE1BQU1rQixnQkFBZ0IsQ0FBQ0wsRUFBRTtZQUN6QixJQUFJSixTQUFTTSxPQUFPLENBQUNmLFFBQVEsR0FBRztZQUNoQyxJQUFJLENBQUNFLE9BQU9pQixTQUFTLENBQUNDLG9CQUFvQixDQUFDQyxJQUFJLENBQUNiLFFBQVFSLE1BQU07WUFDOURVLE1BQU0sQ0FBQ1YsSUFBSSxHQUFHUSxNQUFNLENBQUNSLElBQUk7UUFDM0I7SUFDRjtJQUVBLE9BQU9VO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNELElBQUlZLElBQUk7QUFDUjs7O0NBR0MsR0FFRCxNQUFNQztJQUNKQyxhQUFjO1FBQ1osSUFBSSxDQUFDQyxFQUFFLEdBQUcsR0FBR0MsTUFBTSxDQUFDSjtJQUN0QjtBQUVGO0FBRUE7OztDQUdDLEdBQ0QsSUFBSUssZ0JBQWdCLElBQUlDO0FBQ3hCLElBQUlDLGlCQUFpQixJQUFJRDtBQUN6Qjs7O0NBR0MsR0FFRCxJQUFJRSxtQkFBbUIsSUFBSUY7QUFDM0IsSUFBSUcsb0JBQW9CLElBQUlIO0FBQzVCLElBQUlJLGdDQUFnQyxJQUFJSjtBQUN4QyxJQUFJSyxrQkFBa0IsSUFBSUw7QUFDMUIsSUFBSU0sa0JBQWtCLElBQUlOO0FBQzFCLElBQUlPLGNBQWMsSUFBSVA7QUFDdEIsSUFBSVEsMkJBQTJCLElBQUlSO0FBQ25DOztDQUVDLEdBRUQsSUFBSVMsZUFBZSxJQUFJVDtBQUN2QixJQUFJVSxhQUFhLElBQUlWO0FBQ3JCLElBQUlXLGVBQWUsSUFBSVg7QUFDdkIsSUFBSVksMkJBQTJCLElBQUlaO0FBQ25DOztDQUVDLEdBRUQsSUFBSWEsc0JBQXNCLElBQUliO0FBQzlCOztDQUVDLEdBRUQsSUFBSWMsMkJBQTJCLElBQUlkO0FBQ25DLElBQUllLG9DQUFvQyxJQUFJZjtBQUM1QyxJQUFJZ0IsdUJBQXVCLElBQUloQjtBQUMvQjs7Q0FFQyxHQUVELElBQUlpQiwwQkFBMEIsSUFBSWpCO0FBQ2xDLElBQUlrQiwyQkFBMkIsSUFBSWxCO0FBQ25DLElBQUltQiw4QkFBOEIsSUFBSW5CO0FBQ3RDLElBQUlvQix5QkFBeUIsSUFBSXBCO0FBQ2pDOztDQUVDLEdBRUQsSUFBSXFCLHFCQUFxQkMsT0FBTztBQUNoQyxJQUFJQywwQkFBMEJELE9BQU87QUFFckM7O0NBRUMsR0FDRCxJQUFJRSxVQUFVQyxXQUFXN0QsSUFBSTtBQUM3Qjs7Q0FFQyxHQUVELElBQUk4RCxpQkFBaUJyRCxDQUFBQTtJQUNuQixPQUFPQSxTQUFTQSxNQUFNc0QsYUFBYSxJQUFJdEQsTUFBTXNELGFBQWEsQ0FBQ0MsV0FBVyxJQUFJO0FBQzVFO0FBQ0E7O0NBRUMsR0FFRCxJQUFJQyxlQUFleEQsQ0FBQUE7SUFDakIsT0FBT3lELFVBQVV6RCxVQUFVQSxNQUFNMEQsUUFBUSxLQUFLO0FBQ2hEO0FBQ0E7O0NBRUMsR0FFRCxJQUFJQyxlQUFlM0QsQ0FBQUE7SUFDakIsT0FBT3lELFVBQVV6RCxVQUFVQSxNQUFNMEQsUUFBUSxLQUFLO0FBQ2hEO0FBQ0E7O0NBRUMsR0FFRCxJQUFJRCxZQUFZekQsQ0FBQUE7SUFDZCxJQUFJNEQsVUFBU1AsZUFBZXJEO0lBQzVCLE9BQU8sQ0FBQyxDQUFDNEQsV0FBVTVELGlCQUFpQjRELFFBQU90RSxJQUFJO0FBQ2pEO0FBQ0E7O0NBRUMsR0FFRCxJQUFJdUUsaUJBQWlCN0QsQ0FBQUE7SUFDbkIsSUFBSTRELFVBQVM1RCxTQUFTQSxNQUFNOEQsVUFBVSxJQUFJVCxlQUFlckQsTUFBTThELFVBQVU7SUFDekUsT0FBTyxDQUFDLENBQUNGLFdBQVU1RCxpQkFBaUI0RCxRQUFPRyxTQUFTO0FBQ3REO0FBQ0E7O0NBRUMsR0FFRCxJQUFJQyxZQUFZaEUsQ0FBQUE7SUFDZCxPQUFPeUQsVUFBVXpELFVBQVVBLE1BQU0wRCxRQUFRLEtBQUs7QUFDaEQ7QUFDQTs7Q0FFQyxHQUVELElBQUlPLHVCQUF1QkMsQ0FBQUE7SUFDekIsT0FBT0EsTUFBTUMsYUFBYSxJQUFJRCxNQUFNQyxhQUFhLENBQUNDLE9BQU8sQ0FBQyxrQkFBa0IsTUFBTUYsTUFBTUMsYUFBYSxDQUFDRSxLQUFLLENBQUN4RCxNQUFNLEtBQUs7QUFDekg7QUFDQTs7Q0FFQyxHQUVELElBQUl5RCxvQkFBb0JDLENBQUFBO0lBQ3RCLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxHQUFHRixVQUFVLDBFQUEwRTtJQUN6RyxxRUFBcUU7SUFFckUsSUFBSVosYUFBYWEsU0FBU0EsS0FBS0UsVUFBVSxDQUFDN0QsTUFBTSxFQUFFO1FBQ2hELElBQUk4RCxTQUFTRixXQUFXRCxLQUFLRSxVQUFVLENBQUM3RCxNQUFNO1FBQzlDLElBQUkrRCxRQUFRRCxTQUFTRixTQUFTLElBQUlBO1FBQ2xDLENBQUNELE1BQU1JLE1BQU0sR0FBR0MseUJBQXlCTCxNQUFNSSxPQUFPRCxTQUFTLGFBQWEsWUFBWSxzRkFBc0Y7UUFFOUtBLFNBQVNDLFFBQVFILFFBQVEsMkVBQTJFO1FBQ3BHLHFEQUFxRDtRQUVyRCxNQUFPZCxhQUFhYSxTQUFTQSxLQUFLRSxVQUFVLENBQUM3RCxNQUFNLENBQUU7WUFDbkQsSUFBSUQsSUFBSStELFNBQVNILEtBQUtFLFVBQVUsQ0FBQzdELE1BQU0sR0FBRyxJQUFJO1lBQzlDMkQsT0FBT00saUJBQWlCTixNQUFNNUQsR0FBRytELFNBQVMsYUFBYTtRQUN6RCxFQUFFLGlEQUFpRDtRQUduREYsU0FBU0UsVUFBVUgsS0FBS08sV0FBVyxJQUFJLE9BQU9QLEtBQUtPLFdBQVcsQ0FBQ2xFLE1BQU0sR0FBRztJQUMxRSxFQUFFLDhCQUE4QjtJQUdoQyxPQUFPO1FBQUMyRDtRQUFNQztLQUFPO0FBQ3ZCO0FBQ0E7O0NBRUMsR0FFRCxJQUFJTyxnQkFBZ0JSLENBQUFBO0lBQ2xCLElBQUlTLFNBQVNULFFBQVFBLEtBQUtVLFVBQVU7SUFFcEMsTUFBT0QsT0FBUTtRQUNiLElBQUlBLE9BQU9FLFFBQVEsT0FBTyx1QkFBdUI7WUFDL0MsT0FBTztRQUNUO1FBRUFGLFNBQVNBLE9BQU9DLFVBQVU7SUFDNUI7SUFFQSxPQUFPO0FBQ1Q7QUFDQTs7O0NBR0MsR0FFRCxJQUFJTCwyQkFBMkIsQ0FBQ0ksUUFBUUwsT0FBT1E7SUFDN0MsSUFBSSxFQUNGVixVQUFVLEVBQ1gsR0FBR087SUFDSixJQUFJSSxRQUFRWCxVQUFVLENBQUNFLE1BQU07SUFDN0IsSUFBSWhFLElBQUlnRTtJQUNSLElBQUlVLGVBQWU7SUFDbkIsSUFBSUMsZ0JBQWdCLE9BQU8sMEVBQTBFO0lBQ3JHLCtEQUErRDtJQUUvRCxNQUFPL0IsYUFBYTZCLFVBQVUxQixhQUFhMEIsVUFBVUEsTUFBTVgsVUFBVSxDQUFDN0QsTUFBTSxLQUFLLEtBQUs4QyxhQUFhMEIsVUFBVUEsTUFBTUcsWUFBWSxDQUFDLHVCQUF1QixRQUFTO1FBQzlKLElBQUlGLGdCQUFnQkMsZUFBZTtZQUNqQztRQUNGO1FBRUEsSUFBSTNFLEtBQUs4RCxXQUFXN0QsTUFBTSxFQUFFO1lBQzFCeUUsZUFBZTtZQUNmMUUsSUFBSWdFLFFBQVE7WUFDWlEsWUFBWTtZQUNaO1FBQ0Y7UUFFQSxJQUFJeEUsSUFBSSxHQUFHO1lBQ1QyRSxnQkFBZ0I7WUFDaEIzRSxJQUFJZ0UsUUFBUTtZQUNaUSxZQUFZO1lBQ1o7UUFDRjtRQUVBQyxRQUFRWCxVQUFVLENBQUM5RCxFQUFFO1FBQ3JCZ0UsUUFBUWhFO1FBQ1JBLEtBQUt3RSxjQUFjLFlBQVksSUFBSSxDQUFDO0lBQ3RDO0lBRUEsT0FBTztRQUFDQztRQUFPVDtLQUFNO0FBQ3ZCO0FBQ0E7OztDQUdDLEdBRUQsSUFBSUUsbUJBQW1CLENBQUNHLFFBQVFMLE9BQU9RO0lBQ3JDLElBQUksQ0FBQ0MsTUFBTSxHQUFHUix5QkFBeUJJLFFBQVFMLE9BQU9RO0lBQ3RELE9BQU9DO0FBQ1Q7QUFDQTs7Ozs7Q0FLQyxHQUVELElBQUlJLGVBQWVDLENBQUFBO0lBQ2pCLElBQUlDLE9BQU87SUFFWCxJQUFJM0IsVUFBVTBCLFlBQVlBLFFBQVFFLFNBQVMsRUFBRTtRQUMzQyxPQUFPRixRQUFRRSxTQUFTO0lBQzFCO0lBRUEsSUFBSWpDLGFBQWErQixVQUFVO1FBQ3pCLEtBQUssSUFBSUcsYUFBYUMsTUFBTUMsSUFBSSxDQUFDTCxRQUFRaEIsVUFBVSxFQUFHO1lBQ3BEaUIsUUFBUUYsYUFBYUk7UUFDdkI7UUFFQSxJQUFJRyxVQUFVQyxpQkFBaUJQLFNBQVNRLGdCQUFnQixDQUFDO1FBRXpELElBQUlGLFlBQVksV0FBV0EsWUFBWSxVQUFVTixRQUFRUyxPQUFPLEtBQUssTUFBTTtZQUN6RVIsUUFBUTtRQUNWO0lBQ0Y7SUFFQSxPQUFPQTtBQUNUO0FBQ0E7O0NBRUMsR0FFRCxJQUFJUyxxQkFBcUI7QUFDekIsSUFBSUMsNEJBQTRCQyxDQUFBQTtJQUM5QixJQUFJQyxXQUFXRCxhQUFhbEMsT0FBTyxDQUFDO0lBQ3BDLElBQUksR0FBR29DLFNBQVMsR0FBR0QsU0FBU0UsS0FBSyxDQUFDTCx1QkFBdUIsRUFBRTtJQUMzRCxPQUFPSTtBQUNUO0FBQ0E7O0NBRUMsR0FFRCxJQUFJRSxvQkFBb0IsQ0FBQ0MsUUFBUUMsVUFBVUM7SUFDekMsSUFBSSxFQUNGcEcsTUFBTSxFQUNQLEdBQUdtRztJQUVKLElBQUlqRCxhQUFhbEQsV0FBV0EsT0FBT3FHLE9BQU8sQ0FBQyw4QkFBOEI7UUFDdkUsT0FBTztJQUNUO0lBRUEsSUFBSSxFQUNGQyxVQUFBQSxTQUFRLEVBQ1QsR0FBR0MsWUFBWUMsU0FBUyxDQUFDTjtJQUUxQixJQUFJSSxVQUFTRyxRQUFRLENBQUN6RyxTQUFTO1FBQzdCLE9BQU91RyxZQUFZRyxVQUFVLENBQUNSLFFBQVFsRyxRQUFRO1lBQzVDMkcsVUFBVTtRQUNaO0lBQ0Y7SUFFQSxJQUFJQyxpQkFBaUJSLE1BQU1TLElBQUksQ0FBQ0MsQ0FBQUE7UUFDOUIsSUFBSSxFQUNGQyxVQUFVLEVBQ1ZDLFlBQVksRUFDYixHQUFHRjtRQUVKLEtBQUssSUFBSS9DLFFBQVFnRCxXQUFZO1lBQzNCLElBQUloRCxTQUFTL0QsVUFBVStELEtBQUswQyxRQUFRLENBQUN6RyxTQUFTO2dCQUM1QyxPQUFPO1lBQ1Q7UUFDRjtRQUVBLEtBQUssSUFBSWlILFNBQVNELGFBQWM7WUFDOUIsSUFBSUMsVUFBVWpILFVBQVVpSCxNQUFNUixRQUFRLENBQUN6RyxTQUFTO2dCQUM5QyxPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBRUEsSUFBSSxDQUFDNEcsa0JBQWtCQSxtQkFBbUJULFVBQVU7UUFDbEQsT0FBTztJQUNULEVBQUUsb0ZBQW9GO0lBR3RGLE9BQU9GLGtCQUFrQkMsUUFBUVUsZ0JBQWdCUjtBQUNuRDtBQUVBLElBQUljLCtCQUErQkMsU0FBUzNKLG9EQUFhLENBQUM2SixLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPO0FBQ2hGLElBQUlDLFNBQVMsT0FBT0MsY0FBYyxlQUFlLGdCQUFrQixlQUFlLENBQTRDLElBQUksQ0FBZ0I7QUFDbEosSUFBSUksV0FBVyxPQUFPSixjQUFjLGVBQWUsV0FBV0MsSUFBSSxDQUFDRCxVQUFVRSxTQUFTO0FBQ3RGLElBQUlHLGFBQWEsT0FBT0wsY0FBYyxlQUFlLFVBQVVDLElBQUksQ0FBQ0QsVUFBVUUsU0FBUztBQUN2RixJQUFJSSxhQUFhLE9BQU9OLGNBQWMsZUFBZSxtQ0FBbUNDLElBQUksQ0FBQ0QsVUFBVUUsU0FBUztBQUNoSCxJQUFJSyxZQUFZLE9BQU9QLGNBQWMsZUFBZSwyQkFBMkJDLElBQUksQ0FBQ0QsVUFBVUUsU0FBUyxHQUFHLHFDQUFxQztBQUUvSSxJQUFJTSxpQkFBaUIsT0FBT1IsY0FBYyxlQUFlLDBDQUEwQ0MsSUFBSSxDQUFDRCxVQUFVRSxTQUFTO0FBQzNILElBQUlPLFlBQVksT0FBT1QsY0FBYyxlQUFlLFVBQVVDLElBQUksQ0FBQ0QsVUFBVUUsU0FBUyxHQUFHLHNFQUFzRTtBQUMvSixzREFBc0Q7QUFFdEQsSUFBSVEsbUJBQW1CLE9BQU9WLGNBQWMsZUFBZSw0Q0FBNENDLElBQUksQ0FBQ0QsVUFBVUUsU0FBUztBQUMvSCxJQUFJUywyQkFBMkJOLGNBQWMsT0FBT0wsY0FBYyxlQUFlLCtCQUErQkMsSUFBSSxDQUFDRCxVQUFVRSxTQUFTLEdBQUcscURBQXFEO0FBRWhNLElBQUlVLG9CQUFvQixPQUFPWixjQUFjLGVBQWUsb0VBQW9FQyxJQUFJLENBQUNELFVBQVVFLFNBQVMsR0FBRyxvQkFBb0I7QUFFL0ssSUFBSVcsZUFBZSxPQUFPYixjQUFjLGVBQWUsY0FBY0MsSUFBSSxDQUFDRCxVQUFVRSxTQUFTLEdBQUcsaUJBQWlCO0FBRWpILElBQUlZLG1CQUFtQixPQUFPZCxjQUFjLGVBQWUsV0FBV0MsSUFBSSxDQUFDRCxVQUFVRSxTQUFTLEdBQUcsc0RBQXNEO0FBQ3ZKLHdGQUF3RjtBQUV4RixJQUFJYSxjQUFjLENBQUMsQ0FBRSxPQUE0RCxJQUFlLENBQW1ELEdBQUksb0VBQW9FO0FBQzNOLHdEQUF3RDtBQUV4RCxJQUFJRSwyQkFBMkIsQ0FBQyxDQUFDUCxvQkFBb0IsQ0FBQ0Msd0JBQXVCLEtBQU0sQ0FBQ0gsa0JBQWtCLDRDQUE0QztBQUNsSixPQUFPcEYsZUFBZSxlQUFlQSxXQUFXOEYsVUFBVSxJQUFJLDhEQUE4RDtBQUM1SCxPQUFPOUYsV0FBVzhGLFVBQVUsQ0FBQ2hJLFNBQVMsQ0FBQ2lJLGVBQWUsS0FBSztBQUUzRCxJQUFJbkMsY0FBYztJQUNoQjs7R0FFQyxHQUNEb0MsYUFBWXpDLE1BQU07UUFDaEIsT0FBTyxDQUFDLENBQUNyRSxhQUFhK0csR0FBRyxDQUFDMUM7SUFDNUI7SUFFQTs7R0FFQyxHQUNETSxXQUFVTixNQUFNO1FBQ2QsSUFBSS9DLFVBQVMvQixpQkFBaUJ3SCxHQUFHLENBQUMxQztRQUVsQyxJQUFJLENBQUMvQyxTQUFRO1lBQ1gsTUFBTSxJQUFJMEYsTUFBTTtRQUNsQjtRQUVBLE9BQU8xRjtJQUNUO0lBRUE7O0dBRUMsR0FDRDJGLFNBQVE1QyxNQUFNLEVBQUVuQyxJQUFJO1FBQ2xCLElBQUl6RSxNQUFNbUMsWUFBWW1ILEdBQUcsQ0FBQzdFO1FBRTFCLElBQUksQ0FBQ3pFLEtBQUs7WUFDUkEsTUFBTSxJQUFJdUI7WUFDVlksWUFBWXNILEdBQUcsQ0FBQ2hGLE1BQU16RTtRQUN4QjtRQUVBLE9BQU9BO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEMEosVUFBUzlDLE1BQU0sRUFBRW5DLElBQUk7UUFDbkIsSUFBSWtGLE9BQU8sRUFBRTtRQUNiLElBQUlyRSxRQUFRYjtRQUVaLE1BQU8sS0FBTTtZQUNYLElBQUlTLFNBQVNyRCxlQUFleUgsR0FBRyxDQUFDaEU7WUFFaEMsSUFBSUosVUFBVSxNQUFNO2dCQUNsQixJQUFJbEcseUNBQU1BLENBQUM0SyxRQUFRLENBQUN0RSxRQUFRO29CQUMxQixPQUFPcUU7Z0JBQ1QsT0FBTztvQkFDTDtnQkFDRjtZQUNGO1lBRUEsSUFBSTlJLElBQUljLGNBQWMySCxHQUFHLENBQUNoRTtZQUUxQixJQUFJekUsS0FBSyxNQUFNO2dCQUNiO1lBQ0Y7WUFFQThJLEtBQUtFLE9BQU8sQ0FBQ2hKO1lBQ2J5RSxRQUFRSjtRQUNWO1FBRUEsTUFBTSxJQUFJcUUsTUFBTSwyQ0FBMkM3SCxNQUFNLENBQUN6QywyQ0FBUUEsQ0FBQzZLLFNBQVMsQ0FBQ3JGO0lBQ3ZGO0lBRUE7O0dBRUMsR0FDRHNGLDBCQUF5Qm5ELE1BQU07UUFDN0IsSUFBSW9ELEtBQUsvQyxZQUFZZ0QsU0FBUyxDQUFDckQsUUFBUUE7UUFDdkMsSUFBSXNELE9BQU9GLEdBQUdHLFdBQVc7UUFFekIsSUFBSSxDQUFDRCxnQkFBZ0JFLFlBQVlGLGdCQUFnQkcsVUFBUyxLQUFNSCxLQUFLSSxZQUFZLElBQUksTUFBTTtZQUN6RixPQUFPSjtRQUNUO1FBRUEsT0FBT0YsR0FBR3pHLGFBQWE7SUFDekI7SUFFQTs7R0FFQyxHQUNEZ0gsV0FBVTNELE1BQU07UUFDZCxPQUFPLENBQUMsQ0FBQ3RFLFdBQVdnSCxHQUFHLENBQUMxQztJQUMxQjtJQUVBOztHQUVDLEdBQ0Q0RCxZQUFXNUQsTUFBTTtRQUNmLE9BQU8sQ0FBQyxDQUFDdkUsYUFBYWlILEdBQUcsQ0FBQzFDO0lBQzVCO0lBRUE7O0dBRUMsR0FDRDZELE1BQUs3RCxNQUFNO1FBQ1QsSUFBSW9ELEtBQUsvQyxZQUFZZ0QsU0FBUyxDQUFDckQsUUFBUUE7UUFDdkMsSUFBSXNELE9BQU9qRCxZQUFZOEMsd0JBQXdCLENBQUNuRDtRQUNoRHRFLFdBQVdtSCxHQUFHLENBQUM3QyxRQUFRO1FBRXZCLElBQUlzRCxLQUFLUSxhQUFhLEtBQUtWLElBQUk7WUFDN0JBLEdBQUdTLElBQUk7UUFDVDtJQUNGO0lBRUE7O0dBRUMsR0FDREUsT0FBTS9ELE1BQU07UUFDVixJQUFJb0QsS0FBSy9DLFlBQVlnRCxTQUFTLENBQUNyRCxRQUFRQTtRQUN2QyxJQUFJc0QsT0FBT2pELFlBQVk4Qyx3QkFBd0IsQ0FBQ25EO1FBQ2hEdEUsV0FBV21ILEdBQUcsQ0FBQzdDLFFBQVE7UUFFdkIsSUFBSXNELEtBQUtRLGFBQWEsS0FBS1YsSUFBSTtZQUM3QkEsR0FBR1csS0FBSyxDQUFDO2dCQUNQQyxlQUFlO1lBQ2pCO1FBQ0Y7SUFDRjtJQUVBOztHQUVDLEdBQ0RDLFVBQVNqRSxNQUFNO1FBQ2IsSUFBSSxFQUNGa0UsU0FBUyxFQUNWLEdBQUdsRTtRQUNKLElBQUlzRCxPQUFPakQsWUFBWThDLHdCQUF3QixDQUFDbkQ7UUFDaEQsSUFBSW1FLGVBQWViLEtBQUtJLFlBQVk7UUFFcEMsSUFBSVMsZ0JBQWdCQSxhQUFhQyxVQUFVLEdBQUcsR0FBRztZQUMvQ0QsYUFBYUUsZUFBZTtRQUM5QjtRQUVBLElBQUlILFdBQVc7WUFDYjVMLDZDQUFVQSxDQUFDMkwsUUFBUSxDQUFDakU7UUFDdEI7SUFDRjtJQUVBOztHQUVDLEdBQ0RRLFlBQVdSLE1BQU0sRUFBRWxHLE1BQU07UUFDdkIsSUFBSXdLLFVBQVVDLFVBQVVySyxNQUFNLEdBQUcsS0FBS3FLLFNBQVMsQ0FBQyxFQUFFLEtBQUtDLFlBQVlELFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJLEVBQ0Y5RCxXQUFXLEtBQUssRUFDakIsR0FBRzZEO1FBQ0osSUFBSUcsV0FBV3BFLFlBQVlnRCxTQUFTLENBQUNyRCxRQUFRQTtRQUM3QyxJQUFJMEUsVUFBVSx1RUFBdUU7UUFDckYsc0VBQXNFO1FBQ3RFLGlEQUFpRDtRQUNqRCxzREFBc0Q7UUFFdEQsSUFBSTtZQUNGQSxXQUFXMUgsYUFBYWxELFVBQVVBLFNBQVNBLE9BQU82SyxhQUFhO1FBQ2pFLEVBQUUsT0FBT0MsS0FBSztZQUNaLElBQUksQ0FBQ0EsSUFBSUMsT0FBTyxDQUFDQyxRQUFRLENBQUMsb0RBQW9EO2dCQUM1RSxNQUFNRjtZQUNSO1FBQ0Y7UUFFQSxJQUFJLENBQUNGLFVBQVU7WUFDYixPQUFPO1FBQ1Q7UUFFQSxPQUFPQSxTQUFTSyxPQUFPLENBQUMsMkJBQTJCTixZQUFhLEVBQUNoRSxZQUFZaUUsU0FBU00saUJBQWlCLEdBQUcsT0FBTyxPQUFPTixTQUFTTSxpQkFBaUIsS0FBSyxhQUFhLHdGQUF3RjtRQUM1UCxnSkFBZ0o7UUFDaEpOLFNBQVNLLE9BQU8sQ0FBQyxpQ0FBaUNOLFlBQVksQ0FBQyxDQUFDQyxTQUFTN0YsWUFBWSxDQUFDLHdCQUF1QjtJQUMvRztJQUVBOztHQUVDLEdBQ0RvRyxZQUFXakYsTUFBTSxFQUFFa0YsSUFBSTtRQUNyQmxGLE9BQU9pRixVQUFVLENBQUNDO0lBQ3BCO0lBRUE7O0dBRUMsR0FDREMsb0JBQW1CbkYsTUFBTSxFQUFFa0YsSUFBSTtRQUM3QixPQUFPbEYsT0FBT21GLGtCQUFrQixDQUFDRDtJQUNuQztJQUVBOztHQUVDLEdBQ0RFLGdCQUFlcEYsTUFBTSxFQUFFa0YsSUFBSTtRQUN6QixPQUFPbEYsT0FBT29GLGNBQWMsQ0FBQ0Y7SUFDL0I7SUFFQTs7R0FFQyxHQUNERyxpQkFBZ0JyRixNQUFNLEVBQUVrRixJQUFJLEVBQUVJLFdBQVc7UUFDdkN0RixPQUFPcUYsZUFBZSxDQUFDSCxNQUFNSTtJQUMvQjtJQUVBOztHQUVDLEdBQ0RqQyxXQUFVckQsTUFBTSxFQUFFbkMsSUFBSTtRQUNwQixJQUFJMEgsaUJBQWlCL0oseUJBQXlCa0gsR0FBRyxDQUFDMUM7UUFDbEQsSUFBSWpCLFVBQVUzRyx5Q0FBTUEsQ0FBQzRLLFFBQVEsQ0FBQ25GLFFBQVExQyxrQkFBa0J1SCxHQUFHLENBQUMxQyxVQUFVdUYsbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUksS0FBSyxJQUFJQSxlQUFlN0MsR0FBRyxDQUFDckMsWUFBWXVDLE9BQU8sQ0FBQzVDLFFBQVFuQztRQUVyTCxJQUFJLENBQUNrQixTQUFTO1lBQ1osTUFBTSxJQUFJNEQsTUFBTSw4Q0FBOEM3SCxNQUFNLENBQUN6QywyQ0FBUUEsQ0FBQzZLLFNBQVMsQ0FBQ3JGO1FBQzFGO1FBRUEsT0FBT2tCO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEeUcsWUFBV3hGLE1BQU0sRUFBRXlGLEtBQUs7UUFDdEIsSUFBSSxDQUFDNUgsS0FBSyxHQUFHekYseUNBQU1BLENBQUN5RixJQUFJLENBQUNtQyxRQUFReUYsTUFBTTFDLElBQUk7UUFDM0MsSUFBSUssS0FBSy9DLFlBQVlnRCxTQUFTLENBQUNyRCxRQUFRbkM7UUFDdkMsSUFBSUQsVUFBVSx5RUFBeUU7UUFDdkYsa0VBQWtFO1FBRWxFLElBQUl4Rix5Q0FBTUEsQ0FBQ3NOLElBQUksQ0FBQzFGLFFBQVE7WUFDdEIyRixJQUFJRjtRQUNOLElBQUk7WUFDRkEsUUFBUTtnQkFDTjFDLE1BQU0wQyxNQUFNMUMsSUFBSTtnQkFDaEJqRixRQUFRO1lBQ1Y7UUFDRixFQUFFLHVFQUF1RTtRQUN6RSxzRUFBc0U7UUFDdEUsOERBQThEO1FBRzlELElBQUk4SCxXQUFXO1FBQ2YsSUFBSUMsUUFBUTFHLE1BQU1DLElBQUksQ0FBQ2dFLEdBQUcwQyxnQkFBZ0IsQ0FBQ0Y7UUFDM0MsSUFBSUcsUUFBUTtRQUVaLElBQUssSUFBSTlMLElBQUksR0FBR0EsSUFBSTRMLE1BQU0zTCxNQUFNLEVBQUVELElBQUs7WUFDckMsSUFBSStFLE9BQU82RyxLQUFLLENBQUM1TCxFQUFFO1lBQ25CLElBQUk4RSxVQUFVQyxLQUFLakIsVUFBVSxDQUFDLEVBQUU7WUFFaEMsSUFBSWdCLFdBQVcsUUFBUUEsUUFBUVgsV0FBVyxJQUFJLE1BQU07Z0JBQ2xEO1lBQ0Y7WUFFQSxJQUFJLEVBQ0ZsRSxNQUFNLEVBQ1AsR0FBRzZFLFFBQVFYLFdBQVc7WUFDdkIsSUFBSTRILE9BQU9oSCxLQUFLSCxZQUFZLENBQUM7WUFDN0IsSUFBSW9ILGFBQWFELFFBQVEsT0FBTzlMLFNBQVMrRyxTQUFTK0UsTUFBTTtZQUN4RCxJQUFJRSxNQUFNSCxRQUFRRSxZQUFZLHFFQUFxRTtZQUNuRyxxREFBcUQ7WUFFckQsSUFBSUUsV0FBV04sS0FBSyxDQUFDNUwsSUFBSSxFQUFFO1lBRTNCLElBQUl3TCxNQUFNM0gsTUFBTSxLQUFLb0ksT0FBT0MsYUFBYSxRQUFRQSxhQUFhLEtBQUssS0FBS0EsU0FBU0MsWUFBWSxDQUFDLGdDQUFnQztnQkFDNUgsSUFBSUM7Z0JBRUosSUFBSUMsVUFBVUgsU0FBU3BJLFVBQVUsQ0FBQyxFQUFFO2dCQUNwQ0gsV0FBVztvQkFDWCx3RUFBd0U7b0JBQ3hFLDhFQUE4RTtvQkFDOUUsMkdBQTJHO29CQUMzRyxnREFBZ0Q7b0JBQ2hEMEksbUJBQW1COUosVUFBVThKLFVBQVVIO29CQUFXRSxDQUFBQSx3QkFBd0JGLFNBQVMvSCxXQUFXLE1BQU0sUUFBUWlJLDBCQUEwQixLQUFLLEtBQUtBLHNCQUFzQkUsVUFBVSxDQUFDLFlBQVksSUFBSTtpQkFBRTtnQkFDbk07WUFDRjtZQUVBLElBQUlkLE1BQU0zSCxNQUFNLElBQUlvSSxLQUFLO2dCQUN2QixJQUFJcEksU0FBUzBJLEtBQUtDLEdBQUcsQ0FBQ3ZNLFFBQVFzTSxLQUFLRSxHQUFHLENBQUMsR0FBR2pCLE1BQU0zSCxNQUFNLEdBQUdpSTtnQkFDekRuSSxXQUFXO29CQUFDbUI7b0JBQVNqQjtpQkFBTztnQkFDNUI7WUFDRjtZQUVBaUksUUFBUUc7UUFDVjtRQUVBLElBQUksQ0FBQ3RJLFVBQVU7WUFDYixNQUFNLElBQUkrRSxNQUFNLGdEQUFnRDdILE1BQU0sQ0FBQ3pDLDJDQUFRQSxDQUFDNkssU0FBUyxDQUFDdUM7UUFDNUY7UUFFQSxPQUFPN0g7SUFDVDtJQUVBOzs7Ozs7O0dBT0MsR0FDRCtJLFlBQVczRyxNQUFNLEVBQUU0RyxLQUFLO1FBQ3RCLElBQUksRUFDRkMsTUFBTSxFQUNOOUMsS0FBSyxFQUNOLEdBQUc2QztRQUNKLElBQUlFLGFBQWF2Tyx3Q0FBS0EsQ0FBQ3VPLFVBQVUsQ0FBQ0Y7UUFDbEMsSUFBSUcsWUFBWTFHLFlBQVltRixVQUFVLENBQUN4RixRQUFRNkc7UUFDL0MsSUFBSUcsV0FBV3pPLHdDQUFLQSxDQUFDME8sV0FBVyxDQUFDTCxTQUFTRyxZQUFZMUcsWUFBWW1GLFVBQVUsQ0FBQ3hGLFFBQVErRDtRQUNyRixJQUFJOUcsVUFBU29ELFlBQVlDLFNBQVMsQ0FBQ047UUFDbkMsSUFBSWtILFdBQVdqSyxRQUFPbUQsUUFBUSxDQUFDK0csV0FBVztRQUMxQyxJQUFJLENBQUNDLFdBQVdDLFlBQVksR0FBR1AsYUFBYUUsV0FBV0Q7UUFDdkQsSUFBSSxDQUFDTyxTQUFTQyxVQUFVLEdBQUdULGFBQWFDLFlBQVlDLFVBQVUsMkZBQTJGO1FBQ3pKLDRGQUE0RjtRQUM1RixpQ0FBaUM7UUFFakMsSUFBSVEsVUFBVXhLLGFBQWFvSyxhQUFhQSxZQUFZQSxVQUFVekMsYUFBYTtRQUMzRSxJQUFJOEMscUJBQXFCLENBQUMsQ0FBQ0QsUUFBUTNJLFlBQVksQ0FBQztRQUNoRCxJQUFJNkksUUFBUTFLLGFBQWFzSyxXQUFXQSxVQUFVQSxRQUFRM0MsYUFBYTtRQUNuRSxJQUFJZ0QsbUJBQW1CLENBQUMsQ0FBQ0QsTUFBTTdJLFlBQVksQ0FBQztRQUM1Q3FJLFNBQVNVLFFBQVEsQ0FBQ1IsV0FBV0sscUJBQXFCLElBQUlKO1FBQ3RESCxTQUFTVyxNQUFNLENBQUNQLFNBQVNLLG1CQUFtQixJQUFJSjtRQUNoRCxPQUFPTDtJQUNUO0lBRUE7O0dBRUMsR0FDRFksYUFBWTlILE1BQU0sRUFBRWpCLE9BQU87UUFDekIsSUFBSWdKLFFBQVEvSyxhQUFhK0IsV0FBV0EsVUFBVUEsUUFBUTRGLGFBQWE7UUFFbkUsSUFBSW9ELFNBQVMsQ0FBQ0EsTUFBTTNCLFlBQVksQ0FBQyxvQkFBb0I7WUFDbkQyQixRQUFRQSxNQUFNaEQsT0FBTyxDQUFDO1FBQ3hCO1FBRUEsSUFBSWxILE9BQU9rSyxRQUFRMU0sZ0JBQWdCcUgsR0FBRyxDQUFDcUYsU0FBUztRQUVoRCxJQUFJLENBQUNsSyxNQUFNO1lBQ1QsTUFBTSxJQUFJOEUsTUFBTSw4Q0FBOEM3SCxNQUFNLENBQUNpTjtRQUN2RTtRQUVBLE9BQU9sSztJQUNUO0lBRUE7O0dBRUMsR0FDRG1LLGdCQUFlaEksTUFBTSxFQUFFekMsS0FBSztRQUMxQixJQUFJLGlCQUFpQkEsT0FBTztZQUMxQkEsUUFBUUEsTUFBTTBLLFdBQVc7UUFDM0I7UUFFQSxJQUFJLEVBQ0ZDLFNBQVNDLENBQUMsRUFDVkMsU0FBU0MsQ0FBQyxFQUNWdk8sTUFBTSxFQUNQLEdBQUd5RDtRQUVKLElBQUk0SyxLQUFLLFFBQVFFLEtBQUssTUFBTTtZQUMxQixNQUFNLElBQUkxRixNQUFNLGtEQUFrRDdILE1BQU0sQ0FBQ3lDO1FBQzNFO1FBRUEsSUFBSU0sT0FBT3dDLFlBQVl5SCxXQUFXLENBQUM5SCxRQUFRekMsTUFBTXpELE1BQU07UUFDdkQsSUFBSWlKLE9BQU8xQyxZQUFZeUMsUUFBUSxDQUFDOUMsUUFBUW5DLE9BQU8sb0VBQW9FO1FBQ25ILGlFQUFpRTtRQUNqRSw4QkFBOEI7UUFFOUIsSUFBSXBGLDBDQUFTQSxDQUFDNlAsU0FBUyxDQUFDekssU0FBU3pGLHlDQUFNQSxDQUFDbVEsTUFBTSxDQUFDdkksUUFBUW5DLE9BQU87WUFDNUQsSUFBSTJLLE9BQU8xTyxPQUFPMk8scUJBQXFCO1lBQ3ZDLElBQUlDLFNBQVMxSSxPQUFPMkksUUFBUSxDQUFDOUssUUFBUXNLLElBQUlLLEtBQUtJLElBQUksR0FBR0osS0FBS0ksSUFBSSxHQUFHSixLQUFLSyxLQUFLLEdBQUdWLElBQUlFLElBQUlHLEtBQUtNLEdBQUcsR0FBR04sS0FBS00sR0FBRyxHQUFHTixLQUFLTyxNQUFNLEdBQUdWO1lBQzFILElBQUlXLE9BQU81USx5Q0FBTUEsQ0FBQ3FOLEtBQUssQ0FBQ3pGLFFBQVErQyxNQUFNO2dCQUNwQ2lHLE1BQU1OLFNBQVMsVUFBVTtZQUMzQjtZQUNBLElBQUlqRCxRQUFRaUQsU0FBU3RRLHlDQUFNQSxDQUFDNlEsTUFBTSxDQUFDakosUUFBUWdKLFFBQVE1USx5Q0FBTUEsQ0FBQzhRLEtBQUssQ0FBQ2xKLFFBQVFnSjtZQUV4RSxJQUFJdkQsT0FBTztnQkFDVCxJQUFJMEQsU0FBUy9RLHlDQUFNQSxDQUFDd08sS0FBSyxDQUFDNUcsUUFBUXlGO2dCQUVsQyxPQUFPMEQ7WUFDVDtRQUNGLEVBQUUsdUVBQXVFO1FBR3pFLElBQUlqQztRQUNKLElBQUksRUFDRjlHLFVBQUFBLFNBQVEsRUFDVCxHQUFHQyxZQUFZQyxTQUFTLENBQUNOLFNBQVMsd0VBQXdFO1FBRTNHLElBQUlJLFVBQVNnSixtQkFBbUIsRUFBRTtZQUNoQ2xDLFdBQVc5RyxVQUFTZ0osbUJBQW1CLENBQUNqQixHQUFHRTtRQUM3QyxPQUFPO1lBQ0wsSUFBSWdCLFdBQVdqSixVQUFTa0osc0JBQXNCLENBQUNuQixHQUFHRTtZQUVsRCxJQUFJZ0IsVUFBVTtnQkFDWm5DLFdBQVc5RyxVQUFTK0csV0FBVztnQkFDL0JELFNBQVNVLFFBQVEsQ0FBQ3lCLFNBQVNFLFVBQVUsRUFBRUYsU0FBU3ZMLE1BQU07Z0JBQ3REb0osU0FBU1csTUFBTSxDQUFDd0IsU0FBU0UsVUFBVSxFQUFFRixTQUFTdkwsTUFBTTtZQUN0RDtRQUNGO1FBRUEsSUFBSSxDQUFDb0osVUFBVTtZQUNiLE1BQU0sSUFBSXZFLE1BQU0sa0RBQWtEN0gsTUFBTSxDQUFDeUM7UUFDM0UsRUFBRSw0Q0FBNEM7UUFHOUMsSUFBSXFKLFFBQVF2RyxZQUFZbUosWUFBWSxDQUFDeEosUUFBUWtILFVBQVU7WUFDckR1QyxZQUFZO1lBQ1pDLGVBQWU7UUFDakI7UUFDQSxPQUFPOUM7SUFDVDtJQUVBOztHQUVDLEdBQ0QrQyxjQUFhM0osTUFBTSxFQUFFcEMsUUFBUSxFQUFFMEcsT0FBTztRQUNwQyxJQUFJLEVBQ0ZtRixVQUFVLEVBQ1ZDLGFBQWEsRUFDZCxHQUFHcEY7UUFDSixJQUFJLENBQUNzRixhQUFhQyxjQUFjLEdBQUdKLGFBQWE3TCxXQUFXRCxrQkFBa0JDO1FBQzdFLElBQUlXLGFBQWFxTCxZQUFZckwsVUFBVTtRQUN2QyxJQUFJdUwsV0FBVztRQUNmLElBQUloTSxTQUFTO1FBRWIsSUFBSVMsWUFBWTtZQUNkLElBQUl3TCxzQkFBc0JDO1lBRTFCLElBQUl2RixXQUFXcEUsWUFBWWdELFNBQVMsQ0FBQ3JELFFBQVFBO1lBQzdDLElBQUlpSyxvQkFBb0IxTCxXQUFXd0csT0FBTyxDQUFDLDZCQUE2QixvRUFBb0U7WUFDNUkscUZBQXFGO1lBQ3JGLG9GQUFvRjtZQUNwRixrREFBa0Q7WUFFbEQsSUFBSW1GLFdBQVdELHFCQUFxQnhGLFNBQVNsRSxRQUFRLENBQUMwSixxQkFBcUJBLG9CQUFvQjtZQUMvRixJQUFJRSxXQUFXNUwsV0FBV3dHLE9BQU8sQ0FBQztZQUNsQyxJQUFJaEcsVUFBVSxNQUFNLHdFQUF3RTtZQUM1Riw4REFBOEQ7WUFFOUQsSUFBSW9MLFVBQVU7Z0JBQ1pMLFdBQVdLLFNBQVNwRixPQUFPLENBQUM7Z0JBRTVCLElBQUkrRSxVQUFVO29CQUNaLElBQUk3TSxVQUFTb0QsWUFBWUMsU0FBUyxDQUFDTjtvQkFDbkMsSUFBSTRHLFFBQVEzSixRQUFPbUQsUUFBUSxDQUFDK0csV0FBVztvQkFDdkNQLE1BQU1nQixRQUFRLENBQUNrQyxVQUFVO29CQUN6QmxELE1BQU1pQixNQUFNLENBQUMrQixhQUFhQztvQkFDMUIsSUFBSU8sV0FBV3hELE1BQU15RCxhQUFhO29CQUNsQyxJQUFJQyxXQUFXOzJCQUFJbkwsTUFBTTVFLFNBQVMsQ0FBQ2dRLEtBQUssQ0FBQzlQLElBQUksQ0FBQzJQLFNBQVN0RSxnQkFBZ0IsQ0FBQzsyQkFBZ0MzRyxNQUFNNUUsU0FBUyxDQUFDZ1EsS0FBSyxDQUFDOVAsSUFBSSxDQUFDMlAsU0FBU3RFLGdCQUFnQixDQUFDO3FCQUE0QjtvQkFDekx3RSxTQUFTRSxPQUFPLENBQUNwSCxDQUFBQTt3QkFDZiwwRUFBMEU7d0JBQzFFLGdEQUFnRDt3QkFDaEQsSUFBSTFCLGNBQWMsQ0FBQytILGNBQWNyRyxHQUFHZ0QsWUFBWSxDQUFDLDRCQUE0QmhELEdBQUdoRixXQUFXLENBQUNsRSxNQUFNLEdBQUcsS0FBS2tKLEdBQUdxSCxXQUFXLEtBQUssVUFBVTs0QkFDckksSUFBSXJILEdBQUdoRixXQUFXLENBQUNtSSxVQUFVLENBQUMsV0FBVztnQ0FDdkNuRCxHQUFHaEYsV0FBVyxHQUFHZ0YsR0FBR2hGLFdBQVcsQ0FBQ21NLEtBQUssQ0FBQzs0QkFDeEM7NEJBRUE7d0JBQ0Y7d0JBRUFuSCxHQUFHN0UsVUFBVSxDQUFDbU0sV0FBVyxDQUFDdEg7b0JBQzVCLElBQUksK0RBQStEO29CQUNuRSwrREFBK0Q7b0JBQy9ELHNFQUFzRTtvQkFDdEUsOEJBQThCO29CQUM5QixpRkFBaUY7b0JBRWpGdEYsU0FBU3NNLFNBQVNoTSxXQUFXLENBQUNsRSxNQUFNO29CQUNwQzZFLFVBQVUrSztnQkFDWjtZQUNGLE9BQU8sSUFBSUksVUFBVTtnQkFDbkIsMkVBQTJFO2dCQUMzRSxpRkFBaUY7Z0JBQ2pGLCtDQUErQztnQkFDL0MsSUFBSVMsWUFBWVQsU0FBU3BFLGdCQUFnQixDQUFDO2dCQUUxQyxJQUFLLElBQUk3SCxRQUFRLEdBQUdBLFFBQVEwTSxVQUFVelEsTUFBTSxFQUFFK0QsUUFBUztvQkFDckQsSUFBSTJNLFVBQVVELFNBQVMsQ0FBQzFNLE1BQU07b0JBRTlCLElBQUlvQyxZQUFZRyxVQUFVLENBQUNSLFFBQVE0SyxVQUFVO3dCQUMzQ1QsV0FBV1M7d0JBQ1g7b0JBQ0Y7Z0JBQ0YsRUFBRSx5REFBeUQ7Z0JBRzNELElBQUksQ0FBQ1QsVUFBVTtvQkFDYnJNLFNBQVM7Z0JBQ1gsT0FBTztvQkFDTGdNLFdBQVdLLFNBQVNwRixPQUFPLENBQUM7b0JBQzVCaEcsVUFBVW9MO29CQUNWck0sU0FBU2lCLFFBQVFYLFdBQVcsQ0FBQ2xFLE1BQU07b0JBQ25DNkUsUUFBUStHLGdCQUFnQixDQUFDLDJCQUEyQjBFLE9BQU8sQ0FBQ3BILENBQUFBO3dCQUMxRHRGLFVBQVVzRixHQUFHaEYsV0FBVyxDQUFDbEUsTUFBTTtvQkFDakM7Z0JBQ0Y7WUFDRjtZQUVBLElBQUk2RSxXQUFXakIsV0FBV2lCLFFBQVFYLFdBQVcsQ0FBQ2xFLE1BQU0sSUFBSSwwRUFBMEU7WUFDbEksdUNBQXVDO1lBQ3ZDd0gsY0FBYzNDLFFBQVFGLFlBQVksQ0FBQyw2QkFBNkIsT0FBTyxDQUFDa0wsdUJBQXVCaEwsUUFBUVgsV0FBVyxNQUFNLFFBQVEyTCx5QkFBeUIsS0FBSyxLQUFLQSxxQkFBcUJ4RCxVQUFVLENBQUMsYUFBY2hJLENBQUFBLFdBQVc2SCxZQUFZLENBQUMsNEJBQTRCekUsY0FBYyxDQUFDcUksd0JBQXdCakwsUUFBUVgsV0FBVyxNQUFNLFFBQVE0TCwwQkFBMEIsS0FBSyxLQUFLQSxzQkFBc0JhLFFBQVEsQ0FBQyxPQUFNLEdBQUk7Z0JBQ3haL007WUFDRjtRQUNGO1FBRUEsSUFBSTRELGNBQWMsQ0FBQ29JLFlBQVksQ0FBQ0wsWUFBWTtZQUMxQyxJQUFJNUwsT0FBT1UsV0FBVzZILFlBQVksQ0FBQyxxQkFBcUI3SCxhQUFhQSxXQUFXd0csT0FBTyxDQUFDO1lBRXhGLElBQUlsSCxRQUFRd0MsWUFBWUcsVUFBVSxDQUFDUixRQUFRbkMsTUFBTTtnQkFDL0M0QyxVQUFVO1lBQ1osSUFBSTtnQkFDRixJQUFJcUssYUFBYXpLLFlBQVl5SCxXQUFXLENBQUM5SCxRQUFRbkM7Z0JBRWpELElBQUksRUFDRmtGLE1BQU1nSSxLQUFLLEVBQ1hqTixRQUFRa04sT0FBTyxFQUNoQixHQUFHNVMseUNBQU1BLENBQUMyTixLQUFLLENBQUMvRixRQUFRSyxZQUFZeUMsUUFBUSxDQUFDOUMsUUFBUThLO2dCQUV0RCxJQUFJLENBQUNqTixLQUFLb04sYUFBYSxDQUFDLHNCQUFzQjtvQkFDNUNELFVBQVVuQjtnQkFDWjtnQkFFQSxPQUFPO29CQUNMOUcsTUFBTWdJO29CQUNOak4sUUFBUWtOO2dCQUNWO1lBQ0Y7UUFDRjtRQUVBLElBQUksQ0FBQ2xCLFVBQVU7WUFDYixJQUFJSixlQUFlO2dCQUNqQixPQUFPO1lBQ1Q7WUFFQSxNQUFNLElBQUkvRyxNQUFNLGdEQUFnRDdILE1BQU0sQ0FBQzhDO1FBQ3pFLEVBQUUscUVBQXFFO1FBQ3ZFLG9FQUFvRTtRQUNwRSxxRUFBcUU7UUFHckUsSUFBSXNOLFlBQVk3SyxZQUFZeUgsV0FBVyxDQUFDOUgsUUFBUThKO1FBQ2hELElBQUkvRyxPQUFPMUMsWUFBWXlDLFFBQVEsQ0FBQzlDLFFBQVFrTDtRQUN4QyxPQUFPO1lBQ0xuSTtZQUNBakY7UUFDRjtJQUNGO0lBRUE7O0dBRUMsR0FDRDBMLGNBQWF4SixNQUFNLEVBQUVrSCxRQUFRLEVBQUU1QyxPQUFPO1FBQ3BDLElBQUksRUFDRm1GLFVBQVUsRUFDVkMsYUFBYSxFQUNkLEdBQUdwRjtRQUNKLElBQUlsQixLQUFLbEcsZUFBZWdLLFlBQVlBLFNBQVMvSixVQUFVLEdBQUcrSixTQUFTaUUsY0FBYztRQUNqRixJQUFJaE87UUFDSixJQUFJaU87UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSXJFO1FBRUosSUFBSTdELElBQUk7WUFDTixJQUFJbEcsZUFBZWdLLFdBQVc7Z0JBQzVCL0osYUFBYStKLFNBQVMvSixVQUFVO2dCQUNoQ2lPLGVBQWVsRSxTQUFTa0UsWUFBWTtnQkFDcENDLFlBQVluRSxTQUFTbUUsU0FBUztnQkFDOUJDLGNBQWNwRSxTQUFTb0UsV0FBVyxFQUFFLGlFQUFpRTtnQkFDckcsOERBQThEO2dCQUM5RCxlQUFlO2dCQUNmLCtEQUErRDtnQkFFL0QsSUFBSXhKLGFBQWF6RCxjQUFjbEIsYUFBYTtvQkFDMUM4SixjQUFjQyxTQUFTL0osVUFBVSxLQUFLK0osU0FBU21FLFNBQVMsSUFBSW5FLFNBQVNrRSxZQUFZLEtBQUtsRSxTQUFTb0UsV0FBVztnQkFDNUcsT0FBTztvQkFDTHJFLGNBQWNDLFNBQVNELFdBQVc7Z0JBQ3BDO1lBQ0YsT0FBTztnQkFDTDlKLGFBQWErSixTQUFTaUUsY0FBYztnQkFDcENDLGVBQWVsRSxTQUFTRyxXQUFXO2dCQUNuQ2dFLFlBQVluRSxTQUFTcUUsWUFBWTtnQkFDakNELGNBQWNwRSxTQUFTSyxTQUFTO2dCQUNoQ04sY0FBY0MsU0FBU3NFLFNBQVM7WUFDbEM7UUFDRjtRQUVBLElBQUlyTyxjQUFjLFFBQVFrTyxhQUFhLFFBQVFELGdCQUFnQixRQUFRRSxlQUFlLE1BQU07WUFDMUYsTUFBTSxJQUFJM0ksTUFBTSxnREFBZ0Q3SCxNQUFNLENBQUNvTTtRQUN6RSxFQUFFLDBFQUEwRTtRQUM1RSx3RUFBd0U7UUFDeEUsNERBQTREO1FBRzVELElBQUksa0JBQWtCbUUsYUFBYUEsVUFBVXhNLFlBQVksQ0FBQyx1QkFBdUIsU0FBUztZQUN4RixJQUFJNE07WUFFSkosWUFBWWxPO1lBQ1ptTyxjQUFjLENBQUMsQ0FBQ0csd0JBQXdCdE8sV0FBV2lCLFdBQVcsTUFBTSxRQUFRcU4sMEJBQTBCLEtBQUssSUFBSSxLQUFLLElBQUlBLHNCQUFzQnZSLE1BQU0sS0FBSztRQUMzSjtRQUVBLElBQUkyTSxTQUFTeEcsWUFBWXNKLFlBQVksQ0FBQzNKLFFBQVE7WUFBQzdDO1lBQVlpTztTQUFhLEVBQUU7WUFDeEUzQjtZQUNBQztRQUNGO1FBRUEsSUFBSSxDQUFDN0MsUUFBUTtZQUNYLE9BQU87UUFDVDtRQUVBLElBQUk5QyxRQUFRa0QsY0FBY0osU0FBU3hHLFlBQVlzSixZQUFZLENBQUMzSixRQUFRO1lBQUNxTDtZQUFXQztTQUFZLEVBQUU7WUFDNUY3QjtZQUNBQztRQUNGO1FBRUEsSUFBSSxDQUFDM0YsT0FBTztZQUNWLE9BQU87UUFDVDtRQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBc0JDLEdBR0QsSUFBSXBDLGNBQWMsQ0FBQ3NGLGVBQWU5SixlQUFla08sV0FBVztZQUMxRCxJQUFJSyxRQUFRdFQseUNBQU1BLENBQUNzVCxLQUFLLENBQUMxTCxRQUFRNkcsUUFBUUEsT0FBTzlELElBQUk7WUFDcEQsSUFBSTRJLFVBQVV2VCx5Q0FBTUEsQ0FBQ3VULE9BQU8sQ0FBQzNMLFFBQVErRCxPQUFPQSxNQUFNaEIsSUFBSTtZQUV0RCxJQUFJMkksT0FBTztnQkFDVCxJQUFJeEMsUUFBUTlRLHlDQUFNQSxDQUFDOFEsS0FBSyxDQUFDbEosUUFBUTZHLFNBQVMsd0NBQXdDO2dCQUVsRkEsU0FBU3FDLFNBQVNyQztZQUNwQjtZQUVBLElBQUk4RSxTQUFTO2dCQUNYLElBQUkxQyxTQUFTN1EseUNBQU1BLENBQUM2USxNQUFNLENBQUNqSixRQUFRK0Q7Z0JBQ25DQSxRQUFRa0YsVUFBVWxGO1lBQ3BCO1FBQ0Y7UUFFQSxJQUFJNkMsUUFBUTtZQUNWQyxRQUFRQTtZQUNSOUMsT0FBT0E7UUFDVCxHQUFHLDBEQUEwRDtRQUM3RCxrQ0FBa0M7UUFDbEMsdURBQXVEO1FBQ3ZELDBEQUEwRDtRQUUxRCxJQUFJeEwsd0NBQUtBLENBQUNxVCxVQUFVLENBQUNoRixVQUFVck8sd0NBQUtBLENBQUNzVCxTQUFTLENBQUNqRixVQUFVNUosYUFBYXFPLGNBQWNqVCx5Q0FBTUEsQ0FBQ3NOLElBQUksQ0FBQzFGLFFBQVE7WUFDdEcyRixJQUFJaUIsTUFBTTdDLEtBQUs7WUFDZitILE1BQU07UUFDUixJQUFJO1lBQ0ZsRixRQUFReE8seUNBQU1BLENBQUMyVCxXQUFXLENBQUMvTCxRQUFRNEcsT0FBTztnQkFDeENvRixPQUFPO1lBQ1Q7UUFDRjtRQUVBLE9BQU9wRjtJQUNUO0lBRUFxRixVQUFTak0sTUFBTSxFQUFFNEcsS0FBSztRQUNwQixJQUFJLEVBQ0ZDLE1BQU0sRUFDTjlDLEtBQUssRUFDTixHQUFHNkM7UUFDSixPQUFPeE8seUNBQU1BLENBQUM4VCxPQUFPLENBQUNsTSxRQUFRNkcsT0FBTzlELElBQUksS0FBSzNLLHlDQUFNQSxDQUFDOFQsT0FBTyxDQUFDbE0sUUFBUStELE1BQU1oQixJQUFJO0lBQ2pGO0lBRUE7O0dBRUMsR0FDRG9KLFdBQVVuTSxNQUFNLEVBQUVsRyxNQUFNO1FBQ3RCLE9BQU9nRCxVQUFVaEQsV0FBV3VHLFlBQVlHLFVBQVUsQ0FBQ1IsUUFBUWxHO0lBQzdEO0lBRUE7O0dBRUMsR0FDRHNTLG1CQUFrQnBNLE1BQU0sRUFBRWxHLE1BQU07UUFDOUIsT0FBT2dELFVBQVVoRCxXQUFXdUcsWUFBWUcsVUFBVSxDQUFDUixRQUFRbEcsUUFBUTtZQUNqRTJHLFVBQVU7UUFDWjtJQUNGO0lBRUE7O0dBRUMsR0FDRDRMLHFCQUFvQnJNLE1BQU0sRUFBRWxHLE1BQU07UUFDaEMsT0FBT3VHLFlBQVkrTCxpQkFBaUIsQ0FBQ3BNLFFBQVFsRyxXQUFXdUcsWUFBWWlNLDZCQUE2QixDQUFDdE0sUUFBUWxHO0lBQzVHO0lBRUE7O0dBRUMsR0FDRHdTLCtCQUE4QnRNLE1BQU0sRUFBRWxHLE1BQU07UUFDMUMsSUFBSTJCLGFBQWFpSCxHQUFHLENBQUMxQyxTQUFTLE9BQU87UUFDckMsSUFBSWtMLFlBQVk3SyxZQUFZOEwsU0FBUyxDQUFDbk0sUUFBUWxHLFdBQVd1RyxZQUFZeUgsV0FBVyxDQUFDOUgsUUFBUWxHO1FBQ3pGLE9BQU9yQiwwQ0FBU0EsQ0FBQzZQLFNBQVMsQ0FBQzRDLGNBQWM5Uyx5Q0FBTUEsQ0FBQ21RLE1BQU0sQ0FBQ3ZJLFFBQVFrTDtJQUNqRTtJQUVBOztHQUVDLEdBQ0RxQixzQkFBcUJ2TSxNQUFNO1FBQ3pCLElBQUl3TTtRQUVIQSxDQUFBQSx3QkFBd0IxUSx5QkFBeUI0RyxHQUFHLENBQUMxQyxPQUFNLE1BQU8sUUFBUXdNLDBCQUEwQixLQUFLLElBQUksS0FBSyxJQUFJQTtJQUN6SDtJQUVBOztHQUVDLEdBQ0RDLHFCQUFvQnpNLE1BQU07UUFDeEIsT0FBTy9ELHdCQUF3QnlHLEdBQUcsQ0FBQzFDO0lBQ3JDO0FBRUY7QUFFQSxJQUFJME0sY0FBYztJQUFDO0lBQVU7Q0FBUSxFQUNqQ0MsZUFBZTtJQUFDO0lBQVU7Q0FBUTtBQUN0QyxJQUFJQyxpQkFBaUIsQ0FBQ0MsTUFBTUMsT0FBU3hULE9BQU9VLElBQUksQ0FBQzZTLE1BQU0zUyxNQUFNLEtBQUtaLE9BQU9VLElBQUksQ0FBQzhTLE1BQU01UyxNQUFNLElBQUlaLE9BQU9VLElBQUksQ0FBQzZTLE1BQU1FLEtBQUssQ0FBQzNULENBQUFBLE1BQU8wVCxLQUFLRSxjQUFjLENBQUM1VCxRQUFReVQsSUFBSSxDQUFDelQsSUFBSSxLQUFLMFQsSUFBSSxDQUFDMVQsSUFBSTtBQUVoTCxJQUFJNlQseUJBQXlCLENBQUNyRyxPQUFPc0c7SUFDbkMsSUFBSUMsZ0JBQWdCL1MseUJBQXlCd00sT0FBTzhGO0lBRXBELElBQUlVLGdCQUFnQmhULHlCQUF5QjhTLE9BQU9QO0lBRXBELE9BQU8vRixLQUFLLENBQUN2SyxtQkFBbUIsS0FBSzZRLEtBQUssQ0FBQzdRLG1CQUFtQixJQUFJdVEsZUFBZU8sZUFBZUM7QUFDbEc7QUFDQTs7Ozs7O0NBTUMsR0FHRCxJQUFJQyw0QkFBNEIsQ0FBQ0MsTUFBTUM7SUFDckMsSUFBSUQsS0FBS3BULE1BQU0sS0FBS3FULFFBQVFyVCxNQUFNLEVBQUU7UUFDbEMsT0FBTztJQUNUO0lBRUEsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLElBQUlxVCxLQUFLcFQsTUFBTSxFQUFFRCxJQUFLO1FBQ3BDLElBQUkyTSxRQUFRMEcsSUFBSSxDQUFDclQsRUFBRTtRQUNuQixJQUFJaVQsUUFBUUssT0FBTyxDQUFDdFQsRUFBRTtRQUV0QixJQUFJLENBQUMxQix3Q0FBS0EsQ0FBQ2lWLE1BQU0sQ0FBQzVHLE9BQU9zRyxVQUFVLENBQUNELHVCQUF1QnJHLE9BQU9zRyxRQUFRO1lBQ3hFLE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztBQUNUO0FBQ0E7Ozs7OztDQU1DLEdBRUQsSUFBSU8seUJBQXlCLENBQUNILE1BQU1DO0lBQ2xDLElBQUlELEtBQUtwVCxNQUFNLEtBQUtxVCxRQUFRclQsTUFBTSxFQUFFO1FBQ2xDLE9BQU87SUFDVDtJQUVBLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJcVQsS0FBS3BULE1BQU0sRUFBRUQsSUFBSztRQUNwQyxJQUFJMk0sUUFBUTBHLElBQUksQ0FBQ3JULEVBQUU7UUFDbkIsSUFBSWlULFFBQVFLLE9BQU8sQ0FBQ3RULEVBQUUsRUFBRSw2REFBNkQ7UUFFckYsSUFBSTJNLE1BQU1DLE1BQU0sQ0FBQy9JLE1BQU0sS0FBS29QLE1BQU1yRyxNQUFNLENBQUMvSSxNQUFNLElBQUk4SSxNQUFNN0MsS0FBSyxDQUFDakcsTUFBTSxLQUFLb1AsTUFBTW5KLEtBQUssQ0FBQ2pHLE1BQU0sSUFBSSxDQUFDbVAsdUJBQXVCckcsT0FBT3NHLFFBQVE7WUFDckksT0FBTztRQUNUO0lBQ0Y7SUFFQSxPQUFPO0FBQ1Q7QUFFQTs7Q0FFQyxHQUVELElBQUlRLDRCQUE0QnRMLGNBQWM3SyxrREFBZUEsR0FBR0MsNENBQVNBO0FBRXpFOztDQUVDLEdBRUQsSUFBSW1XLFNBQVNDLENBQUFBO0lBQ1gsSUFBSSxFQUNGNVAsTUFBTSxFQUNONlAsSUFBSSxFQUNKdlAsTUFBTSxFQUNOVSxJQUFJLEVBQ0wsR0FBRzRPO0lBQ0osSUFBSTVOLFNBQVM4TjtJQUNiLElBQUkvSyxPQUFPMUMsWUFBWXlDLFFBQVEsQ0FBQzlDLFFBQVFoQjtJQUN4QyxJQUFJK08sYUFBYXJWLHVDQUFJQSxDQUFDNEYsTUFBTSxDQUFDeUU7SUFDN0IsSUFBSWlMLG9CQUFvQkgsSUFBSSxDQUFDdFIsd0JBQXdCLEtBQUssTUFBTSxpRUFBaUU7SUFDakksaUVBQWlFO0lBRWpFLElBQUl5RCxPQUFPdUksTUFBTSxDQUFDakssU0FBUztRQUN6QixPQUFPLFdBQVcsR0FBRWhILDBEQUFtQixDQUFDMlcsaUJBQWlCO1lBQ3ZEL1QsUUFBUXZCLHVDQUFJQSxDQUFDdVYsTUFBTSxDQUFDNVAsUUFBUXBFLE1BQU07UUFDcEM7SUFDRixFQUFFLDBFQUEwRTtJQUM1RSwyRUFBMkU7SUFDM0Usa0NBQWtDO0lBR2xDLElBQUkyVCxLQUFLN08sSUFBSSxLQUFLLE1BQU1WLE9BQU82UCxRQUFRLENBQUM3UCxPQUFPNlAsUUFBUSxDQUFDalUsTUFBTSxHQUFHLEVBQUUsS0FBSzhFLFFBQVEsQ0FBQ2dCLE9BQU8ySSxRQUFRLENBQUNySyxXQUFXbEcseUNBQU1BLENBQUM4VixNQUFNLENBQUNsTyxRQUFRK04sZ0JBQWdCLElBQUk7UUFDcEosT0FBTyxXQUFXLEdBQUV6VywwREFBbUIsQ0FBQzJXLGlCQUFpQjtZQUN2REcsYUFBYTtZQUNiSixtQkFBbUJBO1FBQ3JCO0lBQ0YsRUFBRSwyRUFBMkU7SUFDN0UscUVBQXFFO0lBQ3JFLDZCQUE2QjtJQUc3QixJQUFJSCxLQUFLN08sSUFBSSxLQUFLLElBQUk7UUFDcEIsT0FBTyxXQUFXLEdBQUUxSCwwREFBbUIsQ0FBQzJXLGlCQUFpQjtZQUN2REQsbUJBQW1CQTtRQUNyQjtJQUNGLEVBQUUsMEVBQTBFO0lBQzVFLGlFQUFpRTtJQUdqRSxJQUFJaFEsVUFBVTZQLEtBQUs3TyxJQUFJLENBQUN1TCxLQUFLLENBQUMsQ0FBQyxPQUFPLE1BQU07UUFDMUMsT0FBTyxXQUFXLEdBQUVqVCwwREFBbUIsQ0FBQytXLFlBQVk7WUFDbERDLFlBQVk7WUFDWnRQLE1BQU02TyxLQUFLN08sSUFBSTtRQUNqQjtJQUNGO0lBRUEsT0FBTyxXQUFXLEdBQUUxSCwwREFBbUIsQ0FBQytXLFlBQVk7UUFDbERyUCxNQUFNNk8sS0FBSzdPLElBQUk7SUFDakI7QUFDRjtBQUNBOztDQUVDLEdBR0QsSUFBSXFQLGFBQWFULENBQUFBO0lBQ2YsSUFBSSxFQUNGNU8sSUFBSSxFQUNKc1AsYUFBYSxLQUFLLEVBQ25CLEdBQUdWO0lBQ0osSUFBSVcsTUFBTTlXLDZDQUFNQSxDQUFDO0lBRWpCLElBQUkrVyxpQkFBaUI7UUFDbkIsT0FBTyxHQUFHMVQsTUFBTSxDQUFDa0UsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSUEsT0FBTyxJQUFJbEUsTUFBTSxDQUFDd1QsYUFBYSxPQUFPO0lBQzVGO0lBRUEsSUFBSSxDQUFDRyxZQUFZLEdBQUcvVywrQ0FBUUEsQ0FBQzhXLGlCQUFpQiw2RUFBNkU7SUFDM0gsK0dBQStHO0lBQy9HLDBHQUEwRztJQUMxRywrSEFBK0g7SUFDL0gscUZBQXFGO0lBQ3JGLDhIQUE4SDtJQUM5SCxrRUFBa0U7SUFDbEUsMERBQTBEO0lBRTFEZCwwQkFBMEI7UUFDeEIsd0hBQXdIO1FBQ3hILElBQUlnQixtQkFBbUJGO1FBRXZCLElBQUlELElBQUkzRCxPQUFPLElBQUkyRCxJQUFJM0QsT0FBTyxDQUFDeE0sV0FBVyxLQUFLc1Esa0JBQWtCO1lBQy9ESCxJQUFJM0QsT0FBTyxDQUFDeE0sV0FBVyxHQUFHc1E7UUFDNUIsRUFBRSxzRkFBc0Y7SUFDeEYsOEdBQThHO0lBRWhILElBQUksdUhBQXVIO0lBQzNILG1HQUFtRztJQUVuRyxPQUFPLFdBQVcsR0FBRXBYLDBEQUFtQixDQUFDcVgsZ0JBQWdCO1FBQ3RESixLQUFLQTtJQUNQLEdBQUdFO0FBQ0w7QUFFQSxJQUFJRSxpQkFBaUIsV0FBVyxHQUFFaFgsMkNBQUlBLENBQUUsV0FBVyxHQUFFQyxpREFBVUEsQ0FBQyxDQUFDZ1csT0FBT1c7SUFDdEUsT0FBTyxXQUFXLEdBQUVqWCwwREFBbUIsQ0FBQyxRQUFRO1FBQzlDLHFCQUFxQjtRQUNyQmlYLEtBQUtBO0lBQ1AsR0FBR1gsTUFBTU8sUUFBUTtBQUNuQjtBQUNBOztDQUVDLEdBRUQsSUFBSUYsa0JBQWtCTCxDQUFBQTtJQUNwQixJQUFJLEVBQ0YxVCxTQUFTLENBQUMsRUFDVmtVLGNBQWMsS0FBSyxFQUNuQkosb0JBQW9CLEtBQUssRUFDMUIsR0FBR0o7SUFDSixJQUFJZ0IsYUFBYTtRQUNmLHlCQUF5QlIsY0FBYyxNQUFNO1FBQzdDLHFCQUFxQmxVO0lBQ3ZCO0lBRUEsSUFBSThULG1CQUFtQjtRQUNyQlksVUFBVSxDQUFDLDhCQUE4QixHQUFHO0lBQzlDO0lBRUEsT0FBTyxXQUFXLEdBQUV0WCwwREFBbUIsQ0FBQyxRQUFRZ0MsT0FBT3VWLE1BQU0sQ0FBQyxDQUFDLEdBQUdELGFBQWEsQ0FBQ2xOLGNBQWMsQ0FBQzBNLGNBQWMsV0FBVyxNQUFNQSxjQUFjLFdBQVcsR0FBRTlXLDBEQUFtQixDQUFDLE1BQU0sUUFBUTtBQUM3TDtBQUVBOztDQUVDLEdBRUQsSUFBSXdYLGdCQUFnQixXQUFXLEdBQUVqWCxvREFBYUEsQ0FBQztBQUMvQzs7Q0FFQyxHQUVELElBQUlpVyxpQkFBaUI7SUFDbkIsSUFBSTlOLFNBQVNsSSxpREFBVUEsQ0FBQ2dYO0lBRXhCLElBQUksQ0FBQzlPLFFBQVE7UUFDWCxNQUFNLElBQUkyQyxNQUFNO0lBQ2xCO0lBRUEsT0FBTzNDO0FBQ1Q7QUFFQTs7Q0FFQyxHQUVELElBQUkrTyxPQUFPbkIsQ0FBQUE7SUFDVCxJQUFJLEVBQ0ZDLElBQUksRUFDSjdQLE1BQU0sRUFDTmdCLElBQUksRUFDSlYsTUFBTSxFQUNOMFEsaUJBQWlCLEVBQ2pCQyxhQUFhckIsQ0FBQUEsUUFBUyxXQUFXLEdBQUV0VywwREFBbUIsQ0FBQzRYLGFBQWE1VixPQUFPdVYsTUFBTSxDQUFDLENBQUMsR0FBR2pCLE9BQU8sRUFDOUYsR0FBR0E7SUFDSixJQUFJdUIscUJBQXFCMVgsNkNBQU1BLENBQUM7SUFDaEMsSUFBSTJYLGlCQUFpQjNYLDZDQUFNQSxDQUFDO0lBQzVCLElBQUl1SSxTQUFTOE47SUFDYixJQUFJdUIsNEJBQTRCNVgsNkNBQU1BLENBQUM7SUFDdkNELGdEQUFTQSxDQUFDO1FBQ1IsT0FBTztZQUNMLElBQUk2WCwwQkFBMEJ6RSxPQUFPLEVBQUU7Z0JBQ3JDeUUsMEJBQTBCekUsT0FBTyxDQUFDMEUsVUFBVTtZQUM5QztRQUNGO0lBQ0YsR0FBRyxFQUFFO0lBQ0w5WCxnREFBU0EsQ0FBQztRQUNSLElBQUkrWCxnQkFBZ0JILG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsZUFBZXhFLE9BQU87UUFFMUcsSUFBSTJFLGVBQWU7WUFDakJuVSw4QkFBOEJ5SCxHQUFHLENBQUM3QyxRQUFRdVA7UUFDNUMsT0FBTztZQUNMblUsOEJBQThCb1UsTUFBTSxDQUFDeFA7UUFDdkM7UUFFQSxJQUFJcVAsMEJBQTBCekUsT0FBTyxFQUFFO1lBQ3JDLDRCQUE0QjtZQUM1QnlFLDBCQUEwQnpFLE9BQU8sQ0FBQzBFLFVBQVU7WUFDNUMsSUFBSUMsZUFBZUYsMEJBQTBCekUsT0FBTyxDQUFDNkUsT0FBTyxDQUFDRjtRQUMvRCxPQUFPLElBQUlBLGVBQWU7WUFDeEIsNkRBQTZEO1lBQzdELElBQUlHLG1CQUFtQnpTLE9BQU9sRSxjQUFjLElBQUlBLG1FQUFjQTtZQUM5RHNXLDBCQUEwQnpFLE9BQU8sR0FBRyxJQUFJOEUsaUJBQWlCO2dCQUN2RCxtRUFBbUU7Z0JBQ25FLHdDQUF3QztnQkFDeEMsSUFBSUMsY0FBY3ZULHVCQUF1QnNHLEdBQUcsQ0FBQzFDO2dCQUM3QzJQLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSUE7WUFDNUQ7WUFDQU4sMEJBQTBCekUsT0FBTyxDQUFDNkUsT0FBTyxDQUFDRjtRQUM1QztRQUVBLElBQUksQ0FBQ0EsaUJBQWlCSixtQkFBbUJ2RSxPQUFPLEVBQUU7WUFDaEQsNERBQTREO1lBQzVELGtFQUFrRTtZQUNsRSxJQUFJK0UsY0FBY3ZULHVCQUF1QnNHLEdBQUcsQ0FBQzFDO1lBQzdDMlAsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJQTtRQUM1RDtRQUVBUixtQkFBbUJ2RSxPQUFPLEdBQUd3RSxlQUFleEUsT0FBTztRQUNuRCxPQUFPO1lBQ0x4UCw4QkFBOEJvVSxNQUFNLENBQUN4UDtRQUN2QztJQUNGLEdBQUc7UUFBQ29QO1FBQWdCdkI7S0FBSztJQUN6QixJQUFJTSxXQUFXLFdBQVcsR0FBRTdXLDBEQUFtQixDQUFDcVcsUUFBUTtRQUN0RDNQLFFBQVFBO1FBQ1I2UCxNQUFNQTtRQUNOdlAsUUFBUUE7UUFDUlUsTUFBTUE7SUFDUjtJQUVBLElBQUk2TyxJQUFJLENBQUN4UixtQkFBbUIsRUFBRTtRQUM1QixJQUFJdVQsbUJBQW1CO1lBQ3JCekIsVUFBVU4sS0FBS2dDLFdBQVc7WUFDMUJqQixZQUFZO2dCQUNWLDBCQUEwQjtnQkFDMUJrQixPQUFPO29CQUNMekcsVUFBVTtvQkFDVjBHLGVBQWU7b0JBQ2ZsSCxPQUFPO29CQUNQbUgsVUFBVTtvQkFDVjNRLFNBQVM7b0JBQ1Q0USxTQUFTO29CQUNUQyxZQUFZO29CQUNaQyxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxpQkFBaUI7Z0JBQ2pCN0IsS0FBS2E7WUFDUDtRQUNGO1FBQ0FqQixXQUFXLFdBQVcsR0FBRTdXLDBEQUFtQixDQUFDQSx1REFBYyxFQUFFLE1BQU0wWCxrQkFBa0JZLG1CQUFtQnpCO0lBQ3pHLEVBQUUsNEVBQTRFO0lBQzlFLDBFQUEwRTtJQUMxRSwwQ0FBMEM7SUFHMUMsSUFBSVMsYUFBYTtRQUNmLG1CQUFtQjtJQUNyQjtJQUNBLE9BQU9LLFdBQVc7UUFDaEJMO1FBQ0FUO1FBQ0FOO1FBQ0E3TztJQUNGO0FBQ0Y7QUFFQSxJQUFJc1IsZUFBZSxXQUFXLEdBQUVoWixpREFBVSxDQUFDeVgsTUFBTSxDQUFDd0IsTUFBTUM7SUFDdEQsT0FBT0EsS0FBS2xTLE1BQU0sS0FBS2lTLEtBQUtqUyxNQUFNLElBQUlrUyxLQUFLeFMsTUFBTSxLQUFLdVMsS0FBS3ZTLE1BQU0sSUFBSXdTLEtBQUt2QixVQUFVLEtBQUtzQixLQUFLdEIsVUFBVSxJQUFJdUIsS0FBS3hCLGlCQUFpQixLQUFLdUIsS0FBS3ZCLGlCQUFpQixJQUFJd0IsS0FBS3hSLElBQUksS0FBS3VSLEtBQUt2UixJQUFJLElBQUluRyx1Q0FBTUEsQ0FBQzJVLE1BQU0sQ0FBQ2dELEtBQUszQyxJQUFJLEVBQUUwQyxLQUFLMUMsSUFBSSxLQUFLMkMsS0FBSzNDLElBQUksQ0FBQ3hSLG1CQUFtQixLQUFLa1UsS0FBSzFDLElBQUksQ0FBQ3hSLG1CQUFtQjtBQUNwUztBQUNBLElBQUk2UyxjQUFjdEIsQ0FBQUE7SUFDaEIsSUFBSSxFQUNGZ0IsVUFBVSxFQUNWVCxRQUFRLEVBQ1QsR0FBR1A7SUFDSixPQUFPLFdBQVcsR0FBRXRXLDBEQUFtQixDQUFDLFFBQVFnQyxPQUFPdVYsTUFBTSxDQUFDLENBQUMsR0FBR0QsYUFBYVQ7QUFDakY7QUFFQTs7Q0FFQyxHQUVELElBQUl2VixPQUFPZ1YsQ0FBQUE7SUFDVCxJQUFJLEVBQ0Y2QyxXQUFXLEVBQ1h6UyxNQUFNLEVBQ05NLE1BQU0sRUFDTjBRLGlCQUFpQixFQUNqQkMsVUFBVSxFQUNWalEsSUFBSSxFQUNMLEdBQUc0TztJQUNKLElBQUk1TixTQUFTOE47SUFDYixJQUFJUyxNQUFNOVcsNkNBQU1BLENBQUM7SUFDakIsSUFBSWlaLFNBQVM3WCx1Q0FBTUEsQ0FBQzRYLFdBQVcsQ0FBQ3pSLE1BQU15UjtJQUN0QyxJQUFJclgsTUFBTWlILFlBQVl1QyxPQUFPLENBQUM1QyxRQUFRaEI7SUFDdEMsSUFBSW1QLFdBQVcsRUFBRTtJQUVqQixJQUFLLElBQUlsVSxJQUFJLEdBQUdBLElBQUl5VyxPQUFPeFcsTUFBTSxFQUFFRCxJQUFLO1FBQ3RDLElBQUk0VCxPQUFPNkMsTUFBTSxDQUFDelcsRUFBRTtRQUNwQmtVLFNBQVN3QyxJQUFJLENBQUUsV0FBVyxHQUFFclosMERBQW1CLENBQUNnWixjQUFjO1lBQzVEdFMsUUFBUUEsVUFBVS9ELE1BQU15VyxPQUFPeFcsTUFBTSxHQUFHO1lBQ3hDZCxLQUFLLEdBQUcwQixNQUFNLENBQUMxQixJQUFJeUIsRUFBRSxFQUFFLEtBQUtDLE1BQU0sQ0FBQ2I7WUFDbkMrVSxtQkFBbUJBO1lBQ25CbkIsTUFBTUE7WUFDTjdPLE1BQU1BO1lBQ05WLFFBQVFBO1lBQ1IyUSxZQUFZQTtRQUNkO0lBQ0YsRUFBRSw2REFBNkQ7SUFHL0QsSUFBSTJCLGNBQWM3WSxrREFBV0EsQ0FBQzhZLENBQUFBO1FBQzVCLElBQUl0TCxpQkFBaUIvSix5QkFBeUJrSCxHQUFHLENBQUMxQztRQUVsRCxJQUFJNlEsTUFBTTtZQUNSdEwsbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUksS0FBSyxJQUFJQSxlQUFlMUMsR0FBRyxDQUFDekosS0FBS3lYO1lBQ3hGdlYsZ0JBQWdCdUgsR0FBRyxDQUFDN0QsTUFBTTZSO1lBQzFCeFYsZ0JBQWdCd0gsR0FBRyxDQUFDZ08sTUFBTTdSO1FBQzVCLE9BQU87WUFDTHVHLG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsZUFBZWlLLE1BQU0sQ0FBQ3BXO1lBQ3RGa0MsZ0JBQWdCa1UsTUFBTSxDQUFDeFE7WUFFdkIsSUFBSXVQLElBQUkzRCxPQUFPLEVBQUU7Z0JBQ2Z2UCxnQkFBZ0JtVSxNQUFNLENBQUNqQixJQUFJM0QsT0FBTztZQUNwQztRQUNGO1FBRUEyRCxJQUFJM0QsT0FBTyxHQUFHaUc7SUFDaEIsR0FBRztRQUFDdEM7UUFBS3ZPO1FBQVE1RztRQUFLNEY7S0FBSztJQUMzQixPQUFPLFdBQVcsR0FBRTFILDBEQUFtQixDQUFDLFFBQVE7UUFDOUMsbUJBQW1CO1FBQ25CaVgsS0FBS3FDO0lBQ1AsR0FBR3pDO0FBQ0w7QUFFQSxJQUFJMkMsZUFBZSxXQUFXLEdBQUV4WixpREFBVSxDQUFDc0IsTUFBTSxDQUFDMlgsTUFBTUM7SUFDdEQsT0FBT0EsS0FBS2xTLE1BQU0sS0FBS2lTLEtBQUtqUyxNQUFNLElBQUlrUyxLQUFLeFMsTUFBTSxLQUFLdVMsS0FBS3ZTLE1BQU0sSUFBSXdTLEtBQUt2QixVQUFVLEtBQUtzQixLQUFLdEIsVUFBVSxJQUFJdUIsS0FBS3hCLGlCQUFpQixLQUFLdUIsS0FBS3ZCLGlCQUFpQixJQUFJd0IsS0FBS3hSLElBQUksS0FBS3VSLEtBQUt2UixJQUFJLElBQUl5Tyx1QkFBdUIrQyxLQUFLQyxXQUFXLEVBQUVGLEtBQUtFLFdBQVc7QUFDdlA7QUFFQTs7Q0FFQyxHQUVELElBQUlqWSxVQUFVb1YsQ0FBQUE7SUFDWixJQUFJLEVBQ0Y2QyxXQUFXLEVBQ1hNLE9BQU8sRUFDUEMsZ0JBQWdCQyxDQUFBQSxJQUFLLFdBQVcsR0FBRTNaLDBEQUFtQixDQUFDNFosZ0JBQWdCNVgsT0FBT3VWLE1BQU0sQ0FBQyxDQUFDLEdBQUdvQyxHQUFHLEVBQzNGakMsaUJBQWlCLEVBQ2pCQyxVQUFVLEVBQ1YvSyxTQUFTLEVBQ1YsR0FBRzBKO0lBQ0osSUFBSTVOLFNBQVM4TjtJQUNiLElBQUlxRCxXQUFXQztJQUNmLElBQUl6SSxXQUFXM0ksT0FBTzJJLFFBQVEsQ0FBQ29JO0lBQy9CLElBQUkzWCxNQUFNaUgsWUFBWXVDLE9BQU8sQ0FBQzVDLFFBQVErUTtJQUN0QyxJQUFJeEMsTUFBTXhXLGtEQUFXQSxDQUFDd1csQ0FBQUE7UUFDcEIsNkRBQTZEO1FBQzdELElBQUloSixpQkFBaUIvSix5QkFBeUJrSCxHQUFHLENBQUMxQztRQUVsRCxJQUFJdU8sS0FBSztZQUNQaEosbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUksS0FBSyxJQUFJQSxlQUFlMUMsR0FBRyxDQUFDekosS0FBS21WO1lBQ3hGalQsZ0JBQWdCdUgsR0FBRyxDQUFDa08sU0FBU3hDO1lBQzdCbFQsZ0JBQWdCd0gsR0FBRyxDQUFDMEwsS0FBS3dDO1FBQzNCLE9BQU87WUFDTHhMLG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsZUFBZWlLLE1BQU0sQ0FBQ3BXO1lBQ3RGa0MsZ0JBQWdCa1UsTUFBTSxDQUFDdUI7UUFDekI7SUFDRixHQUFHO1FBQUMvUTtRQUFRNUc7UUFBSzJYO0tBQVE7SUFDekIsSUFBSTVDLFdBQVdrRCxZQUFZO1FBQ3pCWjtRQUNBNVMsTUFBTWtUO1FBQ05DO1FBQ0FoQztRQUNBQztRQUNBL0s7SUFDRixJQUFJLG1FQUFtRTtJQUN2RSxrQ0FBa0M7SUFFbEMsSUFBSTBLLGFBQWE7UUFDZixtQkFBbUI7UUFDbkJMO0lBQ0Y7SUFFQSxJQUFJNUYsVUFBVTtRQUNaaUcsVUFBVSxDQUFDLG9CQUFvQixHQUFHO0lBQ3BDLEVBQUUsNEVBQTRFO0lBQzlFLHNCQUFzQjtJQUd0QixJQUFJLENBQUNqRyxZQUFZdlEseUNBQU1BLENBQUNrWixVQUFVLENBQUN0UixRQUFRK1EsVUFBVTtRQUNuRCxJQUFJL1IsT0FBT3JHLHVDQUFJQSxDQUFDdVYsTUFBTSxDQUFDNkM7UUFDdkIsSUFBSVEsTUFBTXBhLGdEQUFZQSxDQUFDNkg7UUFFdkIsSUFBSXVTLFFBQVEsT0FBTztZQUNqQjNDLFdBQVcyQyxHQUFHLEdBQUdBO1FBQ25CO0lBQ0YsRUFBRSwwRUFBMEU7SUFHNUUsSUFBSW5aLHlDQUFNQSxDQUFDbVEsTUFBTSxDQUFDdkksUUFBUStRLFVBQVU7UUFDbENuQyxVQUFVLENBQUMsa0JBQWtCLEdBQUc7UUFFaEMsSUFBSSxDQUFDdUMsWUFBWXhJLFVBQVU7WUFDekJpRyxXQUFXd0IsZUFBZSxHQUFHO1FBQy9CO1FBRUEsSUFBSW9CLE1BQU03SSxXQUFXLFNBQVM7UUFDOUIsSUFBSSxDQUFDLENBQUM4SSxNQUFNLENBQUMsR0FBRzlZLHVDQUFJQSxDQUFDa04sS0FBSyxDQUFDa0w7UUFDM0I1QyxXQUFXLFdBQVcsR0FBRTdXLDBEQUFtQixDQUFDa2EsS0FBSztZQUMvQyxxQkFBcUI7WUFDckIxQixPQUFPO2dCQUNML0csUUFBUTtnQkFDUjJJLE9BQU87Z0JBQ1BDLFNBQVM7Z0JBQ1R0SSxVQUFVO1lBQ1o7UUFDRixHQUFHLFdBQVcsR0FBRS9SLDBEQUFtQixDQUFDd1osY0FBYztZQUNoRDlCLG1CQUFtQkE7WUFDbkJ5QixhQUFhLEVBQUU7WUFDZnpTLFFBQVE7WUFDUk0sUUFBUXlTO1lBQ1IvUixNQUFNeVM7UUFDUjtRQUNBMVcsY0FBYzhILEdBQUcsQ0FBQzRPLE9BQU87UUFDekJ4VyxlQUFlNEgsR0FBRyxDQUFDNE8sT0FBT1Y7SUFDNUI7SUFFQSxPQUFPQyxjQUFjO1FBQ25CcEM7UUFDQVQ7UUFDQTRDO0lBQ0Y7QUFDRjtBQUVBLElBQUlhLGtCQUFrQixXQUFXLEdBQUV0YSxpREFBVSxDQUFDa0IsU0FBUyxDQUFDK1gsTUFBTUM7SUFDNUQsT0FBT0QsS0FBS1EsT0FBTyxLQUFLUCxLQUFLTyxPQUFPLElBQUlSLEtBQUtTLGFBQWEsS0FBS1IsS0FBS1EsYUFBYSxJQUFJVCxLQUFLdEIsVUFBVSxLQUFLdUIsS0FBS3ZCLFVBQVUsSUFBSXNCLEtBQUt2QixpQkFBaUIsS0FBS3dCLEtBQUt4QixpQkFBaUIsSUFBSTNCLDBCQUEwQmtELEtBQUtFLFdBQVcsRUFBRUQsS0FBS0MsV0FBVyxLQUFNRixDQUFBQSxLQUFLck0sU0FBUyxLQUFLc00sS0FBS3RNLFNBQVMsSUFBSSxDQUFDLENBQUNxTSxLQUFLck0sU0FBUyxJQUFJLENBQUMsQ0FBQ3NNLEtBQUt0TSxTQUFTLElBQUkzTCx3Q0FBS0EsQ0FBQ2lWLE1BQU0sQ0FBQytDLEtBQUtyTSxTQUFTLEVBQUVzTSxLQUFLdE0sU0FBUztBQUM3VztBQUNBOztDQUVDLEdBRUQsSUFBSWdOLGlCQUFpQnRELENBQUFBO0lBQ25CLElBQUksRUFDRmdCLFVBQVUsRUFDVlQsUUFBUSxFQUNSNEMsT0FBTyxFQUNSLEdBQUduRDtJQUNKLElBQUk1TixTQUFTOE47SUFDYixJQUFJMEQsTUFBTXhSLE9BQU8ySSxRQUFRLENBQUNvSSxXQUFXLFNBQVM7SUFDOUMsT0FBTyxXQUFXLEdBQUV6WiwwREFBbUIsQ0FBQ2thLEtBQUtsWSxPQUFPdVYsTUFBTSxDQUFDLENBQUMsR0FBR0QsWUFBWTtRQUN6RWtCLE9BQU87WUFDTHpHLFVBQVU7UUFDWjtJQUNGLElBQUk4RTtBQUNOO0FBRUE7O0NBRUMsR0FFRCxJQUFJMEQsa0JBQWtCLFdBQVcsR0FBRWhhLG9EQUFhQSxDQUFDLElBQU0sRUFBRTtBQUN6RDs7Q0FFQyxHQUVELElBQUlpYSxjQUFjO0lBQ2hCLE9BQU9oYSxpREFBVUEsQ0FBQytaO0FBQ3BCO0FBRUE7O0NBRUMsR0FFRCxJQUFJRSxrQkFBa0IsV0FBVyxHQUFFbGEsb0RBQWFBLENBQUM7QUFDakQ7O0NBRUMsR0FFRCxJQUFJbWEsY0FBYztJQUNoQixPQUFPbGEsaURBQVVBLENBQUNpYTtBQUNwQjtBQUVBOztDQUVDLEdBRUQsSUFBSVYsY0FBY3pELENBQUFBO0lBQ2hCLElBQUksRUFDRjZDLFdBQVcsRUFDWDVTLElBQUksRUFDSm1ULGFBQWEsRUFDYmhDLGlCQUFpQixFQUNqQkMsVUFBVSxFQUNWL0ssU0FBUyxFQUNWLEdBQUcwSjtJQUNKLElBQUlxRSxXQUFXSDtJQUNmLElBQUk5UixTQUFTOE47SUFDYixJQUFJL0ssT0FBTzFDLFlBQVl5QyxRQUFRLENBQUM5QyxRQUFRbkM7SUFDeEMsSUFBSXNRLFdBQVcsRUFBRTtJQUNqQixJQUFJK0QsY0FBY3paLDBDQUFTQSxDQUFDNlAsU0FBUyxDQUFDekssU0FBUyxDQUFDbUMsT0FBTzJJLFFBQVEsQ0FBQzlLLFNBQVN6Rix5Q0FBTUEsQ0FBQ2taLFVBQVUsQ0FBQ3RSLFFBQVFuQztJQUVuRyxJQUFLLElBQUk1RCxJQUFJLEdBQUdBLElBQUk0RCxLQUFLc1EsUUFBUSxDQUFDalUsTUFBTSxFQUFFRCxJQUFLO1FBQzdDLElBQUlnWCxJQUFJbE8sS0FBS2pJLE1BQU0sQ0FBQ2I7UUFDcEIsSUFBSVMsSUFBSW1ELEtBQUtzUSxRQUFRLENBQUNsVSxFQUFFO1FBQ3hCLElBQUliLE1BQU1pSCxZQUFZdUMsT0FBTyxDQUFDNUMsUUFBUXRGO1FBQ3RDLElBQUlrTSxRQUFReE8seUNBQU1BLENBQUN3TyxLQUFLLENBQUM1RyxRQUFRaVI7UUFDakMsSUFBSWtCLE1BQU1qTyxhQUFhM0wsd0NBQUtBLENBQUM2WixZQUFZLENBQUN4TCxPQUFPMUM7UUFDakQsSUFBSW1PLEtBQUtKLFNBQVM7WUFBQ3ZYO1lBQUd1VztTQUFFO1FBRXhCLEtBQUssSUFBSXFCLE9BQU83QixZQUFhO1lBQzNCLElBQUk4QixJQUFJaGEsd0NBQUtBLENBQUM2WixZQUFZLENBQUNFLEtBQUsxTDtZQUVoQyxJQUFJMkwsR0FBRztnQkFDTEYsR0FBRzFCLElBQUksQ0FBQzRCO1lBQ1Y7UUFDRjtRQUVBLElBQUk5WiwwQ0FBU0EsQ0FBQzZQLFNBQVMsQ0FBQzVOLElBQUk7WUFDMUJ5VCxTQUFTd0MsSUFBSSxDQUFFLFdBQVcsR0FBRXJaLDBEQUFtQixDQUFDeWEsZ0JBQWdCUyxRQUFRLEVBQUU7Z0JBQ3hFcFosS0FBSyxZQUFZMEIsTUFBTSxDQUFDMUIsSUFBSXlCLEVBQUU7Z0JBQzlCeEIsT0FBTyxDQUFDLENBQUM4WTtZQUNYLEdBQUcsV0FBVyxHQUFFN2EsMERBQW1CLENBQUNzYSxpQkFBaUI7Z0JBQ25EbkIsYUFBYTRCO2dCQUNidEIsU0FBU3JXO2dCQUNUdEIsS0FBS0EsSUFBSXlCLEVBQUU7Z0JBQ1htVyxlQUFlQTtnQkFDZmhDLG1CQUFtQkE7Z0JBQ25CQyxZQUFZQTtnQkFDWi9LLFdBQVdpTztZQUNiO1FBQ0YsT0FBTztZQUNMaEUsU0FBU3dDLElBQUksQ0FBRSxXQUFXLEdBQUVyWiwwREFBbUIsQ0FBQ3daLGNBQWM7Z0JBQzVETCxhQUFhNEI7Z0JBQ2JqWixLQUFLQSxJQUFJeUIsRUFBRTtnQkFDWG1ELFFBQVFrVSxlQUFlalksTUFBTTRELEtBQUtzUSxRQUFRLENBQUNqVSxNQUFNLEdBQUc7Z0JBQ3BEb0UsUUFBUVQ7Z0JBQ1JtUixtQkFBbUJBO2dCQUNuQkMsWUFBWUE7Z0JBQ1pqUSxNQUFNdEU7WUFDUjtRQUNGO1FBRUFLLGNBQWM4SCxHQUFHLENBQUNuSSxHQUFHVDtRQUNyQmdCLGVBQWU0SCxHQUFHLENBQUNuSSxHQUFHbUQ7SUFDeEI7SUFFQSxPQUFPc1E7QUFDVDtBQUVBOztDQUVDLEdBRUQsSUFBSXNFLGtCQUFrQixXQUFXLEdBQUU1YSxvREFBYUEsQ0FBQztBQUNqRDs7Q0FFQyxHQUVELElBQUl1WixjQUFjO0lBQ2hCLE9BQU90WixpREFBVUEsQ0FBQzJhO0FBQ3BCO0FBRUEsSUFBSUMsZUFBZSxXQUFXLEdBQUU3YSxvREFBYUEsQ0FBQztBQUM5Qzs7Q0FFQyxHQUVELElBQUk4YSxXQUFXO0lBQ2IsSUFBSUMsVUFBVTlhLGlEQUFVQSxDQUFDNGE7SUFFekIsSUFBSSxDQUFDRSxTQUFTO1FBQ1osTUFBTSxJQUFJalEsTUFBTTtJQUNsQjtJQUVBLElBQUksRUFDRjNDLE1BQU0sRUFDUCxHQUFHNFM7SUFDSixPQUFPNVM7QUFDVDtBQUNBLElBQUk2UyxnQkFBZ0I7SUFDbEIsSUFBSUQsVUFBVTlhLGlEQUFVQSxDQUFDNGE7SUFFekIsSUFBSSxDQUFDRSxTQUFTO1FBQ1osTUFBTSxJQUFJalEsTUFBTTtJQUNsQjtJQUVBLE9BQU9pUTtBQUNUO0FBRUEsSUFBSUUsZUFBZTtBQUVuQjs7Q0FFQyxHQUVELElBQUlDLFVBQVU7SUFDWkMsTUFBTTtJQUNOQyxTQUFTO1FBQUM7UUFBUTtRQUFRO1FBQVM7UUFBTTtRQUFhO0tBQVE7SUFDOURDLGNBQWM7SUFDZEMsYUFBYTtJQUNiQyxrQkFBa0I7SUFDbEJDLGlCQUFpQjtJQUNqQkMsZ0JBQWdCO0lBQ2hCQyxlQUFlO0lBQ2ZDLGdCQUFnQjtJQUNoQkMsZUFBZTtJQUNmQyxRQUFRO0lBQ1JDLGlCQUFpQjtJQUNqQkMsWUFBWTtJQUNaQyxNQUFNO0FBQ1I7QUFDQSxJQUFJQyxnQkFBZ0I7SUFDbEJDLGtCQUFrQjtJQUNsQkMsaUJBQWlCO0lBQ2pCWixrQkFBa0I7SUFDbEJDLGlCQUFpQjtJQUNqQkMsZ0JBQWdCO1FBQUM7UUFBa0I7S0FBUztJQUM1Q0MsZUFBZTtRQUFDO1FBQWU7S0FBUztJQUN4Q1Usb0JBQW9CO0lBQ3BCQyxtQkFBbUI7UUFBQztRQUFxQjtLQUFTO0lBQ2xEQyxvQkFBb0I7SUFDcEJDLG1CQUFtQjtJQUNuQkMsb0JBQW9CO0lBQ3BCQyxtQkFBbUI7SUFDbkJDLE1BQU07SUFDTkMsb0JBQW9CO0FBQ3RCO0FBQ0EsSUFBSUMsa0JBQWtCO0lBQ3BCTixvQkFBb0I7SUFDcEJDLG1CQUFtQjtJQUNuQkcsTUFBTTtRQUFDO1FBQVU7S0FBZTtBQUNsQztBQUNBOztDQUVDLEdBRUQsSUFBSUcsU0FBU3RiLENBQUFBO0lBQ1gsSUFBSXViLFVBQVU1QixPQUFPLENBQUMzWixJQUFJO0lBQzFCLElBQUl3YixRQUFRZCxhQUFhLENBQUMxYSxJQUFJO0lBQzlCLElBQUl5YixVQUFVSixlQUFlLENBQUNyYixJQUFJO0lBQ2xDLElBQUkwYixZQUFZSCxXQUFXM2Isc0RBQVdBLENBQUMyYjtJQUN2QyxJQUFJSSxVQUFVSCxTQUFTNWIsc0RBQVdBLENBQUM0YjtJQUNuQyxJQUFJSSxZQUFZSCxXQUFXN2Isc0RBQVdBLENBQUM2YjtJQUN2QyxPQUFPdFgsQ0FBQUE7UUFDTCxJQUFJdVgsYUFBYUEsVUFBVXZYLFFBQVEsT0FBTztRQUMxQyxJQUFJa0UsWUFBWXNULFdBQVdBLFFBQVF4WCxRQUFRLE9BQU87UUFDbEQsSUFBSSxDQUFDa0UsWUFBWXVULGFBQWFBLFVBQVV6WCxRQUFRLE9BQU87UUFDdkQsT0FBTztJQUNUO0FBQ0Y7QUFDQTs7Q0FFQyxHQUdELElBQUkwWCxVQUFVO0lBQ1pDLFFBQVFSLE9BQU87SUFDZlMsV0FBV1QsT0FBTztJQUNsQlUsZ0JBQWdCVixPQUFPO0lBQ3ZCVyxlQUFlWCxPQUFPO0lBQ3RCWSxrQkFBa0JaLE9BQU87SUFDekJhLGlCQUFpQmIsT0FBTztJQUN4QmMsc0JBQXNCZCxPQUFPO0lBQzdCZSxxQkFBcUJmLE9BQU87SUFDNUJnQixzQkFBc0JoQixPQUFPO0lBQzdCaUIscUJBQXFCakIsT0FBTztJQUM1QmtCLGtCQUFrQmxCLE9BQU87SUFDekJtQixpQkFBaUJuQixPQUFPO0lBQ3hCb0Isc0JBQXNCcEIsT0FBTztJQUM3QnFCLHFCQUFxQnJCLE9BQU87SUFDNUJzQixVQUFVdEIsT0FBTztJQUNqQnVCLG9CQUFvQnZCLE9BQU87SUFDM0J3QixtQkFBbUJ4QixPQUFPO0lBQzFCeUIsb0JBQW9CekIsT0FBTztJQUMzQjBCLG1CQUFtQjFCLE9BQU87SUFDMUIyQixRQUFRM0IsT0FBTztJQUNmNEIsYUFBYTVCLE9BQU87SUFDcEI2QixjQUFjN0IsT0FBTztJQUNyQjhCLHNCQUFzQjlCLE9BQU87SUFDN0IrQixRQUFRL0IsT0FBTztBQUNqQjtBQUVBLElBQUlnQywwQkFBMEIsQ0FBQzFXLFFBQVEyVztJQUNyQyxJQUFJQyxvQkFBb0IsRUFBRTtJQUUxQixJQUFJQyxRQUFRO1FBQ1ZELG9CQUFvQixFQUFFO0lBQ3hCO0lBRUEsSUFBSUUsb0JBQW9CQyxDQUFBQTtRQUN0QixJQUFJLENBQUNKLGtCQUFrQi9MLE9BQU8sRUFBRTtZQUM5QjtRQUNGO1FBRUEsSUFBSW9NLG1CQUFtQkQsVUFBVUUsTUFBTSxDQUFDaFgsQ0FBQUEsV0FBWUYsa0JBQWtCQyxRQUFRQyxVQUFVOFc7UUFDeEZILGtCQUFrQmpHLElBQUksSUFBSXFHO0lBQzVCO0lBRUEsU0FBU0U7UUFDUCxJQUFJTixrQkFBa0IxYyxNQUFNLEdBQUcsR0FBRztZQUNoQzBjLGtCQUFrQk8sT0FBTyxHQUFHM00sT0FBTyxDQUFDdkssQ0FBQUE7Z0JBQ2xDLElBQUlBLFNBQVNtWCxJQUFJLEtBQUssaUJBQWlCO29CQUNyQywrREFBK0Q7b0JBQy9ELDJDQUEyQztvQkFDM0M7Z0JBQ0Y7Z0JBRUFuWCxTQUFTYSxZQUFZLENBQUMwSixPQUFPLENBQUMzTSxDQUFBQTtvQkFDNUJvQyxTQUFTbkcsTUFBTSxDQUFDdWQsWUFBWSxDQUFDeFosTUFBTW9DLFNBQVNxWCxXQUFXO2dCQUN6RDtnQkFDQXJYLFNBQVNZLFVBQVUsQ0FBQzJKLE9BQU8sQ0FBQzNNLENBQUFBO29CQUMxQm9DLFNBQVNuRyxNQUFNLENBQUM0USxXQUFXLENBQUM3TTtnQkFDOUI7WUFDRixJQUFJLDhEQUE4RDtZQUVsRWdaO1FBQ0Y7SUFDRjtJQUVBLE9BQU87UUFDTEM7UUFDQUk7UUFDQUw7SUFDRjtBQUNGO0FBRUEsSUFBSVUsNkJBQTZCO0lBQy9CQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsZUFBZTtJQUNmQyx1QkFBdUI7QUFDekIsR0FBRyw4R0FBOEc7QUFDakgsOEZBQThGO0FBRTlGLE1BQU1DLDRCQUE0QjVmLDRDQUFTQTtJQUN6QzRDLGFBQWM7UUFDWixLQUFLLElBQUkySjtRQUNULElBQUksQ0FBQ3FPLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ2lGLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7SUFDMUI7SUFFQXJJLFVBQVU7UUFDUixJQUFJc0k7UUFFSixJQUFJLEVBQ0ZsYSxJQUFJLEVBQ0wsR0FBRyxJQUFJLENBQUMrUCxLQUFLO1FBRWQsSUFBSSxDQUFDL1AsS0FBSytNLE9BQU8sRUFBRTtZQUNqQixNQUFNLElBQUlqSSxNQUFNO1FBQ2xCO1FBRUNvVixDQUFBQSx3QkFBd0IsSUFBSSxDQUFDRCxnQkFBZ0IsTUFBTSxRQUFRQywwQkFBMEIsS0FBSyxJQUFJLEtBQUssSUFBSUEsc0JBQXNCdEksT0FBTyxDQUFDNVIsS0FBSytNLE9BQU8sRUFBRTJNO0lBQ3RKO0lBRUFTLG9CQUFvQjtRQUNsQixJQUFJLEVBQ0ZyQixpQkFBaUIsRUFDbEIsR0FBRyxJQUFJLENBQUMvSSxLQUFLO1FBQ2QsSUFBSTVOLFNBQVMsSUFBSSxDQUFDNFMsT0FBTztRQUN6QixJQUFJLENBQUNpRixPQUFPLEdBQUduQix3QkFBd0IxVyxRQUFRMlc7UUFDL0MsSUFBSSxDQUFDbUIsZ0JBQWdCLEdBQUcsSUFBSUcsaUJBQWlCLElBQUksQ0FBQ0osT0FBTyxDQUFDZixpQkFBaUI7UUFDM0UsSUFBSSxDQUFDckgsT0FBTztJQUNkO0lBRUF5SSwwQkFBMEI7UUFDeEIsSUFBSUMsd0JBQXdCQyx3QkFBd0JDO1FBRXBELElBQUlDLG1CQUFtQixDQUFDSCx5QkFBeUIsSUFBSSxDQUFDTCxnQkFBZ0IsTUFBTSxRQUFRSywyQkFBMkIsS0FBSyxJQUFJLEtBQUssSUFBSUEsdUJBQXVCSSxXQUFXO1FBRW5LLElBQUlELHFCQUFxQixRQUFRQSxxQkFBcUIsS0FBSyxLQUFLQSxpQkFBaUJwZSxNQUFNLEVBQUU7WUFDdkYsSUFBSXNlO1lBRUhBLENBQUFBLGdCQUFnQixJQUFJLENBQUNYLE9BQU8sTUFBTSxRQUFRVyxrQkFBa0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsY0FBYzFCLGlCQUFpQixDQUFDd0I7UUFDakg7UUFFQ0YsQ0FBQUEseUJBQXlCLElBQUksQ0FBQ04sZ0JBQWdCLE1BQU0sUUFBUU0sMkJBQTJCLEtBQUssSUFBSSxLQUFLLElBQUlBLHVCQUF1QjlJLFVBQVU7UUFDMUkrSSxDQUFBQSxpQkFBaUIsSUFBSSxDQUFDUixPQUFPLE1BQU0sUUFBUVEsbUJBQW1CLEtBQUssSUFBSSxLQUFLLElBQUlBLGVBQWVuQixVQUFVO1FBQzFHLE9BQU87SUFDVDtJQUVBdUIscUJBQXFCO1FBQ25CLElBQUlDO1FBRUhBLENBQUFBLGlCQUFpQixJQUFJLENBQUNiLE9BQU8sTUFBTSxRQUFRYSxtQkFBbUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsZUFBZTdCLEtBQUs7UUFDckcsSUFBSSxDQUFDcEgsT0FBTztJQUNkO0lBRUFrSix1QkFBdUI7UUFDckIsSUFBSUM7UUFFSEEsQ0FBQUEseUJBQXlCLElBQUksQ0FBQ2QsZ0JBQWdCLE1BQU0sUUFBUWMsMkJBQTJCLEtBQUssSUFBSSxLQUFLLElBQUlBLHVCQUF1QnRKLFVBQVU7SUFDN0k7SUFFQXVKLFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQ2pMLEtBQUssQ0FBQ08sUUFBUTtJQUM1QjtBQUVGO0FBRUF5SixvQkFBb0JrQixXQUFXLEdBQUdoSztBQUNsQyxJQUFJaUssYUFBYXJYLGFBQWFrVyxzQkFBc0JoWCxDQUFBQTtJQUNsRCxJQUFJLEVBQ0Z1TixRQUFRLEVBQ1QsR0FBR3ZOO0lBQ0osT0FBTyxXQUFXLEdBQUV0SiwwREFBbUIsQ0FBQ0EsdURBQWMsRUFBRSxNQUFNNlc7QUFDaEU7QUFFQTs7O0NBR0MsR0FFRCxTQUFTNkssZ0JBQWdCaFosTUFBTSxFQUFFaVosUUFBUTtJQUN2QyxJQUFJLEVBQ0ZsVyxJQUFJLEVBQ0ptVyxJQUFJLEVBQ0wsR0FBR0Q7SUFFSixJQUFJLENBQUM3Z0IseUNBQU1BLENBQUM4VCxPQUFPLENBQUNsTSxRQUFRK0MsT0FBTztRQUNqQyxPQUFPO0lBQ1Q7SUFFQSxJQUFJbEYsT0FBT2xGLHVDQUFJQSxDQUFDK0osR0FBRyxDQUFDMUMsUUFBUStDO0lBRTVCLElBQUksQ0FBQ2xLLHVDQUFNQSxDQUFDc2dCLE1BQU0sQ0FBQ3RiLE9BQU87UUFDeEIsT0FBTztJQUNUO0lBRUEsSUFBSXFiLEtBQUtuVCxLQUFLLEtBQUtsSSxLQUFLbUIsSUFBSSxDQUFDOUUsTUFBTSxJQUFJZ2YsS0FBS2xhLElBQUksQ0FBQzlFLE1BQU0sS0FBSyxHQUFHO1FBQzdELE9BQU8yRCxLQUFLbUIsSUFBSSxDQUFDdUwsS0FBSyxDQUFDMk8sS0FBS25ULEtBQUssRUFBRW1ULEtBQUtuVCxLQUFLLEdBQUdtVCxLQUFLbGEsSUFBSSxDQUFDOUUsTUFBTSxNQUFNZ2YsS0FBS2xhLElBQUk7SUFDakY7SUFFQSxJQUFJb2EsV0FBVzFnQix1Q0FBSUEsQ0FBQzhYLElBQUksQ0FBQ3pOO0lBRXpCLElBQUksQ0FBQzNLLHlDQUFNQSxDQUFDOFQsT0FBTyxDQUFDbE0sUUFBUW9aLFdBQVc7UUFDckMsT0FBTztJQUNUO0lBRUEsSUFBSUMsV0FBVzFnQix1Q0FBSUEsQ0FBQytKLEdBQUcsQ0FBQzFDLFFBQVFvWjtJQUNoQyxPQUFPdmdCLHVDQUFNQSxDQUFDc2dCLE1BQU0sQ0FBQ0UsYUFBYUEsU0FBU3JhLElBQUksQ0FBQ3VILFVBQVUsQ0FBQzJTLEtBQUtsYSxJQUFJO0FBQ3RFO0FBQ0EsU0FBU3NhLGdCQUFnQnRhLElBQUk7SUFDM0IsSUFBSyxJQUFJdWEsT0FBT2hWLFVBQVVySyxNQUFNLEVBQUVzZixRQUFRLElBQUlyYSxNQUFNb2EsT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUUsT0FBTyxHQUFHQSxPQUFPRixNQUFNRSxPQUFRO1FBQzNHRCxLQUFLLENBQUNDLE9BQU8sRUFBRSxHQUFHbFYsU0FBUyxDQUFDa1YsS0FBSztJQUNuQztJQUVBLE9BQU9ELE1BQU1FLE1BQU0sQ0FBQyxDQUFDMWEsTUFBTWthLE9BQVNsYSxLQUFLdUwsS0FBSyxDQUFDLEdBQUcyTyxLQUFLblQsS0FBSyxJQUFJbVQsS0FBS2xhLElBQUksR0FBR0EsS0FBS3VMLEtBQUssQ0FBQzJPLEtBQUtoVCxHQUFHLEdBQUdsSDtBQUNwRztBQUVBLFNBQVMyYSwwQkFBMEJDLEdBQUcsRUFBRXJNLE9BQU87SUFDN0MsSUFBSXJULFNBQVNzTSxLQUFLQyxHQUFHLENBQUNtVCxJQUFJMWYsTUFBTSxFQUFFcVQsUUFBUXJULE1BQU07SUFFaEQsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLElBQUlDLFFBQVFELElBQUs7UUFDL0IsSUFBSTJmLElBQUlDLE1BQU0sQ0FBQzVmLE9BQU9zVCxRQUFRc00sTUFBTSxDQUFDNWYsSUFBSTtZQUN2QyxPQUFPQTtRQUNUO0lBQ0Y7SUFFQSxPQUFPQztBQUNUO0FBRUEsU0FBUzRmLDBCQUEwQkYsR0FBRyxFQUFFck0sT0FBTyxFQUFFN0csR0FBRztJQUNsRCxJQUFJeE0sU0FBU3NNLEtBQUtDLEdBQUcsQ0FBQ21ULElBQUkxZixNQUFNLEVBQUVxVCxRQUFRclQsTUFBTSxFQUFFd007SUFFbEQsSUFBSyxJQUFJek0sSUFBSSxHQUFHQSxJQUFJQyxRQUFRRCxJQUFLO1FBQy9CLElBQUkyZixJQUFJQyxNQUFNLENBQUNELElBQUkxZixNQUFNLEdBQUdELElBQUksT0FBT3NULFFBQVFzTSxNQUFNLENBQUN0TSxRQUFRclQsTUFBTSxHQUFHRCxJQUFJLElBQUk7WUFDN0UsT0FBT0E7UUFDVDtJQUNGO0lBRUEsT0FBT0M7QUFDVDtBQUNBOztDQUVDLEdBR0QsU0FBUzZmLG9CQUFvQkMsVUFBVSxFQUFFZCxJQUFJO0lBQzNDLElBQUksRUFDRm5ULEtBQUssRUFDTEcsR0FBRyxFQUNIbEgsSUFBSSxFQUNMLEdBQUdrYTtJQUNKLElBQUllLGNBQWNELFdBQVd6UCxLQUFLLENBQUN4RSxPQUFPRztJQUMxQyxJQUFJZ1UsZUFBZVAsMEJBQTBCTSxhQUFhamI7SUFDMUQsSUFBSTBILE1BQU1GLEtBQUtDLEdBQUcsQ0FBQ3dULFlBQVkvZixNQUFNLEdBQUdnZ0IsY0FBY2xiLEtBQUs5RSxNQUFNLEdBQUdnZ0I7SUFDcEUsSUFBSUMsZUFBZUwsMEJBQTBCRyxhQUFhamIsTUFBTTBIO0lBQ2hFLElBQUkwVCxhQUFhO1FBQ2ZyVSxPQUFPQSxRQUFRbVU7UUFDZmhVLEtBQUtBLE1BQU1pVTtRQUNYbmIsTUFBTUEsS0FBS3VMLEtBQUssQ0FBQzJQLGNBQWNsYixLQUFLOUUsTUFBTSxHQUFHaWdCO0lBQy9DO0lBRUEsSUFBSUMsV0FBV3JVLEtBQUssS0FBS3FVLFdBQVdsVSxHQUFHLElBQUlrVSxXQUFXcGIsSUFBSSxDQUFDOUUsTUFBTSxLQUFLLEdBQUc7UUFDdkUsT0FBTztJQUNUO0lBRUEsT0FBT2tnQjtBQUNUO0FBQ0E7OztDQUdDLEdBRUQsU0FBU0MsaUJBQWlCTCxVQUFVLEVBQUVNLENBQUMsRUFBRUMsQ0FBQztJQUN4QyxJQUFJeFUsUUFBUVMsS0FBS0MsR0FBRyxDQUFDNlQsRUFBRXZVLEtBQUssRUFBRXdVLEVBQUV4VSxLQUFLO0lBQ3JDLElBQUl5VSxVQUFVaFUsS0FBS0UsR0FBRyxDQUFDLEdBQUdGLEtBQUtDLEdBQUcsQ0FBQzZULEVBQUV2VSxLQUFLLEdBQUd1VSxFQUFFdGIsSUFBSSxDQUFDOUUsTUFBTSxFQUFFcWdCLEVBQUVyVSxHQUFHLElBQUlxVSxFQUFFeFUsS0FBSztJQUM1RSxJQUFJMFUsVUFBVW5CLGdCQUFnQlUsWUFBWU0sR0FBR0M7SUFDN0MsSUFBSUcsV0FBV2xVLEtBQUtFLEdBQUcsQ0FBQzZULEVBQUV4VSxLQUFLLEdBQUd3VSxFQUFFdmIsSUFBSSxDQUFDOUUsTUFBTSxFQUFFb2dCLEVBQUV2VSxLQUFLLEdBQUd1VSxFQUFFdGIsSUFBSSxDQUFDOUUsTUFBTSxHQUFJb2dCLENBQUFBLEVBQUV2VSxLQUFLLEdBQUd1VSxFQUFFdGIsSUFBSSxDQUFDOUUsTUFBTSxHQUFHcWdCLEVBQUV4VSxLQUFLLEdBQUd3VSxFQUFFdmIsSUFBSSxDQUFDOUUsTUFBTSxHQUFHLEtBQUtzZ0I7SUFDckksSUFBSXhiLE9BQU95YixRQUFRbFEsS0FBSyxDQUFDeEUsT0FBTzJVO0lBQ2hDLElBQUl4VSxNQUFNTSxLQUFLRSxHQUFHLENBQUM0VCxFQUFFcFUsR0FBRyxFQUFFcVUsRUFBRXJVLEdBQUcsR0FBR29VLEVBQUV0YixJQUFJLENBQUM5RSxNQUFNLEdBQUlvZ0IsQ0FBQUEsRUFBRXBVLEdBQUcsR0FBR29VLEVBQUV2VSxLQUFLO0lBQ2xFLE9BQU9nVSxvQkFBb0JDLFlBQVk7UUFDckNqVTtRQUNBRztRQUNBbEg7SUFDRjtBQUNGO0FBQ0E7O0NBRUMsR0FFRCxTQUFTMmIsWUFBWTFCLFFBQVE7SUFDM0IsSUFBSSxFQUNGbFcsSUFBSSxFQUNKbVcsSUFBSSxFQUNMLEdBQUdEO0lBQ0osT0FBTztRQUNMcFMsUUFBUTtZQUNOOUQ7WUFDQWpGLFFBQVFvYixLQUFLblQsS0FBSztRQUNwQjtRQUNBaEMsT0FBTztZQUNMaEI7WUFDQWpGLFFBQVFvYixLQUFLaFQsR0FBRztRQUNsQjtJQUNGO0FBQ0Y7QUFDQTs7Ozs7Q0FLQyxHQUVELFNBQVMwVSxlQUFlNWEsTUFBTSxFQUFFeUYsS0FBSztJQUNuQyxJQUFJLEVBQ0YxQyxJQUFJLEVBQ0pqRixNQUFNLEVBQ1AsR0FBRzJIO0lBRUosSUFBSSxDQUFDck4seUNBQU1BLENBQUM4VCxPQUFPLENBQUNsTSxRQUFRK0MsT0FBTztRQUNqQyxPQUFPO0lBQ1Q7SUFFQSxJQUFJOEssT0FBT2xWLHVDQUFJQSxDQUFDK0osR0FBRyxDQUFDMUMsUUFBUStDO0lBRTVCLElBQUksQ0FBQ2xLLHVDQUFNQSxDQUFDc2dCLE1BQU0sQ0FBQ3RMLE9BQU87UUFDeEIsT0FBTztJQUNUO0lBRUEsSUFBSWdOLGNBQWN6aUIseUNBQU1BLENBQUMwaUIsS0FBSyxDQUFDOWEsUUFBUTtRQUNyQ0YsT0FBT3BGLENBQUFBLElBQUtqQywwQ0FBU0EsQ0FBQzZQLFNBQVMsQ0FBQzVOLE1BQU10Qyx5Q0FBTUEsQ0FBQzJpQixPQUFPLENBQUMvYSxRQUFRdEY7UUFDN0RpTCxJQUFJNUM7SUFDTjtJQUVBLElBQUksQ0FBQzhYLGFBQWE7UUFDaEIsT0FBTztJQUNUO0lBRUEsTUFBTy9jLFNBQVMrUCxLQUFLN08sSUFBSSxDQUFDOUUsTUFBTSxDQUFFO1FBQ2hDLElBQUk4Z0IsUUFBUTVpQix5Q0FBTUEsQ0FBQ29ZLElBQUksQ0FBQ3hRLFFBQVE7WUFDOUIyRixJQUFJNUM7WUFDSmpELE9BQU9qSCx1Q0FBTUEsQ0FBQ3NnQixNQUFNO1FBQ3RCO1FBRUEsSUFBSSxDQUFDNkIsU0FBUyxDQUFDdGlCLHVDQUFJQSxDQUFDdWlCLFlBQVksQ0FBQ0QsS0FBSyxDQUFDLEVBQUUsRUFBRUgsV0FBVyxDQUFDLEVBQUUsR0FBRztZQUMxRCxPQUFPO1FBQ1Q7UUFFQS9jLFVBQVUrUCxLQUFLN08sSUFBSSxDQUFDOUUsTUFBTTtRQUMxQjJULE9BQU9tTixLQUFLLENBQUMsRUFBRTtRQUNmalksT0FBT2lZLEtBQUssQ0FBQyxFQUFFO0lBQ2pCO0lBRUEsT0FBTztRQUNMalk7UUFDQWpGO0lBQ0Y7QUFDRjtBQUNBOztDQUVDLEdBRUQsU0FBU29kLGVBQWVsYixNQUFNLEVBQUU0RyxLQUFLO0lBQ25DLElBQUlDLFNBQVMrVCxlQUFlNWEsUUFBUTRHLE1BQU1DLE1BQU07SUFFaEQsSUFBSSxDQUFDQSxRQUFRO1FBQ1gsT0FBTztJQUNUO0lBRUEsSUFBSXRPLHdDQUFLQSxDQUFDME8sV0FBVyxDQUFDTCxRQUFRO1FBQzVCLE9BQU87WUFDTEM7WUFDQTlDLE9BQU84QztRQUNUO0lBQ0Y7SUFFQSxJQUFJOUMsUUFBUTZXLGVBQWU1YSxRQUFRNEcsTUFBTTdDLEtBQUs7SUFFOUMsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBRUEsT0FBTztRQUNMOEM7UUFDQTlDO0lBQ0Y7QUFDRjtBQUNBLFNBQVNvWCxzQkFBc0JuYixNQUFNLEVBQUV5RixLQUFLLEVBQUUyVixFQUFFO0lBQzlDLElBQUlDLGVBQWVwZix3QkFBd0J5RyxHQUFHLENBQUMxQztJQUMvQyxJQUFJaVosV0FBV29DLGlCQUFpQixRQUFRQSxpQkFBaUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsYUFBYTFhLElBQUksQ0FBQ0MsQ0FBQUE7UUFDM0YsSUFBSSxFQUNGbUMsSUFBSSxFQUNMLEdBQUduQztRQUNKLE9BQU9sSSx1Q0FBSUEsQ0FBQzhVLE1BQU0sQ0FBQ3pLLE1BQU0wQyxNQUFNMUMsSUFBSTtJQUNyQztJQUVBLElBQUksQ0FBQ2tXLFlBQVl4VCxNQUFNM0gsTUFBTSxJQUFJbWIsU0FBU0MsSUFBSSxDQUFDblQsS0FBSyxFQUFFO1FBQ3BELE9BQU9qTix3Q0FBS0EsQ0FBQ3dpQixTQUFTLENBQUM3VixPQUFPMlYsSUFBSTtZQUNoQ0csVUFBVTtRQUNaO0lBQ0Y7SUFFQSxJQUFJLEVBQ0ZyQyxJQUFJLEVBQ0wsR0FBR0QsVUFBVSx5RkFBeUY7SUFDdkcsa0VBQWtFO0lBRWxFLElBQUl4VCxNQUFNM0gsTUFBTSxJQUFJb2IsS0FBS25ULEtBQUssR0FBR21ULEtBQUtsYSxJQUFJLENBQUM5RSxNQUFNLEVBQUU7UUFDakQsSUFBSXNoQixVQUFVO1lBQ1p6WSxNQUFNMEMsTUFBTTFDLElBQUk7WUFDaEJqRixRQUFRb2IsS0FBS25ULEtBQUs7UUFDcEI7UUFFQSxJQUFJMFYsZUFBZTNpQix3Q0FBS0EsQ0FBQ3dpQixTQUFTLENBQUNFLFNBQVNKLElBQUk7WUFDOUNHLFVBQVU7UUFDWjtRQUVBLElBQUksQ0FBQ0UsY0FBYztZQUNqQixPQUFPO1FBQ1Q7UUFFQSxPQUFPO1lBQ0wxWSxNQUFNMFksYUFBYTFZLElBQUk7WUFDdkJqRixRQUFRMmQsYUFBYTNkLE1BQU0sR0FBRzJILE1BQU0zSCxNQUFNLEdBQUdvYixLQUFLblQsS0FBSztRQUN6RDtJQUNGLEVBQUUsMkNBQTJDO0lBRzdDLElBQUljLFNBQVM7UUFDWDlELE1BQU0wQyxNQUFNMUMsSUFBSTtRQUNoQmpGLFFBQVEySCxNQUFNM0gsTUFBTSxHQUFHb2IsS0FBS2xhLElBQUksQ0FBQzlFLE1BQU0sR0FBR2dmLEtBQUtoVCxHQUFHLEdBQUdnVCxLQUFLblQsS0FBSztJQUNqRTtJQUNBLElBQUkyVixjQUFjNWlCLHdDQUFLQSxDQUFDd2lCLFNBQVMsQ0FBQ3pVLFFBQVF1VSxJQUFJO1FBQzVDRyxVQUFVO0lBQ1o7SUFFQSxJQUFJLENBQUNHLGFBQWE7UUFDaEIsT0FBTztJQUNUO0lBRUEsSUFBSU4sR0FBR2hFLElBQUksS0FBSyxnQkFBZ0IxZSx1Q0FBSUEsQ0FBQzhVLE1BQU0sQ0FBQzROLEdBQUdyWSxJQUFJLEVBQUUwQyxNQUFNMUMsSUFBSSxLQUFLOEQsT0FBTy9JLE1BQU0sR0FBR3NkLEdBQUcvUixRQUFRLElBQUk2UCxLQUFLblQsS0FBSyxHQUFHcVYsR0FBRy9SLFFBQVEsRUFBRTtRQUMzSCxPQUFPcVM7SUFDVDtJQUVBLE9BQU87UUFDTDNZLE1BQU0yWSxZQUFZM1ksSUFBSTtRQUN0QmpGLFFBQVE0ZCxZQUFZNWQsTUFBTSxHQUFHb2IsS0FBS2xhLElBQUksQ0FBQzlFLE1BQU0sR0FBR2dmLEtBQUtoVCxHQUFHLEdBQUdnVCxLQUFLblQsS0FBSztJQUN2RTtBQUNGO0FBQ0EsU0FBUzRWLHNCQUFzQjNiLE1BQU0sRUFBRTRHLEtBQUssRUFBRXdVLEVBQUU7SUFDOUMsSUFBSXZVLFNBQVNzVSxzQkFBc0JuYixRQUFRNEcsTUFBTUMsTUFBTSxFQUFFdVU7SUFFekQsSUFBSSxDQUFDdlUsUUFBUTtRQUNYLE9BQU87SUFDVDtJQUVBLElBQUl0Tyx3Q0FBS0EsQ0FBQzBPLFdBQVcsQ0FBQ0wsUUFBUTtRQUM1QixPQUFPO1lBQ0xDO1lBQ0E5QyxPQUFPOEM7UUFDVDtJQUNGO0lBRUEsSUFBSTlDLFFBQVFvWCxzQkFBc0JuYixRQUFRNEcsTUFBTTdDLEtBQUssRUFBRXFYO0lBRXZELElBQUksQ0FBQ3JYLE9BQU87UUFDVixPQUFPO0lBQ1Q7SUFFQSxPQUFPO1FBQ0w4QztRQUNBOUM7SUFDRjtBQUNGO0FBQ0EsU0FBUzZYLGtCQUFrQjNDLFFBQVEsRUFBRW1DLEVBQUU7SUFDckMsSUFBSSxFQUNGclksSUFBSSxFQUNKbVcsSUFBSSxFQUNKcmUsRUFBRSxFQUNILEdBQUdvZTtJQUVKLE9BQVFtQyxHQUFHaEUsSUFBSTtRQUNiLEtBQUs7WUFDSDtnQkFDRSxJQUFJLENBQUMxZSx1Q0FBSUEsQ0FBQzhVLE1BQU0sQ0FBQzROLEdBQUdyWSxJQUFJLEVBQUVBLFNBQVNxWSxHQUFHdGQsTUFBTSxJQUFJb2IsS0FBS2hULEdBQUcsRUFBRTtvQkFDeEQsT0FBTytTO2dCQUNUO2dCQUVBLElBQUltQyxHQUFHdGQsTUFBTSxJQUFJb2IsS0FBS25ULEtBQUssRUFBRTtvQkFDM0IsT0FBTzt3QkFDTG1ULE1BQU07NEJBQ0puVCxPQUFPcVYsR0FBR3BjLElBQUksQ0FBQzlFLE1BQU0sR0FBR2dmLEtBQUtuVCxLQUFLOzRCQUNsQ0csS0FBS2tWLEdBQUdwYyxJQUFJLENBQUM5RSxNQUFNLEdBQUdnZixLQUFLaFQsR0FBRzs0QkFDOUJsSCxNQUFNa2EsS0FBS2xhLElBQUk7d0JBQ2pCO3dCQUNBbkU7d0JBQ0FrSTtvQkFDRjtnQkFDRjtnQkFFQSxPQUFPO29CQUNMbVcsTUFBTTt3QkFDSm5ULE9BQU9tVCxLQUFLblQsS0FBSzt3QkFDakJHLEtBQUtnVCxLQUFLaFQsR0FBRyxHQUFHa1YsR0FBR3BjLElBQUksQ0FBQzlFLE1BQU07d0JBQzlCOEUsTUFBTWthLEtBQUtsYSxJQUFJO29CQUNqQjtvQkFDQW5FO29CQUNBa0k7Z0JBQ0Y7WUFDRjtRQUVGLEtBQUs7WUFDSDtnQkFDRSxJQUFJLENBQUNySyx1Q0FBSUEsQ0FBQzhVLE1BQU0sQ0FBQzROLEdBQUdyWSxJQUFJLEVBQUVBLFNBQVNxWSxHQUFHdGQsTUFBTSxJQUFJb2IsS0FBS2hULEdBQUcsRUFBRTtvQkFDeEQsT0FBTytTO2dCQUNUO2dCQUVBLElBQUltQyxHQUFHdGQsTUFBTSxHQUFHc2QsR0FBR3BjLElBQUksQ0FBQzlFLE1BQU0sSUFBSWdmLEtBQUtuVCxLQUFLLEVBQUU7b0JBQzVDLE9BQU87d0JBQ0xtVCxNQUFNOzRCQUNKblQsT0FBT21ULEtBQUtuVCxLQUFLLEdBQUdxVixHQUFHcGMsSUFBSSxDQUFDOUUsTUFBTTs0QkFDbENnTSxLQUFLZ1QsS0FBS2hULEdBQUcsR0FBR2tWLEdBQUdwYyxJQUFJLENBQUM5RSxNQUFNOzRCQUM5QjhFLE1BQU1rYSxLQUFLbGEsSUFBSTt3QkFDakI7d0JBQ0FuRTt3QkFDQWtJO29CQUNGO2dCQUNGO2dCQUVBLE9BQU87b0JBQ0xtVyxNQUFNO3dCQUNKblQsT0FBT21ULEtBQUtuVCxLQUFLO3dCQUNqQkcsS0FBS2dULEtBQUtoVCxHQUFHLEdBQUdrVixHQUFHcGMsSUFBSSxDQUFDOUUsTUFBTTt3QkFDOUI4RSxNQUFNa2EsS0FBS2xhLElBQUk7b0JBQ2pCO29CQUNBbkU7b0JBQ0FrSTtnQkFDRjtZQUNGO1FBRUYsS0FBSztZQUNIO2dCQUNFLElBQUksQ0FBQ3JLLHVDQUFJQSxDQUFDOFUsTUFBTSxDQUFDNE4sR0FBR3JZLElBQUksRUFBRUEsU0FBU3FZLEdBQUcvUixRQUFRLElBQUk2UCxLQUFLaFQsR0FBRyxFQUFFO29CQUMxRCxPQUFPO3dCQUNMZ1Q7d0JBQ0FyZTt3QkFDQWtJLE1BQU1ySyx1Q0FBSUEsQ0FBQzRpQixTQUFTLENBQUN2WSxNQUFNcVksSUFBSTs0QkFDN0JHLFVBQVU7d0JBQ1o7b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsSUFBSUgsR0FBRy9SLFFBQVEsR0FBRzZQLEtBQUtuVCxLQUFLLEVBQUU7b0JBQzVCLE9BQU87d0JBQ0xtVCxNQUFNOzRCQUNKblQsT0FBT21ULEtBQUtuVCxLQUFLOzRCQUNqQkcsS0FBS00sS0FBS0MsR0FBRyxDQUFDMlUsR0FBRy9SLFFBQVEsRUFBRTZQLEtBQUtoVCxHQUFHOzRCQUNuQ2xILE1BQU1rYSxLQUFLbGEsSUFBSTt3QkFDakI7d0JBQ0FuRTt3QkFDQWtJO29CQUNGO2dCQUNGO2dCQUVBLE9BQU87b0JBQ0xtVyxNQUFNO3dCQUNKblQsT0FBT21ULEtBQUtuVCxLQUFLLEdBQUdxVixHQUFHL1IsUUFBUTt3QkFDL0JuRCxLQUFLZ1QsS0FBS2hULEdBQUcsR0FBR2tWLEdBQUcvUixRQUFRO3dCQUMzQnJLLE1BQU1rYSxLQUFLbGEsSUFBSTtvQkFDakI7b0JBQ0FuRTtvQkFDQWtJLE1BQU1ySyx1Q0FBSUEsQ0FBQzRpQixTQUFTLENBQUN2WSxNQUFNcVksSUFBSTt3QkFDN0JHLFVBQVU7b0JBQ1o7Z0JBQ0Y7WUFDRjtRQUVGLEtBQUs7WUFDSDtnQkFDRSxJQUFJLENBQUM3aUIsdUNBQUlBLENBQUM4VSxNQUFNLENBQUM0TixHQUFHclksSUFBSSxFQUFFQSxPQUFPO29CQUMvQixPQUFPO3dCQUNMbVc7d0JBQ0FyZTt3QkFDQWtJLE1BQU1ySyx1Q0FBSUEsQ0FBQzRpQixTQUFTLENBQUN2WSxNQUFNcVk7b0JBQzdCO2dCQUNGO2dCQUVBLE9BQU87b0JBQ0xsQyxNQUFNO3dCQUNKblQsT0FBT21ULEtBQUtuVCxLQUFLLEdBQUdxVixHQUFHL1IsUUFBUTt3QkFDL0JuRCxLQUFLZ1QsS0FBS2hULEdBQUcsR0FBR2tWLEdBQUcvUixRQUFRO3dCQUMzQnJLLE1BQU1rYSxLQUFLbGEsSUFBSTtvQkFDakI7b0JBQ0FuRTtvQkFDQWtJLE1BQU1ySyx1Q0FBSUEsQ0FBQzRpQixTQUFTLENBQUN2WSxNQUFNcVk7Z0JBQzdCO1lBQ0Y7SUFDSjtJQUVBLElBQUlTLFVBQVVuakIsdUNBQUlBLENBQUM0aUIsU0FBUyxDQUFDdlksTUFBTXFZO0lBRW5DLElBQUksQ0FBQ1MsU0FBUztRQUNaLE9BQU87SUFDVDtJQUVBLE9BQU87UUFDTDNDO1FBQ0FuVyxNQUFNOFk7UUFDTmhoQjtJQUNGO0FBQ0Y7QUFFQSxTQUFTaWhCLFVBQVVDLE1BQU0sRUFBRUMsY0FBYztJQUFJLElBQUloaUIsT0FBT1YsT0FBT1UsSUFBSSxDQUFDK2hCO0lBQVMsSUFBSXppQixPQUFPZSxxQkFBcUIsRUFBRTtRQUFFLElBQUk0aEIsVUFBVTNpQixPQUFPZSxxQkFBcUIsQ0FBQzBoQjtRQUFTLElBQUlDLGdCQUFnQjtZQUFFQyxVQUFVQSxRQUFRaEYsTUFBTSxDQUFDLFNBQVVpRixHQUFHO2dCQUFJLE9BQU81aUIsT0FBTzZpQix3QkFBd0IsQ0FBQ0osUUFBUUcsS0FBSzFpQixVQUFVO1lBQUU7UUFBSTtRQUFFUSxLQUFLMlcsSUFBSSxDQUFDeUwsS0FBSyxDQUFDcGlCLE1BQU1paUI7SUFBVTtJQUFFLE9BQU9qaUI7QUFBTTtBQUUxVixTQUFTcWlCLGdCQUFnQnZpQixNQUFNO0lBQUksSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlzSyxVQUFVckssTUFBTSxFQUFFRCxJQUFLO1FBQUUsSUFBSUwsU0FBUzJLLFNBQVMsQ0FBQ3RLLEVBQUUsSUFBSSxPQUFPc0ssU0FBUyxDQUFDdEssRUFBRSxHQUFHLENBQUM7UUFBRyxJQUFJQSxJQUFJLEdBQUc7WUFBRTZoQixVQUFVeGlCLE9BQU9NLFNBQVMsTUFBTTRRLE9BQU8sQ0FBQyxTQUFVcFIsR0FBRztnQkFBSUYsZ0JBQWdCWSxRQUFRVixLQUFLUSxNQUFNLENBQUNSLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSUUsT0FBT2dqQix5QkFBeUIsRUFBRTtZQUFFaGpCLE9BQU9pakIsZ0JBQWdCLENBQUN6aUIsUUFBUVIsT0FBT2dqQix5QkFBeUIsQ0FBQzFpQjtRQUFVLE9BQU87WUFBRWtpQixVQUFVeGlCLE9BQU9NLFNBQVM0USxPQUFPLENBQUMsU0FBVXBSLEdBQUc7Z0JBQUlFLE9BQU9DLGNBQWMsQ0FBQ08sUUFBUVYsS0FBS0UsT0FBTzZpQix3QkFBd0IsQ0FBQ3ZpQixRQUFRUjtZQUFPO1FBQUk7SUFBRTtJQUFFLE9BQU9VO0FBQVE7QUFDM2hCLHlKQUF5SjtBQUV6SixJQUFJMGlCLGdCQUFnQixJQUFJLHNGQUFzRjtBQUU5RyxJQUFJQyxjQUFjLEtBQUssb0RBQW9EO0FBRTNFLElBQUlDLFFBQVEsU0FBU0EsU0FBUyxHQUFHLG1EQUFtRDtBQUdwRixJQUFJQyxpQkFBaUJ0akIsQ0FBQUEsUUFBUyxDQUFDQSxVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTXVCLFdBQVcsQ0FBQ2dpQixJQUFJLE1BQU07QUFFekcsU0FBU0MsMEJBQTBCamMsSUFBSTtJQUNyQyxJQUFJLEVBQ0ZaLE1BQU0sRUFDTjhjLDRCQUE0QixFQUM1QkMsb0JBQW9CLEVBQ3JCLEdBQUduYztJQUNKLElBQUlvYyxXQUFXO0lBQ2YsSUFBSUMsMEJBQTBCO0lBQzlCLElBQUlDLGlCQUFpQjtJQUNyQixJQUFJQyxrQkFBa0I7SUFDdEIsSUFBSUMsWUFBWTtJQUNoQixJQUFJQyxxQkFBcUI7SUFFekIsSUFBSUMsd0JBQXdCO1FBQzFCLElBQUlDLG1CQUFtQnBoQiw0QkFBNEJ1RyxHQUFHLENBQUMxQztRQUN2RDdELDRCQUE0QnFULE1BQU0sQ0FBQ3hQO1FBRW5DLElBQUl1ZCxrQkFBa0I7WUFDcEIsSUFBSSxFQUNGclosU0FBUyxFQUNWLEdBQUdsRTtZQUNKLElBQUlvYSxhQUFhYyxlQUFlbGIsUUFBUXVkO1lBRXhDLElBQUluRCxjQUFlLEVBQUNsVyxhQUFhLENBQUMzTCx3Q0FBS0EsQ0FBQ2lWLE1BQU0sQ0FBQzRNLFlBQVlsVyxVQUFTLEdBQUk7Z0JBQ3RFNUwsNkNBQVVBLENBQUNrbEIsTUFBTSxDQUFDeGQsUUFBUW9hO1lBQzVCO1FBQ0Y7SUFDRjtJQUVBLElBQUlxRCxnQkFBZ0I7UUFDbEIsSUFBSUMsU0FBU3hoQix5QkFBeUJ3RyxHQUFHLENBQUMxQztRQUMxQzlELHlCQUF5QnNULE1BQU0sQ0FBQ3hQO1FBRWhDLElBQUksQ0FBQzBkLFFBQVE7WUFDWDtRQUNGO1FBRUEsSUFBSUEsT0FBTy9YLEVBQUUsRUFBRTtZQUNiLElBQUk3TCxTQUFTaEIsd0NBQUtBLENBQUM2a0IsT0FBTyxDQUFDRCxPQUFPL1gsRUFBRSxJQUFJaVYsZUFBZTVhLFFBQVEwZCxPQUFPL1gsRUFBRSxJQUFJdVYsZUFBZWxiLFFBQVEwZCxPQUFPL1gsRUFBRTtZQUU1RyxJQUFJLENBQUM3TCxRQUFRO2dCQUNYO1lBQ0Y7WUFFQSxJQUFJOGpCLGVBQWV4bEIseUNBQU1BLENBQUN3TyxLQUFLLENBQUM1RyxRQUFRbEc7WUFFeEMsSUFBSSxDQUFDa0csT0FBT2tFLFNBQVMsSUFBSSxDQUFDM0wsd0NBQUtBLENBQUNpVixNQUFNLENBQUN4TixPQUFPa0UsU0FBUyxFQUFFMFosZUFBZTtnQkFDdEV0bEIsNkNBQVVBLENBQUNrbEIsTUFBTSxDQUFDeGQsUUFBUWxHO1lBQzVCO1FBQ0Y7UUFFQTRqQixPQUFPRyxHQUFHO0lBQ1o7SUFFQSxJQUFJQyxRQUFRO1FBQ1YsSUFBSVosZ0JBQWdCO1lBQ2xCYSxhQUFhYjtZQUNiQSxpQkFBaUI7UUFDbkI7UUFFQSxJQUFJQyxpQkFBaUI7WUFDbkJZLGFBQWFaO1lBQ2JBLGtCQUFrQjtRQUNwQjtRQUVBLElBQUksQ0FBQ2EscUJBQXFCLENBQUNDLG9CQUFvQjtZQUM3Q1g7WUFDQTtRQUNGO1FBRUEsSUFBSSxDQUFDTixVQUFVO1lBQ2JBLFdBQVc7WUFDWGtCLFdBQVcsSUFBTWxCLFdBQVc7UUFDOUI7UUFFQSxJQUFJaUIsb0JBQW9CO1lBQ3RCakIsV0FBVztRQUNiO1FBRUEsSUFBSW1CLGVBQWVuZSxPQUFPa0UsU0FBUyxJQUFJOUwseUNBQU1BLENBQUNnbUIsUUFBUSxDQUFDcGUsUUFBUUEsT0FBT2tFLFNBQVMsRUFBRTtZQUMvRXFYLFVBQVU7UUFDWjtRQUNBdmYscUJBQXFCNkcsR0FBRyxDQUFDN0MsUUFBUUEsT0FBT3FlLEtBQUs7UUFDN0MzQixNQUFNLFNBQVN4Z0IseUJBQXlCd0csR0FBRyxDQUFDMUMsU0FBUy9ELHdCQUF3QnlHLEdBQUcsQ0FBQzFDO1FBQ2pGLElBQUlzZSwwQkFBMEJOO1FBQzlCLElBQUk5RTtRQUVKLE1BQU9BLE9BQU8sQ0FBQ3FGLHdCQUF3QnRpQix3QkFBd0J5RyxHQUFHLENBQUMxQyxPQUFNLE1BQU8sUUFBUXVlLDBCQUEwQixLQUFLLElBQUksS0FBSyxJQUFJQSxxQkFBcUIsQ0FBQyxFQUFFLENBQUU7WUFDNUosSUFBSUEsdUJBQXVCQztZQUUzQixJQUFJQyxlQUFlMWlCLGtDQUFrQzJHLEdBQUcsQ0FBQzFDO1lBRXpELElBQUl5ZSxpQkFBaUJqYSxXQUFXO2dCQUM5QnpJLGtDQUFrQ3lULE1BQU0sQ0FBQ3hQO2dCQUN6Q0EsT0FBT3FlLEtBQUssR0FBR0k7WUFDakI7WUFFQSxJQUFJQSxnQkFBZ0JwQix1QkFBdUIsT0FBTztnQkFDaERBLHFCQUFxQjtZQUN2QjtZQUVBLElBQUl6VyxRQUFRK1QsWUFBWXpCO1lBRXhCLElBQUksQ0FBQ2xaLE9BQU9rRSxTQUFTLElBQUksQ0FBQzNMLHdDQUFLQSxDQUFDaVYsTUFBTSxDQUFDeE4sT0FBT2tFLFNBQVMsRUFBRTBDLFFBQVE7Z0JBQy9EdE8sNkNBQVVBLENBQUNrbEIsTUFBTSxDQUFDeGQsUUFBUTRHO1lBQzVCO1lBRUEsSUFBSXNTLEtBQUtBLElBQUksQ0FBQ2xhLElBQUksRUFBRTtnQkFDbEI1Ryx5Q0FBTUEsQ0FBQ3NtQixVQUFVLENBQUMxZSxRQUFRa1osS0FBS0EsSUFBSSxDQUFDbGEsSUFBSTtZQUMxQyxPQUFPO2dCQUNMNUcseUNBQU1BLENBQUN1bUIsY0FBYyxDQUFDM2U7WUFDeEIsRUFBRSxnRkFBZ0Y7WUFDbEYsa0JBQWtCO1lBR2xCL0Qsd0JBQXdCNEcsR0FBRyxDQUFDN0MsUUFBUSxDQUFDd2UseUJBQXlCdmlCLHdCQUF3QnlHLEdBQUcsQ0FBQzFDLE9BQU0sTUFBTyxRQUFRd2UsMkJBQTJCLEtBQUssSUFBSSxLQUFLLElBQUlBLHVCQUF1QnZILE1BQU0sQ0FBQzJILENBQUFBO2dCQUN4TCxJQUFJLEVBQ0YvakIsRUFBRSxFQUNILEdBQUcrakI7Z0JBQ0osT0FBTy9qQixPQUFPcWUsS0FBS3JlLEVBQUU7WUFDdkI7WUFFQSxJQUFJLENBQUNtZSxnQkFBZ0JoWixRQUFRa1osT0FBTztnQkFDbENvRiwwQkFBMEI7Z0JBQzFCcGlCLHlCQUF5QnNULE1BQU0sQ0FBQ3hQO2dCQUNoQ2hFLHFCQUFxQndULE1BQU0sQ0FBQ3hQO2dCQUM1QmdkLFdBQVcsVUFBVSwyREFBMkQ7Z0JBQ2hGLGlEQUFpRDtnQkFFakQ3Z0IsNEJBQTRCcVQsTUFBTSxDQUFDeFA7Z0JBQ25DOGMsNkJBQTZCK0IsTUFBTTtnQkFDbkM5QixxQkFBcUI4QixNQUFNO2dCQUMzQlYsaUJBQWlCLFFBQVFBLGlCQUFpQixLQUFLLElBQUksS0FBSyxJQUFJQSxhQUFhVyxLQUFLO1lBQ2hGO1FBQ0Y7UUFFQSxJQUFJNWEsWUFBWWlhLGlCQUFpQixRQUFRQSxpQkFBaUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsYUFBYVcsS0FBSztRQUU5RixJQUFJNWEsYUFBYSxDQUFDL0gsNEJBQTRCdUcsR0FBRyxDQUFDMUMsV0FBWSxFQUFDQSxPQUFPa0UsU0FBUyxJQUFJLENBQUMzTCx3Q0FBS0EsQ0FBQ2lWLE1BQU0sQ0FBQ3RKLFdBQVdsRSxPQUFPa0UsU0FBUyxJQUFJO1lBQzlINUwsNkNBQVVBLENBQUNrbEIsTUFBTSxDQUFDeGQsUUFBUWtFO1FBQzVCO1FBRUEsSUFBSStaLG9CQUFvQjtZQUN0QlI7WUFDQTtRQUNGLEVBQUUsNEVBQTRFO1FBQzlFLG1GQUFtRjtRQUNuRiw4Q0FBOEM7UUFHOUMsSUFBSWEseUJBQXlCO1lBQzNCeEI7UUFDRjtRQUVBQSw2QkFBNkJnQixLQUFLO1FBQ2xDZixxQkFBcUJlLEtBQUs7UUFDMUJSO1FBQ0EsSUFBSXlCLFlBQVkvaUIscUJBQXFCMEcsR0FBRyxDQUFDMUM7UUFDekNoRSxxQkFBcUJ3VCxNQUFNLENBQUN4UDtRQUU1QixJQUFJK2UsY0FBY3ZhLFdBQVc7WUFDM0J4RSxPQUFPcWUsS0FBSyxHQUFHVTtZQUNmL2UsT0FBT2dmLFFBQVE7UUFDakI7SUFDRjtJQUVBLElBQUlDLHVCQUF1QkMsQ0FBQUE7UUFDekIsSUFBSWpDLHlCQUF5QjtZQUMzQmMsYUFBYWQ7UUFDZjtRQUVBQSwwQkFBMEJpQixXQUFXO1lBQ25DdmlCLGFBQWFrSCxHQUFHLENBQUM3QyxRQUFRO1lBQ3pCOGQ7UUFDRixHQUFHdEI7SUFDTDtJQUVBLElBQUkyQyx5QkFBeUJELENBQUFBO1FBQzNCdmpCLGFBQWFrSCxHQUFHLENBQUM3QyxRQUFRO1FBRXpCLElBQUlpZCx5QkFBeUI7WUFDM0JjLGFBQWFkO1lBQ2JBLDBCQUEwQjtRQUM1QjtJQUNGO0lBRUEsSUFBSW1DLDhCQUE4QixTQUFTQTtRQUN6QyxJQUFJQyxZQUFZOWEsVUFBVXJLLE1BQU0sR0FBRyxLQUFLcUssU0FBUyxDQUFDLEVBQUUsS0FBS0MsWUFBWUQsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUNwRixJQUFJK2EscUJBQXFCbGtCLDhCQUE4QnNILEdBQUcsQ0FBQzFDO1FBRTNELElBQUksQ0FBQ3NmLG9CQUFvQjtZQUN2QjtRQUNGO1FBRUEsSUFBSXRCLHFCQUFxQnFCLFdBQVc7WUFDbENDLG1CQUFtQnhQLEtBQUssQ0FBQ3pRLE9BQU8sR0FBRztZQUNuQztRQUNGO1FBRUFpZ0IsbUJBQW1CeFAsS0FBSyxDQUFDeVAsY0FBYyxDQUFDO0lBQzFDO0lBRUEsSUFBSUMsWUFBWSxDQUFDemMsTUFBTW1XO1FBQ3JCLElBQUl1RztRQUNKLElBQUlwRSxlQUFlLENBQUNvRSx5QkFBeUJ4akIsd0JBQXdCeUcsR0FBRyxDQUFDMUMsT0FBTSxNQUFPLFFBQVF5ZiwyQkFBMkIsS0FBSyxJQUFJQSx5QkFBeUIsRUFBRTtRQUM3SnhqQix3QkFBd0I0RyxHQUFHLENBQUM3QyxRQUFRcWI7UUFDcEMsSUFBSXZoQixTQUFTbkIsdUNBQUlBLENBQUNrVixJQUFJLENBQUM3TixRQUFRK0M7UUFDL0IsSUFBSTJjLE1BQU1yRSxhQUFhc0UsU0FBUyxDQUFDQyxDQUFBQSxTQUFVbG5CLHVDQUFJQSxDQUFDOFUsTUFBTSxDQUFDb1MsT0FBTzdjLElBQUksRUFBRUE7UUFFcEUsSUFBSTJjLE1BQU0sR0FBRztZQUNYLElBQUl0RixhQUFhTCxvQkFBb0JqZ0IsT0FBT2tGLElBQUksRUFBRWthO1lBRWxELElBQUlrQixZQUFZO2dCQUNkaUIsYUFBYTFLLElBQUksQ0FBQztvQkFDaEI1TjtvQkFDQW1XO29CQUNBcmUsSUFBSXVpQjtnQkFDTjtZQUNGO1lBRUFnQztZQUNBO1FBQ0Y7UUFFQSxJQUFJUyxTQUFTeEYsaUJBQWlCdmdCLE9BQU9rRixJQUFJLEVBQUVxYyxZQUFZLENBQUNxRSxJQUFJLENBQUN4RyxJQUFJLEVBQUVBO1FBRW5FLElBQUksQ0FBQzJHLFFBQVE7WUFDWHhFLGFBQWF5RSxNQUFNLENBQUNKLEtBQUs7WUFDekJOO1lBQ0E7UUFDRjtRQUVBL0QsWUFBWSxDQUFDcUUsSUFBSSxHQUFHckQsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHaEIsWUFBWSxDQUFDcUUsSUFBSSxHQUFHLENBQUMsR0FBRztZQUM5RXhHLE1BQU0yRztRQUNSO0lBQ0Y7SUFFQSxJQUFJRSxpQkFBaUIsU0FBU0EsZUFBZWxDLEdBQUc7UUFDOUMsSUFBSSxFQUNGbFksRUFBRSxFQUNILEdBQUdwQixVQUFVckssTUFBTSxHQUFHLEtBQUtxSyxTQUFTLENBQUMsRUFBRSxLQUFLQyxZQUFZRCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDekU4WSxxQkFBcUI7UUFDckJsaEIsNEJBQTRCcVQsTUFBTSxDQUFDeFA7UUFDbkM4Yyw2QkFBNkIrQixNQUFNO1FBQ25DOUIscUJBQXFCOEIsTUFBTTtRQUUzQixJQUFJWixvQkFBb0I7WUFDdEJIO1FBQ0Y7UUFFQTVoQix5QkFBeUIyRyxHQUFHLENBQUM3QyxRQUFRO1lBQ25DMkY7WUFDQWtZO1FBQ0YsSUFBSSw4RkFBOEY7UUFDbEcsaUdBQWlHO1FBQ2pHLDJEQUEyRDtRQUUzRFYsa0JBQWtCZSxXQUFXSjtJQUMvQjtJQUVBLElBQUlrQyx1QkFBdUJ6aUIsQ0FBQUE7UUFDekIsSUFBSTBpQjtRQUVKLElBQUkvQyxnQkFBZ0I7WUFDbEJhLGFBQWFiO1lBQ2JBLGlCQUFpQjtRQUNuQjtRQUVBLElBQUksRUFDRmdELFdBQVc5SSxJQUFJLEVBQ2hCLEdBQUc3WjtRQUNKLElBQUlvZCxjQUFjO1FBQ2xCLElBQUl6VixPQUFPM0gsTUFBTW9DLFlBQVksSUFBSXBDLE1BQU0ySCxJQUFJLElBQUlWO1FBRS9DLElBQUk2WSx1QkFBdUIsU0FBU2pHLFNBQVMsZ0JBQWdCQSxTQUFTLHlCQUF5QjtZQUM3RmlHLHFCQUFxQjtRQUN2QjtRQUVBLElBQUksQ0FBQzhDLGtCQUFrQixHQUFHNWlCLE1BQU1pRixlQUFlO1FBRS9DLElBQUkyZCxtQkFBbUI7WUFDckJ4RixjQUFjdGEsWUFBWW1KLFlBQVksQ0FBQ3hKLFFBQVFtZ0IsbUJBQW1CO2dCQUNoRTFXLFlBQVk7Z0JBQ1pDLGVBQWU7WUFDakI7UUFDRixFQUFFLDhFQUE4RTtRQUNoRixxRUFBcUU7UUFHckUsSUFBSXpNLFVBQVNvRCxZQUFZQyxTQUFTLENBQUNOO1FBQ25DLElBQUltRSxlQUFlbEgsUUFBT3lHLFlBQVk7UUFFdEMsSUFBSSxDQUFDaVgsZUFBZXhXLGNBQWM7WUFDaENnYyxvQkFBb0JoYztZQUNwQndXLGNBQWN0YSxZQUFZbUosWUFBWSxDQUFDeEosUUFBUW1FLGNBQWM7Z0JBQzNEc0YsWUFBWTtnQkFDWkMsZUFBZTtZQUNqQjtRQUNGO1FBRUFpUixjQUFjLENBQUNzRixnQkFBZ0J0RixXQUFVLE1BQU8sUUFBUXNGLGtCQUFrQixLQUFLLElBQUlBLGdCQUFnQmpnQixPQUFPa0UsU0FBUztRQUVuSCxJQUFJLENBQUN5VyxhQUFhO1lBQ2hCO1FBQ0YsRUFBRSx5RUFBeUU7UUFDM0UsdUVBQXVFO1FBQ3ZFLDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUsOERBQThEO1FBRzlELElBQUl5RixlQUFlO1FBRW5CLElBQUloSixLQUFLN1EsVUFBVSxDQUFDLFdBQVc7WUFDN0IsSUFBSWhPLHdDQUFLQSxDQUFDcVQsVUFBVSxDQUFDK08sY0FBYztnQkFDakMsSUFBSSxDQUFDMEYsUUFBUUMsS0FBSyxHQUFHL25CLHdDQUFLQSxDQUFDZ29CLEtBQUssQ0FBQzVGO2dCQUVqQyxJQUFJNkYsUUFBUTduQix1Q0FBSUEsQ0FBQ2tWLElBQUksQ0FBQzdOLFFBQVFxZ0IsT0FBT3RkLElBQUk7Z0JBRXpDLElBQUl5ZCxNQUFNeGhCLElBQUksQ0FBQzlFLE1BQU0sS0FBS21tQixPQUFPdmlCLE1BQU0sSUFBSXdpQixLQUFLeGlCLE1BQU0sS0FBSyxHQUFHO29CQUM1RCxJQUFJMFMsT0FBT3BZLHlDQUFNQSxDQUFDb1ksSUFBSSxDQUFDeFEsUUFBUTt3QkFDN0IyRixJQUFJMGEsT0FBT3RkLElBQUk7d0JBQ2ZqRCxPQUFPakgsdUNBQU1BLENBQUNzZ0IsTUFBTTtvQkFDdEI7b0JBRUEsSUFBSTNJLFFBQVE5WCx1Q0FBSUEsQ0FBQzhVLE1BQU0sQ0FBQ2dELElBQUksQ0FBQyxFQUFFLEVBQUU4UCxLQUFLdmQsSUFBSSxHQUFHO3dCQUMzQzRYLGNBQWM7NEJBQ1o5VCxRQUFReVo7NEJBQ1J2YyxPQUFPdWM7d0JBQ1Q7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUVBLElBQUk3aEIsWUFBWTJZLEtBQUt2TSxRQUFRLENBQUMsY0FBYyxhQUFhO1lBQ3pELElBQUksQ0FBQzlFLE9BQU9HLElBQUksR0FBRzNOLHdDQUFLQSxDQUFDZ29CLEtBQUssQ0FBQzVGO1lBQy9CLElBQUksQ0FBQzlNLE1BQU05SyxLQUFLLEdBQUczSyx5Q0FBTUEsQ0FBQ3lWLElBQUksQ0FBQzdOLFFBQVErRixNQUFNaEQsSUFBSTtZQUNqRCxJQUFJbVcsT0FBTztnQkFDVGxhLE1BQU07Z0JBQ04rRyxPQUFPQSxNQUFNakksTUFBTTtnQkFDbkJvSSxLQUFLQSxJQUFJcEksTUFBTTtZQUNqQjtZQUNBLElBQUl1ZCxlQUFlcGYsd0JBQXdCeUcsR0FBRyxDQUFDMUM7WUFDL0MsSUFBSXlnQix1QkFBdUJwRixpQkFBaUIsUUFBUUEsaUJBQWlCLEtBQUssSUFBSSxLQUFLLElBQUlBLGFBQWExYSxJQUFJLENBQUNpZixDQUFBQSxTQUFVbG5CLHVDQUFJQSxDQUFDOFUsTUFBTSxDQUFDb1MsT0FBTzdjLElBQUksRUFBRUE7WUFDNUksSUFBSXlXLFFBQVFpSCx1QkFBdUI7Z0JBQUNBLHFCQUFxQnZILElBQUk7Z0JBQUVBO2FBQUssR0FBRztnQkFBQ0E7YUFBSztZQUM3RSxJQUFJbGEsT0FBT3NhLGdCQUFnQnpMLEtBQUs3TyxJQUFJLEtBQUt3YTtZQUV6QyxJQUFJeGEsS0FBSzlFLE1BQU0sS0FBSyxHQUFHO2dCQUNyQix1REFBdUQ7Z0JBQ3ZELDBEQUEwRDtnQkFDMUQsdUJBQXVCO2dCQUN2QmttQixlQUFlO1lBQ2pCO1lBRUEsSUFBSTduQix3Q0FBS0EsQ0FBQ3FULFVBQVUsQ0FBQytPLGNBQWM7Z0JBQ2pDLElBQUl5RixnQkFBZ0IxbkIsdUNBQUlBLENBQUM4VSxNQUFNLENBQUNtTixZQUFZOVQsTUFBTSxDQUFDOUQsSUFBSSxFQUFFNFgsWUFBWTVXLEtBQUssQ0FBQ2hCLElBQUksR0FBRztvQkFDaEYsSUFBSTBDLFFBQVE7d0JBQ1YxQyxNQUFNNFgsWUFBWTlULE1BQU0sQ0FBQzlELElBQUk7d0JBQzdCakYsUUFBUWlJLE1BQU1qSSxNQUFNO29CQUN0QjtvQkFDQSxJQUFJOEksUUFBUXhPLHlDQUFNQSxDQUFDd08sS0FBSyxDQUFDNUcsUUFBUXlGLE9BQU9BO29CQUN4Q2liLGlCQUFpQjlaO29CQUNqQixPQUFPNFksVUFBVTdFLFlBQVk5VCxNQUFNLENBQUM5RCxJQUFJLEVBQUU7d0JBQ3hDL0QsTUFBTTt3QkFDTmtILEtBQUtBLElBQUlwSSxNQUFNO3dCQUNmaUksT0FBT0EsTUFBTWpJLE1BQU07b0JBQ3JCO2dCQUNGO2dCQUVBLE9BQU9paUIsZUFBZSxJQUFNM25CLHlDQUFNQSxDQUFDdW1CLGNBQWMsQ0FBQzNlLFFBQVE7d0JBQ3hEdkI7b0JBQ0YsSUFBSTtvQkFDRmtILElBQUlnVjtnQkFDTjtZQUNGO1FBQ0Y7UUFFQSxPQUFRdkQ7WUFDTixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0g7b0JBQ0UsT0FBTzJJLGVBQWUsSUFBTTNuQix5Q0FBTUEsQ0FBQ3VtQixjQUFjLENBQUMzZSxTQUFTO3dCQUN6RDJGLElBQUlnVjtvQkFDTjtnQkFDRjtZQUVGLEtBQUs7WUFDTCxLQUFLO2dCQUNIO29CQUNFLElBQUksRUFDRjlULE1BQU0sRUFDUCxHQUFHOFQ7b0JBRUosSUFBSXlGLGdCQUFnQjduQix3Q0FBS0EsQ0FBQzBPLFdBQVcsQ0FBQzBULGNBQWM7d0JBQ2xELElBQUlnRyxhQUFhaG9CLHVDQUFJQSxDQUFDa1YsSUFBSSxDQUFDN04sUUFBUTZHLE9BQU85RCxJQUFJO3dCQUU5QyxJQUFJOEQsT0FBTy9JLE1BQU0sR0FBRzZpQixXQUFXM2hCLElBQUksQ0FBQzlFLE1BQU0sRUFBRTs0QkFDMUMsT0FBT3NsQixVQUFVM1ksT0FBTzlELElBQUksRUFBRTtnQ0FDNUIvRCxNQUFNO2dDQUNOK0csT0FBT2MsT0FBTy9JLE1BQU07Z0NBQ3BCb0ksS0FBS1csT0FBTy9JLE1BQU0sR0FBRzs0QkFDdkI7d0JBQ0Y7b0JBQ0Y7b0JBRUEsT0FBT2lpQixlQUFlLElBQU0zbkIseUNBQU1BLENBQUNtYixhQUFhLENBQUN2VCxTQUFTO3dCQUN4RDJGLElBQUlnVjtvQkFDTjtnQkFDRjtZQUVGLEtBQUs7Z0JBQ0g7b0JBQ0UsSUFBSWlHO29CQUVKLElBQUksRUFDRi9aLFFBQVEyVSxPQUFPLEVBQ2hCLEdBQUdiLGFBQWEsK0VBQStFO29CQUNoRyxrRkFBa0Y7b0JBQ2xGLGtGQUFrRjtvQkFFbEYsSUFBSWtHLGtCQUFrQjNqQixlQUFlaWpCLHFCQUFxQkEsa0JBQWtCbFosV0FBVyxHQUFHLENBQUMsQ0FBRSxFQUFDMloscUJBQXFCVCxpQkFBZ0IsTUFBTyxRQUFRUyx1QkFBdUIsS0FBSyxLQUFLQSxtQkFBbUJwVixTQUFTO29CQUUvTSxJQUFJNFUsZ0JBQWdCUyxtQkFBbUJ0b0Isd0NBQUtBLENBQUMwTyxXQUFXLENBQUMwVCxnQkFBZ0JhLFFBQVExZCxNQUFNLEdBQUcsR0FBRzt3QkFDM0YsT0FBTzBoQixVQUFVaEUsUUFBUXpZLElBQUksRUFBRTs0QkFDN0IvRCxNQUFNOzRCQUNOK0csT0FBT3lWLFFBQVExZCxNQUFNLEdBQUc7NEJBQ3hCb0ksS0FBS3NWLFFBQVExZCxNQUFNO3dCQUNyQjtvQkFDRjtvQkFFQSxPQUFPaWlCLGVBQWUsSUFBTTNuQix5Q0FBTUEsQ0FBQ2tiLGNBQWMsQ0FBQ3RULFNBQVM7d0JBQ3pEMkYsSUFBSWdWO29CQUNOO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxPQUFPb0YsZUFBZTt3QkFDcEIzbkIseUNBQU1BLENBQUNrYixjQUFjLENBQUN0VCxRQUFROzRCQUM1QjhnQixNQUFNO3dCQUNSO3dCQUNBMW9CLHlDQUFNQSxDQUFDbWIsYUFBYSxDQUFDdlQsUUFBUTs0QkFDM0I4Z0IsTUFBTTt3QkFDUjtvQkFDRixHQUFHO3dCQUNEbmIsSUFBSWdWO29CQUNOO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxPQUFPb0YsZUFBZSxJQUFNM25CLHlDQUFNQSxDQUFDa2IsY0FBYyxDQUFDdFQsUUFBUTs0QkFDeEQ4Z0IsTUFBTTt3QkFDUixJQUFJO3dCQUNGbmIsSUFBSWdWO29CQUNOO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxPQUFPb0YsZUFBZSxJQUFNM25CLHlDQUFNQSxDQUFDa2IsY0FBYyxDQUFDdFQsUUFBUTs0QkFDeEQ4Z0IsTUFBTTt3QkFDUixJQUFJO3dCQUNGbmIsSUFBSWdWO29CQUNOO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxPQUFPb0YsZUFBZSxJQUFNM25CLHlDQUFNQSxDQUFDbWIsYUFBYSxDQUFDdlQsUUFBUTs0QkFDdkQ4Z0IsTUFBTTt3QkFDUixJQUFJO3dCQUNGbmIsSUFBSWdWO29CQUNOO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxPQUFPb0YsZUFBZSxJQUFNM25CLHlDQUFNQSxDQUFDbWIsYUFBYSxDQUFDdlQsUUFBUTs0QkFDdkQ4Z0IsTUFBTTt3QkFDUixJQUFJO3dCQUNGbmIsSUFBSWdWO29CQUNOO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxPQUFPb0YsZUFBZSxJQUFNM25CLHlDQUFNQSxDQUFDa2IsY0FBYyxDQUFDdFQsUUFBUTs0QkFDeEQ4Z0IsTUFBTTt3QkFDUixJQUFJO3dCQUNGbmIsSUFBSWdWO29CQUNOO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxPQUFPb0YsZUFBZSxJQUFNM25CLHlDQUFNQSxDQUFDbWIsYUFBYSxDQUFDdlQsUUFBUTs0QkFDdkQ4Z0IsTUFBTTt3QkFDUixJQUFJO3dCQUNGbmIsSUFBSWdWO29CQUNOO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxPQUFPb0YsZUFBZSxJQUFNM25CLHlDQUFNQSxDQUFDdWIsZUFBZSxDQUFDM1QsU0FBUzt3QkFDMUQyRixJQUFJZ1Y7b0JBQ047Z0JBQ0Y7WUFFRixLQUFLO2dCQUNIO29CQUNFLE9BQU9vRixlQUFlLElBQU0zbkIseUNBQU1BLENBQUMyb0IsV0FBVyxDQUFDL2dCLFNBQVM7d0JBQ3REMkYsSUFBSWdWO29CQUNOO2dCQUNGO1lBRUYsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0g7b0JBQ0UsSUFBSWdDLGVBQWV6WCxPQUFPO3dCQUN4QixPQUFPNmEsZUFBZSxJQUFNMWYsWUFBWTRFLFVBQVUsQ0FBQ2pGLFFBQVFrRixPQUFPOzRCQUNoRVMsSUFBSWdWO3dCQUNOO29CQUNGO29CQUVBLElBQUlsSixRQUFRdk0sU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSUEsT0FBTyxJQUFJLGtGQUFrRjtvQkFDNUksb0ZBQW9GO29CQUdwRixJQUFJbkosa0NBQWtDMkcsR0FBRyxDQUFDMUMsU0FBUzt3QkFDakR5UixRQUFRQSxNQUFNdVAsT0FBTyxDQUFDLFVBQVU7b0JBQ2xDLEVBQUUsdUVBQXVFO29CQUN6RSxtRUFBbUU7b0JBQ25FLCtDQUErQztvQkFHL0MsSUFBSTVKLFNBQVMsZ0JBQWdCLFlBQVk5VixJQUFJLENBQUNtUSxRQUFRO3dCQUNwREEsUUFBUUEsTUFBTWxILEtBQUssQ0FBQyxHQUFHLENBQUM7b0JBQzFCLEVBQUUsZ0ZBQWdGO29CQUNsRiw0Q0FBNEM7b0JBRzVDLElBQUlrSCxNQUFNM00sUUFBUSxDQUFDLE9BQU87d0JBQ3hCLE9BQU9pYixlQUFlOzRCQUNwQixJQUFJa0IsUUFBUXhQLE1BQU10USxLQUFLLENBQUM7NEJBRXhCOGYsTUFBTXpXLE9BQU8sQ0FBQyxDQUFDMFcsTUFBTWpuQjtnQ0FDbkIsSUFBSWluQixNQUFNO29DQUNSOW9CLHlDQUFNQSxDQUFDc21CLFVBQVUsQ0FBQzFlLFFBQVFraEI7Z0NBQzVCO2dDQUVBLElBQUlqbkIsTUFBTWduQixNQUFNL21CLE1BQU0sR0FBRyxHQUFHO29DQUMxQjlCLHlDQUFNQSxDQUFDdWIsZUFBZSxDQUFDM1Q7Z0NBQ3pCOzRCQUNGO3dCQUNGLEdBQUc7NEJBQ0QyRixJQUFJZ1Y7d0JBQ047b0JBQ0Y7b0JBRUEsSUFBSWppQix1Q0FBSUEsQ0FBQzhVLE1BQU0sQ0FBQ21OLFlBQVk5VCxNQUFNLENBQUM5RCxJQUFJLEVBQUU0WCxZQUFZNVcsS0FBSyxDQUFDaEIsSUFBSSxHQUFHO3dCQUNoRSxJQUFJLENBQUNvZSxTQUFTQyxNQUFNLEdBQUc3b0Isd0NBQUtBLENBQUNnb0IsS0FBSyxDQUFDNUY7d0JBQ25DLElBQUkwRyxRQUFROzRCQUNWdGIsT0FBT29iLFFBQVFyakIsTUFBTTs0QkFDckJvSSxLQUFLa2IsTUFBTXRqQixNQUFNOzRCQUNqQmtCLE1BQU15Uzt3QkFDUixHQUFHLDBFQUEwRTt3QkFDN0UsZ0ZBQWdGO3dCQUNoRixrRkFBa0Y7d0JBQ2xGLDJGQUEyRjt3QkFDM0Ysd0ZBQXdGO3dCQUN4RixxQ0FBcUM7d0JBRXJDLElBQUlBLFNBQVM0TCxzQkFBc0JqRyxTQUFTLHlCQUF5Qjs0QkFDbkUsSUFBSWtLLGVBQWVqRSxtQkFBbUJ0WCxLQUFLLEdBQUdzWCxtQkFBbUJyZSxJQUFJLENBQUN1aUIsTUFBTSxDQUFDOzRCQUU3RSxJQUFJQyxlQUFlSCxNQUFNdGIsS0FBSyxHQUFHc2IsTUFBTXJpQixJQUFJLENBQUN1aUIsTUFBTSxDQUFDOzRCQUVuRCxJQUFJQyxpQkFBaUJGLGVBQWUsS0FBS0QsTUFBTW5iLEdBQUcsS0FBS21YLG1CQUFtQnRYLEtBQUssR0FBR3NYLG1CQUFtQnJlLElBQUksQ0FBQzlFLE1BQU0sRUFBRTtnQ0FDaEhtbkIsTUFBTXRiLEtBQUssSUFBSTtnQ0FDZnNYLHFCQUFxQjtnQ0FDckJvRTs0QkFDRixPQUFPO2dDQUNMcEUscUJBQXFCOzRCQUN2Qjt3QkFDRixPQUFPLElBQUlqRyxTQUFTLGNBQWM7NEJBQ2hDLElBQUlpRyx1QkFBdUIsTUFBTTtnQ0FDL0JBLHFCQUFxQmdFOzRCQUN2QixPQUFPLElBQUloRSxzQkFBc0I5a0Isd0NBQUtBLENBQUMwTyxXQUFXLENBQUMwVCxnQkFBZ0IwQyxtQkFBbUJuWCxHQUFHLEdBQUdtWCxtQkFBbUJyZSxJQUFJLENBQUM5RSxNQUFNLEtBQUtpbkIsUUFBUXJqQixNQUFNLEVBQUU7Z0NBQzdJdWYscUJBQXFCaEIsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHZ0IscUJBQXFCLENBQUMsR0FBRztvQ0FDaEZyZSxNQUFNcWUsbUJBQW1CcmUsSUFBSSxHQUFHeVM7Z0NBQ2xDOzRCQUNGLE9BQU87Z0NBQ0w0TCxxQkFBcUI7NEJBQ3ZCO3dCQUNGLE9BQU87NEJBQ0xBLHFCQUFxQjt3QkFDdkI7d0JBRUEsSUFBSStDLGNBQWM7NEJBQ2hCWixVQUFVMkIsUUFBUXBlLElBQUksRUFBRXNlOzRCQUN4Qjt3QkFDRjtvQkFDRjtvQkFFQSxPQUFPdEIsZUFBZSxJQUFNM25CLHlDQUFNQSxDQUFDc21CLFVBQVUsQ0FBQzFlLFFBQVF5UixRQUFRO3dCQUM1RDlMLElBQUlnVjtvQkFDTjtnQkFDRjtRQUNKO0lBQ0Y7SUFFQSxJQUFJc0QsbUJBQW1CO1FBQ3JCLE9BQU8sQ0FBQyxDQUFDL2hCLHlCQUF5QndHLEdBQUcsQ0FBQzFDO0lBQ3hDO0lBRUEsSUFBSWdlLGtCQUFrQjtRQUNwQixJQUFJMEQ7UUFFSixPQUFPLENBQUMsQ0FBRSxFQUFDQSx5QkFBeUJ6bEIsd0JBQXdCeUcsR0FBRyxDQUFDMUMsT0FBTSxNQUFPLFFBQVEwaEIsMkJBQTJCLEtBQUssS0FBS0EsdUJBQXVCeG5CLE1BQU07SUFDeko7SUFFQSxJQUFJeW5CLG9CQUFvQjtRQUN0QixPQUFPMUQsc0JBQXNCRDtJQUMvQjtJQUVBLElBQUk0RCxhQUFhO1FBQ2YsT0FBTzVFO0lBQ1Q7SUFFQSxJQUFJMEQsbUJBQW1COVosQ0FBQUE7UUFDckJ6Syw0QkFBNEIwRyxHQUFHLENBQUM3QyxRQUFRNEc7UUFFeEMsSUFBSXNXLGdCQUFnQjtZQUNsQmEsYUFBYWI7WUFDYkEsaUJBQWlCO1FBQ25CO1FBRUEsSUFBSSxFQUNGaFosU0FBUyxFQUNWLEdBQUdsRTtRQUVKLElBQUksQ0FBQzRHLE9BQU87WUFDVjtRQUNGO1FBRUEsSUFBSWliLGNBQWMsQ0FBQzNkLGFBQWEsQ0FBQ3hMLHVDQUFJQSxDQUFDOFUsTUFBTSxDQUFDdEosVUFBVTJDLE1BQU0sQ0FBQzlELElBQUksRUFBRTZELE1BQU1DLE1BQU0sQ0FBQzlELElBQUk7UUFDckYsSUFBSStlLG9CQUFvQixDQUFDNWQsYUFBYSxDQUFDeEwsdUNBQUlBLENBQUM4VSxNQUFNLENBQUN0SixVQUFVMkMsTUFBTSxDQUFDOUQsSUFBSSxDQUFDd0gsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJM0QsTUFBTUMsTUFBTSxDQUFDOUQsSUFBSSxDQUFDd0gsS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUVuSCxJQUFJc1gsZUFBZXhFLHNCQUFzQnlFLG1CQUFtQjtZQUMxRHpFLHFCQUFxQjtRQUN2QjtRQUVBLElBQUl3RSxlQUFlN0QsbUJBQW1CO1lBQ3BDZCxpQkFBaUJnQixXQUFXSixPQUFPckI7UUFDckM7SUFDRjtJQUVBLElBQUlzRixjQUFjO1FBQ2hCLElBQUk5RCxzQkFBc0IsQ0FBQ0QsbUJBQW1CO1lBQzVDRjtRQUNGO0lBQ0Y7SUFFQSxJQUFJa0UsZ0JBQWdCQyxDQUFBQTtRQUNsQix1RUFBdUU7UUFDdkUsc0VBQXNFO1FBQ3RFLDBFQUEwRTtRQUMxRSw2RUFBNkU7UUFDN0Usc0ZBQXNGO1FBQ3RGLElBQUksQ0FBQ2pFLG1CQUFtQjtZQUN0Qm9CLDRCQUE0QjtZQUM1QmxCLFdBQVdrQjtRQUNiO0lBQ0Y7SUFFQSxJQUFJcUMsZ0JBQWdCO1FBQ2xCLElBQUksQ0FBQ3hELG9CQUFvQjtZQUN2QmQsa0JBQWtCZSxXQUFXSjtRQUMvQjtJQUNGO0lBRUEsSUFBSW9FLHFCQUFxQm5MLENBQUFBO1FBQ3ZCLElBQUlpSCxxQkFBcUJDLG9CQUFvQjtZQUMzQztRQUNGO1FBRUEsSUFBSWxILFVBQVVvTCxJQUFJLENBQUNsaUIsQ0FBQUEsV0FBWUYsa0JBQWtCQyxRQUFRQyxVQUFVOFcsYUFBYTtZQUM5RSxJQUFJcUw7WUFFSix1RkFBdUY7WUFDdkYsa0NBQWtDO1lBQ2pDQSxDQUFBQSx3QkFBd0JobUIsdUJBQXVCc0csR0FBRyxDQUFDMUMsT0FBTSxNQUFPLFFBQVFvaUIsMEJBQTBCLEtBQUssSUFBSSxLQUFLLElBQUlBO1FBQ3ZIO0lBQ0Y7SUFFQSxPQUFPO1FBQ0x0RTtRQUNBMkQ7UUFDQXpEO1FBQ0FDO1FBQ0EwRDtRQUNBQztRQUNBbEI7UUFDQXpCO1FBQ0FFO1FBQ0FhO1FBQ0FnQztRQUNBRTtRQUNBSDtJQUNGO0FBQ0Y7QUFFQSxTQUFTTTtJQUNQLElBQUlDLGVBQWU3cUIsNkNBQU1BLENBQUM7SUFDMUJELGdEQUFTQSxDQUFDO1FBQ1I4cUIsYUFBYTFYLE9BQU8sR0FBRztRQUN2QixPQUFPO1lBQ0wwWCxhQUFhMVgsT0FBTyxHQUFHO1FBQ3pCO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsT0FBTzBYLGFBQWExWCxPQUFPO0FBQzdCO0FBRUEsU0FBUzJYLG9CQUFvQjFrQixJQUFJLEVBQUUya0IsUUFBUSxFQUFFbGUsT0FBTztJQUNsRCxJQUFJLENBQUN3VCxpQkFBaUIsR0FBR3BnQiwrQ0FBUUEsQ0FBQyxJQUFNLElBQUl1Z0IsaUJBQWlCdUs7SUFDN0Q5VSwwQkFBMEI7UUFDeEIsZ0ZBQWdGO1FBQ2hGLDZFQUE2RTtRQUM3RW9LLGlCQUFpQlMsV0FBVztJQUM5QjtJQUNBL2dCLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDcUcsS0FBSytNLE9BQU8sRUFBRTtZQUNqQixNQUFNLElBQUlqSSxNQUFNO1FBQ2xCO1FBRUFtVixpQkFBaUJySSxPQUFPLENBQUM1UixLQUFLK00sT0FBTyxFQUFFdEc7UUFDdkMsT0FBTyxJQUFNd1QsaUJBQWlCeEksVUFBVTtJQUMxQyxHQUFHLEVBQUU7QUFDUDtBQUVBLElBQUltVCxjQUFjO0lBQUM7Q0FBTztBQUUxQixTQUFTQyxVQUFVM0csTUFBTSxFQUFFQyxjQUFjO0lBQUksSUFBSWhpQixPQUFPVixPQUFPVSxJQUFJLENBQUMraEI7SUFBUyxJQUFJemlCLE9BQU9lLHFCQUFxQixFQUFFO1FBQUUsSUFBSTRoQixVQUFVM2lCLE9BQU9lLHFCQUFxQixDQUFDMGhCO1FBQVMsSUFBSUMsZ0JBQWdCO1lBQUVDLFVBQVVBLFFBQVFoRixNQUFNLENBQUMsU0FBVWlGLEdBQUc7Z0JBQUksT0FBTzVpQixPQUFPNmlCLHdCQUF3QixDQUFDSixRQUFRRyxLQUFLMWlCLFVBQVU7WUFBRTtRQUFJO1FBQUVRLEtBQUsyVyxJQUFJLENBQUN5TCxLQUFLLENBQUNwaUIsTUFBTWlpQjtJQUFVO0lBQUUsT0FBT2ppQjtBQUFNO0FBRTFWLFNBQVMyb0IsZ0JBQWdCN29CLE1BQU07SUFBSSxJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSXNLLFVBQVVySyxNQUFNLEVBQUVELElBQUs7UUFBRSxJQUFJTCxTQUFTMkssU0FBUyxDQUFDdEssRUFBRSxJQUFJLE9BQU9zSyxTQUFTLENBQUN0SyxFQUFFLEdBQUcsQ0FBQztRQUFHLElBQUlBLElBQUksR0FBRztZQUFFeW9CLFVBQVVwcEIsT0FBT00sU0FBUyxNQUFNNFEsT0FBTyxDQUFDLFNBQVVwUixHQUFHO2dCQUFJRixnQkFBZ0JZLFFBQVFWLEtBQUtRLE1BQU0sQ0FBQ1IsSUFBSTtZQUFHO1FBQUksT0FBTyxJQUFJRSxPQUFPZ2pCLHlCQUF5QixFQUFFO1lBQUVoakIsT0FBT2lqQixnQkFBZ0IsQ0FBQ3ppQixRQUFRUixPQUFPZ2pCLHlCQUF5QixDQUFDMWlCO1FBQVUsT0FBTztZQUFFOG9CLFVBQVVwcEIsT0FBT00sU0FBUzRRLE9BQU8sQ0FBQyxTQUFVcFIsR0FBRztnQkFBSUUsT0FBT0MsY0FBYyxDQUFDTyxRQUFRVixLQUFLRSxPQUFPNmlCLHdCQUF3QixDQUFDdmlCLFFBQVFSO1lBQU87UUFBSTtJQUFFO0lBQUUsT0FBT1U7QUFBUTtBQUMzaEIsSUFBSThvQiwyQkFBMkI7SUFDN0JwTCxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsZUFBZTtBQUNqQjtBQUNBLFNBQVNtTCx1QkFBdUJqaUIsSUFBSTtJQUNsQyxJQUFJLEVBQ0YvQyxJQUFJLEVBQ0wsR0FBRytDLE1BQ0EwRCxVQUFVbEsseUJBQXlCd0csTUFBTTZoQjtJQUU3QyxJQUFJLENBQUMvZ0IsWUFBWTtRQUNmLE9BQU87SUFDVDtJQUVBLElBQUkxQixTQUFTOE47SUFDYixJQUFJZ1YsWUFBWVQ7SUFDaEIsSUFBSSxDQUFDVSxhQUFhLEdBQUdyckIsK0NBQVFBLENBQUMsSUFBTW1sQiwwQkFBMEI4RixnQkFBZ0I7WUFDNUUzaUI7UUFDRixHQUFHc0U7SUFDSGllLG9CQUFvQjFrQixNQUFNa2xCLGFBQWFiLGtCQUFrQixFQUFFVTtJQUMzRDltQix5QkFBeUIrRyxHQUFHLENBQUM3QyxRQUFRK2lCLGFBQWF0QixhQUFhO0lBRS9ELElBQUlxQixXQUFXO1FBQ2JDLGFBQWFqRixLQUFLO0lBQ3BCO0lBRUEsT0FBT2lGO0FBQ1Q7QUFFQSxTQUFTQztJQUNQLElBQUloakIsU0FBUzhOO0lBQ2IsSUFBSTZJLG9CQUFvQmxmLDZDQUFNQSxDQUFDO0lBQy9CLElBQUl3ckIsc0JBQXNCeHJCLDZDQUFNQSxDQUFDO0lBQ2pDLElBQUl5ckIsY0FBY25yQixrREFBV0EsQ0FBQztRQUM1QixJQUFJNGUsa0JBQWtCL0wsT0FBTyxFQUFFO1lBQzdCO1FBQ0Y7UUFFQStMLGtCQUFrQi9MLE9BQU8sR0FBRztRQUM1QixJQUFJM04sVUFBU29ELFlBQVlDLFNBQVMsQ0FBQ047UUFDbkMvQyxRQUFPa21CLG9CQUFvQixDQUFDRixvQkFBb0JyWSxPQUFPO1FBQ3ZEcVksb0JBQW9CclksT0FBTyxHQUFHM04sUUFBT21tQixxQkFBcUIsQ0FBQztZQUN6RHpNLGtCQUFrQi9MLE9BQU8sR0FBRztRQUM5QjtJQUNGLEdBQUcsRUFBRTtJQUNMcFQsZ0RBQVNBLENBQUMsSUFBTSxJQUFNMnJCLHFCQUFxQkYsb0JBQW9CclksT0FBTyxHQUFHLEVBQUU7SUFDM0UsT0FBTztRQUNMK0w7UUFDQXVNO0lBQ0Y7QUFDRjtBQUVBLElBQUlHLGNBQWM7SUFBQztJQUFhO0lBQVk7SUFBb0I7SUFBZTtJQUFZO0lBQWlCO0lBQWM7SUFBcUI7SUFBMkI7SUFBUztJQUFNO0NBQXVCLEVBQzVNQyxhQUFhO0lBQUM7Q0FBTztBQUV6QixTQUFTQyxVQUFVeEgsTUFBTSxFQUFFQyxjQUFjO0lBQUksSUFBSWhpQixPQUFPVixPQUFPVSxJQUFJLENBQUMraEI7SUFBUyxJQUFJemlCLE9BQU9lLHFCQUFxQixFQUFFO1FBQUUsSUFBSTRoQixVQUFVM2lCLE9BQU9lLHFCQUFxQixDQUFDMGhCO1FBQVMsSUFBSUMsZ0JBQWdCO1lBQUVDLFVBQVVBLFFBQVFoRixNQUFNLENBQUMsU0FBVWlGLEdBQUc7Z0JBQUksT0FBTzVpQixPQUFPNmlCLHdCQUF3QixDQUFDSixRQUFRRyxLQUFLMWlCLFVBQVU7WUFBRTtRQUFJO1FBQUVRLEtBQUsyVyxJQUFJLENBQUN5TCxLQUFLLENBQUNwaUIsTUFBTWlpQjtJQUFVO0lBQUUsT0FBT2ppQjtBQUFNO0FBRTFWLFNBQVN3cEIsZ0JBQWdCMXBCLE1BQU07SUFBSSxJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSXNLLFVBQVVySyxNQUFNLEVBQUVELElBQUs7UUFBRSxJQUFJTCxTQUFTMkssU0FBUyxDQUFDdEssRUFBRSxJQUFJLE9BQU9zSyxTQUFTLENBQUN0SyxFQUFFLEdBQUcsQ0FBQztRQUFHLElBQUlBLElBQUksR0FBRztZQUFFc3BCLFVBQVVqcUIsT0FBT00sU0FBUyxNQUFNNFEsT0FBTyxDQUFDLFNBQVVwUixHQUFHO2dCQUFJRixnQkFBZ0JZLFFBQVFWLEtBQUtRLE1BQU0sQ0FBQ1IsSUFBSTtZQUFHO1FBQUksT0FBTyxJQUFJRSxPQUFPZ2pCLHlCQUF5QixFQUFFO1lBQUVoakIsT0FBT2lqQixnQkFBZ0IsQ0FBQ3ppQixRQUFRUixPQUFPZ2pCLHlCQUF5QixDQUFDMWlCO1FBQVUsT0FBTztZQUFFMnBCLFVBQVVqcUIsT0FBT00sU0FBUzRRLE9BQU8sQ0FBQyxTQUFVcFIsR0FBRztnQkFBSUUsT0FBT0MsY0FBYyxDQUFDTyxRQUFRVixLQUFLRSxPQUFPNmlCLHdCQUF3QixDQUFDdmlCLFFBQVFSO1lBQU87UUFBSTtJQUFFO0lBQUUsT0FBT1U7QUFBUTtBQUUzaEIsSUFBSTJwQixXQUFXN1YsQ0FBQUEsUUFBUyxXQUFXLEdBQUV0VywwREFBbUIsQ0FBQ0EsdURBQWMsRUFBRSxNQUFNK1osWUFBWXpEO0FBQzNGOztDQUVDLEdBR0QsSUFBSThWLFdBQVc5VixDQUFBQTtJQUNiLElBQUkrVix1QkFBdUJDO0lBRTNCLElBQUlDLDJCQUEyQjlyQixrREFBV0EsQ0FBQzZWLENBQUFBLFFBQVMsV0FBVyxHQUFFdFcsMERBQW1CLENBQUN3c0Isb0JBQW9CeHFCLE9BQU91VixNQUFNLENBQUMsQ0FBQyxHQUFHakIsU0FBUyxFQUFFO0lBRXRJLElBQUksRUFDRm1XLFNBQVMsRUFDVDlSLFdBQVcrUixlQUFlLEVBQzFCQyxrQkFBa0JDLHFCQUFxQixFQUN2Q3JVLFdBQVcsRUFDWHNCLFdBQVcsS0FBSyxFQUNoQkgsYUFBYSxFQUNiL0IsVUFBVSxFQUNWRCxvQkFBb0I2VSx3QkFBd0IsRUFDNUNNLDBCQUEwQkMsOEJBQThCLEVBQ3hEdFUsT0FBT3VVLFlBQVksQ0FBQyxDQUFDLEVBQ3JCQyxJQUFJdHNCLFlBQVksS0FBSyxFQUNyQnVzQix1QkFBdUIsS0FBSyxFQUM3QixHQUFHM1csT0FDQWdCLGFBQWF4VSx5QkFBeUJ3VCxPQUFPeVY7SUFFakQsSUFBSXJqQixTQUFTMlMsWUFBWSxrREFBa0Q7SUFFM0UsSUFBSSxDQUFDbFEsYUFBYStoQixlQUFlLEdBQUc5c0IsK0NBQVFBLENBQUM7SUFDN0MsSUFBSTZXLE1BQU05Vyw2Q0FBTUEsQ0FBQztJQUNqQixJQUFJZ3RCLHFCQUFxQmh0Qiw2Q0FBTUEsQ0FBQyxFQUFFO0lBQ2xDLElBQUksRUFDRnlyQixXQUFXLEVBQ1h2TSxpQkFBaUIsRUFDbEIsR0FBR3FNO0lBQ0osSUFBSSxHQUFHclQsWUFBWSxHQUFHMVgsaURBQVVBLENBQUN5c0IsQ0FBQUEsSUFBS0EsSUFBSSxHQUFHO0lBQzdDdG9CLHVCQUF1QnlHLEdBQUcsQ0FBQzdDLFFBQVEyUCxjQUFjLHdDQUF3QztJQUV6RmxVLGFBQWFvSCxHQUFHLENBQUM3QyxRQUFRbVIsV0FBVyx3REFBd0Q7SUFFNUYsSUFBSXdULFFBQVF6c0IsOENBQU9BLENBQUMsSUFBTztZQUN6QjBzQixzQkFBc0I7WUFDdEJDLHFCQUFxQjtZQUNyQkMsZUFBZTtZQUNmQyxvQkFBb0I7UUFDdEIsSUFBSSxFQUFFLEdBQUcsMEVBQTBFO0lBQ25GLGdDQUFnQztJQUVoQ3Z0QixnREFBU0EsQ0FBQztRQUNSLElBQUkrVyxJQUFJM0QsT0FBTyxJQUFJbVosV0FBVztZQUM1QnhWLElBQUkzRCxPQUFPLENBQUM3RyxLQUFLO1FBQ25CO0lBQ0YsR0FBRztRQUFDZ2dCO0tBQVUsR0FBRyw2RUFBNkU7SUFDOUYsOEVBQThFO0lBQzlFLHVFQUF1RTtJQUN2RSwwRUFBMEU7SUFDMUUsc0NBQXNDO0lBRXRDLElBQUloSCx1QkFBdUJobEIsa0RBQVdBLENBQUNWLHNEQUFRQSxDQUFDO1FBQzlDLElBQUksQ0FBQ3FLLGNBQWMsQ0FBQ3JCLFlBQVlvQyxXQUFXLENBQUN6QyxPQUFNLEtBQU8sRUFBQzJrQixNQUFNRSxtQkFBbUIsSUFBSUcsd0JBQXdCLFFBQVFBLHdCQUF3QixLQUFLLEtBQUtBLG9CQUFvQnBELFVBQVUsRUFBQyxLQUFNLENBQUMrQyxNQUFNQyxvQkFBb0IsRUFBRTtZQUN6TixJQUFJdGhCLE9BQU9qRCxZQUFZOEMsd0JBQXdCLENBQUNuRDtZQUNoRCxJQUFJLEVBQ0Y4RCxhQUFhLEVBQ2QsR0FBR1I7WUFDSixJQUFJRixLQUFLL0MsWUFBWWdELFNBQVMsQ0FBQ3JELFFBQVFBO1lBQ3ZDLElBQUltRSxlQUFlYixLQUFLSSxZQUFZO1lBRXBDLElBQUlJLGtCQUFrQlYsSUFBSTtnQkFDeEJ1aEIsTUFBTUcsYUFBYSxHQUFHaGhCO2dCQUN0QnBJLFdBQVdtSCxHQUFHLENBQUM3QyxRQUFRO1lBQ3pCLE9BQU87Z0JBQ0x0RSxXQUFXOFQsTUFBTSxDQUFDeFA7WUFDcEI7WUFFQSxJQUFJLENBQUNtRSxjQUFjO2dCQUNqQixPQUFPN0wsNkNBQVVBLENBQUMyTCxRQUFRLENBQUNqRTtZQUM3QjtZQUVBLElBQUksRUFDRjdDLFVBQVUsRUFDVmtPLFNBQVMsRUFDVixHQUFHbEg7WUFDSixJQUFJOGdCLHVCQUF1QjVrQixZQUFZK0wsaUJBQWlCLENBQUNwTSxRQUFRN0MsZUFBZWtELFlBQVlpTSw2QkFBNkIsQ0FBQ3RNLFFBQVE3QztZQUNsSSxJQUFJK25CLHNCQUFzQjdrQixZQUFZK0wsaUJBQWlCLENBQUNwTSxRQUFRcUwsY0FBY2hMLFlBQVlpTSw2QkFBNkIsQ0FBQ3RNLFFBQVFxTDtZQUVoSSxJQUFJNFosd0JBQXdCQyxxQkFBcUI7Z0JBQy9DLElBQUl0ZSxRQUFRdkcsWUFBWW1KLFlBQVksQ0FBQ3hKLFFBQVFtRSxjQUFjO29CQUN6RHNGLFlBQVk7b0JBQ1pDLGVBQWU7Z0JBQ2pCO2dCQUVBLElBQUk5QyxPQUFPO29CQUNULElBQUksQ0FBQ3ZHLFlBQVlvQyxXQUFXLENBQUN6QyxXQUFXLENBQUVnbEIsQ0FBQUEsd0JBQXdCLFFBQVFBLHdCQUF3QixLQUFLLEtBQUtBLG9CQUFvQnJELGlCQUFpQixFQUFDLEtBQU0sQ0FBRXFELENBQUFBLHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxLQUFLQSxvQkFBb0JwRCxVQUFVLEVBQUMsR0FBSTt3QkFDN1B0cEIsNkNBQVVBLENBQUNrbEIsTUFBTSxDQUFDeGQsUUFBUTRHO29CQUM1QixPQUFPO3dCQUNMb2Usd0JBQXdCLFFBQVFBLHdCQUF3QixLQUFLLElBQUksS0FBSyxJQUFJQSxvQkFBb0J0RSxnQkFBZ0IsQ0FBQzlaO29CQUNqSDtnQkFDRjtZQUNGLEVBQUUsOEVBQThFO1lBR2hGLElBQUl1SyxZQUFhLEVBQUM4VCx3QkFBd0IsQ0FBQ0MsbUJBQWtCLEdBQUk7Z0JBQy9ENXNCLDZDQUFVQSxDQUFDMkwsUUFBUSxDQUFDakU7WUFDdEI7UUFDRjtJQUNGLEdBQUcsTUFBTTtRQUFDbVI7S0FBUztJQUNuQixJQUFJMkwsK0JBQStCNWtCLDhDQUFPQSxDQUFDLElBQU1kLHNEQUFRQSxDQUFDMmxCLHNCQUFzQixJQUFJO1FBQUNBO0tBQXFCO0lBQzFHLElBQUlpSSxzQkFBc0JuQyx1QkFBdUI7UUFDL0NobEIsTUFBTTBRO1FBQ053TztRQUNBRDtJQUNGO0lBQ0FwUCwwQkFBMEI7UUFDeEIsNkRBQTZEO1FBQzdELElBQUl6UTtRQUVKLElBQUlzUixJQUFJM0QsT0FBTyxJQUFLM04sQ0FBQUEsVUFBU1AsZUFBZTZSLElBQUkzRCxPQUFPLElBQUk7WUFDekQxUCxpQkFBaUIySCxHQUFHLENBQUM3QyxRQUFRL0M7WUFDN0I5QixrQkFBa0IwSCxHQUFHLENBQUM3QyxRQUFRdU8sSUFBSTNELE9BQU87WUFDekN0UCxnQkFBZ0J1SCxHQUFHLENBQUM3QyxRQUFRdU8sSUFBSTNELE9BQU87WUFDdkN2UCxnQkFBZ0J3SCxHQUFHLENBQUMwTCxJQUFJM0QsT0FBTyxFQUFFNUs7UUFDbkMsT0FBTztZQUNMMUUsZ0JBQWdCa1UsTUFBTSxDQUFDeFA7UUFDekIsRUFBRSxnREFBZ0Q7UUFHbEQsSUFBSSxFQUNGa0UsU0FBUyxFQUNWLEdBQUdsRTtRQUNKLElBQUlzRCxPQUFPakQsWUFBWThDLHdCQUF3QixDQUFDbkQ7UUFDaEQsSUFBSW1FLGVBQWViLEtBQUtJLFlBQVk7UUFFcEMsSUFBSSxDQUFDUyxnQkFBZ0IsQ0FBQzlELFlBQVlzRCxTQUFTLENBQUMzRCxXQUFXZ2xCLHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxLQUFLQSxvQkFBb0IvRyxnQkFBZ0IsSUFBSTtZQUMvSjtRQUNGO1FBRUEsSUFBSWtILGtCQUFrQkMsQ0FBQUE7WUFDcEIsSUFBSUMsa0JBQWtCbGhCLGFBQWFpVCxJQUFJLEtBQUssUUFBUSxzREFBc0Q7WUFFMUcsSUFBSSxDQUFDbFQsYUFBYSxDQUFDbWhCLGlCQUFpQjtnQkFDbEM7WUFDRixFQUFFLGlEQUFpRDtZQUduRCxJQUFJQyxnQkFBZ0JucUIsa0JBQWtCdUgsR0FBRyxDQUFDMUM7WUFDMUMsSUFBSXVsQiwwQkFBMEI7WUFFOUIsSUFBSUQsY0FBYy9rQixRQUFRLENBQUM0RCxhQUFhaEgsVUFBVSxLQUFLbW9CLGNBQWMva0IsUUFBUSxDQUFDNEQsYUFBYWtILFNBQVMsR0FBRztnQkFDckdrYSwwQkFBMEI7WUFDNUIsRUFBRSxpR0FBaUc7WUFHbkcsSUFBSUYsbUJBQW1CRSwyQkFBMkJyaEIsYUFBYSxDQUFDa2hCLGFBQWE7Z0JBQzNFLElBQUlJLGFBQWFubEIsWUFBWW1KLFlBQVksQ0FBQ3hKLFFBQVFtRSxjQUFjO29CQUM5RHNGLFlBQVk7b0JBQ1osc0RBQXNEO29CQUN0RCx3REFBd0Q7b0JBQ3hEQyxlQUFlO2dCQUNqQjtnQkFFQSxJQUFJOGIsY0FBY2p0Qix3Q0FBS0EsQ0FBQ2lWLE1BQU0sQ0FBQ2dZLFlBQVl0aEIsWUFBWTtvQkFDckQsSUFBSXVoQjtvQkFFSixJQUFJLENBQUNkLE1BQU1JLGtCQUFrQixFQUFFO3dCQUM3QjtvQkFDRixFQUFFLGtEQUFrRDtvQkFHcEQsSUFBSSxFQUNGNW5CLFVBQVUsRUFDWCxHQUFHZ0g7b0JBRUosSUFBSWhILGVBQWUsUUFBUUEsZUFBZSxLQUFLLEtBQUssQ0FBQ3NvQix3QkFBd0J0b0IsV0FBV3dILGFBQWEsTUFBTSxRQUFROGdCLDBCQUEwQixLQUFLLEtBQUtBLHNCQUFzQnJmLFlBQVksQ0FBQyxnQ0FBZ0M7d0JBQ3hOO29CQUNGO2dCQUNGO1lBQ0YsRUFBRSw4REFBOEQ7WUFDaEUsc0VBQXNFO1lBQ3RFLCtEQUErRDtZQUMvRCxxREFBcUQ7WUFHckQsSUFBSWxDLGFBQWEsQ0FBQzdELFlBQVk0TCxRQUFRLENBQUNqTSxRQUFRa0UsWUFBWTtnQkFDekRsRSxPQUFPa0UsU0FBUyxHQUFHN0QsWUFBWW1KLFlBQVksQ0FBQ3hKLFFBQVFtRSxjQUFjO29CQUNoRXNGLFlBQVk7b0JBQ1pDLGVBQWU7Z0JBQ2pCO2dCQUNBO1lBQ0YsRUFBRSw0REFBNEQ7WUFHOURpYixNQUFNRSxtQkFBbUIsR0FBRztZQUM1QixJQUFJYSxjQUFjeGhCLGFBQWE3RCxZQUFZc0csVUFBVSxDQUFDM0csUUFBUWtFO1lBRTlELElBQUl3aEIsYUFBYTtnQkFDZixJQUFJbnRCLHdDQUFLQSxDQUFDdU8sVUFBVSxDQUFDNUMsWUFBWTtvQkFDL0JDLGFBQWF3aEIsZ0JBQWdCLENBQUNELFlBQVluYSxZQUFZLEVBQUVtYSxZQUFZbmUsU0FBUyxFQUFFbWUsWUFBWXZhLGNBQWMsRUFBRXVhLFlBQVlyZSxXQUFXO2dCQUNwSSxPQUFPO29CQUNMbEQsYUFBYXdoQixnQkFBZ0IsQ0FBQ0QsWUFBWXZhLGNBQWMsRUFBRXVhLFlBQVlyZSxXQUFXLEVBQUVxZSxZQUFZbmEsWUFBWSxFQUFFbWEsWUFBWW5lLFNBQVM7Z0JBQ3BJO2dCQUVBNGMsd0JBQXdCbmtCLFFBQVEwbEI7WUFDbEMsT0FBTztnQkFDTHZoQixhQUFhRSxlQUFlO1lBQzlCO1lBRUEsT0FBT3FoQjtRQUNUO1FBRUEsSUFBSUEsY0FBY1A7UUFDbEIsSUFBSVMsa0JBQWtCLENBQUNaLHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CcEQsVUFBVSxFQUFDLE1BQU87UUFFdkksSUFBSSxDQUFDbGdCLGNBQWMsQ0FBQ2trQixpQkFBaUI7WUFDbkMxSCxXQUFXO2dCQUNULHVFQUF1RTtnQkFDdkUseURBQXlEO2dCQUN6RCxJQUFJd0gsZUFBZS9qQixZQUFZO29CQUM3QixJQUFJeUIsS0FBSy9DLFlBQVlnRCxTQUFTLENBQUNyRCxRQUFRQTtvQkFDdkNvRCxHQUFHVyxLQUFLO2dCQUNWO2dCQUVBNGdCLE1BQU1FLG1CQUFtQixHQUFHO1lBQzlCO1lBQ0E7UUFDRjtRQUVBLElBQUlnQixZQUFZO1FBQ2hCLElBQUlDLG1CQUFtQjFDLHNCQUFzQjtZQUMzQyxJQUFJd0MsaUJBQWlCO2dCQUNuQixJQUFJRyxxQkFBcUJYLENBQUFBO29CQUN2QixJQUFJO3dCQUNGLElBQUloaUIsS0FBSy9DLFlBQVlnRCxTQUFTLENBQUNyRCxRQUFRQTt3QkFDdkNvRCxHQUFHVyxLQUFLO3dCQUNSb2hCLGdCQUFnQkM7b0JBQ2xCLEVBQUUsT0FBT1ksR0FBRyxDQUNaO2dCQUNGLEdBQUcscUdBQXFHO2dCQUN4Ryx1R0FBdUc7Z0JBQ3ZHLHVHQUF1RztnQkFDdkcsbUJBQW1CO2dCQUduQkQ7Z0JBQ0FGLFlBQVkzSCxXQUFXO29CQUNyQixtR0FBbUc7b0JBQ25HLHFHQUFxRztvQkFDckcsK0RBQStEO29CQUMvRDZILG1CQUFtQjtvQkFDbkJwQixNQUFNRSxtQkFBbUIsR0FBRztnQkFDOUI7WUFDRjtRQUNGO1FBQ0EsT0FBTztZQUNMMUIscUJBQXFCMkM7WUFFckIsSUFBSUQsV0FBVztnQkFDYjlILGFBQWE4SDtZQUNmO1FBQ0Y7SUFDRixJQUFJLDhFQUE4RTtJQUNsRiw4RUFBOEU7SUFDOUUsd0NBQXdDO0lBQ3hDLGlEQUFpRDtJQUVqRCxJQUFJNUIsbUJBQW1CbHNCLGtEQUFXQSxDQUFDd0YsQ0FBQUE7UUFDakMybEI7UUFFQSxJQUFJLENBQUMvUixZQUFZOVEsWUFBWStMLGlCQUFpQixDQUFDcE0sUUFBUXpDLE1BQU16RCxNQUFNLEtBQUssQ0FBQ21zQixrQkFBa0Ixb0IsT0FBTzJtQix3QkFBd0I7WUFDeEgsSUFBSWdDO1lBRUosa0lBQWtJO1lBQ2xJLElBQUlsQixxQkFBcUI7Z0JBQ3ZCLE9BQU9BLG9CQUFvQmhGLG9CQUFvQixDQUFDemlCO1lBQ2xELEVBQUUsdUZBQXVGO1lBQ3pGLDBGQUEwRjtZQUMxRixpQkFBaUI7WUFHakJ1Ziw2QkFBNkJnQixLQUFLO1lBQ2xDZixxQkFBcUJlLEtBQUs7WUFDMUIsSUFBSSxFQUNGNVosU0FBUyxFQUNWLEdBQUdsRTtZQUNKLElBQUksRUFDRmtnQixXQUFXOUksSUFBSSxFQUNoQixHQUFHN1o7WUFDSixJQUFJMkgsT0FBTzNILE1BQU1vQyxZQUFZLElBQUlwQyxNQUFNMkgsSUFBSSxJQUFJVjtZQUMvQyxJQUFJMmhCLHNCQUFzQi9PLFNBQVMsMkJBQTJCQSxTQUFTLHlCQUF5Qiw0RUFBNEU7WUFDNUssNkdBQTZHO1lBRTdHLElBQUkrTyx1QkFBdUI5bEIsWUFBWW9DLFdBQVcsQ0FBQ3pDLFNBQVM7Z0JBQzFEO1lBQ0Y7WUFFQSxJQUFJb21CLFNBQVM7WUFFYixJQUFJaFAsU0FBUyxnQkFBZ0JsVCxhQUFhM0wsd0NBQUtBLENBQUMwTyxXQUFXLENBQUMvQyxjQUFjLGtGQUFrRjtZQUM1SixtRkFBbUY7WUFDbkYsNEJBQTRCO1lBQzVCM0csTUFBTTJILElBQUksSUFBSTNILE1BQU0ySCxJQUFJLENBQUNoTCxNQUFNLEtBQUssS0FBSyxVQUFVb0gsSUFBSSxDQUFDL0QsTUFBTTJILElBQUksS0FBSyx3SEFBd0g7WUFDL0wsK0RBQStEO1lBQy9ELCtDQUErQztZQUMvQ2hCLFVBQVUyQyxNQUFNLENBQUMvSSxNQUFNLEtBQUssR0FBRztnQkFDN0IsSUFBSXVvQixxQkFBcUJDO2dCQUV6QkYsU0FBUyxNQUFNLHFDQUFxQztnQkFDcEQsa0RBQWtEO2dCQUVsRCxJQUFJcG1CLE9BQU9xZSxLQUFLLEVBQUU7b0JBQ2hCK0gsU0FBUztnQkFDWCxFQUFFLHFJQUFxSTtnQkFDdkksb0ZBQW9GO2dCQUdwRixJQUFJLEVBQ0Z2ZixNQUFNLEVBQ1AsR0FBRzNDO2dCQUNKLElBQUksQ0FBQ3JHLE1BQU1DLE9BQU8sR0FBR3VDLFlBQVltRixVQUFVLENBQUN4RixRQUFRNkc7Z0JBQ3BELElBQUkxSixhQUFhLENBQUNrcEIsc0JBQXNCeG9CLEtBQUs4RyxhQUFhLE1BQU0sUUFBUTBoQix3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CdGhCLE9BQU8sQ0FBQztnQkFDOUksSUFBSTlILFVBQVNvRCxZQUFZQyxTQUFTLENBQUNOO2dCQUVuQyxJQUFJb21CLFVBQVVqcEIsY0FBY2tELFlBQVlHLFVBQVUsQ0FBQ1IsUUFBUTdDLGFBQWE7b0JBQ3RFLElBQUlvcEI7b0JBRUosNkNBQTZDO29CQUM3QyxJQUFJQyxXQUFXdnBCLFlBQVcsUUFBUUEsWUFBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFPbUQsUUFBUSxDQUFDcW1CLGdCQUFnQixDQUFDdHBCLFlBQVl1cEIsV0FBV0MsU0FBUyxFQUFFQyxTQUFTO29CQUUzSSxJQUFJSixhQUFhM29CLFFBQVEsQ0FBQyxDQUFDMG9CLHdCQUF3QkMsU0FBU3BvQixXQUFXLE1BQU0sUUFBUW1vQiwwQkFBMEIsS0FBSyxJQUFJLEtBQUssSUFBSUEsc0JBQXNCcnNCLE1BQU0sTUFBTTRELFFBQVE7d0JBQ3pLc29CLFNBQVM7b0JBQ1g7Z0JBQ0YsRUFBRSxnR0FBZ0c7Z0JBQ2xHLGtHQUFrRztnQkFHbEcsSUFBSUEsVUFBVXZvQixLQUFLOEcsYUFBYSxJQUFJLENBQUMxSCxZQUFXLFFBQVFBLFlBQVcsS0FBSyxJQUFJLEtBQUssSUFBSSxDQUFDcXBCLHdCQUF3QnJwQixRQUFPcUMsZ0JBQWdCLENBQUN6QixLQUFLOEcsYUFBYSxPQUFPLFFBQVEyaEIsMEJBQTBCLEtBQUssSUFBSSxLQUFLLElBQUlBLHNCQUFzQk8sVUFBVSxNQUFNLE9BQU87b0JBQzlQLElBQUlDLFFBQVExdUIseUNBQU1BLENBQUMwaUIsS0FBSyxDQUFDOWEsUUFBUTt3QkFDL0IyRixJQUFJa0IsT0FBTzlELElBQUk7d0JBQ2ZqRCxPQUFPcEYsQ0FBQUEsSUFBS2pDLDBDQUFTQSxDQUFDNlAsU0FBUyxDQUFDNU4sTUFBTXRDLHlDQUFNQSxDQUFDMmlCLE9BQU8sQ0FBQy9hLFFBQVF0RjtvQkFDL0Q7b0JBRUEsSUFBSW9zQixTQUFTbnVCLHVDQUFJQSxDQUFDdVYsTUFBTSxDQUFDNFksS0FBSyxDQUFDLEVBQUUsRUFBRWhpQixRQUFRLENBQUMsTUFBTzt3QkFDakRzaEIsU0FBUztvQkFDWDtnQkFDRjtZQUNGLEVBQUUsc0VBQXNFO1lBQ3hFLHdFQUF3RTtZQUN4RSxvREFBb0Q7WUFHcEQsSUFBSSxDQUFDaFAsS0FBSzdRLFVBQVUsQ0FBQyxhQUFhNlEsS0FBSzdRLFVBQVUsQ0FBQyxhQUFhO2dCQUM3RCxJQUFJLENBQUNvVSxZQUFZLEdBQUdwZCxNQUFNaUYsZUFBZTtnQkFFekMsSUFBSW1ZLGFBQWE7b0JBQ2YsSUFBSS9ULFFBQVF2RyxZQUFZbUosWUFBWSxDQUFDeEosUUFBUTJhLGFBQWE7d0JBQ3hEbFIsWUFBWTt3QkFDWkMsZUFBZTtvQkFDakI7b0JBRUEsSUFBSSxDQUFDeEYsYUFBYSxDQUFDM0wsd0NBQUtBLENBQUNpVixNQUFNLENBQUN0SixXQUFXMEMsUUFBUTt3QkFDakR3ZixTQUFTO3dCQUNULElBQUlqSSxlQUFlLENBQUNnSSx1QkFBdUJubUIsT0FBT2tFLFNBQVMsSUFBSTlMLHlDQUFNQSxDQUFDZ21CLFFBQVEsQ0FBQ3BlLFFBQVFBLE9BQU9rRSxTQUFTO3dCQUN2RzVMLDZDQUFVQSxDQUFDa2xCLE1BQU0sQ0FBQ3hkLFFBQVE0Rzt3QkFFMUIsSUFBSXVYLGNBQWM7NEJBQ2hCdmlCLHlCQUF5QmlILEdBQUcsQ0FBQzdDLFFBQVFtZTt3QkFDdkM7b0JBQ0Y7Z0JBQ0Y7WUFDRixFQUFFLDZFQUE2RTtZQUMvRSxtRUFBbUU7WUFHbkUsSUFBSWdJLHFCQUFxQjtnQkFDdkI7WUFDRjtZQUVBLElBQUksQ0FBQ0MsUUFBUTtnQkFDWDdvQixNQUFNd3BCLGNBQWM7WUFDdEIsRUFBRSx1RUFBdUU7WUFDekUsb0VBQW9FO1lBR3BFLElBQUk3aUIsYUFBYTNMLHdDQUFLQSxDQUFDcVQsVUFBVSxDQUFDMUgsY0FBY2tULEtBQUs3USxVQUFVLENBQUMsV0FBVztnQkFDekUsSUFBSTlILFlBQVkyWSxLQUFLdk0sUUFBUSxDQUFDLGNBQWMsYUFBYTtnQkFDekR6Uyx5Q0FBTUEsQ0FBQ3VtQixjQUFjLENBQUMzZSxRQUFRO29CQUM1QnZCO2dCQUNGO2dCQUNBO1lBQ0Y7WUFFQSxPQUFRMlk7Z0JBQ04sS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0g7d0JBQ0VoZix5Q0FBTUEsQ0FBQ3VtQixjQUFjLENBQUMzZTt3QkFDdEI7b0JBQ0Y7Z0JBRUYsS0FBSztnQkFDTCxLQUFLO29CQUNIO3dCQUNFNUgseUNBQU1BLENBQUNtYixhQUFhLENBQUN2VDt3QkFDckI7b0JBQ0Y7Z0JBRUYsS0FBSztvQkFDSDt3QkFDRTVILHlDQUFNQSxDQUFDa2IsY0FBYyxDQUFDdFQ7d0JBQ3RCO29CQUNGO2dCQUVGLEtBQUs7b0JBQ0g7d0JBQ0U1SCx5Q0FBTUEsQ0FBQ2tiLGNBQWMsQ0FBQ3RULFFBQVE7NEJBQzVCOGdCLE1BQU07d0JBQ1I7d0JBQ0Exb0IseUNBQU1BLENBQUNtYixhQUFhLENBQUN2VCxRQUFROzRCQUMzQjhnQixNQUFNO3dCQUNSO3dCQUNBO29CQUNGO2dCQUVGLEtBQUs7b0JBQ0g7d0JBQ0Uxb0IseUNBQU1BLENBQUNrYixjQUFjLENBQUN0VCxRQUFROzRCQUM1QjhnQixNQUFNO3dCQUNSO3dCQUNBO29CQUNGO2dCQUVGLEtBQUs7b0JBQ0g7d0JBQ0Uxb0IseUNBQU1BLENBQUNrYixjQUFjLENBQUN0VCxRQUFROzRCQUM1QjhnQixNQUFNO3dCQUNSO3dCQUNBO29CQUNGO2dCQUVGLEtBQUs7b0JBQ0g7d0JBQ0Uxb0IseUNBQU1BLENBQUNtYixhQUFhLENBQUN2VCxRQUFROzRCQUMzQjhnQixNQUFNO3dCQUNSO3dCQUNBO29CQUNGO2dCQUVGLEtBQUs7b0JBQ0g7d0JBQ0Uxb0IseUNBQU1BLENBQUNtYixhQUFhLENBQUN2VCxRQUFROzRCQUMzQjhnQixNQUFNO3dCQUNSO3dCQUNBO29CQUNGO2dCQUVGLEtBQUs7b0JBQ0g7d0JBQ0Uxb0IseUNBQU1BLENBQUNrYixjQUFjLENBQUN0VCxRQUFROzRCQUM1QjhnQixNQUFNO3dCQUNSO3dCQUNBO29CQUNGO2dCQUVGLEtBQUs7b0JBQ0g7d0JBQ0Uxb0IseUNBQU1BLENBQUNtYixhQUFhLENBQUN2VCxRQUFROzRCQUMzQjhnQixNQUFNO3dCQUNSO3dCQUNBO29CQUNGO2dCQUVGLEtBQUs7b0JBQ0gxb0IseUNBQU1BLENBQUN1YixlQUFlLENBQUMzVDtvQkFDdkI7Z0JBRUYsS0FBSztvQkFDSDt3QkFDRTVILHlDQUFNQSxDQUFDMm9CLFdBQVcsQ0FBQy9nQjt3QkFDbkI7b0JBQ0Y7Z0JBRUYsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0g7d0JBQ0UsSUFBSW9YLFNBQVMseUJBQXlCOzRCQUNwQyw4REFBOEQ7NEJBQzlELG1FQUFtRTs0QkFDbkUscUVBQXFFOzRCQUNyRSw2QkFBNkI7NEJBQzdCLHdDQUF3Qzs0QkFDeEMsSUFBSS9XLFlBQVlvQyxXQUFXLENBQUN6QyxTQUFTO2dDQUNuQ3drQixlQUFlO2dDQUNmN29CLGFBQWFrSCxHQUFHLENBQUM3QyxRQUFROzRCQUMzQjt3QkFDRixFQUFFLHlEQUF5RDt3QkFDM0QsbUVBQW1FO3dCQUNuRSxzREFBc0Q7d0JBR3RELElBQUksQ0FBQ2tGLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLdEssV0FBVyxDQUFDZ2lCLElBQUksTUFBTSxnQkFBZ0I7NEJBQzFGdmMsWUFBWTRFLFVBQVUsQ0FBQ2pGLFFBQVFrRjt3QkFDakMsT0FBTyxJQUFJLE9BQU9BLFNBQVMsVUFBVTs0QkFDbkMsb0VBQW9FOzRCQUNwRSwyREFBMkQ7NEJBQzNELElBQUlraEIsUUFBUTtnQ0FDVjNCLG1CQUFtQjdaLE9BQU8sQ0FBQytGLElBQUksQ0FBQyxJQUFNdlkseUNBQU1BLENBQUNzbUIsVUFBVSxDQUFDMWUsUUFBUWtGOzRCQUNsRSxPQUFPO2dDQUNMOU0seUNBQU1BLENBQUNzbUIsVUFBVSxDQUFDMWUsUUFBUWtGOzRCQUM1Qjt3QkFDRjt3QkFFQTtvQkFDRjtZQUNKLEVBQUUsOERBQThEO1lBR2hFLElBQUk4aEIsWUFBWSxDQUFDZCx3QkFBd0J0cUIseUJBQXlCOEcsR0FBRyxDQUFDMUMsT0FBTSxNQUFPLFFBQVFrbUIsMEJBQTBCLEtBQUssSUFBSSxLQUFLLElBQUlBLHNCQUFzQnBILEtBQUs7WUFDbEtsakIseUJBQXlCNFQsTUFBTSxDQUFDeFA7WUFFaEMsSUFBSWduQixhQUFjLEVBQUNobkIsT0FBT2tFLFNBQVMsSUFBSSxDQUFDM0wsd0NBQUtBLENBQUNpVixNQUFNLENBQUN4TixPQUFPa0UsU0FBUyxFQUFFOGlCLFVBQVMsR0FBSTtnQkFDbEYxdUIsNkNBQVVBLENBQUNrbEIsTUFBTSxDQUFDeGQsUUFBUWduQjtZQUM1QjtRQUNGO0lBQ0YsR0FBRztRQUFDN1Y7UUFBVStTO0tBQXNCO0lBQ3BDLElBQUl0VCxjQUFjN1ksa0RBQVdBLENBQUM4RixDQUFBQTtRQUM1QixJQUFJQSxRQUFRLE1BQU07WUFDaEJrZixxQkFBcUI4QixNQUFNO1lBQzNCL0IsNkJBQTZCK0IsTUFBTTtZQUNuQzFqQixrQkFBa0JxVSxNQUFNLENBQUN4UDtZQUN6QjFFLGdCQUFnQmtVLE1BQU0sQ0FBQ3hQO1lBRXZCLElBQUl1TyxJQUFJM0QsT0FBTyxJQUFJdEksMEJBQTBCO2dCQUMzQyx1REFBdUQ7Z0JBQ3ZEaU0sSUFBSTNELE9BQU8sQ0FBQ3FjLG1CQUFtQixDQUFDLGVBQWVoRDtZQUNqRDtRQUNGLE9BQU87WUFDTCw4RUFBOEU7WUFDOUUsNEVBQTRFO1lBQzVFLGtEQUFrRDtZQUNsRCxpREFBaUQ7WUFDakQsSUFBSTNoQiwwQkFBMEI7Z0JBQzVCLHVEQUF1RDtnQkFDdkR6RSxLQUFLcXBCLGdCQUFnQixDQUFDLGVBQWVqRDtZQUN2QztRQUNGO1FBRUExVixJQUFJM0QsT0FBTyxHQUFHL007SUFDaEIsR0FBRztRQUFDMFE7UUFBSzBWO1FBQWtCbEg7UUFBc0JEO0tBQTZCLEdBQUcsMkVBQTJFO0lBQzVKLDZFQUE2RTtJQUM3RSw4RUFBOEU7SUFDOUUsdUVBQXVFO0lBQ3ZFLGdEQUFnRDtJQUVoRHBQLDBCQUEwQjtRQUN4QixJQUFJelEsVUFBU29ELFlBQVlDLFNBQVMsQ0FBQ047UUFDbkMvQyxRQUFPbUQsUUFBUSxDQUFDOG1CLGdCQUFnQixDQUFDLG1CQUFtQnBLO1FBQ3BELE9BQU87WUFDTDdmLFFBQU9tRCxRQUFRLENBQUM2bUIsbUJBQW1CLENBQUMsbUJBQW1Cbks7UUFDekQ7SUFDRixHQUFHO1FBQUNBO0tBQTZCO0lBQ2pDLElBQUlyTSxjQUFjd0IsU0FBUztRQUFDalM7UUFBUSxFQUFFO0tBQUM7SUFFdkMsSUFBSTZQLGVBQWU3UCxPQUFPbU8sUUFBUSxDQUFDalUsTUFBTSxLQUFLLEtBQUtpRixNQUFNQyxJQUFJLENBQUN6Ryx1Q0FBSUEsQ0FBQ2tOLEtBQUssQ0FBQzdGLFNBQVM5RixNQUFNLEtBQUssS0FBS3ZCLHVDQUFJQSxDQUFDdVYsTUFBTSxDQUFDbE8sWUFBWSxNQUFNLENBQUN5QyxhQUFhO1FBQzVJLElBQUlzRCxRQUFRM04seUNBQU1BLENBQUMyTixLQUFLLENBQUMvRixRQUFRLEVBQUU7UUFDbkN5USxZQUFZRSxJQUFJLENBQUM7WUFDZixDQUFDdFUsbUJBQW1CLEVBQUU7WUFDdEJ3VDtZQUNBaEosUUFBUWQ7WUFDUmhDLE9BQU9nQztRQUNUO0lBQ0Y7SUFFQSxJQUFJLEVBQ0ZzWSxLQUFLLEVBQ04sR0FBR3JlO0lBQ0oya0IsTUFBTUksa0JBQWtCLEdBQUc7SUFFM0IsSUFBSS9rQixPQUFPa0UsU0FBUyxJQUFJM0wsd0NBQUtBLENBQUMwTyxXQUFXLENBQUNqSCxPQUFPa0UsU0FBUyxLQUFLbWEsT0FBTztRQUNwRSxJQUFJLEVBQ0Z4WCxNQUFNLEVBQ1AsR0FBRzdHLE9BQU9rRSxTQUFTO1FBQ3BCLElBQUkySixPQUFPbFYsdUNBQUlBLENBQUNrVixJQUFJLENBQUM3TixRQUFRNkcsT0FBTzlELElBQUk7UUFFeEMsSUFBSW9rQixPQUFPL3NCLHlCQUF5QnlULE1BQU15VixhQUFhLDBFQUEwRTtRQUNqSSx5Q0FBeUM7UUFHekMsSUFBSSxDQUFDenFCLHVDQUFNQSxDQUFDMlUsTUFBTSxDQUFDSyxNQUFNd1EsT0FBTztZQUM5QitJLE9BQU87UUFDVCxJQUFJO1lBQ0Z6QyxNQUFNSSxrQkFBa0IsR0FBRztZQUMzQixJQUFJc0MsUUFBUS90QixPQUFPZ3VCLFdBQVcsQ0FBQ2h1QixPQUFPVSxJQUFJLENBQUNtdEIsTUFBTUksR0FBRyxDQUFDQyxDQUFBQSxPQUFRO29CQUFDQTtvQkFBTTtpQkFBSztZQUN6RS9XLFlBQVlFLElBQUksQ0FBQzZTLGdCQUFnQkEsZ0JBQWdCQSxnQkFBZ0I7Z0JBQy9ELENBQUNqbkIsd0JBQXdCLEVBQUU7WUFDN0IsR0FBRzhxQixRQUFRaEosUUFBUSxDQUFDLEdBQUc7Z0JBQ3JCeFg7Z0JBQ0E5QyxPQUFPOEM7WUFDVDtRQUNGO0lBQ0YsRUFBRSw0RkFBNEY7SUFDOUYsK0NBQStDO0lBRy9DclAsZ0RBQVNBLENBQUM7UUFDUjBtQixXQUFXO1lBQ1QsSUFBSSxFQUNGaGEsU0FBUyxFQUNWLEdBQUdsRTtZQUVKLElBQUlrRSxXQUFXO2dCQUNiLElBQUksRUFDRjJDLFFBQVEyVSxPQUFPLEVBQ2hCLEdBQUd0WDtnQkFFSixJQUFJdU4sUUFBUTlZLHVDQUFJQSxDQUFDa1YsSUFBSSxDQUFDN04sUUFBUXdiLFFBQVF6WSxJQUFJLEdBQUcsMEVBQTBFO2dCQUN2SCx5Q0FBeUM7Z0JBR3pDLElBQUlzYixTQUFTLENBQUN4bEIsdUNBQU1BLENBQUMyVSxNQUFNLENBQUNpRSxPQUFPNE0sT0FBTztvQkFDeEMrSSxPQUFPO2dCQUNULElBQUk7b0JBQ0ZyckIsa0NBQWtDOEcsR0FBRyxDQUFDN0MsUUFBUXFlO29CQUM5QztnQkFDRjtZQUNGO1lBRUF0aUIsa0NBQWtDeVQsTUFBTSxDQUFDeFA7UUFDM0M7SUFDRjtJQUNBLElBQUl5bkIsb0JBQW9CLENBQUM5RCx3QkFBd0J2b0IsOEJBQThCc0gsR0FBRyxDQUFDMUMsT0FBTSxNQUFPLFFBQVEyakIsMEJBQTBCLEtBQUssSUFBSSxLQUFLLElBQUksQ0FBQ0MseUJBQXlCRCxzQkFBc0JsYixxQkFBcUIsRUFBQyxNQUFPLFFBQVFtYiwyQkFBMkIsS0FBSyxJQUFJLEtBQUssSUFBSUEsdUJBQXVCN2EsTUFBTTtJQUNuVCxPQUFPLFdBQVcsR0FBRXpSLDBEQUFtQixDQUFDbWIsZ0JBQWdCRCxRQUFRLEVBQUU7UUFDaEVuWixPQUFPOFg7SUFDVCxHQUFHLFdBQVcsR0FBRTdaLDBEQUFtQixDQUFDdWEsZ0JBQWdCVyxRQUFRLEVBQUU7UUFDNURuWixPQUFPNFk7SUFDVCxHQUFHLFdBQVcsR0FBRTNhLDBEQUFtQixDQUFDeWhCLFlBQVk7UUFDOUNsYixNQUFNMFE7UUFDTm9JLG1CQUFtQkE7SUFDckIsR0FBRyxXQUFXLEdBQUVyZiwwREFBbUIsQ0FBQ1UsV0FBV3NCLE9BQU91VixNQUFNLENBQUM7UUFDM0Q2WSxNQUFNdlcsV0FBVzNNLFlBQVk7UUFDN0Isa0JBQWtCMk0sV0FBVzNNLFlBQVk7SUFDM0MsR0FBR29LLFlBQVk7UUFDYiwwRUFBMEU7UUFDMUUsbUVBQW1FO1FBQ25FLDJFQUEyRTtRQUMzRSwwRUFBMEU7UUFDMUUsbURBQW1EO1FBQ25EK1ksWUFBWXJsQiw0QkFBNEIsQ0FBQ0YsY0FBY3dNLFdBQVcrWSxVQUFVLEdBQUc7UUFDL0VDLGFBQWF0bEIsNEJBQTRCLENBQUNGLGNBQWN3TSxXQUFXZ1osV0FBVyxHQUFHO1FBQ2pGQyxnQkFBZ0J2bEIsNEJBQTRCLENBQUNGLGNBQWN3TSxXQUFXaVosY0FBYyxHQUFHO1FBQ3ZGLHFCQUFxQjtRQUNyQixtQkFBbUI7UUFDbkIsc0JBQXNCO1FBQ3RCelgsaUJBQWlCLENBQUNlO1FBQ2xCLDZGQUE2RjtRQUM3Riw0RUFBNEU7UUFDNUUscUNBQXFDO1FBQ3JDMlcsUUFBUSxDQUFDO1FBQ1RDLGdDQUFnQztRQUNoQ3haLEtBQUtxQztRQUNMZCxPQUFPMFQsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHZSx1QkFBdUIsQ0FBQyxJQUFJZixnQkFBZ0I7WUFDckYsc0RBQXNEO1lBQ3REbmEsVUFBVTtZQUNWLHNDQUFzQztZQUN0Q3NJLFNBQVM7WUFDVCw4Q0FBOEM7WUFDOUNrVixZQUFZO1lBQ1osNkNBQTZDO1lBQzdDbUIsVUFBVTtRQUNaLEdBQUdQLG9CQUFvQjtZQUNyQlEsV0FBV1I7UUFDYixJQUFJLENBQUMsS0FBS3BEO1FBQ1Y2RCxlQUFlbndCLGtEQUFXQSxDQUFDd0YsQ0FBQUE7WUFDekIsd0VBQXdFO1lBQ3hFLDhEQUE4RDtZQUM5RCw4Q0FBOEM7WUFDOUMsSUFBSSxDQUFDK0UsNEJBQTRCLENBQUM2TyxZQUFZLENBQUNnWCxlQUFlNXFCLE9BQU9xUixXQUFXc1osYUFBYSxLQUFLN25CLFlBQVlnTSxtQkFBbUIsQ0FBQ3JNLFFBQVF6QyxNQUFNekQsTUFBTSxHQUFHO2dCQUN2SnlELE1BQU13cEIsY0FBYztnQkFFcEIsSUFBSSxDQUFDMW1CLFlBQVlvQyxXQUFXLENBQUN6QyxTQUFTO29CQUNwQyxJQUFJb29CLFNBQVM3cUIsTUFBTTJILElBQUk7b0JBQ3ZCOU0seUNBQU1BLENBQUNzbUIsVUFBVSxDQUFDMWUsUUFBUW9vQjtnQkFDNUI7WUFDRjtRQUNGLEdBQUc7WUFBQ2pYO1NBQVM7UUFDYmtYLFNBQVN0d0Isa0RBQVdBLENBQUN3RixDQUFBQTtZQUNuQixJQUFJNHFCLGVBQWU1cUIsT0FBT3FSLFdBQVd5WixPQUFPLEdBQUc7Z0JBQzdDO1lBQ0Y7WUFFQSxJQUFJckQscUJBQXFCO2dCQUN2QkEsb0JBQW9CakQsV0FBVztnQkFDL0I7WUFDRixFQUFFLGlFQUFpRTtZQUNuRSw2REFBNkQ7WUFDN0QsZ0VBQWdFO1lBQ2hFLG1DQUFtQztZQUduQyxLQUFLLElBQUkzRyxNQUFNcUosbUJBQW1CN1osT0FBTyxDQUFFO2dCQUN6Q3dRO1lBQ0Y7WUFFQXFKLG1CQUFtQjdaLE9BQU8sR0FBRyxFQUFFO1FBQ2pDLEdBQUcsRUFBRTtRQUNMMGQsUUFBUXZ3QixrREFBV0EsQ0FBQ3dGLENBQUFBO1lBQ2xCLElBQUk0VCxZQUFZd1QsTUFBTUUsbUJBQW1CLElBQUksQ0FBQ3hrQixZQUFZZ00sbUJBQW1CLENBQUNyTSxRQUFRekMsTUFBTXpELE1BQU0sS0FBS3F1QixlQUFlNXFCLE9BQU9xUixXQUFXMFosTUFBTSxHQUFHO2dCQUMvSTtZQUNGLEVBQUUsK0RBQStEO1lBQ2pFLDREQUE0RDtZQUM1RCxrRUFBa0U7WUFDbEUsNkRBQTZEO1lBRzdELElBQUlobEIsT0FBT2pELFlBQVk4Qyx3QkFBd0IsQ0FBQ25EO1lBRWhELElBQUkya0IsTUFBTUcsYUFBYSxLQUFLeGhCLEtBQUtRLGFBQWEsRUFBRTtnQkFDOUM7WUFDRjtZQUVBLElBQUksRUFDRnlrQixhQUFhLEVBQ2QsR0FBR2hyQjtZQUNKLElBQUk2RixLQUFLL0MsWUFBWWdELFNBQVMsQ0FBQ3JELFFBQVFBLFNBQVMsZ0VBQWdFO1lBQ2hILGtFQUFrRTtZQUNsRSwrQkFBK0I7WUFFL0IsSUFBSXVvQixrQkFBa0JubEIsSUFBSTtnQkFDeEI7WUFDRixFQUFFLGtFQUFrRTtZQUNwRSxxREFBcUQ7WUFHckQsSUFBSXBHLGFBQWF1ckIsa0JBQWtCQSxjQUFjbmlCLFlBQVksQ0FBQyxzQkFBc0I7Z0JBQ2xGO1lBQ0YsRUFBRSxrRUFBa0U7WUFDcEUsa0VBQWtFO1lBQ2xFLDBDQUEwQztZQUcxQyxJQUFJbWlCLGlCQUFpQixRQUFRenJCLFVBQVV5ckIsa0JBQWtCbG9CLFlBQVlHLFVBQVUsQ0FBQ1IsUUFBUXVvQixnQkFBZ0I7Z0JBQ3RHLElBQUkxcUIsT0FBT3dDLFlBQVl5SCxXQUFXLENBQUM5SCxRQUFRdW9CO2dCQUUzQyxJQUFJOXZCLDBDQUFTQSxDQUFDNlAsU0FBUyxDQUFDekssU0FBUyxDQUFDbUMsT0FBT3VJLE1BQU0sQ0FBQzFLLE9BQU87b0JBQ3JEO2dCQUNGO1lBQ0YsRUFBRSwwRUFBMEU7WUFDNUUsa0RBQWtEO1lBQ2xELGdJQUFnSTtZQUdoSSxJQUFJK0QsV0FBVztnQkFDYixJQUFJdUMsZUFBZWIsS0FBS0ksWUFBWTtnQkFDcENTLGlCQUFpQixRQUFRQSxpQkFBaUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsYUFBYUUsZUFBZTtZQUMxRjtZQUVBM0ksV0FBVzhULE1BQU0sQ0FBQ3hQO1FBQ3BCLEdBQUc7WUFBQ21SO1lBQVV2QyxXQUFXMFosTUFBTTtTQUFDO1FBQ2hDRSxTQUFTendCLGtEQUFXQSxDQUFDd0YsQ0FBQUE7WUFDbkIsSUFBSThDLFlBQVk4TCxTQUFTLENBQUNuTSxRQUFRekMsTUFBTXpELE1BQU0sS0FBSyxDQUFDcXVCLGVBQWU1cUIsT0FBT3FSLFdBQVc0WixPQUFPLEtBQUsxckIsVUFBVVMsTUFBTXpELE1BQU0sR0FBRztnQkFDeEgsSUFBSStELE9BQU93QyxZQUFZeUgsV0FBVyxDQUFDOUgsUUFBUXpDLE1BQU16RCxNQUFNO2dCQUN2RCxJQUFJaUosT0FBTzFDLFlBQVl5QyxRQUFRLENBQUM5QyxRQUFRbkMsT0FBTyxpRUFBaUU7Z0JBQ2hILHVFQUF1RTtnQkFDdkUsMERBQTBEO2dCQUMxRCw2Q0FBNkM7Z0JBRTdDLElBQUksQ0FBQ3pGLHlDQUFNQSxDQUFDOFQsT0FBTyxDQUFDbE0sUUFBUStDLFNBQVNwSyx1Q0FBSUEsQ0FBQytKLEdBQUcsQ0FBQzFDLFFBQVErQyxVQUFVbEYsTUFBTTtvQkFDcEU7Z0JBQ0Y7Z0JBRUEsSUFBSU4sTUFBTWtyQixNQUFNLEtBQUszVixnQkFBZ0IvUCxLQUFLN0ksTUFBTSxJQUFJLEdBQUc7b0JBQ3JELElBQUl3dUIsWUFBWTNsQjtvQkFFaEIsSUFBSSxDQUFFdEssQ0FBQUEsMENBQVNBLENBQUM2UCxTQUFTLENBQUN6SyxTQUFTekYseUNBQU1BLENBQUMyaUIsT0FBTyxDQUFDL2EsUUFBUW5DLEtBQUksR0FBSTt3QkFDaEUsSUFBSThxQjt3QkFFSixJQUFJN0IsUUFBUTF1Qix5Q0FBTUEsQ0FBQzBpQixLQUFLLENBQUM5YSxRQUFROzRCQUMvQkYsT0FBT3BGLENBQUFBLElBQUtqQywwQ0FBU0EsQ0FBQzZQLFNBQVMsQ0FBQzVOLE1BQU10Qyx5Q0FBTUEsQ0FBQzJpQixPQUFPLENBQUMvYSxRQUFRdEY7NEJBQzdEaUwsSUFBSTVDO3dCQUNOO3dCQUNBMmxCLFlBQVksQ0FBQ0MsVUFBVTdCLFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLLENBQUMsRUFBRSxNQUFNLFFBQVE2QixZQUFZLEtBQUssSUFBSUEsVUFBVTVsQixLQUFLd0gsS0FBSyxDQUFDLEdBQUc7b0JBQzFJO29CQUVBLElBQUkzRCxRQUFReE8seUNBQU1BLENBQUN3TyxLQUFLLENBQUM1RyxRQUFRMG9CO29CQUNqQ3B3Qiw2Q0FBVUEsQ0FBQ2tsQixNQUFNLENBQUN4ZCxRQUFRNEc7b0JBQzFCO2dCQUNGO2dCQUVBLElBQUl1SyxVQUFVO29CQUNaO2dCQUNGO2dCQUVBLElBQUlrUCxTQUFTam9CLHlDQUFNQSxDQUFDMk4sS0FBSyxDQUFDL0YsUUFBUStDO2dCQUVsQyxJQUFJbUQsTUFBTTlOLHlDQUFNQSxDQUFDOE4sR0FBRyxDQUFDbEcsUUFBUStDO2dCQUM3QixJQUFJNmxCLFlBQVl4d0IseUNBQU1BLENBQUNzTixJQUFJLENBQUMxRixRQUFRO29CQUNsQzJGLElBQUkwYTtnQkFDTjtnQkFDQSxJQUFJd0ksVUFBVXp3Qix5Q0FBTUEsQ0FBQ3NOLElBQUksQ0FBQzFGLFFBQVE7b0JBQ2hDMkYsSUFBSU87Z0JBQ047Z0JBRUEsSUFBSTBpQixhQUFhQyxXQUFXbndCLHVDQUFJQSxDQUFDOFUsTUFBTSxDQUFDb2IsU0FBUyxDQUFDLEVBQUUsRUFBRUMsT0FBTyxDQUFDLEVBQUUsR0FBRztvQkFDakUsSUFBSTFmLFNBQVMvUSx5Q0FBTUEsQ0FBQ3dPLEtBQUssQ0FBQzVHLFFBQVFxZ0I7b0JBRWxDL25CLDZDQUFVQSxDQUFDa2xCLE1BQU0sQ0FBQ3hkLFFBQVFtSjtnQkFDNUI7WUFDRjtRQUNGLEdBQUc7WUFBQ2dJO1lBQVV2QyxXQUFXNFosT0FBTztTQUFDO1FBQ2pDTSxrQkFBa0Ivd0Isa0RBQVdBLENBQUN3RixDQUFBQTtZQUM1QixJQUFJOEMsWUFBWWdNLG1CQUFtQixDQUFDck0sUUFBUXpDLE1BQU16RCxNQUFNLEdBQUc7Z0JBQ3pELElBQUl1RyxZQUFZb0MsV0FBVyxDQUFDekMsU0FBUztvQkFDbkN3a0IsZUFBZTtvQkFDZjdvQixhQUFha0gsR0FBRyxDQUFDN0MsUUFBUTtnQkFDM0I7Z0JBRUFnbEIsd0JBQXdCLFFBQVFBLHdCQUF3QixLQUFLLElBQUksS0FBSyxJQUFJQSxvQkFBb0IvRixvQkFBb0IsQ0FBQzFoQjtnQkFFbkgsSUFBSTRxQixlQUFlNXFCLE9BQU9xUixXQUFXa2EsZ0JBQWdCLEtBQUtwbkIsWUFBWTtvQkFDcEU7Z0JBQ0YsRUFBRSwyREFBMkQ7Z0JBQzdELDREQUE0RDtnQkFDNUQsK0RBQStEO2dCQUMvRCw2REFBNkQ7Z0JBRzdELElBQUksQ0FBQ0UsYUFBYSxDQUFDSyxxQkFBcUIsQ0FBQ2IsVUFBVSxDQUFDZSxvQkFBb0IsQ0FBQ0QsZ0JBQWdCM0UsTUFBTTJILElBQUksRUFBRTtvQkFDbkcsSUFBSTZqQixtQkFBbUJodEIsa0NBQWtDMkcsR0FBRyxDQUFDMUM7b0JBQzdEakUsa0NBQWtDeVQsTUFBTSxDQUFDeFAsU0FBUyxvRUFBb0U7b0JBRXRILElBQUkrb0IscUJBQXFCdmtCLFdBQVc7d0JBQ2xDeEkscUJBQXFCNkcsR0FBRyxDQUFDN0MsUUFBUUEsT0FBT3FlLEtBQUs7d0JBQzdDcmUsT0FBT3FlLEtBQUssR0FBRzBLO29CQUNqQjtvQkFFQTN3Qix5Q0FBTUEsQ0FBQ3NtQixVQUFVLENBQUMxZSxRQUFRekMsTUFBTTJILElBQUk7b0JBQ3BDLElBQUk2WixZQUFZL2lCLHFCQUFxQjBHLEdBQUcsQ0FBQzFDO29CQUN6Q2hFLHFCQUFxQndULE1BQU0sQ0FBQ3hQO29CQUU1QixJQUFJK2UsY0FBY3ZhLFdBQVc7d0JBQzNCeEUsT0FBT3FlLEtBQUssR0FBR1U7b0JBQ2pCO2dCQUNGO1lBQ0Y7UUFDRixHQUFHO1lBQUNuUSxXQUFXa2EsZ0JBQWdCO1NBQUM7UUFDaENFLHFCQUFxQmp4QixrREFBV0EsQ0FBQ3dGLENBQUFBO1lBQy9CLElBQUk4QyxZQUFZZ00sbUJBQW1CLENBQUNyTSxRQUFRekMsTUFBTXpELE1BQU0sS0FBSyxDQUFDcXVCLGVBQWU1cUIsT0FBT3FSLFdBQVdvYSxtQkFBbUIsR0FBRztnQkFDbkgsSUFBSSxDQUFDM29CLFlBQVlvQyxXQUFXLENBQUN6QyxTQUFTO29CQUNwQ3drQixlQUFlO29CQUNmN29CLGFBQWFrSCxHQUFHLENBQUM3QyxRQUFRO2dCQUMzQjtZQUNGO1FBQ0YsR0FBRztZQUFDNE8sV0FBV29hLG1CQUFtQjtTQUFDO1FBQ25DQyxvQkFBb0JseEIsa0RBQVdBLENBQUN3RixDQUFBQTtZQUM5QixJQUFJOEMsWUFBWWdNLG1CQUFtQixDQUFDck0sUUFBUXpDLE1BQU16RCxNQUFNLEdBQUc7Z0JBQ3pEa3JCLHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CN0Ysc0JBQXNCLENBQUM1aEI7Z0JBRXJILElBQUk0cUIsZUFBZTVxQixPQUFPcVIsV0FBV3FhLGtCQUFrQixLQUFLdm5CLFlBQVk7b0JBQ3RFO2dCQUNGO2dCQUVBOGlCLGVBQWU7Z0JBQ2YsSUFBSSxFQUNGdGdCLFNBQVMsRUFDVixHQUFHbEU7Z0JBRUosSUFBSWtFLFdBQVc7b0JBQ2IsSUFBSTNMLHdDQUFLQSxDQUFDcVQsVUFBVSxDQUFDMUgsWUFBWTt3QkFDL0I5TCx5Q0FBTUEsQ0FBQ3VtQixjQUFjLENBQUMzZTt3QkFDdEI7b0JBQ0Y7b0JBRUEsSUFBSWtwQixTQUFTOXdCLHlDQUFNQSxDQUFDMGlCLEtBQUssQ0FBQzlhLFFBQVE7d0JBQ2hDRixPQUFPcEYsQ0FBQUEsSUFBS2pDLDBDQUFTQSxDQUFDNlAsU0FBUyxDQUFDNU4sTUFBTXRDLHlDQUFNQSxDQUFDdVEsUUFBUSxDQUFDM0ksUUFBUXRGO3dCQUM5RG9SLE1BQU07b0JBQ1I7b0JBRUEsSUFBSW9kLFFBQVE7d0JBQ1YsSUFBSSxHQUFHQyxXQUFXLEdBQUdEO3dCQUVyQixJQUFJOXdCLHlDQUFNQSxDQUFDc1QsS0FBSyxDQUFDMUwsUUFBUWtFLFVBQVUyQyxNQUFNLEVBQUVzaUIsYUFBYTs0QkFDdEQsSUFBSTFqQixRQUFRck4seUNBQU1BLENBQUM4USxLQUFLLENBQUNsSixRQUFRbXBCOzRCQUNqQzd3Qiw2Q0FBVUEsQ0FBQzh3QixZQUFZLENBQUNwcEIsUUFBUTtnQ0FDOUI2RyxRQUFRcEI7Z0NBQ1IxQixPQUFPMEI7NEJBQ1Q7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGLEdBQUc7WUFBQ21KLFdBQVdxYSxrQkFBa0I7U0FBQztRQUNsQ0ksUUFBUXR4QixrREFBV0EsQ0FBQ3dGLENBQUFBO1lBQ2xCLElBQUk4QyxZQUFZZ00sbUJBQW1CLENBQUNyTSxRQUFRekMsTUFBTXpELE1BQU0sS0FBSyxDQUFDcXVCLGVBQWU1cUIsT0FBT3FSLFdBQVd5YSxNQUFNLEdBQUc7Z0JBQ3RHOXJCLE1BQU13cEIsY0FBYztnQkFDcEIxbUIsWUFBWWdGLGVBQWUsQ0FBQ3JGLFFBQVF6QyxNQUFNQyxhQUFhLEVBQUU7WUFDM0Q7UUFDRixHQUFHO1lBQUNvUixXQUFXeWEsTUFBTTtTQUFDO1FBQ3RCQyxPQUFPdnhCLGtEQUFXQSxDQUFDd0YsQ0FBQUE7WUFDakIsSUFBSSxDQUFDNFQsWUFBWTlRLFlBQVlnTSxtQkFBbUIsQ0FBQ3JNLFFBQVF6QyxNQUFNekQsTUFBTSxLQUFLLENBQUNxdUIsZUFBZTVxQixPQUFPcVIsV0FBVzBhLEtBQUssR0FBRztnQkFDbEgvckIsTUFBTXdwQixjQUFjO2dCQUNwQjFtQixZQUFZZ0YsZUFBZSxDQUFDckYsUUFBUXpDLE1BQU1DLGFBQWEsRUFBRTtnQkFDekQsSUFBSSxFQUNGMEcsU0FBUyxFQUNWLEdBQUdsRTtnQkFFSixJQUFJa0UsV0FBVztvQkFDYixJQUFJM0wsd0NBQUtBLENBQUNxVCxVQUFVLENBQUMxSCxZQUFZO3dCQUMvQjlMLHlDQUFNQSxDQUFDdW1CLGNBQWMsQ0FBQzNlO29CQUN4QixPQUFPO3dCQUNMLElBQUluQyxPQUFPbEYsdUNBQUlBLENBQUMyRixNQUFNLENBQUMwQixRQUFRa0UsVUFBVTJDLE1BQU0sQ0FBQzlELElBQUk7d0JBRXBELElBQUkzSyx5Q0FBTUEsQ0FBQ21RLE1BQU0sQ0FBQ3ZJLFFBQVFuQyxPQUFPOzRCQUMvQnZGLDZDQUFVQSxDQUFDa1gsTUFBTSxDQUFDeFA7d0JBQ3BCO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRixHQUFHO1lBQUNtUjtZQUFVdkMsV0FBVzBhLEtBQUs7U0FBQztRQUMvQkMsWUFBWXh4QixrREFBV0EsQ0FBQ3dGLENBQUFBO1lBQ3RCLElBQUk4QyxZQUFZOEwsU0FBUyxDQUFDbk0sUUFBUXpDLE1BQU16RCxNQUFNLEtBQUssQ0FBQ3F1QixlQUFlNXFCLE9BQU9xUixXQUFXMmEsVUFBVSxHQUFHO2dCQUNoRyxnRUFBZ0U7Z0JBQ2hFLDJEQUEyRDtnQkFDM0QsMERBQTBEO2dCQUMxRCxJQUFJMXJCLE9BQU93QyxZQUFZeUgsV0FBVyxDQUFDOUgsUUFBUXpDLE1BQU16RCxNQUFNO2dCQUV2RCxJQUFJckIsMENBQVNBLENBQUM2UCxTQUFTLENBQUN6SyxTQUFTekYseUNBQU1BLENBQUNtUSxNQUFNLENBQUN2SSxRQUFRbkMsT0FBTztvQkFDNUROLE1BQU13cEIsY0FBYztnQkFDdEI7WUFDRjtRQUNGLEdBQUc7WUFBQ25ZLFdBQVcyYSxVQUFVO1NBQUM7UUFDMUJDLGFBQWF6eEIsa0RBQVdBLENBQUN3RixDQUFBQTtZQUN2QixJQUFJLENBQUM0VCxZQUFZOVEsWUFBWThMLFNBQVMsQ0FBQ25NLFFBQVF6QyxNQUFNekQsTUFBTSxLQUFLLENBQUNxdUIsZUFBZTVxQixPQUFPcVIsV0FBVzRhLFdBQVcsR0FBRztnQkFDOUcsSUFBSTNyQixPQUFPd0MsWUFBWXlILFdBQVcsQ0FBQzlILFFBQVF6QyxNQUFNekQsTUFBTTtnQkFDdkQsSUFBSWlKLE9BQU8xQyxZQUFZeUMsUUFBUSxDQUFDOUMsUUFBUW5DO2dCQUN4QyxJQUFJNHJCLFlBQVloeEIsMENBQVNBLENBQUM2UCxTQUFTLENBQUN6SyxTQUFTekYseUNBQU1BLENBQUNtUSxNQUFNLENBQUN2SSxRQUFRbkMsU0FBU3pGLHlDQUFNQSxDQUFDc04sSUFBSSxDQUFDMUYsUUFBUTtvQkFDOUYyRixJQUFJNUM7b0JBQ0ppSixPQUFPO2dCQUNULElBQUksOERBQThEO2dCQUNsRSxtREFBbUQ7Z0JBRW5ELElBQUl5ZCxXQUFXO29CQUNiLElBQUk3aUIsUUFBUXhPLHlDQUFNQSxDQUFDd08sS0FBSyxDQUFDNUcsUUFBUStDO29CQUNqQ3pLLDZDQUFVQSxDQUFDa2xCLE1BQU0sQ0FBQ3hkLFFBQVE0RztnQkFDNUI7Z0JBRUErZCxNQUFNQyxvQkFBb0IsR0FBRztnQkFDN0J2a0IsWUFBWWdGLGVBQWUsQ0FBQ3JGLFFBQVF6QyxNQUFNb0MsWUFBWSxFQUFFO1lBQzFEO1FBQ0YsR0FBRztZQUFDd1I7WUFBVXZDLFdBQVc0YSxXQUFXO1NBQUM7UUFDckNFLFFBQVEzeEIsa0RBQVdBLENBQUN3RixDQUFBQTtZQUNsQixJQUFJLENBQUM0VCxZQUFZOVEsWUFBWThMLFNBQVMsQ0FBQ25NLFFBQVF6QyxNQUFNekQsTUFBTSxLQUFLLENBQUNxdUIsZUFBZTVxQixPQUFPcVIsV0FBVzhhLE1BQU0sR0FBRztnQkFDekduc0IsTUFBTXdwQixjQUFjLElBQUksa0VBQWtFO2dCQUUxRixJQUFJNEMsZUFBZTNwQixPQUFPa0UsU0FBUyxFQUFFLHlDQUF5QztnQkFFOUUsSUFBSTBDLFFBQVF2RyxZQUFZMkgsY0FBYyxDQUFDaEksUUFBUXpDO2dCQUMvQyxJQUFJMkgsT0FBTzNILE1BQU1vQyxZQUFZO2dCQUM3QnJILDZDQUFVQSxDQUFDa2xCLE1BQU0sQ0FBQ3hkLFFBQVE0RztnQkFFMUIsSUFBSStkLE1BQU1DLG9CQUFvQixFQUFFO29CQUM5QixJQUFJK0UsZ0JBQWdCLENBQUNweEIsd0NBQUtBLENBQUNpVixNQUFNLENBQUNtYyxjQUFjL2lCLFVBQVUsQ0FBQ3hPLHlDQUFNQSxDQUFDc04sSUFBSSxDQUFDMUYsUUFBUTt3QkFDN0UyRixJQUFJaUI7d0JBQ0pvRixPQUFPO29CQUNULElBQUk7d0JBQ0YxVCw2Q0FBVUEsQ0FBQ2tYLE1BQU0sQ0FBQ3hQLFFBQVE7NEJBQ3hCMkYsSUFBSWdrQjt3QkFDTjtvQkFDRjtnQkFDRjtnQkFFQXRwQixZQUFZNEUsVUFBVSxDQUFDakYsUUFBUWtGLE9BQU8sbUVBQW1FO2dCQUN6RywrQ0FBK0M7Z0JBRS9DLElBQUksQ0FBQzdFLFlBQVlzRCxTQUFTLENBQUMzRCxTQUFTO29CQUNsQ0ssWUFBWTBELEtBQUssQ0FBQy9EO2dCQUNwQjtZQUNGO1lBRUEya0IsTUFBTUMsb0JBQW9CLEdBQUc7UUFDL0IsR0FBRztZQUFDelQ7WUFBVXZDLFdBQVc4YSxNQUFNO1NBQUM7UUFDaENFLFdBQVc3eEIsa0RBQVdBLENBQUN3RixDQUFBQTtZQUNyQixJQUFJLENBQUM0VCxZQUFZd1QsTUFBTUMsb0JBQW9CLElBQUloVyxXQUFXZ2IsU0FBUyxJQUFJdnBCLFlBQVk4TCxTQUFTLENBQUNuTSxRQUFRekMsTUFBTXpELE1BQU0sR0FBRztnQkFDbEg4VSxXQUFXZ2IsU0FBUyxDQUFDcnNCO1lBQ3ZCLEVBQUUsMEVBQTBFO1lBQzVFLHlFQUF5RTtZQUN6RSwrREFBK0Q7WUFHL0RvbkIsTUFBTUMsb0JBQW9CLEdBQUc7UUFDL0IsR0FBRztZQUFDelQ7WUFBVXZDLFdBQVdnYixTQUFTO1NBQUM7UUFDbkNDLFNBQVM5eEIsa0RBQVdBLENBQUN3RixDQUFBQTtZQUNuQixJQUFJLENBQUM0VCxZQUFZLENBQUN3VCxNQUFNRSxtQkFBbUIsSUFBSXhrQixZQUFZK0wsaUJBQWlCLENBQUNwTSxRQUFRekMsTUFBTXpELE1BQU0sS0FBSyxDQUFDcXVCLGVBQWU1cUIsT0FBT3FSLFdBQVdpYixPQUFPLEdBQUc7Z0JBQ2hKLElBQUl6bUIsS0FBSy9DLFlBQVlnRCxTQUFTLENBQUNyRCxRQUFRQTtnQkFDdkMsSUFBSXNELE9BQU9qRCxZQUFZOEMsd0JBQXdCLENBQUNuRDtnQkFDaEQya0IsTUFBTUcsYUFBYSxHQUFHeGhCLEtBQUtRLGFBQWEsRUFBRSxnRUFBZ0U7Z0JBQzFHLGdFQUFnRTtnQkFDaEUsMkRBQTJEO2dCQUUzRCxJQUFJbkMsY0FBY3BFLE1BQU16RCxNQUFNLEtBQUtzSixJQUFJO29CQUNyQ0EsR0FBR1csS0FBSztvQkFDUjtnQkFDRjtnQkFFQXJJLFdBQVdtSCxHQUFHLENBQUM3QyxRQUFRO1lBQ3pCO1FBQ0YsR0FBRztZQUFDbVI7WUFBVXZDLFdBQVdpYixPQUFPO1NBQUM7UUFDakNDLFdBQVcveEIsa0RBQVdBLENBQUN3RixDQUFBQTtZQUNyQixJQUFJLENBQUM0VCxZQUFZOVEsWUFBWStMLGlCQUFpQixDQUFDcE0sUUFBUXpDLE1BQU16RCxNQUFNLEdBQUc7Z0JBQ3BFa3JCLHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CaEQsYUFBYSxDQUFDemtCO2dCQUM1RyxJQUFJLEVBQ0YwSyxXQUFXLEVBQ1osR0FBRzFLLE9BQU8sMEVBQTBFO2dCQUNyRiwyRUFBMkU7Z0JBQzNFLDZCQUE2QjtnQkFFN0IsSUFBSThDLFlBQVlvQyxXQUFXLENBQUN6QyxXQUFXaUksWUFBWXhGLFdBQVcsS0FBSyxPQUFPO29CQUN4RTlHLGFBQWFrSCxHQUFHLENBQUM3QyxRQUFRO29CQUN6QndrQixlQUFlO2dCQUNqQjtnQkFFQSxJQUFJMkQsZUFBZTVxQixPQUFPcVIsV0FBV2tiLFNBQVMsS0FBS3pwQixZQUFZb0MsV0FBVyxDQUFDekMsU0FBUztvQkFDbEY7Z0JBQ0Y7Z0JBRUEsSUFBSSxFQUNGa0UsU0FBUyxFQUNWLEdBQUdsRTtnQkFDSixJQUFJK1EsVUFBVS9RLE9BQU9tTyxRQUFRLENBQUNqSyxjQUFjLE9BQU9BLFVBQVVILEtBQUssQ0FBQ2hCLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRTtnQkFDL0UsSUFBSWduQixRQUFRNXlCLGdEQUFZQSxDQUFDd0IsdUNBQUlBLENBQUN1VixNQUFNLENBQUM2QyxjQUFjLE9BQU8sbURBQW1EO2dCQUM3RywrREFBK0Q7Z0JBQy9ELGdFQUFnRTtnQkFDaEUsa0NBQWtDO2dCQUVsQyxJQUFJa0UsUUFBUW9CLE1BQU0sQ0FBQ3BPLGNBQWM7b0JBQy9CMUssTUFBTXdwQixjQUFjO29CQUNwQixJQUFJaUQscUJBQXFCaHFCO29CQUV6QixJQUFJLE9BQU9ncUIsbUJBQW1CelYsSUFBSSxLQUFLLFlBQVk7d0JBQ2pEeVYsbUJBQW1CelYsSUFBSTtvQkFDekI7b0JBRUE7Z0JBQ0Y7Z0JBRUEsSUFBSVUsUUFBUXdCLE1BQU0sQ0FBQ3hPLGNBQWM7b0JBQy9CMUssTUFBTXdwQixjQUFjO29CQUNwQixJQUFJa0Qsc0JBQXNCanFCO29CQUUxQixJQUFJLE9BQU9pcUIsb0JBQW9CcFcsSUFBSSxLQUFLLFlBQVk7d0JBQ2xEb1csb0JBQW9CcFcsSUFBSTtvQkFDMUI7b0JBRUE7Z0JBQ0YsRUFBRSw4REFBOEQ7Z0JBQ2hFLDhEQUE4RDtnQkFDOUQsMERBQTBEO2dCQUMxRCxlQUFlO2dCQUdmLElBQUlvQixRQUFRZ0Isa0JBQWtCLENBQUNoTyxjQUFjO29CQUMzQzFLLE1BQU13cEIsY0FBYztvQkFDcEJ6dUIsNkNBQVVBLENBQUM0eEIsSUFBSSxDQUFDbHFCLFFBQVE7d0JBQ3RCOGdCLE1BQU07d0JBQ04zSixTQUFTO29CQUNYO29CQUNBO2dCQUNGO2dCQUVBLElBQUlsQyxRQUFRaUIsaUJBQWlCLENBQUNqTyxjQUFjO29CQUMxQzFLLE1BQU13cEIsY0FBYztvQkFDcEJ6dUIsNkNBQVVBLENBQUM0eEIsSUFBSSxDQUFDbHFCLFFBQVE7d0JBQ3RCOGdCLE1BQU07b0JBQ1I7b0JBQ0E7Z0JBQ0Y7Z0JBRUEsSUFBSTdMLFFBQVFhLG9CQUFvQixDQUFDN04sY0FBYztvQkFDN0MxSyxNQUFNd3BCLGNBQWM7b0JBQ3BCenVCLDZDQUFVQSxDQUFDNHhCLElBQUksQ0FBQ2xxQixRQUFRO3dCQUN0QjhnQixNQUFNO3dCQUNOOVgsTUFBTTt3QkFDTm1PLFNBQVM7b0JBQ1g7b0JBQ0E7Z0JBQ0Y7Z0JBRUEsSUFBSWxDLFFBQVFjLG1CQUFtQixDQUFDOU4sY0FBYztvQkFDNUMxSyxNQUFNd3BCLGNBQWM7b0JBQ3BCenVCLDZDQUFVQSxDQUFDNHhCLElBQUksQ0FBQ2xxQixRQUFRO3dCQUN0QjhnQixNQUFNO3dCQUNOOVgsTUFBTTtvQkFDUjtvQkFDQTtnQkFDRixFQUFFLGdFQUFnRTtnQkFDbEUsNkRBQTZEO2dCQUM3RCwrREFBK0Q7Z0JBQy9ELDZEQUE2RDtnQkFDN0QsVUFBVTtnQkFHVixJQUFJaU0sUUFBUUcsY0FBYyxDQUFDbk4sY0FBYztvQkFDdkMxSyxNQUFNd3BCLGNBQWM7b0JBRXBCLElBQUk3aUIsYUFBYTNMLHdDQUFLQSxDQUFDME8sV0FBVyxDQUFDL0MsWUFBWTt3QkFDN0M1TCw2Q0FBVUEsQ0FBQzR4QixJQUFJLENBQUNscUIsUUFBUTs0QkFDdEJtWCxTQUFTLENBQUM0Uzt3QkFDWjtvQkFDRixPQUFPO3dCQUNMenhCLDZDQUFVQSxDQUFDNnhCLFFBQVEsQ0FBQ25xQixRQUFROzRCQUMxQmdKLE1BQU07d0JBQ1I7b0JBQ0Y7b0JBRUE7Z0JBQ0Y7Z0JBRUEsSUFBSWlNLFFBQVFJLGFBQWEsQ0FBQ3BOLGNBQWM7b0JBQ3RDMUssTUFBTXdwQixjQUFjO29CQUVwQixJQUFJN2lCLGFBQWEzTCx3Q0FBS0EsQ0FBQzBPLFdBQVcsQ0FBQy9DLFlBQVk7d0JBQzdDNUwsNkNBQVVBLENBQUM0eEIsSUFBSSxDQUFDbHFCLFFBQVE7NEJBQ3RCbVgsU0FBUzRTO3dCQUNYO29CQUNGLE9BQU87d0JBQ0x6eEIsNkNBQVVBLENBQUM2eEIsUUFBUSxDQUFDbnFCLFFBQVE7NEJBQzFCZ0osTUFBTTt3QkFDUjtvQkFDRjtvQkFFQTtnQkFDRjtnQkFFQSxJQUFJaU0sUUFBUWtCLGtCQUFrQixDQUFDbE8sY0FBYztvQkFDM0MxSyxNQUFNd3BCLGNBQWM7b0JBRXBCLElBQUk3aUIsYUFBYTNMLHdDQUFLQSxDQUFDcVQsVUFBVSxDQUFDMUgsWUFBWTt3QkFDNUM1TCw2Q0FBVUEsQ0FBQzZ4QixRQUFRLENBQUNucUIsUUFBUTs0QkFDMUJnSixNQUFNO3dCQUNSO29CQUNGO29CQUVBMVEsNkNBQVVBLENBQUM0eEIsSUFBSSxDQUFDbHFCLFFBQVE7d0JBQ3RCOGdCLE1BQU07d0JBQ04zSixTQUFTLENBQUM0UztvQkFDWjtvQkFDQTtnQkFDRjtnQkFFQSxJQUFJOVUsUUFBUW1CLGlCQUFpQixDQUFDbk8sY0FBYztvQkFDMUMxSyxNQUFNd3BCLGNBQWM7b0JBRXBCLElBQUk3aUIsYUFBYTNMLHdDQUFLQSxDQUFDcVQsVUFBVSxDQUFDMUgsWUFBWTt3QkFDNUM1TCw2Q0FBVUEsQ0FBQzZ4QixRQUFRLENBQUNucUIsUUFBUTs0QkFDMUJnSixNQUFNO3dCQUNSO29CQUNGO29CQUVBMVEsNkNBQVVBLENBQUM0eEIsSUFBSSxDQUFDbHFCLFFBQVE7d0JBQ3RCOGdCLE1BQU07d0JBQ04zSixTQUFTNFM7b0JBQ1g7b0JBQ0E7Z0JBQ0YsRUFBRSx3RUFBd0U7Z0JBQzFFLDREQUE0RDtnQkFDNUQsMkRBQTJEO2dCQUczRCxJQUFJLENBQUN6bkIsMEJBQTBCO29CQUM3QiwrREFBK0Q7b0JBQy9ELCtDQUErQztvQkFDL0MsSUFBSTJTLFFBQVFDLE1BQU0sQ0FBQ2pOLGdCQUFnQmdOLFFBQVFlLFFBQVEsQ0FBQy9OLGdCQUFnQmdOLFFBQVF1QixvQkFBb0IsQ0FBQ3ZPLGNBQWM7d0JBQzdHMUssTUFBTXdwQixjQUFjO3dCQUNwQjtvQkFDRjtvQkFFQSxJQUFJOVIsUUFBUXFCLFdBQVcsQ0FBQ3JPLGNBQWM7d0JBQ3BDMUssTUFBTXdwQixjQUFjO3dCQUNwQjN1Qix5Q0FBTUEsQ0FBQ3ViLGVBQWUsQ0FBQzNUO3dCQUN2QjtvQkFDRjtvQkFFQSxJQUFJaVYsUUFBUXNCLFlBQVksQ0FBQ3RPLGNBQWM7d0JBQ3JDMUssTUFBTXdwQixjQUFjO3dCQUNwQjN1Qix5Q0FBTUEsQ0FBQzJvQixXQUFXLENBQUMvZ0I7d0JBQ25CO29CQUNGO29CQUVBLElBQUlpVixRQUFRSyxnQkFBZ0IsQ0FBQ3JOLGNBQWM7d0JBQ3pDMUssTUFBTXdwQixjQUFjO3dCQUVwQixJQUFJN2lCLGFBQWEzTCx3Q0FBS0EsQ0FBQ3FULFVBQVUsQ0FBQzFILFlBQVk7NEJBQzVDOUwseUNBQU1BLENBQUN1bUIsY0FBYyxDQUFDM2UsUUFBUTtnQ0FDNUJ2QixXQUFXOzRCQUNiO3dCQUNGLE9BQU87NEJBQ0xyRyx5Q0FBTUEsQ0FBQ2tiLGNBQWMsQ0FBQ3RUO3dCQUN4Qjt3QkFFQTtvQkFDRjtvQkFFQSxJQUFJaVYsUUFBUU0sZUFBZSxDQUFDdE4sY0FBYzt3QkFDeEMxSyxNQUFNd3BCLGNBQWM7d0JBRXBCLElBQUk3aUIsYUFBYTNMLHdDQUFLQSxDQUFDcVQsVUFBVSxDQUFDMUgsWUFBWTs0QkFDNUM5TCx5Q0FBTUEsQ0FBQ3VtQixjQUFjLENBQUMzZSxRQUFRO2dDQUM1QnZCLFdBQVc7NEJBQ2I7d0JBQ0YsT0FBTzs0QkFDTHJHLHlDQUFNQSxDQUFDbWIsYUFBYSxDQUFDdlQ7d0JBQ3ZCO3dCQUVBO29CQUNGO29CQUVBLElBQUlpVixRQUFRTyxvQkFBb0IsQ0FBQ3ZOLGNBQWM7d0JBQzdDMUssTUFBTXdwQixjQUFjO3dCQUVwQixJQUFJN2lCLGFBQWEzTCx3Q0FBS0EsQ0FBQ3FULFVBQVUsQ0FBQzFILFlBQVk7NEJBQzVDOUwseUNBQU1BLENBQUN1bUIsY0FBYyxDQUFDM2UsUUFBUTtnQ0FDNUJ2QixXQUFXOzRCQUNiO3dCQUNGLE9BQU87NEJBQ0xyRyx5Q0FBTUEsQ0FBQ2tiLGNBQWMsQ0FBQ3RULFFBQVE7Z0NBQzVCOGdCLE1BQU07NEJBQ1I7d0JBQ0Y7d0JBRUE7b0JBQ0Y7b0JBRUEsSUFBSTdMLFFBQVFRLG1CQUFtQixDQUFDeE4sY0FBYzt3QkFDNUMxSyxNQUFNd3BCLGNBQWM7d0JBRXBCLElBQUk3aUIsYUFBYTNMLHdDQUFLQSxDQUFDcVQsVUFBVSxDQUFDMUgsWUFBWTs0QkFDNUM5TCx5Q0FBTUEsQ0FBQ3VtQixjQUFjLENBQUMzZSxRQUFRO2dDQUM1QnZCLFdBQVc7NEJBQ2I7d0JBQ0YsT0FBTzs0QkFDTHJHLHlDQUFNQSxDQUFDbWIsYUFBYSxDQUFDdlQsUUFBUTtnQ0FDM0I4Z0IsTUFBTTs0QkFDUjt3QkFDRjt3QkFFQTtvQkFDRjtvQkFFQSxJQUFJN0wsUUFBUVMsb0JBQW9CLENBQUN6TixjQUFjO3dCQUM3QzFLLE1BQU13cEIsY0FBYzt3QkFFcEIsSUFBSTdpQixhQUFhM0wsd0NBQUtBLENBQUNxVCxVQUFVLENBQUMxSCxZQUFZOzRCQUM1QzlMLHlDQUFNQSxDQUFDdW1CLGNBQWMsQ0FBQzNlLFFBQVE7Z0NBQzVCdkIsV0FBVzs0QkFDYjt3QkFDRixPQUFPOzRCQUNMckcseUNBQU1BLENBQUNrYixjQUFjLENBQUN0VCxRQUFRO2dDQUM1QjhnQixNQUFNOzRCQUNSO3dCQUNGO3dCQUVBO29CQUNGO29CQUVBLElBQUk3TCxRQUFRVSxtQkFBbUIsQ0FBQzFOLGNBQWM7d0JBQzVDMUssTUFBTXdwQixjQUFjO3dCQUVwQixJQUFJN2lCLGFBQWEzTCx3Q0FBS0EsQ0FBQ3FULFVBQVUsQ0FBQzFILFlBQVk7NEJBQzVDOUwseUNBQU1BLENBQUN1bUIsY0FBYyxDQUFDM2UsUUFBUTtnQ0FDNUJ2QixXQUFXOzRCQUNiO3dCQUNGLE9BQU87NEJBQ0xyRyx5Q0FBTUEsQ0FBQ21iLGFBQWEsQ0FBQ3ZULFFBQVE7Z0NBQzNCOGdCLE1BQU07NEJBQ1I7d0JBQ0Y7d0JBRUE7b0JBQ0Y7Z0JBQ0YsT0FBTztvQkFDTCxJQUFJaGYsYUFBYUYsV0FBVzt3QkFDMUIsd0VBQXdFO3dCQUN4RSxrRUFBa0U7d0JBQ2xFLElBQUlzQyxhQUFjK1EsQ0FBQUEsUUFBUUssZ0JBQWdCLENBQUNyTixnQkFBZ0JnTixRQUFRTSxlQUFlLENBQUN0TixZQUFXLEtBQU0xUCx3Q0FBS0EsQ0FBQzBPLFdBQVcsQ0FBQy9DLFlBQVk7NEJBQ2hJLElBQUlrbUIsY0FBY3p4Qix1Q0FBSUEsQ0FBQzJGLE1BQU0sQ0FBQzBCLFFBQVFrRSxVQUFVMkMsTUFBTSxDQUFDOUQsSUFBSTs0QkFFM0QsSUFBSXRLLDBDQUFTQSxDQUFDNlAsU0FBUyxDQUFDOGhCLGdCQUFnQmh5Qix5Q0FBTUEsQ0FBQ21RLE1BQU0sQ0FBQ3ZJLFFBQVFvcUIsZ0JBQWlCaHlCLENBQUFBLHlDQUFNQSxDQUFDdVEsUUFBUSxDQUFDM0ksUUFBUW9xQixnQkFBZ0JoeUIseUNBQU1BLENBQUMyaUIsT0FBTyxDQUFDL2EsUUFBUW9xQixZQUFXLEdBQUk7Z0NBQzNKN3NCLE1BQU13cEIsY0FBYztnQ0FDcEIzdUIseUNBQU1BLENBQUNrYixjQUFjLENBQUN0VCxRQUFRO29DQUM1QjhnQixNQUFNO2dDQUNSO2dDQUNBOzRCQUNGO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRixHQUFHO1lBQUMzUDtZQUFVdkMsV0FBV2tiLFNBQVM7U0FBQztRQUNuQ08sU0FBU3R5QixrREFBV0EsQ0FBQ3dGLENBQUFBO1lBQ25CLElBQUksQ0FBQzRULFlBQVk5USxZQUFZK0wsaUJBQWlCLENBQUNwTSxRQUFRekMsTUFBTXpELE1BQU0sS0FBSyxDQUFDcXVCLGVBQWU1cUIsT0FBT3FSLFdBQVd5YixPQUFPLEdBQUc7Z0JBQ2xILHdFQUF3RTtnQkFDeEUsK0NBQStDO2dCQUMvQyxxRUFBcUU7Z0JBQ3JFLHFFQUFxRTtnQkFDckUsZ0VBQWdFO2dCQUNoRSxpREFBaUQ7Z0JBQ2pELG9DQUFvQztnQkFDcEMsSUFBSSxDQUFDL25CLDRCQUE0QmhGLHFCQUFxQkMsTUFBTTBLLFdBQVcsS0FBS3JHLFdBQVc7b0JBQ3JGckUsTUFBTXdwQixjQUFjO29CQUNwQjFtQixZQUFZNEUsVUFBVSxDQUFDakYsUUFBUXpDLE1BQU1DLGFBQWE7Z0JBQ3BEO1lBQ0Y7UUFDRixHQUFHO1lBQUMyVDtZQUFVdkMsV0FBV3liLE9BQU87U0FBQztJQUNuQyxJQUFJLFdBQVcsR0FBRS95QiwwREFBbUIsQ0FBQ21zQixVQUFVO1FBQzdDaFQsYUFBYUE7UUFDYjVTLE1BQU1tQztRQUNOZ1IsZUFBZUE7UUFDZmhDLG1CQUFtQkE7UUFDbkJDLFlBQVlBO1FBQ1ovSyxXQUFXbEUsT0FBT2tFLFNBQVM7SUFDN0I7QUFDRjtBQUNBOztDQUVDLEdBRUQsSUFBSTRmLHFCQUFxQmxqQixDQUFBQTtJQUN2QixJQUFJLEVBQ0ZnTyxVQUFVLEVBQ1ZULFFBQVEsRUFDVCxHQUFHdk47SUFDSixPQUNFLFdBQVcsR0FDWCw4RUFBOEU7SUFDOUUsd0dBQXdHO0lBQ3hHdEosMERBQW1CLENBQUMsUUFBUWdDLE9BQU91VixNQUFNLENBQUMsQ0FBQyxHQUFHRCxhQUFhVCxVQUFVek0sY0FBYyxXQUFXLEdBQUVwSywwREFBbUIsQ0FBQyxNQUFNO0FBRTlIO0FBQ0E7O0NBRUMsR0FFRCxJQUFJMHNCLGtCQUFrQixJQUFNLEVBQUU7QUFDOUI7O0NBRUMsR0FFRCxJQUFJSSxpQ0FBaUMsQ0FBQ3BrQixRQUFRa0g7SUFDNUMsNkVBQTZFO0lBQzdFLHVEQUF1RDtJQUN2RCxJQUFJQSxTQUFTdUIscUJBQXFCLElBQUssRUFBQ3pJLE9BQU9rRSxTQUFTLElBQUlsRSxPQUFPa0UsU0FBUyxJQUFJM0wsd0NBQUtBLENBQUMwTyxXQUFXLENBQUNqSCxPQUFPa0UsU0FBUyxJQUFJO1FBQ3BILElBQUlvbUIsU0FBU3BqQixTQUFTaUUsY0FBYyxDQUFDeEcsYUFBYTtRQUNsRDJsQixPQUFPN2hCLHFCQUFxQixHQUFHdkIsU0FBU3VCLHFCQUFxQixDQUFDOGhCLElBQUksQ0FBQ3JqQjtRQUNuRS9PLHNFQUFjQSxDQUFDbXlCLFFBQVE7WUFDckJFLFlBQVk7UUFDZCxJQUFJLDJDQUEyQztRQUUvQyxPQUFPRixPQUFPN2hCLHFCQUFxQjtJQUNyQztBQUNGO0FBQ0E7O0NBRUMsR0FHRCxJQUFJMGYsaUJBQWlCLENBQUM1cUIsT0FBT2t0QjtJQUMzQixJQUFJLENBQUNBLFNBQVM7UUFDWixPQUFPO0lBQ1QsRUFBRSw2RUFBNkU7SUFDL0UsNENBQTRDO0lBRzVDLElBQUlDLDRCQUE0QkQsUUFBUWx0QjtJQUV4QyxJQUFJbXRCLDZCQUE2QixNQUFNO1FBQ3JDLE9BQU9BO0lBQ1Q7SUFFQSxPQUFPbnRCLE1BQU1vdEIsa0JBQWtCLE1BQU1wdEIsTUFBTXF0QixvQkFBb0I7QUFDakU7QUFDQTs7Q0FFQyxHQUVELElBQUkzRSxvQkFBb0IsQ0FBQzFvQixPQUFPa3RCO0lBQzlCLElBQUksQ0FBQ0EsU0FBUztRQUNaLE9BQU87SUFDVCxFQUFFLDZFQUE2RTtJQUMvRSw0Q0FBNEM7SUFHNUMsSUFBSUMsNEJBQTRCRCxRQUFRbHRCO0lBRXhDLElBQUltdEIsNkJBQTZCLE1BQU07UUFDckMsT0FBT0E7SUFDVDtJQUVBLE9BQU9udEIsTUFBTXN0QixnQkFBZ0I7QUFDL0I7QUFFQTs7Q0FFQyxHQUVELElBQUlDLGlCQUFpQixXQUFXLEdBQUVqekIsb0RBQWFBLENBQUM7QUFDaEQ7O0NBRUMsR0FFRCxJQUFJa3pCLGFBQWE7SUFDZixPQUFPanpCLGlEQUFVQSxDQUFDZ3pCO0FBQ3BCO0FBRUEsU0FBU0UsUUFBUUMsS0FBSztJQUNwQixPQUFPQSxpQkFBaUJ0b0I7QUFDMUI7QUFDQTs7Q0FFQyxHQUdELElBQUl1b0IsdUJBQXVCLFdBQVcsR0FBRXJ6QixvREFBYUEsQ0FBQyxDQUFDO0FBRXZELElBQUlzekIsY0FBYyxDQUFDN1EsR0FBR0MsSUFBTUQsTUFBTUM7QUFDbEM7Ozs7Ozs7O0NBUUMsR0FHRCxTQUFTNlEsaUJBQWlCeGxCLFFBQVE7SUFDaEMsSUFBSXlsQixhQUFhOW1CLFVBQVVySyxNQUFNLEdBQUcsS0FBS3FLLFNBQVMsQ0FBQyxFQUFFLEtBQUtDLFlBQVlELFNBQVMsQ0FBQyxFQUFFLEdBQUc0bUI7SUFDckYsSUFBSSxHQUFHeGIsWUFBWSxHQUFHMVgsaURBQVVBLENBQUN5c0IsQ0FBQUEsSUFBS0EsSUFBSSxHQUFHO0lBQzdDLElBQUk5UixVQUFVOWEsaURBQVVBLENBQUNvekI7SUFFekIsSUFBSSxDQUFDdFksU0FBUztRQUNaLE1BQU0sSUFBSWpRLE1BQU07SUFDbEI7SUFFQSxJQUFJLEVBQ0Yyb0IsUUFBUSxFQUNScEUsZ0JBQWdCLEVBQ2pCLEdBQUd0VTtJQUNKLElBQUkyWSxrQ0FBa0M5ekIsNkNBQU1BO0lBQzVDLElBQUkrekIsaUJBQWlCL3pCLDZDQUFNQSxDQUFDLElBQU07SUFDbEMsSUFBSWcwQixzQkFBc0JoMEIsNkNBQU1BLENBQUM7SUFDakMsSUFBSWkwQjtJQUVKLElBQUk7UUFDRixJQUFJOWxCLGFBQWE0bEIsZUFBZTVnQixPQUFPLElBQUkyZ0IsZ0NBQWdDM2dCLE9BQU8sRUFBRTtZQUNsRjhnQixnQkFBZ0I5bEIsU0FBUzBsQjtRQUMzQixPQUFPO1lBQ0xJLGdCQUFnQkQsb0JBQW9CN2dCLE9BQU87UUFDN0M7SUFDRixFQUFFLE9BQU9oRyxLQUFLO1FBQ1osSUFBSTJtQixnQ0FBZ0MzZ0IsT0FBTyxJQUFJb2dCLFFBQVFwbUIsTUFBTTtZQUMzREEsSUFBSUMsT0FBTyxJQUFJLDREQUE0RC9KLE1BQU0sQ0FBQ3l3QixnQ0FBZ0MzZ0IsT0FBTyxDQUFDK2dCLEtBQUssRUFBRTtRQUNuSTtRQUVBLE1BQU0vbUI7SUFDUjtJQUVBOEksMEJBQTBCO1FBQ3hCOGQsZUFBZTVnQixPQUFPLEdBQUdoRjtRQUN6QjZsQixvQkFBb0I3Z0IsT0FBTyxHQUFHOGdCO1FBQzlCSCxnQ0FBZ0MzZ0IsT0FBTyxHQUFHcEc7SUFDNUM7SUFDQWtKLDBCQUEwQjtRQUN4QixTQUFTa2U7WUFDUCxJQUFJO2dCQUNGLElBQUlDLG1CQUFtQkwsZUFBZTVnQixPQUFPLENBQUMwZ0I7Z0JBRTlDLElBQUlELFdBQVdRLGtCQUFrQkosb0JBQW9CN2dCLE9BQU8sR0FBRztvQkFDN0Q7Z0JBQ0Y7Z0JBRUE2Z0Isb0JBQW9CN2dCLE9BQU8sR0FBR2loQjtZQUNoQyxFQUFFLE9BQU9qbkIsS0FBSztnQkFDWixzREFBc0Q7Z0JBQ3RELHNEQUFzRDtnQkFDdEQscURBQXFEO2dCQUNyRCxVQUFVO2dCQUNWMm1CLGdDQUFnQzNnQixPQUFPLEdBQUdoRztZQUM1QztZQUVBK0s7UUFDRjtRQUVBLElBQUltYyxjQUFjNUUsaUJBQWlCMEU7UUFDbkNBO1FBQ0EsT0FBTyxJQUFNRTtJQUNmLEdBQ0E7UUFBQzVFO1FBQWtCb0U7S0FBUztJQUM1QixPQUFPSTtBQUNUO0FBQ0E7O0NBRUMsR0FFRCxTQUFTSyxtQkFBbUIvckIsTUFBTTtJQUNoQyxJQUFJZ3NCLGlCQUFpQnYwQiw2Q0FBTUEsQ0FBQyxFQUFFLEVBQUVtVCxPQUFPO0lBQ3ZDLElBQUlxaEIsV0FBV3gwQiw2Q0FBTUEsQ0FBQztRQUNwQnVJO0lBQ0YsR0FBRzRLLE9BQU87SUFDVixJQUFJb1UsV0FBV2puQixrREFBV0EsQ0FBQ2lJLENBQUFBO1FBQ3pCaXNCLFNBQVNqc0IsTUFBTSxHQUFHQTtRQUNsQmdzQixlQUFleGhCLE9BQU8sQ0FBQzBoQixDQUFBQSxXQUFZQSxTQUFTbHNCO0lBQzlDLEdBQUcsRUFBRTtJQUNMLElBQUltc0Isa0JBQWtCajBCLDhDQUFPQSxDQUFDO1FBQzVCLE9BQU87WUFDTG96QixVQUFVLElBQU1XLFNBQVNqc0IsTUFBTTtZQUMvQmtuQixrQkFBa0IxRSxDQUFBQTtnQkFDaEJ3SixlQUFlcmIsSUFBSSxDQUFDNlI7Z0JBQ3BCLE9BQU87b0JBQ0x3SixlQUFlbE0sTUFBTSxDQUFDa00sZUFBZTd4QixPQUFPLENBQUNxb0IsV0FBVztnQkFDMUQ7WUFDRjtRQUNGO0lBQ0YsR0FBRztRQUFDd0o7UUFBZ0JDO0tBQVM7SUFDN0IsT0FBTztRQUNMRTtRQUNBbk47SUFDRjtBQUNGO0FBRUEsSUFBSW9OLFlBQVk7SUFBQztJQUFVO0lBQVk7SUFBWTtDQUFRO0FBQzNEOzs7Q0FHQyxHQUVELElBQUlDLFFBQVF6ZSxDQUFBQTtJQUNWLElBQUksRUFDRjVOLE1BQU0sRUFDTm1PLFFBQVEsRUFDUjZRLFFBQVEsRUFDUjNsQixLQUFLLEVBQ04sR0FBR3VVLE9BQ0F1WixPQUFPL3NCLHlCQUF5QndULE9BQU93ZTtJQUUzQyxJQUFJRSxhQUFhNzBCLDZDQUFNQSxDQUFDO0lBQ3hCLElBQUksQ0FBQ21iLFNBQVMyWixXQUFXLEdBQUdqMUIscURBQWMsQ0FBQztRQUN6QyxJQUFJLENBQUNxQix1Q0FBSUEsQ0FBQzZ6QixVQUFVLENBQUNuekIsUUFBUTtZQUMzQixNQUFNLElBQUlzSixNQUFNLGtFQUFrRTdILE1BQU0sQ0FBQ3pDLDJDQUFRQSxDQUFDNkssU0FBUyxDQUFDN0o7UUFDOUc7UUFFQSxJQUFJLENBQUNqQix5Q0FBTUEsQ0FBQzRLLFFBQVEsQ0FBQ2hELFNBQVM7WUFDNUIsTUFBTSxJQUFJMkMsTUFBTSwwQ0FBMEM3SCxNQUFNLENBQUN6QywyQ0FBUUEsQ0FBQzZLLFNBQVMsQ0FBQ2xEO1FBQ3RGO1FBRUFBLE9BQU9tTyxRQUFRLEdBQUc5VTtRQUNsQkMsT0FBT3VWLE1BQU0sQ0FBQzdPLFFBQVFtbkI7UUFDdEIsT0FBTztZQUNMc0YsR0FBRztZQUNIenNCO1FBQ0Y7SUFDRjtJQUNBLElBQUksRUFDRm1zQixlQUFlLEVBQ2ZuTixVQUFVME4sb0JBQW9CLEVBQy9CLEdBQUdYLG1CQUFtQi9yQjtJQUN2QixJQUFJMnNCLGtCQUFrQjUwQixrREFBV0EsQ0FBQztRQUNoQyxJQUFJaW5CLFVBQVU7WUFDWkEsU0FBU2hmLE9BQU9tTyxRQUFRO1FBQzFCO1FBRUFvZSxXQUFXSyxDQUFBQSxjQUFnQjtnQkFDekJILEdBQUdHLFlBQVlILENBQUMsR0FBRztnQkFDbkJ6c0I7WUFDRjtRQUNBMHNCLHFCQUFxQjFzQjtJQUN2QixHQUFHO1FBQUNnZjtLQUFTO0lBQ2J4bkIsZ0RBQVNBLENBQUM7UUFDUnFFLG9CQUFvQmdILEdBQUcsQ0FBQzdDLFFBQVEyc0I7UUFDaEMsT0FBTztZQUNMOXdCLG9CQUFvQmdILEdBQUcsQ0FBQzdDLFFBQVEsS0FBTztZQUN2Q3NzQixXQUFXMWhCLE9BQU8sR0FBRztRQUN2QjtJQUNGLEdBQUc7UUFBQytoQjtLQUFnQjtJQUNwQixJQUFJLENBQUNocEIsV0FBV2twQixhQUFhLEdBQUduMUIsK0NBQVFBLENBQUMySSxZQUFZc0QsU0FBUyxDQUFDM0Q7SUFDL0R4SSxnREFBU0EsQ0FBQztRQUNScTFCLGFBQWF4c0IsWUFBWXNELFNBQVMsQ0FBQzNEO0lBQ3JDO0lBQ0EwTiwwQkFBMEI7UUFDeEIsSUFBSW9mLEtBQUssSUFBTUQsYUFBYXhzQixZQUFZc0QsU0FBUyxDQUFDM0Q7UUFFbEQsSUFBSWdCLDhCQUE4QjtZQUNoQyx5R0FBeUc7WUFDekcsb0hBQW9IO1lBQ3BILDZHQUE2RztZQUM3R1osU0FBUzhtQixnQkFBZ0IsQ0FBQyxXQUFXNEY7WUFDckMxc0IsU0FBUzhtQixnQkFBZ0IsQ0FBQyxZQUFZNEY7WUFDdEMsT0FBTztnQkFDTDFzQixTQUFTNm1CLG1CQUFtQixDQUFDLFdBQVc2RjtnQkFDeEMxc0IsU0FBUzZtQixtQkFBbUIsQ0FBQyxZQUFZNkY7WUFDM0M7UUFDRixPQUFPO1lBQ0wxc0IsU0FBUzhtQixnQkFBZ0IsQ0FBQyxTQUFTNEYsSUFBSTtZQUN2QzFzQixTQUFTOG1CLGdCQUFnQixDQUFDLFFBQVE0RixJQUFJO1lBQ3RDLE9BQU87Z0JBQ0wxc0IsU0FBUzZtQixtQkFBbUIsQ0FBQyxTQUFTNkYsSUFBSTtnQkFDMUMxc0IsU0FBUzZtQixtQkFBbUIsQ0FBQyxRQUFRNkYsSUFBSTtZQUMzQztRQUNGO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsT0FBTyxXQUFXLEdBQUV4MUIsMERBQW1CLENBQUM0ekIscUJBQXFCMVksUUFBUSxFQUFFO1FBQ3JFblosT0FBTzh5QjtJQUNULEdBQUcsV0FBVyxHQUFFNzBCLDBEQUFtQixDQUFDb2IsYUFBYUYsUUFBUSxFQUFFO1FBQ3pEblosT0FBT3VaO0lBQ1QsR0FBRyxXQUFXLEdBQUV0YiwwREFBbUIsQ0FBQ3dYLGNBQWMwRCxRQUFRLEVBQUU7UUFDMURuWixPQUFPdVosUUFBUTVTLE1BQU07SUFDdkIsR0FBRyxXQUFXLEdBQUUxSSwwREFBbUIsQ0FBQ3d6QixlQUFldFksUUFBUSxFQUFFO1FBQzNEblosT0FBT3NLO0lBQ1QsR0FBR3dLO0FBQ0w7QUFFQTs7O0NBR0MsR0FFRCxJQUFJNGUsWUFBWTtJQUNkLElBQUkvc0IsU0FBU2xJLGlEQUFVQSxDQUFDZ1g7SUFFeEIsSUFBSSxDQUFDOU8sUUFBUTtRQUNYLE1BQU0sSUFBSTJDLE1BQU07SUFDbEI7SUFFQSxPQUFPM0M7QUFDVDtBQUVBOzs7Q0FHQyxHQUVELElBQUlndEIsb0JBQW9CO0lBQ3RCLE9BQU81QixpQkFBaUJwckIsQ0FBQUEsU0FBVUEsT0FBT2tFLFNBQVMsRUFBRStvQjtBQUN0RDtBQUVBLElBQUlBLG1CQUFtQixDQUFDM1MsR0FBR0M7SUFDekIsSUFBSSxDQUFDRCxLQUFLLENBQUNDLEdBQUcsT0FBTztJQUNyQixJQUFJLENBQUNELEtBQUssQ0FBQ0MsR0FBRyxPQUFPO0lBQ3JCLE9BQU9oaUIsd0NBQUtBLENBQUNpVixNQUFNLENBQUM4TSxHQUFHQztBQUN6QjtBQUVBOztDQUVDLEdBRUQsSUFBSTJTLG1CQUFtQixDQUFDMWtCLE1BQU0ya0I7SUFDNUIsSUFBSUMsU0FBUyxDQUFDRCxZQUFZcmtCLEdBQUcsR0FBR3FrQixZQUFZRSxNQUFNLElBQUk7SUFDdEQsT0FBTzdrQixLQUFLTSxHQUFHLElBQUlza0IsVUFBVTVrQixLQUFLNmtCLE1BQU0sSUFBSUQ7QUFDOUM7QUFFQSxJQUFJRSxvQkFBb0IsQ0FBQ3R0QixRQUFRdXRCLFFBQVFDO0lBQ3ZDLElBQUlDLFFBQVFwdEIsWUFBWXNHLFVBQVUsQ0FBQzNHLFFBQVF1dEIsUUFBUTlrQixxQkFBcUI7SUFDeEUsSUFBSWlsQixRQUFRcnRCLFlBQVlzRyxVQUFVLENBQUMzRyxRQUFRd3RCLFFBQVEva0IscUJBQXFCO0lBQ3hFLE9BQU95a0IsaUJBQWlCTyxPQUFPQyxVQUFVUixpQkFBaUJRLE9BQU9EO0FBQ25FO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUdELElBQUlFLHVCQUF1QixDQUFDM3RCLFFBQVE0dEI7SUFDbEMsSUFBSUMsc0JBQXNCejFCLHlDQUFNQSxDQUFDd08sS0FBSyxDQUFDNUcsUUFBUXpILHdDQUFLQSxDQUFDMk4sR0FBRyxDQUFDMG5CO0lBQ3pELElBQUlFLFlBQVkzdUIsTUFBTUMsSUFBSSxDQUFDaEgseUNBQU1BLENBQUMwMUIsU0FBUyxDQUFDOXRCLFFBQVE7UUFDbEQyRixJQUFJaW9CO0lBQ047SUFDQSxJQUFJaGxCLE9BQU87SUFDWCxJQUFJbWxCLFFBQVFELFVBQVU1ekIsTUFBTTtJQUM1QixJQUFJa3pCLFNBQVM1bUIsS0FBS3duQixLQUFLLENBQUNELFFBQVE7SUFFaEMsSUFBSVQsa0JBQWtCdHRCLFFBQVE1SCx5Q0FBTUEsQ0FBQ3dPLEtBQUssQ0FBQzVHLFFBQVE4dEIsU0FBUyxDQUFDbGxCLEtBQUssR0FBR2lsQixzQkFBc0I7UUFDekYsT0FBT3oxQix5Q0FBTUEsQ0FBQ3dPLEtBQUssQ0FBQzVHLFFBQVE4dEIsU0FBUyxDQUFDbGxCLEtBQUssRUFBRWlsQjtJQUMvQztJQUVBLElBQUlDLFVBQVU1ekIsTUFBTSxHQUFHLEdBQUc7UUFDeEIsT0FBTzlCLHlDQUFNQSxDQUFDd08sS0FBSyxDQUFDNUcsUUFBUTh0QixTQUFTLENBQUNBLFVBQVU1ekIsTUFBTSxHQUFHLEVBQUUsRUFBRTJ6QjtJQUMvRDtJQUVBLE1BQU9ULFdBQVdVLFVBQVU1ekIsTUFBTSxJQUFJa3pCLFdBQVd4a0IsS0FBTTtRQUNyRCxJQUFJMGtCLGtCQUFrQnR0QixRQUFRNUgseUNBQU1BLENBQUN3TyxLQUFLLENBQUM1RyxRQUFROHRCLFNBQVMsQ0FBQ1YsT0FBTyxHQUFHUyxzQkFBc0I7WUFDM0ZFLFFBQVFYO1FBQ1YsT0FBTztZQUNMeGtCLE9BQU93a0I7UUFDVDtRQUVBQSxTQUFTNW1CLEtBQUt3bkIsS0FBSyxDQUFDLENBQUNwbEIsT0FBT21sQixLQUFJLElBQUs7SUFDdkM7SUFFQSxPQUFPMzFCLHlDQUFNQSxDQUFDd08sS0FBSyxDQUFDNUcsUUFBUTh0QixTQUFTLENBQUNDLE1BQU0sRUFBRUY7QUFDaEQ7QUFFQSxTQUFTSSxRQUFRbFMsTUFBTSxFQUFFQyxjQUFjO0lBQUksSUFBSWhpQixPQUFPVixPQUFPVSxJQUFJLENBQUMraEI7SUFBUyxJQUFJemlCLE9BQU9lLHFCQUFxQixFQUFFO1FBQUUsSUFBSTRoQixVQUFVM2lCLE9BQU9lLHFCQUFxQixDQUFDMGhCO1FBQVMsSUFBSUMsZ0JBQWdCO1lBQUVDLFVBQVVBLFFBQVFoRixNQUFNLENBQUMsU0FBVWlGLEdBQUc7Z0JBQUksT0FBTzVpQixPQUFPNmlCLHdCQUF3QixDQUFDSixRQUFRRyxLQUFLMWlCLFVBQVU7WUFBRTtRQUFJO1FBQUVRLEtBQUsyVyxJQUFJLENBQUN5TCxLQUFLLENBQUNwaUIsTUFBTWlpQjtJQUFVO0lBQUUsT0FBT2ppQjtBQUFNO0FBRXhWLFNBQVNrMEIsY0FBY3AwQixNQUFNO0lBQUksSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlzSyxVQUFVckssTUFBTSxFQUFFRCxJQUFLO1FBQUUsSUFBSUwsU0FBUzJLLFNBQVMsQ0FBQ3RLLEVBQUUsSUFBSSxPQUFPc0ssU0FBUyxDQUFDdEssRUFBRSxHQUFHLENBQUM7UUFBRyxJQUFJQSxJQUFJLEdBQUc7WUFBRWcwQixRQUFRMzBCLE9BQU9NLFNBQVMsTUFBTTRRLE9BQU8sQ0FBQyxTQUFVcFIsR0FBRztnQkFBSUYsZ0JBQWdCWSxRQUFRVixLQUFLUSxNQUFNLENBQUNSLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSUUsT0FBT2dqQix5QkFBeUIsRUFBRTtZQUFFaGpCLE9BQU9pakIsZ0JBQWdCLENBQUN6aUIsUUFBUVIsT0FBT2dqQix5QkFBeUIsQ0FBQzFpQjtRQUFVLE9BQU87WUFBRXEwQixRQUFRMzBCLE9BQU9NLFNBQVM0USxPQUFPLENBQUMsU0FBVXBSLEdBQUc7Z0JBQUlFLE9BQU9DLGNBQWMsQ0FBQ08sUUFBUVYsS0FBS0UsT0FBTzZpQix3QkFBd0IsQ0FBQ3ZpQixRQUFRUjtZQUFPO1FBQUk7SUFBRTtJQUFFLE9BQU9VO0FBQVE7QUFDcmhCOzs7Ozs7O0NBT0MsR0FFRCxJQUFJcTBCLFlBQVksU0FBU0EsVUFBVW51QixNQUFNO0lBQ3ZDLElBQUlvdUIscUJBQXFCN3BCLFVBQVVySyxNQUFNLEdBQUcsS0FBS3FLLFNBQVMsQ0FBQyxFQUFFLEtBQUtDLFlBQVlELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDN0YsSUFBSXloQixJQUFJaG1CO0lBQ1IsSUFBSSxFQUNGb2MsS0FBSyxFQUNMNEMsUUFBUSxFQUNSMUwsY0FBYyxFQUNkK2EsT0FBTyxFQUNQQyxVQUFVLEVBQ1gsR0FBR3RJLEdBQUcsa0dBQWtHO0lBQ3pHLHlFQUF5RTtJQUV6RXhxQix5QkFBeUJxSCxHQUFHLENBQUNtakIsR0FBRyxJQUFJaHJCO0lBRXBDZ3JCLEVBQUVxSSxPQUFPLEdBQUcsQ0FBQ2oxQixLQUFLQztRQUNoQixJQUFJbVQsdUJBQXVCK1I7UUFFMUIvUixDQUFBQSx3QkFBd0IxUSx5QkFBeUI0RyxHQUFHLENBQUNzakIsRUFBQyxNQUFPLFFBQVF4WiwwQkFBMEIsS0FBSyxJQUFJLEtBQUssSUFBSUE7UUFFbEgsSUFBSSxDQUFDelEsa0NBQWtDMkcsR0FBRyxDQUFDc2pCLE1BQU0sQ0FBQ3pILHdCQUF3QnRpQix3QkFBd0J5RyxHQUFHLENBQUNzakIsRUFBQyxNQUFPLFFBQVF6SCwwQkFBMEIsS0FBSyxLQUFLQSxzQkFBc0Jya0IsTUFBTSxFQUFFO1lBQ3RMLCtFQUErRTtZQUMvRSwwQ0FBMEM7WUFDMUM2QixrQ0FBa0M4RyxHQUFHLENBQUNtakIsR0FBRztRQUMzQztRQUVBaHFCLHFCQUFxQndULE1BQU0sQ0FBQ3dXO1FBQzVCcUksUUFBUWoxQixLQUFLQztJQUNmO0lBRUEyc0IsRUFBRXNJLFVBQVUsR0FBR2wxQixDQUFBQTtRQUNiLElBQUlvbEI7UUFFSixJQUFJLENBQUN6aUIsa0NBQWtDMkcsR0FBRyxDQUFDc2pCLE1BQU0sQ0FBQ3hILHlCQUF5QnZpQix3QkFBd0J5RyxHQUFHLENBQUNzakIsRUFBQyxNQUFPLFFBQVF4SCwyQkFBMkIsS0FBSyxLQUFLQSx1QkFBdUJ0a0IsTUFBTSxFQUFFO1lBQ3pMLCtFQUErRTtZQUMvRSwwQ0FBMEM7WUFDMUM2QixrQ0FBa0M4RyxHQUFHLENBQUNtakIsR0FBRztRQUMzQztRQUVBaHFCLHFCQUFxQndULE1BQU0sQ0FBQ3dXO1FBQzVCc0ksV0FBV2wxQjtJQUNiO0lBRUE0c0IsRUFBRTFTLGNBQWMsR0FBR3dOLENBQUFBO1FBQ2pCLElBQUlBLFNBQVMsUUFBUTtZQUNuQixPQUFPeE4sZUFBZXdOO1FBQ3hCO1FBRUEsSUFBSWtGLEVBQUU5aEIsU0FBUyxJQUFJM0wsd0NBQUtBLENBQUMwTyxXQUFXLENBQUMrZSxFQUFFOWhCLFNBQVMsR0FBRztZQUNqRCxJQUFJcXFCLG1CQUFtQm4yQix5Q0FBTUEsQ0FBQzBpQixLQUFLLENBQUNrTCxHQUFHO2dCQUNyQ2xtQixPQUFPcEYsQ0FBQUEsSUFBS2pDLDBDQUFTQSxDQUFDNlAsU0FBUyxDQUFDNU4sTUFBTXRDLHlDQUFNQSxDQUFDMmlCLE9BQU8sQ0FBQ2lMLEdBQUd0ckI7Z0JBQ3hEaUwsSUFBSXFnQixFQUFFOWhCLFNBQVM7WUFDakI7WUFFQSxJQUFJcXFCLGtCQUFrQjtnQkFDcEIsSUFBSSxHQUFHQyxnQkFBZ0IsR0FBR0Q7Z0JBQzFCLElBQUlFLHFCQUFxQnIyQix5Q0FBTUEsQ0FBQ3dPLEtBQUssQ0FBQ29mLEdBQUd3SSxpQkFBaUJ4SSxFQUFFOWhCLFNBQVMsQ0FBQzJDLE1BQU07Z0JBQzVFLElBQUk2bkIsbUJBQW1CZixxQkFBcUIzSCxHQUFHeUk7Z0JBRS9DLElBQUksQ0FBQ2wyQix3Q0FBS0EsQ0FBQzBPLFdBQVcsQ0FBQ3luQixtQkFBbUI7b0JBQ3hDcDJCLDZDQUFVQSxDQUFDa1gsTUFBTSxDQUFDd1csR0FBRzt3QkFDbkJyZ0IsSUFBSStvQjtvQkFDTjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRixHQUFHLG9FQUFvRTtJQUN2RSxzRkFBc0Y7SUFHdEYxSSxFQUFFNUosS0FBSyxHQUFHaEIsQ0FBQUE7UUFDUixJQUFJamIsVUFBVSxFQUFFO1FBQ2hCLElBQUlrYixlQUFlcGYsd0JBQXdCeUcsR0FBRyxDQUFDc2pCO1FBRS9DLElBQUkzSyxpQkFBaUIsUUFBUUEsaUJBQWlCLEtBQUssS0FBS0EsYUFBYW5oQixNQUFNLEVBQUU7WUFDM0UsSUFBSXdoQixjQUFjTCxhQUFha00sR0FBRyxDQUFDdE8sQ0FBQUEsV0FBWTJDLGtCQUFrQjNDLFVBQVVtQyxLQUFLbkUsTUFBTSxDQUFDMFg7WUFDdkYxeUIsd0JBQXdCNEcsR0FBRyxDQUFDbWpCLEdBQUd0SztRQUNqQztRQUVBLElBQUk2QixtQkFBbUJwaEIsNEJBQTRCdUcsR0FBRyxDQUFDc2pCO1FBRXZELElBQUl6SSxrQkFBa0I7WUFDcEJwaEIsNEJBQTRCMEcsR0FBRyxDQUFDbWpCLEdBQUdySyxzQkFBc0JxSyxHQUFHekksa0JBQWtCbkM7UUFDaEY7UUFFQSxJQUFJd1QsZ0JBQWdCMXlCLHlCQUF5QndHLEdBQUcsQ0FBQ3NqQjtRQUVqRCxJQUFJNEksa0JBQWtCLFFBQVFBLGtCQUFrQixLQUFLLEtBQUtBLGNBQWNqcEIsRUFBRSxFQUFFO1lBQzFFLElBQUlBLEtBQUs3TSx3Q0FBS0EsQ0FBQzZrQixPQUFPLENBQUNpUixrQkFBa0IsUUFBUUEsa0JBQWtCLEtBQUssSUFBSSxLQUFLLElBQUlBLGNBQWNqcEIsRUFBRSxJQUFJd1Ysc0JBQXNCNkssR0FBRzRJLGNBQWNqcEIsRUFBRSxFQUFFeVYsTUFBTU8sc0JBQXNCcUssR0FBRzRJLGNBQWNqcEIsRUFBRSxFQUFFeVY7WUFDck1sZix5QkFBeUIyRyxHQUFHLENBQUNtakIsR0FBR3JnQixLQUFLdW9CLGNBQWNBLGNBQWMsQ0FBQyxHQUFHVSxnQkFBZ0IsQ0FBQyxHQUFHO2dCQUN2RmpwQjtZQUNGLEtBQUs7UUFDUDtRQUVBLE9BQVF5VixHQUFHaEUsSUFBSTtZQUNiLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0g7b0JBQ0VqWCxRQUFRd1EsSUFBSSxJQUFJa2UsV0FBVzdJLEdBQUc1SyxHQUFHclksSUFBSTtvQkFDckM7Z0JBQ0Y7WUFFRixLQUFLO2dCQUNIO29CQUNFLElBQUltakI7b0JBRUosaUZBQWlGO29CQUNoRkEsQ0FBQUEsd0JBQXdCdHFCLHlCQUF5QjhHLEdBQUcsQ0FBQ3NqQixFQUFDLE1BQU8sUUFBUUUsMEJBQTBCLEtBQUssSUFBSSxLQUFLLElBQUlBLHNCQUFzQnBILEtBQUs7b0JBQzdJbGpCLHlCQUF5QjRULE1BQU0sQ0FBQ3dXO29CQUNoQztnQkFDRjtZQUVGLEtBQUs7WUFDTCxLQUFLO2dCQUNIO29CQUNFN2xCLFFBQVF3USxJQUFJLElBQUlrZSxXQUFXN0ksR0FBR3R0Qix1Q0FBSUEsQ0FBQzRGLE1BQU0sQ0FBQzhjLEdBQUdyWSxJQUFJO29CQUNqRDtnQkFDRjtZQUVGLEtBQUs7Z0JBQ0g7b0JBQ0UsSUFBSStyQixXQUFXcDJCLHVDQUFJQSxDQUFDcTJCLFFBQVEsQ0FBQzNULEdBQUdyWSxJQUFJO29CQUNwQzVDLFFBQVF3USxJQUFJLElBQUlrZSxXQUFXN0ksR0FBRzhJO29CQUM5QjtnQkFDRjtZQUVGLEtBQUs7Z0JBQ0g7b0JBQ0UsSUFBSUUsYUFBYXQyQix1Q0FBSUEsQ0FBQ3UyQixNQUFNLENBQUN2MkIsdUNBQUlBLENBQUM0RixNQUFNLENBQUM4YyxHQUFHclksSUFBSSxHQUFHckssdUNBQUlBLENBQUM0RixNQUFNLENBQUM4YyxHQUFHUyxPQUFPO29CQUN6RTFiLFFBQVF3USxJQUFJLElBQUlrZSxXQUFXN0ksR0FBR2dKO29CQUM5QjtnQkFDRjtRQUNKO1FBRUE1UyxNQUFNaEI7UUFFTixLQUFLLElBQUksQ0FBQ3JZLE1BQU0zSixJQUFJLElBQUkrRyxRQUFTO1lBQy9CLElBQUksQ0FBQ3RDLEtBQUssR0FBR3pGLHlDQUFNQSxDQUFDeUYsSUFBSSxDQUFDbW9CLEdBQUdqakI7WUFDNUJ4SCxZQUFZc0gsR0FBRyxDQUFDaEYsTUFBTXpFO1FBQ3hCO0lBQ0Y7SUFFQTRzQixFQUFFM2dCLGVBQWUsR0FBR0gsQ0FBQUE7UUFDbEIsSUFBSSxFQUNGaEIsU0FBUyxFQUNWLEdBQUc4aEI7UUFFSixJQUFJLENBQUM5aEIsV0FBVztZQUNkO1FBQ0Y7UUFFQSxJQUFJLENBQUM2QixPQUFPRyxJQUFJLEdBQUczTix3Q0FBS0EsQ0FBQ2dvQixLQUFLLENBQUNyYztRQUMvQixJQUFJMGtCLFlBQVl4d0IseUNBQU1BLENBQUNzTixJQUFJLENBQUNzZ0IsR0FBRztZQUM3QnJnQixJQUFJSSxNQUFNaEQsSUFBSTtRQUNoQjtRQUNBLElBQUk4bEIsVUFBVXp3Qix5Q0FBTUEsQ0FBQ3NOLElBQUksQ0FBQ3NnQixHQUFHO1lBQzNCcmdCLElBQUlPLElBQUluRCxJQUFJO1FBQ2Q7UUFFQSxJQUFJeEssd0NBQUtBLENBQUMwTyxXQUFXLENBQUMvQyxjQUFjLENBQUMwa0IsV0FBVztZQUM5QztRQUNGLEVBQUUsMEVBQTBFO1FBQzVFLG9EQUFvRDtRQUdwRCxJQUFJMWhCLFdBQVc3RyxZQUFZc0csVUFBVSxDQUFDcWYsR0FBRzloQjtRQUN6QyxJQUFJa0csV0FBV2xELFNBQVNtRCxhQUFhO1FBQ3JDLElBQUk2a0IsU0FBUzlrQixTQUFTck0sVUFBVSxDQUFDLEVBQUUsRUFBRSx3RUFBd0U7UUFFN0dxTSxTQUFTck0sVUFBVSxDQUFDeU0sT0FBTyxDQUFDM00sQ0FBQUE7WUFDMUIsSUFBSUEsS0FBS08sV0FBVyxJQUFJUCxLQUFLTyxXQUFXLENBQUMrd0IsSUFBSSxPQUFPLElBQUk7Z0JBQ3RERCxTQUFTcnhCO1lBQ1g7UUFDRixJQUFJLHlFQUF5RTtRQUM3RSx3RUFBd0U7UUFDeEUsaUVBQWlFO1FBRWpFLElBQUlnckIsU0FBUztZQUNYLElBQUksQ0FBQzNlLFNBQVMsR0FBRzJlO1lBQ2pCLElBQUl1RyxJQUFJbG9CLFNBQVNtb0IsVUFBVTtZQUMzQixJQUFJdHdCLFVBQVVzQixZQUFZZ0QsU0FBUyxDQUFDMmlCLEdBQUc5YjtZQUN2Q2tsQixFQUFFRSxXQUFXLENBQUN2d0I7WUFDZHFMLFdBQVdnbEIsRUFBRS9rQixhQUFhO1FBQzVCLEVBQUUsMEVBQTBFO1FBQzVFLDBFQUEwRTtRQUMxRSw2RUFBNkU7UUFDN0UsOEJBQThCO1FBRzlCLElBQUl1ZSxXQUFXO1lBQ2JzRyxTQUFTOWtCLFNBQVNhLGFBQWEsQ0FBQztRQUNsQyxFQUFFLDJFQUEyRTtRQUM3RSxpQ0FBaUM7UUFHakM5TCxNQUFNQyxJQUFJLENBQUNnTCxTQUFTdEUsZ0JBQWdCLENBQUMsNEJBQTRCMEUsT0FBTyxDQUFDK2tCLENBQUFBO1lBQ3ZFLElBQUlDLFlBQVlELEdBQUcxd0IsWUFBWSxDQUFDLDZCQUE2QjtZQUM3RDB3QixHQUFHbnhCLFdBQVcsR0FBR294QixZQUFZLE9BQU87UUFDdEMsSUFBSSw0RUFBNEU7UUFDaEYsdUVBQXVFO1FBQ3ZFLDJFQUEyRTtRQUUzRSxJQUFJbnlCLFVBQVU2eEIsU0FBUztZQUNyQixJQUFJcmUsT0FBT3FlLE9BQU92eUIsYUFBYSxDQUFDMEYsYUFBYSxDQUFDLFNBQVMsd0VBQXdFO1lBQy9ILGlFQUFpRTtZQUVqRXdPLEtBQUtmLEtBQUssQ0FBQytXLFVBQVUsR0FBRztZQUN4QmhXLEtBQUs0ZSxXQUFXLENBQUNQO1lBQ2pCOWtCLFNBQVNxbEIsV0FBVyxDQUFDNWU7WUFDckJxZSxTQUFTcmU7UUFDWDtRQUVBLElBQUloUixXQUFXbW1CLEVBQUUwSixXQUFXO1FBQzVCLElBQUl4aEIsU0FBU3loQixLQUFLenNCLFNBQVMsQ0FBQ3JEO1FBQzVCLElBQUkrdkIsVUFBVTN5QixPQUFPNHlCLElBQUksQ0FBQ0MsbUJBQW1CNWhCO1FBQzdDZ2hCLE9BQU9hLFlBQVksQ0FBQyx1QkFBdUJIO1FBQzNDMXFCLEtBQUs4cUIsT0FBTyxDQUFDLGVBQWVsMUIsTUFBTSxDQUFDc3pCLHFCQUFxQndCLFVBQVUsZ0VBQWdFO1FBRWxJLElBQUlLLE1BQU03bEIsU0FBU3pOLGFBQWEsQ0FBQzBGLGFBQWEsQ0FBQztRQUMvQzR0QixJQUFJUixXQUFXLENBQUNybEI7UUFDaEI2bEIsSUFBSUYsWUFBWSxDQUFDLFVBQVU7UUFDM0IzbEIsU0FBU3pOLGFBQWEsQ0FBQ3V6QixJQUFJLENBQUNULFdBQVcsQ0FBQ1E7UUFDeEMvcUIsS0FBSzhxQixPQUFPLENBQUMsYUFBYUMsSUFBSUUsU0FBUztRQUN2Q2pyQixLQUFLOHFCLE9BQU8sQ0FBQyxjQUFjbHhCLGFBQWFteEI7UUFDeEM3bEIsU0FBU3pOLGFBQWEsQ0FBQ3V6QixJQUFJLENBQUN4bEIsV0FBVyxDQUFDdWxCO1FBQ3hDLE9BQU8vcUI7SUFDVDtJQUVBOGdCLEVBQUUvZ0IsVUFBVSxHQUFHQyxDQUFBQTtRQUNiLElBQUksQ0FBQzhnQixFQUFFN2dCLGtCQUFrQixDQUFDRCxPQUFPO1lBQy9COGdCLEVBQUU1Z0IsY0FBYyxDQUFDRjtRQUNuQjtJQUNGO0lBRUE4Z0IsRUFBRTdnQixrQkFBa0IsR0FBR0QsQ0FBQUE7UUFDckI7O0tBRUMsR0FDRCxJQUFJckYsV0FBV3FGLEtBQUt6SCxPQUFPLENBQUMsZUFBZTNDLE1BQU0sQ0FBQ3N6Qix3QkFBd0IxdUIsMEJBQTBCd0Y7UUFFcEcsSUFBSXJGLFVBQVU7WUFDWixJQUFJdXdCLFVBQVVDLG1CQUFtQnB6QixPQUFPcXpCLElBQUksQ0FBQ3p3QjtZQUM3QyxJQUFJMHdCLFNBQVNaLEtBQUthLEtBQUssQ0FBQ0o7WUFDeEJwSyxFQUFFeUssY0FBYyxDQUFDRjtZQUNqQixPQUFPO1FBQ1Q7UUFFQSxPQUFPO0lBQ1Q7SUFFQXZLLEVBQUU1Z0IsY0FBYyxHQUFHRixDQUFBQTtRQUNqQixJQUFJbEcsT0FBT2tHLEtBQUt6SCxPQUFPLENBQUM7UUFFeEIsSUFBSXVCLE1BQU07WUFDUixJQUFJMHhCLFFBQVExeEIsS0FBS21DLEtBQUssQ0FBQztZQUN2QixJQUFJQSxRQUFRO1lBRVosS0FBSyxJQUFJK2YsUUFBUXdQLE1BQU87Z0JBQ3RCLElBQUl2dkIsT0FBTztvQkFDVDdJLDZDQUFVQSxDQUFDcTRCLFVBQVUsQ0FBQzNLLEdBQUc7d0JBQ3ZCNEssUUFBUTtvQkFDVjtnQkFDRjtnQkFFQTVLLEVBQUV0SCxVQUFVLENBQUN3QztnQkFDYi9mLFFBQVE7WUFDVjtZQUVBLE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVDtJQUVBNmtCLEVBQUVoSCxRQUFRLEdBQUcxYSxDQUFBQTtRQUNYLDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUsd0VBQXdFO1FBQ3hFLHdFQUF3RTtRQUN4RXJMLHdFQUFnQyxDQUFDO1lBQy9CLElBQUkwekIsa0JBQWtCOXdCLG9CQUFvQjZHLEdBQUcsQ0FBQ3NqQjtZQUU5QyxJQUFJMkcsaUJBQWlCO2dCQUNuQkE7WUFDRjtZQUVBM04sU0FBUzFhO1FBQ1g7SUFDRjtJQUVBLE9BQU8waEI7QUFDVDtBQUVBLElBQUk2SSxhQUFhLENBQUM3SSxHQUFHampCO0lBQ25CLElBQUk1QyxVQUFVLEVBQUU7SUFFaEIsS0FBSyxJQUFJLENBQUN6RixHQUFHdVcsRUFBRSxJQUFJN1kseUNBQU1BLENBQUMwNEIsTUFBTSxDQUFDOUssR0FBRztRQUNsQ3JnQixJQUFJNUM7SUFDTixHQUFJO1FBQ0YsSUFBSTNKLE1BQU1pSCxZQUFZdUMsT0FBTyxDQUFDb2pCLEdBQUd0ckI7UUFDakN5RixRQUFRd1EsSUFBSSxDQUFDO1lBQUNNO1lBQUc3WDtTQUFJO0lBQ3ZCO0lBRUEsT0FBTytHO0FBQ1Q7QUFFbU8sQ0FDbk8sb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3QvZGlzdC9pbmRleC5lcy5qcz80ZTIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXREaXJlY3Rpb24gZnJvbSAnZGlyZWN0aW9uJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICdsb2Rhc2gvZGVib3VuY2UnO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC90aHJvdHRsZSc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIG1lbW8sIGZvcndhcmRSZWYsIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUNhbGxiYWNrLCBDb21wb25lbnQsIHVzZVJlZHVjZXIsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc2Nyb2xsSW50b1ZpZXcgZnJvbSAnc2Nyb2xsLWludG8tdmlldy1pZi1uZWVkZWQnO1xuaW1wb3J0IHsgRWRpdG9yLCBTY3J1YmJlciwgVHJhbnNmb3JtcywgUmFuZ2UsIEVsZW1lbnQgYXMgRWxlbWVudCQxLCBQYXRoLCBOb2RlLCBUZXh0IGFzIFRleHQkMSwgUG9pbnQgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlciB9IGZyb20gJ0BqdWdnbGUvcmVzaXplLW9ic2VydmVyJztcbmltcG9ydCB7IGlzS2V5SG90a2V5IH0gZnJvbSAnaXMtaG90a2V5JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxyXG4gKiBBbiBhdXRvLWluY3JlbWVudGluZyBpZGVudGlmaWVyIGZvciBrZXlzLlxyXG4gKi9cbnZhciBuID0gMDtcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgYSBrZXkgc3RyaW5nLiBXZSB1c2UgYSBmdWxsIGNsYXNzIGhlcmUgYmVjYXVzZSB3ZVxyXG4gKiB3YW50IHRvIGJlIGFibGUgdG8gdXNlIHRoZW0gYXMga2V5cyBpbiBgV2Vha01hcGAgb2JqZWN0cy5cclxuICovXG5cbmNsYXNzIEtleSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaWQgPSBcIlwiLmNvbmNhdChuKyspO1xuICB9XG5cbn1cblxuLyoqXHJcbiAqIFR3byB3ZWFrIG1hcHMgdGhhdCBhbGxvdyB1cyByZWJ1aWxkIGEgcGF0aCBnaXZlbiBhIG5vZGUuIFRoZXkgYXJlIHBvcHVsYXRlZFxyXG4gKiBhdCByZW5kZXIgdGltZSBzdWNoIHRoYXQgYWZ0ZXIgYSByZW5kZXIgb2NjdXJzIHdlIGNhbiBhbHdheXMgYmFja3RyYWNrLlxyXG4gKi9cbnZhciBOT0RFX1RPX0lOREVYID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX1BBUkVOVCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogV2VhayBtYXBzIHRoYXQgYWxsb3cgdXMgdG8gZ28gYmV0d2VlbiBTbGF0ZSBub2RlcyBhbmQgRE9NIG5vZGVzLiBUaGVzZVxyXG4gKiBhcmUgdXNlZCB0byByZXNvbHZlIERPTSBldmVudC1yZWxhdGVkIGxvZ2ljIGludG8gU2xhdGUgYWN0aW9ucy5cclxuICovXG5cbnZhciBFRElUT1JfVE9fV0lORE9XID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVMRU1FTlRfVE9fTk9ERSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX0tFWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0tFWV9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBXZWFrIG1hcHMgZm9yIHN0b3JpbmcgZWRpdG9yLXJlbGF0ZWQgc3RhdGUuXHJcbiAqL1xuXG52YXIgSVNfUkVBRF9PTkxZID0gbmV3IFdlYWtNYXAoKTtcbnZhciBJU19GT0NVU0VEID0gbmV3IFdlYWtNYXAoKTtcbnZhciBJU19DT01QT1NJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19VU0VSX1NFTEVDVElPTiA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogV2VhayBtYXAgZm9yIGFzc29jaWF0aW5nIHRoZSBjb250ZXh0IGBvbkNoYW5nZWAgY29udGV4dCB3aXRoIHRoZSBwbHVnaW4uXHJcbiAqL1xuXG52YXIgRURJVE9SX1RPX09OX0NIQU5HRSA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogV2VhayBtYXBzIGZvciBzYXZpbmcgcGVuZGluZyBzdGF0ZSBvbiBjb21wb3NpdGlvbiBzdGFnZS5cclxuICovXG5cbnZhciBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0ggPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1VTRVJfTUFSS1MgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIEFuZHJvaWQgaW5wdXQgaGFuZGxpbmcgc3BlY2lmaWMgd2Vhay1tYXBzXHJcbiAqL1xuXG52YXIgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTiA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fRk9SQ0VfUkVOREVSID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBTeW1ib2xzLlxyXG4gKi9cblxudmFyIFBMQUNFSE9MREVSX1NZTUJPTCA9IFN5bWJvbCgncGxhY2Vob2xkZXInKTtcbnZhciBNQVJLX1BMQUNFSE9MREVSX1NZTUJPTCA9IFN5bWJvbCgnbWFyay1wbGFjZWhvbGRlcicpO1xuXG4vKipcclxuICogVHlwZXMuXHJcbiAqL1xudmFyIERPTVRleHQgPSBnbG9iYWxUaGlzLlRleHQ7XG4vKipcclxuICogUmV0dXJucyB0aGUgaG9zdCB3aW5kb3cgb2YgYSBET00gbm9kZVxyXG4gKi9cblxudmFyIGdldERlZmF1bHRWaWV3ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUub3duZXJEb2N1bWVudCAmJiB2YWx1ZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IG51bGw7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYSBjb21tZW50IG5vZGUuXHJcbiAqL1xuXG52YXIgaXNET01Db21tZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gODtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhbiBlbGVtZW50IG5vZGUuXHJcbiAqL1xuXG52YXIgaXNET01FbGVtZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIERPTSBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NTm9kZSA9IHZhbHVlID0+IHtcbiAgdmFyIHdpbmRvdyA9IGdldERlZmF1bHRWaWV3KHZhbHVlKTtcbiAgcmV0dXJuICEhd2luZG93ICYmIHZhbHVlIGluc3RhbmNlb2Ygd2luZG93Lk5vZGU7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBET00gc2VsZWN0aW9uLlxyXG4gKi9cblxudmFyIGlzRE9NU2VsZWN0aW9uID0gdmFsdWUgPT4ge1xuICB2YXIgd2luZG93ID0gdmFsdWUgJiYgdmFsdWUuYW5jaG9yTm9kZSAmJiBnZXREZWZhdWx0Vmlldyh2YWx1ZS5hbmNob3JOb2RlKTtcbiAgcmV0dXJuICEhd2luZG93ICYmIHZhbHVlIGluc3RhbmNlb2Ygd2luZG93LlNlbGVjdGlvbjtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhbiBlbGVtZW50IG5vZGUuXHJcbiAqL1xuXG52YXIgaXNET01UZXh0ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMztcbn07XG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgYSBwYXN0ZSBldmVudCBpcyBhIHBsYWludGV4dC1vbmx5IGV2ZW50LlxyXG4gKi9cblxudmFyIGlzUGxhaW5UZXh0T25seVBhc3RlID0gZXZlbnQgPT4ge1xuICByZXR1cm4gZXZlbnQuY2xpcGJvYXJkRGF0YSAmJiBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKSAhPT0gJycgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YS50eXBlcy5sZW5ndGggPT09IDE7XG59O1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIERPTSBwb2ludCBzbyB0aGF0IGl0IGFsd2F5cyByZWZlcnMgdG8gYSB0ZXh0IG5vZGUuXHJcbiAqL1xuXG52YXIgbm9ybWFsaXplRE9NUG9pbnQgPSBkb21Qb2ludCA9PiB7XG4gIHZhciBbbm9kZSwgb2Zmc2V0XSA9IGRvbVBvaW50OyAvLyBJZiBpdCdzIGFuIGVsZW1lbnQgbm9kZSwgaXRzIG9mZnNldCByZWZlcnMgdG8gdGhlIGluZGV4IG9mIGl0cyBjaGlsZHJlblxuICAvLyBpbmNsdWRpbmcgY29tbWVudCBub2Rlcywgc28gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IHRleHQgY2hpbGQgbm9kZS5cblxuICBpZiAoaXNET01FbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICB2YXIgaXNMYXN0ID0gb2Zmc2V0ID09PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IGlzTGFzdCA/IG9mZnNldCAtIDEgOiBvZmZzZXQ7XG4gICAgW25vZGUsIGluZGV4XSA9IGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleChub2RlLCBpbmRleCwgaXNMYXN0ID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJyk7IC8vIElmIHRoZSBlZGl0YWJsZSBjaGlsZCBmb3VuZCBpcyBpbiBmcm9udCBvZiBpbnB1dCBvZmZzZXQsIHdlIGluc3RlYWQgc2VlayB0byBpdHMgZW5kXG5cbiAgICBpc0xhc3QgPSBpbmRleCA8IG9mZnNldDsgLy8gSWYgdGhlIG5vZGUgaGFzIGNoaWxkcmVuLCB0cmF2ZXJzZSB1bnRpbCB3ZSBoYXZlIGEgbGVhZiBub2RlLiBMZWFmIG5vZGVzXG4gICAgLy8gY2FuIGJlIGVpdGhlciB0ZXh0IG5vZGVzLCBvciBvdGhlciB2b2lkIERPTSBub2Rlcy5cblxuICAgIHdoaWxlIChpc0RPTUVsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgdmFyIGkgPSBpc0xhc3QgPyBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSA6IDA7XG4gICAgICBub2RlID0gZ2V0RWRpdGFibGVDaGlsZChub2RlLCBpLCBpc0xhc3QgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnKTtcbiAgICB9IC8vIERldGVybWluZSB0aGUgbmV3IG9mZnNldCBpbnNpZGUgdGhlIHRleHQgbm9kZS5cblxuXG4gICAgb2Zmc2V0ID0gaXNMYXN0ICYmIG5vZGUudGV4dENvbnRlbnQgIT0gbnVsbCA/IG5vZGUudGV4dENvbnRlbnQubGVuZ3RoIDogMDtcbiAgfSAvLyBSZXR1cm4gdGhlIG5vZGUgYW5kIG9mZnNldC5cblxuXG4gIHJldHVybiBbbm9kZSwgb2Zmc2V0XTtcbn07XG4vKipcclxuICogRGV0ZXJtaW5lcyB3ZXRoZXIgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIG5lc3RlZCB3aXRoaW4gYSBzaGFkb3dSb290XHJcbiAqL1xuXG52YXIgaGFzU2hhZG93Um9vdCA9IG5vZGUgPT4ge1xuICB2YXIgcGFyZW50ID0gbm9kZSAmJiBub2RlLnBhcmVudE5vZGU7XG5cbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcclxuICogR2V0IHRoZSBuZWFyZXN0IGVkaXRhYmxlIGNoaWxkIGFuZCBpbmRleCBhdCBgaW5kZXhgIGluIGEgYHBhcmVudGAsIHByZWZlcnJpbmdcclxuICogYGRpcmVjdGlvbmAuXHJcbiAqL1xuXG52YXIgZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4ID0gKHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikgPT4ge1xuICB2YXIge1xuICAgIGNoaWxkTm9kZXNcbiAgfSA9IHBhcmVudDtcbiAgdmFyIGNoaWxkID0gY2hpbGROb2Rlc1tpbmRleF07XG4gIHZhciBpID0gaW5kZXg7XG4gIHZhciB0cmllZEZvcndhcmQgPSBmYWxzZTtcbiAgdmFyIHRyaWVkQmFja3dhcmQgPSBmYWxzZTsgLy8gV2hpbGUgdGhlIGNoaWxkIGlzIGEgY29tbWVudCBub2RlLCBvciBhbiBlbGVtZW50IG5vZGUgd2l0aCBubyBjaGlsZHJlbixcbiAgLy8ga2VlcCBpdGVyYXRpbmcgdG8gZmluZCBhIHNpYmxpbmcgbm9uLXZvaWQsIG5vbi1jb21tZW50IG5vZGUuXG5cbiAgd2hpbGUgKGlzRE9NQ29tbWVudChjaGlsZCkgfHwgaXNET01FbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCB8fCBpc0RPTUVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScpIHtcbiAgICBpZiAodHJpZWRGb3J3YXJkICYmIHRyaWVkQmFja3dhcmQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpID49IGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICB0cmllZEZvcndhcmQgPSB0cnVlO1xuICAgICAgaSA9IGluZGV4IC0gMTtcbiAgICAgIGRpcmVjdGlvbiA9ICdiYWNrd2FyZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRyaWVkQmFja3dhcmQgPSB0cnVlO1xuICAgICAgaSA9IGluZGV4ICsgMTtcbiAgICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGROb2Rlc1tpXTtcbiAgICBpbmRleCA9IGk7XG4gICAgaSArPSBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IDEgOiAtMTtcbiAgfVxuXG4gIHJldHVybiBbY2hpbGQsIGluZGV4XTtcbn07XG4vKipcclxuICogR2V0IHRoZSBuZWFyZXN0IGVkaXRhYmxlIGNoaWxkIGF0IGBpbmRleGAgaW4gYSBgcGFyZW50YCwgcHJlZmVycmluZ1xyXG4gKiBgZGlyZWN0aW9uYC5cclxuICovXG5cbnZhciBnZXRFZGl0YWJsZUNoaWxkID0gKHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikgPT4ge1xuICB2YXIgW2NoaWxkXSA9IGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pO1xuICByZXR1cm4gY2hpbGQ7XG59O1xuLyoqXHJcbiAqIEdldCBhIHBsYWludGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29udGVudCBvZiBhIG5vZGUsIGFjY291bnRpbmcgZm9yIGJsb2NrXHJcbiAqIGVsZW1lbnRzIHdoaWNoIGdldCBhIG5ld2xpbmUgYXBwZW5kZWQuXHJcbiAqXHJcbiAqIFRoZSBkb21Ob2RlIG11c3QgYmUgYXR0YWNoZWQgdG8gdGhlIERPTS5cclxuICovXG5cbnZhciBnZXRQbGFpblRleHQgPSBkb21Ob2RlID0+IHtcbiAgdmFyIHRleHQgPSAnJztcblxuICBpZiAoaXNET01UZXh0KGRvbU5vZGUpICYmIGRvbU5vZGUubm9kZVZhbHVlKSB7XG4gICAgcmV0dXJuIGRvbU5vZGUubm9kZVZhbHVlO1xuICB9XG5cbiAgaWYgKGlzRE9NRWxlbWVudChkb21Ob2RlKSkge1xuICAgIGZvciAodmFyIGNoaWxkTm9kZSBvZiBBcnJheS5mcm9tKGRvbU5vZGUuY2hpbGROb2RlcykpIHtcbiAgICAgIHRleHQgKz0gZ2V0UGxhaW5UZXh0KGNoaWxkTm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBnZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKTtcblxuICAgIGlmIChkaXNwbGF5ID09PSAnYmxvY2snIHx8IGRpc3BsYXkgPT09ICdsaXN0JyB8fCBkb21Ob2RlLnRhZ05hbWUgPT09ICdCUicpIHtcbiAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRleHQ7XG59O1xuLyoqXHJcbiAqIEdldCB4LXNsYXRlLWZyYWdtZW50IGF0dHJpYnV0ZSBmcm9tIGRhdGEtc2xhdGUtZnJhZ21lbnRcclxuICovXG5cbnZhciBjYXRjaFNsYXRlRnJhZ21lbnQgPSAvZGF0YS1zbGF0ZS1mcmFnbWVudD1cIiguKz8pXCIvbTtcbnZhciBnZXRTbGF0ZUZyYWdtZW50QXR0cmlidXRlID0gZGF0YVRyYW5zZmVyID0+IHtcbiAgdmFyIGh0bWxEYXRhID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuICB2YXIgWywgZnJhZ21lbnRdID0gaHRtbERhdGEubWF0Y2goY2F0Y2hTbGF0ZUZyYWdtZW50KSB8fCBbXTtcbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIGEgbXV0YXRpb24gb3JpZ2luYXRlcyBmcm9tIGEgZWRpdGFibGUgZWxlbWVudCBpbnNpZGUgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciBpc1RyYWNrZWRNdXRhdGlvbiA9IChlZGl0b3IsIG11dGF0aW9uLCBiYXRjaCkgPT4ge1xuICB2YXIge1xuICAgIHRhcmdldFxuICB9ID0gbXV0YXRpb247XG5cbiAgaWYgKGlzRE9NRWxlbWVudCh0YXJnZXQpICYmIHRhcmdldC5tYXRjaGVzKCdbY29udGVudEVkaXRhYmxlPVwiZmFsc2VcIl0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB7XG4gICAgZG9jdW1lbnRcbiAgfSA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuXG4gIGlmIChkb2N1bWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQsIHtcbiAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgcGFyZW50TXV0YXRpb24gPSBiYXRjaC5maW5kKF9yZWYgPT4ge1xuICAgIHZhciB7XG4gICAgICBhZGRlZE5vZGVzLFxuICAgICAgcmVtb3ZlZE5vZGVzXG4gICAgfSA9IF9yZWY7XG5cbiAgICBmb3IgKHZhciBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICAgIGlmIChub2RlID09PSB0YXJnZXQgfHwgbm9kZS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9ub2RlIG9mIHJlbW92ZWROb2Rlcykge1xuICAgICAgaWYgKF9ub2RlID09PSB0YXJnZXQgfHwgX25vZGUuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmICghcGFyZW50TXV0YXRpb24gfHwgcGFyZW50TXV0YXRpb24gPT09IG11dGF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRhcmdldCBhZGQvcmVtb3ZlIGlzIHRyYWNrZWQuIFRyYWNrIHRoZSBtdXRhdGlvbiBpZiB3ZSB0cmFjayB0aGUgcGFyZW50IG11dGF0aW9uLlxuXG5cbiAgcmV0dXJuIGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgcGFyZW50TXV0YXRpb24sIGJhdGNoKTtcbn07XG5cbnZhciBJU19SRUFDVF9WRVJTSU9OXzE3X09SX0FCT1ZFID0gcGFyc2VJbnQoUmVhY3QudmVyc2lvbi5zcGxpdCgnLicpWzBdLCAxMCkgPj0gMTc7XG52YXIgSVNfSU9TID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTtcbnZhciBJU19BUFBMRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9NYWMgT1MgWC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19BTkRST0lEID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfRklSRUZPWCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94KS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19TQUZBUkkgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvVmVyc2lvblxcL1tcXGRcXC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBcIm1vZGVyblwiIEVkZ2Ugd2FzIHJlbGVhc2VkIGF0IDc5LnhcblxudmFyIElTX0VER0VfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0VkZ2U/XFwvKD86WzAtNl1bMC05XXxbMC03XVswLThdKSg/OlxcLikvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0NIUk9NRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9DaHJvbWUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBOYXRpdmUgYGJlZm9yZUlucHV0YCBldmVudHMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggcmVhY3Qgb24gQ2hyb21lIDc1XG4vLyBhbmQgb2xkZXIsIENocm9tZSA3NisgY2FuIHVzZSBgYmVmb3JlSW5wdXRgIHRob3VnaC5cblxudmFyIElTX0NIUk9NRV9MRUdBQ1kgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lP1xcLyg/OlswLTddWzAtNV18WzAtNl1bMC05XSkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19BTkRST0lEX0NIUk9NRV9MRUdBQ1kgPSBJU19BTkRST0lEICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9DaHJvbWU/XFwvKD86WzAtNV0/XFxkKSg/OlxcLikvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBGaXJlZm94IGRpZCBub3Qgc3VwcG9ydCBgYmVmb3JlSW5wdXRgIHVudGlsIGB2ODdgLlxuXG52YXIgSVNfRklSRUZPWF9MRUdBQ1kgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveFxcLyg/OlswLTddWzAtOV18WzAtOF1bMC02XSkoPzpcXC4pKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gVUMgbW9iaWxlIGJyb3dzZXJcblxudmFyIElTX1VDX01PQklMRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC8uKlVDQnJvd3Nlci8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gV2VjaGF0IGJyb3dzZXJcblxudmFyIElTX1dFQ0hBVEJST1dTRVIgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvLipXZWNoYXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIENoZWNrIGlmIERPTSBpcyBhdmFpbGFibGUgYXMgUmVhY3QgZG9lcyBpbnRlcm5hbGx5LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xuXG52YXIgQ0FOX1VTRV9ET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnKTsgLy8gQ09NUEFUOiBGaXJlZm94L0VkZ2UgTGVnYWN5IGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnRcbi8vIENocm9tZSBMZWdhY3kgZG9lc24ndCBzdXBwb3J0IGBiZWZvcmVpbnB1dGAgY29ycmVjdGx5XG5cbnZhciBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgPSAoIUlTX0NIUk9NRV9MRUdBQ1kgfHwgIUlTX0FORFJPSURfQ0hST01FX0xFR0FDWSkgJiYgIUlTX0VER0VfTEVHQUNZICYmIC8vIGdsb2JhbFRoaXMgaXMgdW5kZWZpbmVkIGluIG9sZGVyIGJyb3dzZXJzXG50eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5JbnB1dEV2ZW50ICYmIC8vIEB0cy1pZ25vcmUgVGhlIGBnZXRUYXJnZXRSYW5nZXNgIHByb3BlcnR5IGlzbid0IHJlY29nbml6ZWQuXG50eXBlb2YgZ2xvYmFsVGhpcy5JbnB1dEV2ZW50LnByb3RvdHlwZS5nZXRUYXJnZXRSYW5nZXMgPT09ICdmdW5jdGlvbic7XG5cbnZhciBSZWFjdEVkaXRvciA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHVzZXIgaXMgY3VycmVudGx5IGNvbXBvc2luZyBpbnNpZGUgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaXNDb21wb3NpbmcoZWRpdG9yKSB7XG4gICAgcmV0dXJuICEhSVNfQ09NUE9TSU5HLmdldChlZGl0b3IpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgaG9zdCB3aW5kb3cgb2YgdGhlIGN1cnJlbnQgZWRpdG9yLlxyXG4gICAqL1xuICBnZXRXaW5kb3coZWRpdG9yKSB7XG4gICAgdmFyIHdpbmRvdyA9IEVESVRPUl9UT19XSU5ET1cuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXdpbmRvdykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBhIGhvc3Qgd2luZG93IGVsZW1lbnQgZm9yIHRoaXMgZWRpdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfSxcblxuICAvKipcclxuICAgKiBGaW5kIGEga2V5IGZvciBhIFNsYXRlIG5vZGUuXHJcbiAgICovXG4gIGZpbmRLZXkoZWRpdG9yLCBub2RlKSB7XG4gICAgdmFyIGtleSA9IE5PREVfVE9fS0VZLmdldChub2RlKTtcblxuICAgIGlmICgha2V5KSB7XG4gICAgICBrZXkgPSBuZXcgS2V5KCk7XG4gICAgICBOT0RFX1RPX0tFWS5zZXQobm9kZSwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIHBhdGggb2YgU2xhdGUgbm9kZS5cclxuICAgKi9cbiAgZmluZFBhdGgoZWRpdG9yLCBub2RlKSB7XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICB2YXIgY2hpbGQgPSBub2RlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBOT0RFX1RPX1BBUkVOVC5nZXQoY2hpbGQpO1xuXG4gICAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgaWYgKEVkaXRvci5pc0VkaXRvcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaSA9IE5PREVfVE9fSU5ERVguZ2V0KGNoaWxkKTtcblxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcGF0aC51bnNoaWZ0KGkpO1xuICAgICAgY2hpbGQgPSBwYXJlbnQ7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdGhlIHBhdGggZm9yIFNsYXRlIG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBGaW5kIHRoZSBET00gbm9kZSB0aGF0IGltcGxlbWVudHMgRG9jdW1lbnRPclNoYWRvd1Jvb3QgZm9yIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpIHtcbiAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gZWwuZ2V0Um9vdE5vZGUoKTtcblxuICAgIGlmICgocm9vdCBpbnN0YW5jZW9mIERvY3VtZW50IHx8IHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSAmJiByb290LmdldFNlbGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWwub3duZXJEb2N1bWVudDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgZWRpdG9yIGlzIGZvY3VzZWQuXHJcbiAgICovXG4gIGlzRm9jdXNlZChlZGl0b3IpIHtcbiAgICByZXR1cm4gISFJU19GT0NVU0VELmdldChlZGl0b3IpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgaW4gcmVhZC1vbmx5IG1vZGUuXHJcbiAgICovXG4gIGlzUmVhZE9ubHkoZWRpdG9yKSB7XG4gICAgcmV0dXJuICEhSVNfUkVBRF9PTkxZLmdldChlZGl0b3IpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEJsdXIgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgYmx1cihlZGl0b3IpIHtcbiAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCBmYWxzZSk7XG5cbiAgICBpZiAocm9vdC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xuICAgICAgZWwuYmx1cigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBGb2N1cyB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBmb2N1cyhlZGl0b3IpIHtcbiAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcblxuICAgIGlmIChyb290LmFjdGl2ZUVsZW1lbnQgIT09IGVsKSB7XG4gICAgICBlbC5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBEZXNlbGVjdCB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBkZXNlbGVjdChlZGl0b3IpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSByb290LmdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGRvbVNlbGVjdGlvbiAmJiBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgd2l0aGluIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGVkaXRhYmxlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgZWRpdG9yRWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciB0YXJnZXRFbDsgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCByZWFkaW5nIGB0YXJnZXQubm9kZVR5cGVgIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWZcbiAgICAvLyB0YXJnZXQgaXMgb3JpZ2luYXRpbmcgZnJvbSBhbiBpbnRlcm5hbCBcInJlc3RyaWN0ZWRcIiBlbGVtZW50IChlLmcuIGFcbiAgICAvLyBzdGVwcGVyIGFycm93IG9uIGEgbnVtYmVyIGlucHV0KS4gKDIwMTgvMDUvMDQpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL2lzc3Vlcy8xODE5XG5cbiAgICB0cnkge1xuICAgICAgdGFyZ2V0RWwgPSBpc0RPTUVsZW1lbnQodGFyZ2V0KSA/IHRhcmdldCA6IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFlcnIubWVzc2FnZS5pbmNsdWRlcygnUGVybWlzc2lvbiBkZW5pZWQgdG8gYWNjZXNzIHByb3BlcnR5IFwibm9kZVR5cGVcIicpKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldEVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldEVsLmNsb3Nlc3QoXCJbZGF0YS1zbGF0ZS1lZGl0b3JdXCIpID09PSBlZGl0b3JFbCAmJiAoIWVkaXRhYmxlIHx8IHRhcmdldEVsLmlzQ29udGVudEVkaXRhYmxlID8gdHJ1ZSA6IHR5cGVvZiB0YXJnZXRFbC5pc0NvbnRlbnRFZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nICYmIC8vIGlzQ29udGVudEVkaXRhYmxlIGV4aXN0cyBvbmx5IG9uIEhUTUxFbGVtZW50LCBhbmQgb24gb3RoZXIgbm9kZXMgaXQgd2lsbCBiZSB1bmRlZmluZWRcbiAgICAvLyB0aGlzIGlzIHRoZSBjb3JlIGxvZ2ljIHRoYXQgbGV0cyB5b3Uga25vdyB5b3UgZ290IHRoZSByaWdodCBlZGl0b3Iuc2VsZWN0aW9uIGluc3RlYWQgb2YgbnVsbCB3aGVuIGVkaXRvciBpcyBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiKHJlYWRPbmx5KVxuICAgIHRhcmdldEVsLmNsb3Nlc3QoJ1tjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXScpID09PSBlZGl0b3JFbCB8fCAhIXRhcmdldEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBkYXRhIGZyb20gYSBgRGF0YVRyYW5zZmVyYCBpbnRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGluc2VydERhdGEoZWRpdG9yLCBkYXRhKSB7XG4gICAgZWRpdG9yLmluc2VydERhdGEoZGF0YSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGZyYWdtZW50IGRhdGEgZnJvbSBhIGBEYXRhVHJhbnNmZXJgIGludG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnREYXRhKGVkaXRvciwgZGF0YSkge1xuICAgIHJldHVybiBlZGl0b3IuaW5zZXJ0RnJhZ21lbnREYXRhKGRhdGEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCB0ZXh0IGRhdGEgZnJvbSBhIGBEYXRhVHJhbnNmZXJgIGludG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0VGV4dERhdGEoZWRpdG9yLCBkYXRhKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pbnNlcnRUZXh0RGF0YShkYXRhKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXRzIGRhdGEgZnJvbSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGZyYWdtZW50IG9uIGEgYERhdGFUcmFuc2ZlcmAuXHJcbiAgICovXG4gIHNldEZyYWdtZW50RGF0YShlZGl0b3IsIGRhdGEsIG9yaWdpbkV2ZW50KSB7XG4gICAgZWRpdG9yLnNldEZyYWdtZW50RGF0YShkYXRhLCBvcmlnaW5FdmVudCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCB0aGUgbmF0aXZlIERPTSBlbGVtZW50IGZyb20gYSBTbGF0ZSBub2RlLlxyXG4gICAqL1xuICB0b0RPTU5vZGUoZWRpdG9yLCBub2RlKSB7XG4gICAgdmFyIEtFWV9UT19FTEVNRU5UID0gRURJVE9SX1RPX0tFWV9UT19FTEVNRU5ULmdldChlZGl0b3IpO1xuICAgIHZhciBkb21Ob2RlID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gRURJVE9SX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcikgOiBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogS0VZX1RPX0VMRU1FTlQuZ2V0KFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBub2RlKSk7XG5cbiAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgRE9NIG5vZGUgZnJvbSBTbGF0ZSBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbU5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCBhIG5hdGl2ZSBET00gc2VsZWN0aW9uIHBvaW50IGZyb20gYSBTbGF0ZSBwb2ludC5cclxuICAgKi9cbiAgdG9ET01Qb2ludChlZGl0b3IsIHBvaW50KSB7XG4gICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcG9pbnQucGF0aCk7XG4gICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgbm9kZSk7XG4gICAgdmFyIGRvbVBvaW50OyAvLyBJZiB3ZSdyZSBpbnNpZGUgYSB2b2lkIG5vZGUsIGZvcmNlIHRoZSBvZmZzZXQgdG8gMCwgb3RoZXJ3aXNlIHRoZSB6ZXJvXG4gICAgLy8gd2lkdGggc3BhY2luZyBjaGFyYWN0ZXIgd2lsbCByZXN1bHQgaW4gYW4gaW5jb3JyZWN0IG9mZnNldCBvZiAxXG5cbiAgICBpZiAoRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogcG9pbnRcbiAgICB9KSkge1xuICAgICAgcG9pbnQgPSB7XG4gICAgICAgIHBhdGg6IHBvaW50LnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfTtcbiAgICB9IC8vIEZvciBlYWNoIGxlYWYsIHdlIG5lZWQgdG8gaXNvbGF0ZSBpdHMgY29udGVudCwgd2hpY2ggbWVhbnMgZmlsdGVyaW5nXG4gICAgLy8gdG8gaXRzIGRpcmVjdCB0ZXh0IGFuZCB6ZXJvLXdpZHRoIHNwYW5zLiAoV2UgaGF2ZSB0byBmaWx0ZXIgb3V0IGFueVxuICAgIC8vIG90aGVyIHNpYmxpbmdzIHRoYXQgbWF5IGhhdmUgYmVlbiByZW5kZXJlZCBhbG9uZ3NpZGUgdGhlbS4pXG5cblxuICAgIHZhciBzZWxlY3RvciA9IFwiW2RhdGEtc2xhdGUtc3RyaW5nXSwgW2RhdGEtc2xhdGUtemVyby13aWR0aF1cIjtcbiAgICB2YXIgdGV4dHMgPSBBcnJheS5mcm9tKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRleHQgPSB0ZXh0c1tpXTtcbiAgICAgIHZhciBkb21Ob2RlID0gdGV4dC5jaGlsZE5vZGVzWzBdO1xuXG4gICAgICBpZiAoZG9tTm9kZSA9PSBudWxsIHx8IGRvbU5vZGUudGV4dENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9ID0gZG9tTm9kZS50ZXh0Q29udGVudDtcbiAgICAgIHZhciBhdHRyID0gdGV4dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbGVuZ3RoJyk7XG4gICAgICB2YXIgdHJ1ZUxlbmd0aCA9IGF0dHIgPT0gbnVsbCA/IGxlbmd0aCA6IHBhcnNlSW50KGF0dHIsIDEwKTtcbiAgICAgIHZhciBlbmQgPSBzdGFydCArIHRydWVMZW5ndGg7IC8vIFByZWZlciBwdXR0aW5nIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBtYXJrIHBsYWNlaG9sZGVyIHRvIGVuc3VyZVxuICAgICAgLy8gY29tcG9zZWQgdGV4dCBpcyBkaXNwbGF5ZWQgd2l0aCB0aGUgY29ycmVjdCBtYXJrcy5cblxuICAgICAgdmFyIG5leHRUZXh0ID0gdGV4dHNbaSArIDFdO1xuXG4gICAgICBpZiAocG9pbnQub2Zmc2V0ID09PSBlbmQgJiYgbmV4dFRleHQgIT09IG51bGwgJiYgbmV4dFRleHQgIT09IHZvaWQgMCAmJiBuZXh0VGV4dC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbWFyay1wbGFjZWhvbGRlcicpKSB7XG4gICAgICAgIHZhciBfbmV4dFRleHQkdGV4dENvbnRlbnQ7XG5cbiAgICAgICAgdmFyIGRvbVRleHQgPSBuZXh0VGV4dC5jaGlsZE5vZGVzWzBdO1xuICAgICAgICBkb21Qb2ludCA9IFsvLyBDT01QQVQ6IElmIHdlIGRvbid0IGV4cGxpY2l0eSBzZXQgdGhlIGRvbSBwb2ludCB0byBiZSBvbiB0aGUgYWN0dWFsXG4gICAgICAgIC8vIGRvbSB0ZXh0IGVsZW1lbnQsIGNocm9tZSB3aWxsIHB1dCB0aGUgc2VsZWN0aW9uIGJlaGluZCB0aGUgYWN0dWFsIGRvbVxuICAgICAgICAvLyB0ZXh0IGVsZW1lbnQsIGNhdXNpbmcgZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgY2FsbHMgb24gYSBjb2xsYXBzZWRcbiAgICAgICAgLy8gc2VsZWN0aW9uIHRvIHJldHVybiBpbmNvcnJlY3QgemVybyB2YWx1ZXMgKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQzNTQzOClcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSBpc3N1ZXMgd2hlbiBzY3JvbGxpbmcgdG8gaXQuXG4gICAgICAgIGRvbVRleHQgaW5zdGFuY2VvZiBET01UZXh0ID8gZG9tVGV4dCA6IG5leHRUZXh0LCAoX25leHRUZXh0JHRleHRDb250ZW50ID0gbmV4dFRleHQudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9uZXh0VGV4dCR0ZXh0Q29udGVudCAhPT0gdm9pZCAwICYmIF9uZXh0VGV4dCR0ZXh0Q29udGVudC5zdGFydHNXaXRoKCdcXHVGRUZGJykgPyAxIDogMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnQub2Zmc2V0IDw9IGVuZCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5taW4obGVuZ3RoLCBNYXRoLm1heCgwLCBwb2ludC5vZmZzZXQgLSBzdGFydCkpO1xuICAgICAgICBkb21Qb2ludCA9IFtkb21Ob2RlLCBvZmZzZXRdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgfVxuXG4gICAgaWYgKCFkb21Qb2ludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBET00gcG9pbnQgZnJvbSBTbGF0ZSBwb2ludDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwb2ludCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tUG9pbnQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCBhIG5hdGl2ZSBET00gcmFuZ2UgZnJvbSBhIFNsYXRlIGByYW5nZWAuXHJcbiAgICpcclxuICAgKiBOb3RpY2U6IHRoZSByZXR1cm5lZCByYW5nZSB3aWxsIGFsd2F5cyBiZSBvcmRpbmFsIHJlZ2FyZGxlc3Mgb2YgdGhlIGRpcmVjdGlvbiBvZiBTbGF0ZSBgcmFuZ2VgIGR1ZSB0byBET00gQVBJIGxpbWl0LlxyXG4gICAqXHJcbiAgICogdGhlcmUgaXMgbm8gd2F5IHRvIGNyZWF0ZSBhIHJldmVyc2UgRE9NIFJhbmdlIHVzaW5nIFJhbmdlLnNldFN0YXJ0L3NldEVuZFxyXG4gICAqIGFjY29yZGluZyB0byBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmFuZ2UtYnAtc2V0LlxyXG4gICAqL1xuICB0b0RPTVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgdmFyIGlzQmFja3dhcmQgPSBSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKTtcbiAgICB2YXIgZG9tQW5jaG9yID0gUmVhY3RFZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGFuY2hvcik7XG4gICAgdmFyIGRvbUZvY3VzID0gUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpID8gZG9tQW5jaG9yIDogUmVhY3RFZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGZvY3VzKTtcbiAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgdmFyIGRvbVJhbmdlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgdmFyIFtzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0XSA9IGlzQmFja3dhcmQgPyBkb21Gb2N1cyA6IGRvbUFuY2hvcjtcbiAgICB2YXIgW2VuZE5vZGUsIGVuZE9mZnNldF0gPSBpc0JhY2t3YXJkID8gZG9tQW5jaG9yIDogZG9tRm9jdXM7IC8vIEEgc2xhdGUgUG9pbnQgYXQgemVyby13aWR0aCBMZWFmIGFsd2F5cyBoYXMgYW4gb2Zmc2V0IG9mIDAgYnV0IGEgbmF0aXZlIERPTSBzZWxlY3Rpb24gYXRcbiAgICAvLyB6ZXJvLXdpZHRoIG5vZGUgaGFzIGFuIG9mZnNldCBvZiAxIHNvIHdlIGhhdmUgdG8gY2hlY2sgaWYgd2UgYXJlIGluIGEgemVyby13aWR0aCBub2RlIGFuZFxuICAgIC8vIGFkanVzdCB0aGUgb2Zmc2V0IGFjY29yZGluZ2x5LlxuXG4gICAgdmFyIHN0YXJ0RWwgPSBpc0RPTUVsZW1lbnQoc3RhcnROb2RlKSA/IHN0YXJ0Tm9kZSA6IHN0YXJ0Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHZhciBpc1N0YXJ0QXRaZXJvV2lkdGggPSAhIXN0YXJ0RWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKTtcbiAgICB2YXIgZW5kRWwgPSBpc0RPTUVsZW1lbnQoZW5kTm9kZSkgPyBlbmROb2RlIDogZW5kTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHZhciBpc0VuZEF0WmVyb1dpZHRoID0gISFlbmRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpO1xuICAgIGRvbVJhbmdlLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgaXNTdGFydEF0WmVyb1dpZHRoID8gMSA6IHN0YXJ0T2Zmc2V0KTtcbiAgICBkb21SYW5nZS5zZXRFbmQoZW5kTm9kZSwgaXNFbmRBdFplcm9XaWR0aCA/IDEgOiBlbmRPZmZzZXQpO1xuICAgIHJldHVybiBkb21SYW5nZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBGaW5kIGEgU2xhdGUgbm9kZSBmcm9tIGEgbmF0aXZlIERPTSBgZWxlbWVudGAuXHJcbiAgICovXG4gIHRvU2xhdGVOb2RlKGVkaXRvciwgZG9tTm9kZSkge1xuICAgIHZhciBkb21FbCA9IGlzRE9NRWxlbWVudChkb21Ob2RlKSA/IGRvbU5vZGUgOiBkb21Ob2RlLnBhcmVudEVsZW1lbnQ7XG5cbiAgICBpZiAoZG9tRWwgJiYgIWRvbUVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1ub2RlJykpIHtcbiAgICAgIGRvbUVsID0gZG9tRWwuY2xvc2VzdChcIltkYXRhLXNsYXRlLW5vZGVdXCIpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gZG9tRWwgPyBFTEVNRU5UX1RPX05PREUuZ2V0KGRvbUVsKSA6IG51bGw7XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgbm9kZSBmcm9tIERPTSBub2RlOiBcIi5jb25jYXQoZG9tRWwpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHRhcmdldCByYW5nZSBmcm9tIGEgRE9NIGBldmVudGAuXHJcbiAgICovXG4gIGZpbmRFdmVudFJhbmdlKGVkaXRvciwgZXZlbnQpIHtcbiAgICBpZiAoJ25hdGl2ZUV2ZW50JyBpbiBldmVudCkge1xuICAgICAgZXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgY2xpZW50WDogeCxcbiAgICAgIGNsaWVudFk6IHksXG4gICAgICB0YXJnZXRcbiAgICB9ID0gZXZlbnQ7XG5cbiAgICBpZiAoeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIGEgRE9NIGV2ZW50OiBcIi5jb25jYXQoZXZlbnQpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcbiAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7IC8vIElmIHRoZSBkcm9wIHRhcmdldCBpcyBpbnNpZGUgYSB2b2lkIG5vZGUsIG1vdmUgaXQgaW50byBlaXRoZXIgdGhlXG4gICAgLy8gbmV4dCBvciBwcmV2aW91cyBub2RlLCBkZXBlbmRpbmcgb24gd2hpY2ggc2lkZSB0aGUgYHhgIGFuZCBgeWBcbiAgICAvLyBjb29yZGluYXRlcyBhcmUgY2xvc2VzdCB0by5cblxuICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgaXNQcmV2ID0gZWRpdG9yLmlzSW5saW5lKG5vZGUpID8geCAtIHJlY3QubGVmdCA8IHJlY3QubGVmdCArIHJlY3Qud2lkdGggLSB4IDogeSAtIHJlY3QudG9wIDwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAtIHk7XG4gICAgICB2YXIgZWRnZSA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgsIHtcbiAgICAgICAgZWRnZTogaXNQcmV2ID8gJ3N0YXJ0JyA6ICdlbmQnXG4gICAgICB9KTtcbiAgICAgIHZhciBwb2ludCA9IGlzUHJldiA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBlZGdlKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGVkZ2UpO1xuXG4gICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgdmFyIF9yYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBvaW50KTtcblxuICAgICAgICByZXR1cm4gX3JhbmdlO1xuICAgICAgfVxuICAgIH0gLy8gRWxzZSByZXNvbHZlIGEgcmFuZ2UgZnJvbSB0aGUgY2FyZXQgcG9zaXRpb24gd2hlcmUgdGhlIGRyb3Agb2NjdXJlZC5cblxuXG4gICAgdmFyIGRvbVJhbmdlO1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTsgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCBgY2FyZXRSYW5nZUZyb21Qb2ludGAgZG9lc24ndCBleGlzdC4gKDIwMTYvMDcvMjUpXG5cbiAgICBpZiAoZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgZG9tUmFuZ2UgPSBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuXG4gICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgZG9tUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICBkb21SYW5nZS5zZXRTdGFydChwb3NpdGlvbi5vZmZzZXROb2RlLCBwb3NpdGlvbi5vZmZzZXQpO1xuICAgICAgICBkb21SYW5nZS5zZXRFbmQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWRvbVJhbmdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH0gLy8gUmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gdGhlIERPTSByYW5nZS5cblxuXG4gICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tUmFuZ2UsIHtcbiAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCBhIFNsYXRlIHBvaW50IGZyb20gYSBET00gc2VsZWN0aW9uJ3MgYGRvbU5vZGVgIGFuZCBgZG9tT2Zmc2V0YC5cclxuICAgKi9cbiAgdG9TbGF0ZVBvaW50KGVkaXRvciwgZG9tUG9pbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3dcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgW25lYXJlc3ROb2RlLCBuZWFyZXN0T2Zmc2V0XSA9IGV4YWN0TWF0Y2ggPyBkb21Qb2ludCA6IG5vcm1hbGl6ZURPTVBvaW50KGRvbVBvaW50KTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IG5lYXJlc3ROb2RlLnBhcmVudE5vZGU7XG4gICAgdmFyIHRleHROb2RlID0gbnVsbDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICB2YXIgX2RvbU5vZGUkdGV4dENvbnRlbnQsIF9kb21Ob2RlJHRleHRDb250ZW50MjtcblxuICAgICAgdmFyIGVkaXRvckVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgIHZhciBwb3RlbnRpYWxWb2lkTm9kZSA9IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtdm9pZD1cInRydWVcIl0nKTsgLy8gTmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgY2xvc2VzdCB2b2lkIG5vZGUgaXMgYWN0dWFsbHkgYSB2b2lkIG5vZGVcbiAgICAgIC8vIHdpdGhpbiB0aGlzIGVkaXRvciwgYW5kIG5vdCBhIHZvaWQgbm9kZSB3aXRoaW4gc29tZSBwYXJlbnQgZWRpdG9yLiBUaGlzIGNhbiBoYXBwZW5cbiAgICAgIC8vIGlmIHRoaXMgZWRpdG9yIGlzIHdpdGhpbiBhIHZvaWQgbm9kZSBvZiBhbm90aGVyIGVkaXRvciAoXCJuZXN0ZWQgZWRpdG9yc1wiLCBsaWtlIGluXG4gICAgICAvLyB0aGUgXCJFZGl0YWJsZSBWb2lkc1wiIGV4YW1wbGUgb24gdGhlIGRvY3Mgc2l0ZSkuXG5cbiAgICAgIHZhciB2b2lkTm9kZSA9IHBvdGVudGlhbFZvaWROb2RlICYmIGVkaXRvckVsLmNvbnRhaW5zKHBvdGVudGlhbFZvaWROb2RlKSA/IHBvdGVudGlhbFZvaWROb2RlIDogbnVsbDtcbiAgICAgIHZhciBsZWFmTm9kZSA9IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbGVhZl0nKTtcbiAgICAgIHZhciBkb21Ob2RlID0gbnVsbDsgLy8gQ2FsY3VsYXRlIGhvdyBmYXIgaW50byB0aGUgdGV4dCBub2RlIHRoZSBgbmVhcmVzdE5vZGVgIGlzLCBzbyB0aGF0IHdlXG4gICAgICAvLyBjYW4gZGV0ZXJtaW5lIHdoYXQgdGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgdGV4dCBub2RlIGlzLlxuXG4gICAgICBpZiAobGVhZk5vZGUpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBsZWFmTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwidGV4dFwiXScpO1xuXG4gICAgICAgIGlmICh0ZXh0Tm9kZSkge1xuICAgICAgICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5lYXJlc3ROb2RlLCBuZWFyZXN0T2Zmc2V0KTtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSByYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICAgICAgdmFyIHJlbW92YWxzID0gWy4uLkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykpLCAuLi5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbY29udGVudGVkaXRhYmxlPWZhbHNlXScpKV07XG4gICAgICAgICAgcmVtb3ZhbHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAvLyBDT01QQVQ6IFdoaWxlIGNvbXBvc2luZyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGUsIHNvbWUga2V5Ym9hcmRzIHB1dFxuICAgICAgICAgICAgLy8gdGhlIHRleHQgY29udGVudCBpbnNpZGUgdGhlIHplcm8gd2lkdGggc3BhY2UuXG4gICAgICAgICAgICBpZiAoSVNfQU5EUk9JRCAmJiAhZXhhY3RNYXRjaCAmJiBlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpICYmIGVsLnRleHRDb250ZW50Lmxlbmd0aCA+IDAgJiYgZWwudGV4dENvbnRleHQgIT09ICdcXHVGRUZGJykge1xuICAgICAgICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQuc3RhcnRzV2l0aCgnXFx1RkVGRicpKSB7XG4gICAgICAgICAgICAgICAgZWwudGV4dENvbnRlbnQgPSBlbC50ZXh0Q29udGVudC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgfSk7IC8vIENPTVBBVDogRWRnZSBoYXMgYSBidWcgd2hlcmUgUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nKCkgd2lsbFxuICAgICAgICAgIC8vIGNvbnZlcnQgXFxuIGludG8gXFxyXFxuLiBUaGUgYnVnIGNhdXNlcyBhIGxvb3Agd2hlbiBzbGF0ZS1yZWFjdFxuICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlcG9zaXRpb24gaXRzIGN1cnNvciB0byBtYXRjaCB0aGUgbmF0aXZlIHBvc2l0aW9uLiBVc2VcbiAgICAgICAgICAvLyB0ZXh0Q29udGVudC5sZW5ndGggaW5zdGVhZC5cbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDI5MTExNi9cblxuICAgICAgICAgIG9mZnNldCA9IGNvbnRlbnRzLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICBkb21Ob2RlID0gdGV4dE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodm9pZE5vZGUpIHtcbiAgICAgICAgLy8gRm9yIHZvaWQgbm9kZXMsIHRoZSBlbGVtZW50IHdpdGggdGhlIG9mZnNldCBrZXkgd2lsbCBiZSBhIGNvdXNpbiwgbm90IGFuXG4gICAgICAgIC8vIGFuY2VzdG9yLCBzbyBmaW5kIGl0IGJ5IGdvaW5nIGRvd24gZnJvbSB0aGUgbmVhcmVzdCB2b2lkIHBhcmVudCBhbmQgdGFraW5nIHRoZVxuICAgICAgICAvLyBmaXJzdCBvbmUgdGhhdCBpc24ndCBpbnNpZGUgYSBuZXN0ZWQgZWRpdG9yLlxuICAgICAgICB2YXIgbGVhZk5vZGVzID0gdm9pZE5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtbGVhZl0nKTtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVhZk5vZGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gbGVhZk5vZGVzW2luZGV4XTtcblxuICAgICAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgY3VycmVudCkpIHtcbiAgICAgICAgICAgIGxlYWZOb2RlID0gY3VycmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDT01QQVQ6IEluIHJlYWQtb25seSBlZGl0b3JzIHRoZSBsZWFmIGlzIG5vdCByZW5kZXJlZC5cblxuXG4gICAgICAgIGlmICghbGVhZk5vZGUpIHtcbiAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcbiAgICAgICAgICBkb21Ob2RlID0gbGVhZk5vZGU7XG4gICAgICAgICAgb2Zmc2V0ID0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgZG9tTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgb2Zmc2V0IC09IGVsLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZG9tTm9kZSAmJiBvZmZzZXQgPT09IGRvbU5vZGUudGV4dENvbnRlbnQubGVuZ3RoICYmIC8vIENPTVBBVDogQW5kcm9pZCBJTUVzIG1pZ2h0IHJlbW92ZSB0aGUgemVybyB3aWR0aCBzcGFjZSB3aGlsZSBjb21wb3NpbmcsXG4gICAgICAvLyBhbmQgd2UgZG9uJ3QgYWRkIGl0IGZvciBsaW5lLWJyZWFrcy5cbiAgICAgIElTX0FORFJPSUQgJiYgZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpID09PSAneicgJiYgKF9kb21Ob2RlJHRleHRDb250ZW50ID0gZG9tTm9kZS50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQgIT09IHZvaWQgMCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudC5zdGFydHNXaXRoKCdcXHVGRUZGJykgJiYgKHBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSB8fCBJU19GSVJFRk9YICYmIChfZG9tTm9kZSR0ZXh0Q29udGVudDIgPSBkb21Ob2RlLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudDIgIT09IHZvaWQgMCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudDIuZW5kc1dpdGgoJ1xcblxcbicpKSkge1xuICAgICAgICBvZmZzZXQtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoSVNfQU5EUk9JRCAmJiAhdGV4dE5vZGUgJiYgIWV4YWN0TWF0Y2gpIHtcbiAgICAgIHZhciBub2RlID0gcGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbm9kZScpID8gcGFyZW50Tm9kZSA6IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZV0nKTtcblxuICAgICAgaWYgKG5vZGUgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIG5vZGUsIHtcbiAgICAgICAgZWRpdGFibGU6IHRydWVcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBfc2xhdGVOb2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBub2RlKTtcblxuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldDogX29mZnNldFxuICAgICAgICB9ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBfc2xhdGVOb2RlKSk7XG5cbiAgICAgICAgaWYgKCFub2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNsYXRlLWxlYWZdJykpIHtcbiAgICAgICAgICBfb2Zmc2V0ID0gbmVhcmVzdE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0Tm9kZSkge1xuICAgICAgaWYgKHN1cHByZXNzVGhyb3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcG9pbnQgZnJvbSBET00gcG9pbnQ6IFwiLmNvbmNhdChkb21Qb2ludCkpO1xuICAgIH0gLy8gQ09NUEFUOiBJZiBzb21lb25lIGlzIGNsaWNraW5nIGZyb20gb25lIFNsYXRlIGVkaXRvciBpbnRvIGFub3RoZXIsXG4gICAgLy8gdGhlIHNlbGVjdCBldmVudCBmaXJlcyB0d2ljZSwgb25jZSBmb3IgdGhlIG9sZCBlZGl0b3IncyBgZWxlbWVudGBcbiAgICAvLyBmaXJzdCwgYW5kIHRoZW4gYWZ0ZXJ3YXJkcyBmb3IgdGhlIGNvcnJlY3QgYGVsZW1lbnRgLiAoMjAxNy8wMy8wMylcblxuXG4gICAgdmFyIHNsYXRlTm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgdGV4dE5vZGUpO1xuICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBzbGF0ZU5vZGUpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0XG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBGaW5kIGEgU2xhdGUgcmFuZ2UgZnJvbSBhIERPTSByYW5nZSBvciBzZWxlY3Rpb24uXHJcbiAgICovXG4gIHRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVJhbmdlLCBvcHRpb25zKSB7XG4gICAgdmFyIHtcbiAgICAgIGV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGVsID0gaXNET01TZWxlY3Rpb24oZG9tUmFuZ2UpID8gZG9tUmFuZ2UuYW5jaG9yTm9kZSA6IGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgIHZhciBhbmNob3JOb2RlO1xuICAgIHZhciBhbmNob3JPZmZzZXQ7XG4gICAgdmFyIGZvY3VzTm9kZTtcbiAgICB2YXIgZm9jdXNPZmZzZXQ7XG4gICAgdmFyIGlzQ29sbGFwc2VkO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBpZiAoaXNET01TZWxlY3Rpb24oZG9tUmFuZ2UpKSB7XG4gICAgICAgIGFuY2hvck5vZGUgPSBkb21SYW5nZS5hbmNob3JOb2RlO1xuICAgICAgICBhbmNob3JPZmZzZXQgPSBkb21SYW5nZS5hbmNob3JPZmZzZXQ7XG4gICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmZvY3VzTm9kZTtcbiAgICAgICAgZm9jdXNPZmZzZXQgPSBkb21SYW5nZS5mb2N1c09mZnNldDsgLy8gQ09NUEFUOiBUaGVyZSdzIGEgYnVnIGluIGNocm9tZSB0aGF0IGFsd2F5cyByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgICAgLy8gYGlzQ29sbGFwc2VkYCBmb3IgYSBTZWxlY3Rpb24gdGhhdCBjb21lcyBmcm9tIGEgU2hhZG93Um9vdC5cbiAgICAgICAgLy8gKDIwMjAvMDgvMDgpXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzUyM1xuXG4gICAgICAgIGlmIChJU19DSFJPTUUgJiYgaGFzU2hhZG93Um9vdChhbmNob3JOb2RlKSkge1xuICAgICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuYW5jaG9yTm9kZSA9PT0gZG9tUmFuZ2UuZm9jdXNOb2RlICYmIGRvbVJhbmdlLmFuY2hvck9mZnNldCA9PT0gZG9tUmFuZ2UuZm9jdXNPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNDb2xsYXBzZWQgPSBkb21SYW5nZS5pc0NvbGxhcHNlZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yTm9kZSA9IGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBhbmNob3JPZmZzZXQgPSBkb21SYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgZm9jdXNOb2RlID0gZG9tUmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICBmb2N1c09mZnNldCA9IGRvbVJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgaXNDb2xsYXBzZWQgPSBkb21SYW5nZS5jb2xsYXBzZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFuY2hvck5vZGUgPT0gbnVsbCB8fCBmb2N1c05vZGUgPT0gbnVsbCB8fCBhbmNob3JPZmZzZXQgPT0gbnVsbCB8fCBmb2N1c09mZnNldCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gRE9NIHJhbmdlOiBcIi5jb25jYXQoZG9tUmFuZ2UpKTtcbiAgICB9IC8vIENPTVBBVDogVHJpcGxlLWNsaWNraW5nIGEgd29yZCBpbiBjaHJvbWUgd2lsbCBzb21ldGltZXMgcGxhY2UgdGhlIGZvY3VzXG4gICAgLy8gaW5zaWRlIGEgYGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJgIERPTSBub2RlIGZvbGxvd2luZyB0aGUgd29yZCwgd2hpY2hcbiAgICAvLyB3aWxsIGNhdXNlIGB0b1NsYXRlUG9pbnRgIHRvIHRocm93IGFuIGVycm9yLiAoMjAyMy8wMy8wNylcblxuXG4gICAgaWYgKCdnZXRBdHRyaWJ1dGUnIGluIGZvY3VzTm9kZSAmJiBmb2N1c05vZGUuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSA9PT0gJ2ZhbHNlJykge1xuICAgICAgdmFyIF9hbmNob3JOb2RlJHRleHRDb250ZTtcblxuICAgICAgZm9jdXNOb2RlID0gYW5jaG9yTm9kZTtcbiAgICAgIGZvY3VzT2Zmc2V0ID0gKChfYW5jaG9yTm9kZSR0ZXh0Q29udGUgPSBhbmNob3JOb2RlLnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfYW5jaG9yTm9kZSR0ZXh0Q29udGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hbmNob3JOb2RlJHRleHRDb250ZS5sZW5ndGgpIHx8IDA7XG4gICAgfVxuXG4gICAgdmFyIGFuY2hvciA9IFJlYWN0RWRpdG9yLnRvU2xhdGVQb2ludChlZGl0b3IsIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdLCB7XG4gICAgICBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvd1xuICAgIH0pO1xuXG4gICAgaWYgKCFhbmNob3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmb2N1cyA9IGlzQ29sbGFwc2VkID8gYW5jaG9yIDogUmVhY3RFZGl0b3IudG9TbGF0ZVBvaW50KGVkaXRvciwgW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdLCB7XG4gICAgICBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvd1xuICAgIH0pO1xuXG4gICAgaWYgKCFmb2N1cykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogc3VwcG9zZSB3ZSBoYXZlIHRoaXMgZG9jdW1lbnQ6XHJcbiAgICAgKlxyXG4gICAgICogeyB0eXBlOiAncGFyYWdyYXBoJyxcclxuICAgICAqICAgY2hpbGRyZW46IFtcclxuICAgICAqICAgICB7IHRleHQ6ICdmb28gJyB9LFxyXG4gICAgICogICAgIHsgdGV4dDogJ2JhcicgfSxcclxuICAgICAqICAgICB7IHRleHQ6ICcgYmF6JyB9XHJcbiAgICAgKiAgIF1cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBhIGRvdWJsZSBjbGljayBvbiBcImJhclwiIG9uIGNocm9tZSB3aWxsIGNyZWF0ZSB0aGlzIHJhbmdlOlxyXG4gICAgICpcclxuICAgICAqIGFuY2hvciAtPiBbMCwxXSBvZmZzZXQgMFxyXG4gICAgICogZm9jdXMgIC0+IFswLDFdIG9mZnNldCAzXHJcbiAgICAgKlxyXG4gICAgICogd2hpbGUgb24gZmlyZWZveCB3aWxsIGNyZWF0ZSB0aGlzIHJhbmdlOlxyXG4gICAgICpcclxuICAgICAqIGFuY2hvciAtPiBbMCwwXSBvZmZzZXQgNFxyXG4gICAgICogZm9jdXMgIC0+IFswLDJdIG9mZnNldCAwXHJcbiAgICAgKlxyXG4gICAgICogbGV0J3MgdHJ5IHRvIGZpeCBpdC4uLlxyXG4gICAgICovXG5cblxuICAgIGlmIChJU19GSVJFRk9YICYmICFpc0NvbGxhcHNlZCAmJiBhbmNob3JOb2RlICE9PSBmb2N1c05vZGUpIHtcbiAgICAgIHZhciBpc0VuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGFuY2hvciwgYW5jaG9yLnBhdGgpO1xuICAgICAgdmFyIGlzU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGZvY3VzLCBmb2N1cy5wYXRoKTtcblxuICAgICAgaWYgKGlzRW5kKSB7XG4gICAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGFuY2hvcik7IC8vIEVkaXRvci5hZnRlcigpIG1pZ2h0IHJldHVybiB1bmRlZmluZWRcblxuICAgICAgICBhbmNob3IgPSBhZnRlciB8fCBhbmNob3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0YXJ0KSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgZm9jdXMpO1xuICAgICAgICBmb2N1cyA9IGJlZm9yZSB8fCBmb2N1cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIGZvY3VzOiBmb2N1c1xuICAgIH07IC8vIGlmIHRoZSBzZWxlY3Rpb24gaXMgYSBoYW5naW5nIHJhbmdlIHRoYXQgZW5kcyBpbiBhIHZvaWRcbiAgICAvLyBhbmQgdGhlIERPTSBmb2N1cyBpcyBhbiBFbGVtZW50XG4gICAgLy8gKG1lYW5pbmcgdGhhdCB0aGUgc2VsZWN0aW9uIGVuZHMgYmVmb3JlIHRoZSBlbGVtZW50KVxuICAgIC8vIHVuaGFuZyB0aGUgcmFuZ2UgdG8gYXZvaWQgbWlzdGFrZW5seSBpbmNsdWRpbmcgdGhlIHZvaWRcblxuICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHJhbmdlKSAmJiBSYW5nZS5pc0ZvcndhcmQocmFuZ2UpICYmIGlzRE9NRWxlbWVudChmb2N1c05vZGUpICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IHJhbmdlLmZvY3VzLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSkpIHtcbiAgICAgIHJhbmdlID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgcmFuZ2UsIHtcbiAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfSxcblxuICBoYXNSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBFZGl0b3IuaGFzUGF0aChlZGl0b3IsIGFuY2hvci5wYXRoKSAmJiBFZGl0b3IuaGFzUGF0aChlZGl0b3IsIGZvY3VzLnBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSB0YXJnZXQgaXMgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaGFzVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGlzRE9NTm9kZSh0YXJnZXQpICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSB0YXJnZXQgaXMgZWRpdGFibGUgYW5kIGluIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGlzRE9NTm9kZSh0YXJnZXQpICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQsIHtcbiAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHRhcmdldCBjYW4gYmUgc2VsZWN0YWJsZVxyXG4gICAqL1xuICBoYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSB8fCBSZWFjdEVkaXRvci5pc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZChlZGl0b3IsIHRhcmdldCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHRhcmdldCBpcyBpbnNpZGUgdm9pZCBhbmQgaW4gYW4gbm9uLXJlYWRvbmx5IGVkaXRvci5cclxuICAgKi9cbiAgaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICBpZiAoSVNfUkVBRF9PTkxZLmdldChlZGl0b3IpKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHNsYXRlTm9kZSA9IFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIHRhcmdldCkgJiYgUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCB0YXJnZXQpO1xuICAgIHJldHVybiBFbGVtZW50JDEuaXNFbGVtZW50KHNsYXRlTm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIHNsYXRlTm9kZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRXhwZXJpbWVudGFsIGFuZCBhbmRyb2lkIHNwZWNpZmljOiBGbHVzaCBhbGwgcGVuZGluZyBkaWZmcyBhbmQgY2FuY2VsIGNvbXBvc2l0aW9uIGF0IHRoZSBuZXh0IHBvc3NpYmxlIHRpbWUuXHJcbiAgICovXG4gIGFuZHJvaWRTY2hlZHVsZUZsdXNoKGVkaXRvcikge1xuICAgIHZhciBfRURJVE9SX1RPX1NDSEVEVUxFX0Y7XG5cbiAgICAoX0VESVRPUl9UT19TQ0hFRFVMRV9GID0gRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1NDSEVEVUxFX0YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fU0NIRURVTEVfRigpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEV4cGVyaW1lbnRhbCBhbmQgYW5kcm9pZCBzcGVjaWZpYzogR2V0IHBlbmRpbmcgZGlmZnNcclxuICAgKi9cbiAgYW5kcm9pZFBlbmRpbmdEaWZmcyhlZGl0b3IpIHtcbiAgICByZXR1cm4gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcik7XG4gIH1cblxufTtcblxudmFyIF9leGNsdWRlZCQzID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl0sXG4gICAgX2V4Y2x1ZGVkMiQxID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl07XG52YXIgc2hhbGxvd0NvbXBhcmUgPSAob2JqMSwgb2JqMikgPT4gT2JqZWN0LmtleXMob2JqMSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGggJiYgT2JqZWN0LmtleXMob2JqMSkuZXZlcnkoa2V5ID0+IG9iajIuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBvYmoxW2tleV0gPT09IG9iajJba2V5XSk7XG5cbnZhciBpc0RlY29yYXRpb25GbGFnc0VxdWFsID0gKHJhbmdlLCBvdGhlcikgPT4ge1xuICB2YXIgcmFuZ2VPd25Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhyYW5nZSwgX2V4Y2x1ZGVkJDMpO1xuXG4gIHZhciBvdGhlck93blByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG90aGVyLCBfZXhjbHVkZWQyJDEpO1xuXG4gIHJldHVybiByYW5nZVtQTEFDRUhPTERFUl9TWU1CT0xdID09PSBvdGhlcltQTEFDRUhPTERFUl9TWU1CT0xdICYmIHNoYWxsb3dDb21wYXJlKHJhbmdlT3duUHJvcHMsIG90aGVyT3duUHJvcHMpO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGxpc3Qgb2YgZGVjb3JhdG9yIHJhbmdlcyBhcmUgZXF1YWwgdG8gYW5vdGhlci5cclxuICpcclxuICogUEVSRjogdGhpcyByZXF1aXJlcyB0aGUgdHdvIGxpc3RzIHRvIGFsc28gaGF2ZSB0aGUgcmFuZ2VzIGluc2lkZSB0aGVtIGluIHRoZVxyXG4gKiBzYW1lIG9yZGVyLCBidXQgdGhpcyBpcyBhbiBva2F5IGNvbnN0cmFpbnQgZm9yIHVzIHNpbmNlIGRlY29yYXRpb25zIGFyZVxyXG4gKiBrZXB0IGluIG9yZGVyLCBhbmQgdGhlIG9kZCBjYXNlIHdoZXJlIHRoZXkgYXJlbid0IGlzIG9rYXkgdG8gcmUtcmVuZGVyIGZvci5cclxuICovXG5cblxudmFyIGlzRWxlbWVudERlY29yYXRpb25zRXF1YWwgPSAobGlzdCwgYW5vdGhlcikgPT4ge1xuICBpZiAobGlzdC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJhbmdlID0gbGlzdFtpXTtcbiAgICB2YXIgb3RoZXIgPSBhbm90aGVyW2ldO1xuXG4gICAgaWYgKCFSYW5nZS5lcXVhbHMocmFuZ2UsIG90aGVyKSB8fCAhaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbChyYW5nZSwgb3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgbGlzdCBvZiBkZWNvcmF0b3IgcmFuZ2VzIGFyZSBlcXVhbCB0byBhbm90aGVyLlxyXG4gKlxyXG4gKiBQRVJGOiB0aGlzIHJlcXVpcmVzIHRoZSB0d28gbGlzdHMgdG8gYWxzbyBoYXZlIHRoZSByYW5nZXMgaW5zaWRlIHRoZW0gaW4gdGhlXHJcbiAqIHNhbWUgb3JkZXIsIGJ1dCB0aGlzIGlzIGFuIG9rYXkgY29uc3RyYWludCBmb3IgdXMgc2luY2UgZGVjb3JhdGlvbnMgYXJlXHJcbiAqIGtlcHQgaW4gb3JkZXIsIGFuZCB0aGUgb2RkIGNhc2Ugd2hlcmUgdGhleSBhcmVuJ3QgaXMgb2theSB0byByZS1yZW5kZXIgZm9yLlxyXG4gKi9cblxudmFyIGlzVGV4dERlY29yYXRpb25zRXF1YWwgPSAobGlzdCwgYW5vdGhlcikgPT4ge1xuICBpZiAobGlzdC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJhbmdlID0gbGlzdFtpXTtcbiAgICB2YXIgb3RoZXIgPSBhbm90aGVyW2ldOyAvLyBjb21wYXJlIG9ubHkgb2Zmc2V0cyBiZWNhdXNlIHBhdGhzIGRvZXNuJ3QgbWF0dGVyIGZvciB0ZXh0XG5cbiAgICBpZiAocmFuZ2UuYW5jaG9yLm9mZnNldCAhPT0gb3RoZXIuYW5jaG9yLm9mZnNldCB8fCByYW5nZS5mb2N1cy5vZmZzZXQgIT09IG90aGVyLmZvY3VzLm9mZnNldCB8fCAhaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbChyYW5nZSwgb3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcclxuICogUHJldmVudCB3YXJuaW5nIG9uIFNTUiBieSBmYWxsaW5nIGJhY2sgdG8gdXNlRWZmZWN0IHdoZW4gRE9NIGlzbid0IGF2YWlsYWJsZVxyXG4gKi9cblxudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBDQU5fVVNFX0RPTSA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLyoqXHJcbiAqIExlYWYgY29udGVudCBzdHJpbmdzLlxyXG4gKi9cblxudmFyIFN0cmluZyA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBpc0xhc3QsXG4gICAgbGVhZixcbiAgICBwYXJlbnQsXG4gICAgdGV4dFxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgdGV4dCk7XG4gIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gIHZhciBpc01hcmtQbGFjZWhvbGRlciA9IGxlYWZbTUFSS19QTEFDRUhPTERFUl9TWU1CT0xdID09PSB0cnVlOyAvLyBDT01QQVQ6IFJlbmRlciB0ZXh0IGluc2lkZSB2b2lkIG5vZGVzIHdpdGggYSB6ZXJvLXdpZHRoIHNwYWNlLlxuICAvLyBTbyB0aGUgbm9kZSBjYW4gY29udGFpbiBzZWxlY3Rpb24gYnV0IHRoZSB0ZXh0IGlzIG5vdCB2aXNpYmxlLlxuXG4gIGlmIChlZGl0b3IuaXNWb2lkKHBhcmVudCkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoWmVyb1dpZHRoU3RyaW5nLCB7XG4gICAgICBsZW5ndGg6IE5vZGUuc3RyaW5nKHBhcmVudCkubGVuZ3RoXG4gICAgfSk7XG4gIH0gLy8gQ09NUEFUOiBJZiB0aGlzIGlzIHRoZSBsYXN0IHRleHQgbm9kZSBpbiBhbiBlbXB0eSBibG9jaywgcmVuZGVyIGEgemVyby1cbiAgLy8gd2lkdGggc3BhY2UgdGhhdCB3aWxsIGNvbnZlcnQgaW50byBhIGxpbmUgYnJlYWsgd2hlbiBjb3B5aW5nIGFuZCBwYXN0aW5nXG4gIC8vIHRvIHN1cHBvcnQgZXhwZWN0ZWQgcGxhaW4gdGV4dC5cblxuXG4gIGlmIChsZWFmLnRleHQgPT09ICcnICYmIHBhcmVudC5jaGlsZHJlbltwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPT09IHRleHQgJiYgIWVkaXRvci5pc0lubGluZShwYXJlbnQpICYmIEVkaXRvci5zdHJpbmcoZWRpdG9yLCBwYXJlbnRQYXRoKSA9PT0gJycpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoWmVyb1dpZHRoU3RyaW5nLCB7XG4gICAgICBpc0xpbmVCcmVhazogdHJ1ZSxcbiAgICAgIGlzTWFya1BsYWNlaG9sZGVyOiBpc01hcmtQbGFjZWhvbGRlclxuICAgIH0pO1xuICB9IC8vIENPTVBBVDogSWYgdGhlIHRleHQgaXMgZW1wdHksIGl0J3MgYmVjYXVzZSBpdCdzIG9uIHRoZSBlZGdlIG9mIGFuIGlubGluZVxuICAvLyBub2RlLCBzbyB3ZSByZW5kZXIgYSB6ZXJvLXdpZHRoIHNwYWNlIHNvIHRoYXQgdGhlIHNlbGVjdGlvbiBjYW4gYmVcbiAgLy8gaW5zZXJ0ZWQgbmV4dCB0byBpdCBzdGlsbC5cblxuXG4gIGlmIChsZWFmLnRleHQgPT09ICcnKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFplcm9XaWR0aFN0cmluZywge1xuICAgICAgaXNNYXJrUGxhY2Vob2xkZXI6IGlzTWFya1BsYWNlaG9sZGVyXG4gICAgfSk7XG4gIH0gLy8gQ09NUEFUOiBCcm93c2VycyB3aWxsIGNvbGxhcHNlIHRyYWlsaW5nIG5ldyBsaW5lcyBhdCB0aGUgZW5kIG9mIGJsb2NrcyxcbiAgLy8gc28gd2UgbmVlZCB0byBhZGQgYW4gZXh0cmEgdHJhaWxpbmcgbmV3IGxpbmVzIHRvIHByZXZlbnQgdGhhdC5cblxuXG4gIGlmIChpc0xhc3QgJiYgbGVhZi50ZXh0LnNsaWNlKC0xKSA9PT0gJ1xcbicpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dFN0cmluZywge1xuICAgICAgaXNUcmFpbGluZzogdHJ1ZSxcbiAgICAgIHRleHQ6IGxlYWYudGV4dFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRleHRTdHJpbmcsIHtcbiAgICB0ZXh0OiBsZWFmLnRleHRcbiAgfSk7XG59O1xuLyoqXHJcbiAqIExlYWYgc3RyaW5ncyB3aXRoIHRleHQgaW4gdGhlbS5cclxuICovXG5cblxudmFyIFRleHRTdHJpbmcgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgdGV4dCxcbiAgICBpc1RyYWlsaW5nID0gZmFsc2VcbiAgfSA9IHByb3BzO1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIHZhciBnZXRUZXh0Q29udGVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQodGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogJycpLmNvbmNhdChpc1RyYWlsaW5nID8gJ1xcbicgOiAnJyk7XG4gIH07XG5cbiAgdmFyIFtpbml0aWFsVGV4dF0gPSB1c2VTdGF0ZShnZXRUZXh0Q29udGVudCk7IC8vIFRoaXMgaXMgdGhlIGFjdHVhbCB0ZXh0IHJlbmRlcmluZyBib3VuZGFyeSB3aGVyZSB3ZSBpbnRlcmZhY2Ugd2l0aCB0aGUgRE9NXG4gIC8vIFRoZSB0ZXh0IGlzIG5vdCByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSB2aXJ0dWFsIERPTSwgYXMgc2luY2Ugd2UgaGFuZGxlIGJhc2ljIGNoYXJhY3RlciBpbnNlcnRpb25zIG5hdGl2ZWx5LFxuICAvLyB1cGRhdGluZyB0aGUgRE9NIGlzIG5vdCBhIG9uZSB3YXkgZGF0YWZsb3cgYW55bW9yZS4gV2hhdCB3ZSBuZWVkIGhlcmUgaXMgbm90IHJlY29uY2lsaWF0aW9uIGFuZCBkaWZmaW5nXG4gIC8vIHdpdGggcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgdmlydHVhbCBET00sIGJ1dCByYXRoZXIgZGlmZmluZyB3aXRoIHRoZSBhY3R1YWwgRE9NIGVsZW1lbnQsIGFuZCByZXBsYWNlIHRoZSBET00gPHNwYW4+IGNvbnRlbnRcbiAgLy8gZXhhY3RseSBpZiBhbmQgb25seSBpZiBpdHMgY3VycmVudCBjb250ZW50IGRvZXMgbm90IG1hdGNoIG91ciBjdXJyZW50IHZpcnR1YWwgRE9NLlxuICAvLyBPdGhlcndpc2UgdGhlIERPTSBUZXh0Tm9kZSB3b3VsZCBhbHdheXMgYmUgcmVwbGFjZWQgYnkgUmVhY3QgYXMgdGhlIHVzZXIgdHlwZXMsIHdoaWNoIGludGVyZmVyZXMgd2l0aCBuYXRpdmUgdGV4dCBmZWF0dXJlcyxcbiAgLy8gZWcgbWFrZXMgbmF0aXZlIHNwZWxsY2hlY2sgb3B0IG91dCBmcm9tIGNoZWNraW5nIHRoZSB0ZXh0IG5vZGUuXG4gIC8vIHVzZUxheW91dEVmZmVjdDogdXBkYXRpbmcgb3VyIHNwYW4gYmVmb3JlIGJyb3dzZXIgcGFpbnRcblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAvLyBudWxsIGNvYWxlc2NpbmcgdGV4dCB0byBtYWtlIHN1cmUgd2UncmUgbm90IG91dHB1dGluZyBcIm51bGxcIiBhcyBhIHN0cmluZyBpbiB0aGUgZXh0cmVtZSBjYXNlIGl0IGlzIG51bGxpc2ggYXQgcnVudGltZVxuICAgIHZhciB0ZXh0V2l0aFRyYWlsaW5nID0gZ2V0VGV4dENvbnRlbnQoKTtcblxuICAgIGlmIChyZWYuY3VycmVudCAmJiByZWYuY3VycmVudC50ZXh0Q29udGVudCAhPT0gdGV4dFdpdGhUcmFpbGluZykge1xuICAgICAgcmVmLmN1cnJlbnQudGV4dENvbnRlbnQgPSB0ZXh0V2l0aFRyYWlsaW5nO1xuICAgIH0gLy8gaW50ZW50aW9uYWxseSBub3Qgc3BlY2lmeWluZyBkZXBlbmRlbmNpZXMsIHNvIHRoYXQgdGhpcyBlZmZlY3QgcnVucyBvbiBldmVyeSByZW5kZXJcbiAgICAvLyBhcyB0aGlzIGVmZmVjdGl2ZWx5IHJlcGxhY2VzIFwic3BlY2lmeWluZyB0aGUgdGV4dCBpbiB0aGUgdmlydHVhbCBET00gdW5kZXIgdGhlIDxzcGFuPiBiZWxvd1wiIG9uIGVhY2ggcmVuZGVyXG5cbiAgfSk7IC8vIFdlIGludGVudGlvbmFsbHkgcmVuZGVyIGEgbWVtb2l6ZWQgPHNwYW4+IHRoYXQgb25seSByZWNlaXZlcyB0aGUgaW5pdGlhbCB0ZXh0IGNvbnRlbnQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gIC8vIFdlIGRlZmVyIHRvIHRoZSBsYXlvdXQgZWZmZWN0IGFib3ZlIHRvIHVwZGF0ZSB0aGUgYHRleHRDb250ZW50YCBvZiB0aGUgc3BhbiBlbGVtZW50IHdoZW4gbmVlZGVkLlxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZFRleHQkMSwge1xuICAgIHJlZjogcmVmXG4gIH0sIGluaXRpYWxUZXh0KTtcbn07XG5cbnZhciBNZW1vaXplZFRleHQkMSA9IC8qI19fUFVSRV9fKi9tZW1vKCAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImRhdGEtc2xhdGUtc3RyaW5nXCI6IHRydWUsXG4gICAgcmVmOiByZWZcbiAgfSwgcHJvcHMuY2hpbGRyZW4pO1xufSkpO1xuLyoqXHJcbiAqIExlYWYgc3RyaW5ncyB3aXRob3V0IHRleHQsIHJlbmRlciBhcyB6ZXJvLXdpZHRoIHN0cmluZ3MuXHJcbiAqL1xuXG52YXIgWmVyb1dpZHRoU3RyaW5nID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGxlbmd0aCA9IDAsXG4gICAgaXNMaW5lQnJlYWsgPSBmYWxzZSxcbiAgICBpc01hcmtQbGFjZWhvbGRlciA9IGZhbHNlXG4gIH0gPSBwcm9wcztcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ2RhdGEtc2xhdGUtemVyby13aWR0aCc6IGlzTGluZUJyZWFrID8gJ24nIDogJ3onLFxuICAgICdkYXRhLXNsYXRlLWxlbmd0aCc6IGxlbmd0aFxuICB9O1xuXG4gIGlmIChpc01hcmtQbGFjZWhvbGRlcikge1xuICAgIGF0dHJpYnV0ZXNbJ2RhdGEtc2xhdGUtbWFyay1wbGFjZWhvbGRlciddID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyksICFJU19BTkRST0lEIHx8ICFpc0xpbmVCcmVhayA/ICdcXHVGRUZGJyA6IG51bGwsIGlzTGluZUJyZWFrID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKSA6IG51bGwpO1xufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgZWRpdG9yIG9iamVjdC5cclxuICovXG5cbnZhciBFZGl0b3JDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBvYmplY3QgZnJvbSB0aGUgUmVhY3QgY29udGV4dC5cclxuICovXG5cbnZhciB1c2VTbGF0ZVN0YXRpYyA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG5cbiAgaWYgKCFlZGl0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlU3RhdGljYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZT4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cblxuICByZXR1cm4gZWRpdG9yO1xufTtcblxuLyoqXHJcbiAqIEluZGl2aWR1YWwgbGVhdmVzIGluIGEgdGV4dCBub2RlIHdpdGggdW5pcXVlIGZvcm1hdHRpbmcuXHJcbiAqL1xuXG52YXIgTGVhZiA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBsZWFmLFxuICAgIGlzTGFzdCxcbiAgICB0ZXh0LFxuICAgIHBhcmVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJMZWFmID0gcHJvcHMgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdExlYWYsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSlcbiAgfSA9IHByb3BzO1xuICB2YXIgbGFzdFBsYWNlaG9sZGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgcGxhY2Vob2xkZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlciA9IHVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudCkge1xuICAgICAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgcGxhY2Vob2xkZXJFbCA9IHBsYWNlaG9sZGVyUmVmID09PSBudWxsIHx8IHBsYWNlaG9sZGVyUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwbGFjZWhvbGRlclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHBsYWNlaG9sZGVyRWwpIHtcbiAgICAgIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULnNldChlZGl0b3IsIHBsYWNlaG9sZGVyRWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVC5kZWxldGUoZWRpdG9yKTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50KSB7XG4gICAgICAvLyBVcGRhdGUgZXhpc3Rpbmcgb2JzZXJ2ZXIuXG4gICAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgaWYgKHBsYWNlaG9sZGVyRWwpIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudC5vYnNlcnZlKHBsYWNlaG9sZGVyRWwpO1xuICAgIH0gZWxzZSBpZiAocGxhY2Vob2xkZXJFbCkge1xuICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9ic2VydmVyIGFuZCBvYnNlcnZlIHRoZSBwbGFjZWhvbGRlciBlbGVtZW50LlxuICAgICAgdmFyIFJlc2l6ZU9ic2VydmVyJDEgPSB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgfHwgUmVzaXplT2JzZXJ2ZXI7XG4gICAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQgPSBuZXcgUmVzaXplT2JzZXJ2ZXIkMSgoKSA9PiB7XG4gICAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyIG9mIHRoZSBlZGl0b3Igc28gaXRzIG1pbi1oZWlnaHQgY2FuIGJlIHVwZGF0ZWRcbiAgICAgICAgLy8gdG8gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAgICB2YXIgZm9yY2VSZW5kZXIgPSBFRElUT1JfVE9fRk9SQ0VfUkVOREVSLmdldChlZGl0b3IpO1xuICAgICAgICBmb3JjZVJlbmRlciA9PT0gbnVsbCB8fCBmb3JjZVJlbmRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9yY2VSZW5kZXIoKTtcbiAgICAgIH0pO1xuICAgICAgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50Lm9ic2VydmUocGxhY2Vob2xkZXJFbCk7XG4gICAgfVxuXG4gICAgaWYgKCFwbGFjZWhvbGRlckVsICYmIGxhc3RQbGFjZWhvbGRlclJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBObyBwbGFjZWhvbGRlciBlbGVtZW50LCBzbyBubyBuZWVkIGZvciBhIHJlc2l6ZSBvYnNlcnZlci5cbiAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyIG9mIHRoZSBlZGl0b3Igc28gaXRzIG1pbi1oZWlnaHQgY2FuIGJlIHJlc2V0LlxuICAgICAgdmFyIGZvcmNlUmVuZGVyID0gRURJVE9SX1RPX0ZPUkNFX1JFTkRFUi5nZXQoZWRpdG9yKTtcbiAgICAgIGZvcmNlUmVuZGVyID09PSBudWxsIHx8IGZvcmNlUmVuZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JjZVJlbmRlcigpO1xuICAgIH1cblxuICAgIGxhc3RQbGFjZWhvbGRlclJlZi5jdXJyZW50ID0gcGxhY2Vob2xkZXJSZWYuY3VycmVudDtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgfTtcbiAgfSwgW3BsYWNlaG9sZGVyUmVmLCBsZWFmXSk7XG4gIHZhciBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFN0cmluZywge1xuICAgIGlzTGFzdDogaXNMYXN0LFxuICAgIGxlYWY6IGxlYWYsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgdGV4dDogdGV4dFxuICB9KTtcblxuICBpZiAobGVhZltQTEFDRUhPTERFUl9TWU1CT0xdKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyUHJvcHMgPSB7XG4gICAgICBjaGlsZHJlbjogbGVhZi5wbGFjZWhvbGRlcixcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgJ2RhdGEtc2xhdGUtcGxhY2Vob2xkZXInOiB0cnVlLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICBvcGFjaXR5OiAnMC4zMzMnLFxuICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRFZGl0YWJsZTogZmFsc2UsXG4gICAgICAgIHJlZjogcGxhY2Vob2xkZXJSZWZcbiAgICAgIH1cbiAgICB9O1xuICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHJlbmRlclBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyUHJvcHMpLCBjaGlsZHJlbik7XG4gIH0gLy8gQ09NUEFUOiBIYXZpbmcgdGhlIGBkYXRhLWAgYXR0cmlidXRlcyBvbiB0aGVzZSBsZWFmIGVsZW1lbnRzIGVuc3VyZXMgdGhhdFxuICAvLyBpbiBjZXJ0YWluIG1pc2JlaGF2aW5nIGJyb3dzZXJzIHRoZXkgYXJlbid0IHdlaXJkbHkgY2xvbmVkL2Rlc3Ryb3llZCBieVxuICAvLyBjb250ZW50ZWRpdGFibGUgYmVoYXZpb3JzLiAoMjAxOS8wNS8wOClcblxuXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICdkYXRhLXNsYXRlLWxlYWYnOiB0cnVlXG4gIH07XG4gIHJldHVybiByZW5kZXJMZWFmKHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGxlYWYsXG4gICAgdGV4dFxuICB9KTtcbn07XG5cbnZhciBNZW1vaXplZExlYWYgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhMZWFmLCAocHJldiwgbmV4dCkgPT4ge1xuICByZXR1cm4gbmV4dC5wYXJlbnQgPT09IHByZXYucGFyZW50ICYmIG5leHQuaXNMYXN0ID09PSBwcmV2LmlzTGFzdCAmJiBuZXh0LnJlbmRlckxlYWYgPT09IHByZXYucmVuZGVyTGVhZiAmJiBuZXh0LnJlbmRlclBsYWNlaG9sZGVyID09PSBwcmV2LnJlbmRlclBsYWNlaG9sZGVyICYmIG5leHQudGV4dCA9PT0gcHJldi50ZXh0ICYmIFRleHQkMS5lcXVhbHMobmV4dC5sZWFmLCBwcmV2LmxlYWYpICYmIG5leHQubGVhZltQTEFDRUhPTERFUl9TWU1CT0xdID09PSBwcmV2LmxlYWZbUExBQ0VIT0xERVJfU1lNQk9MXTtcbn0pO1xudmFyIERlZmF1bHRMZWFmID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW5cbiAgfSA9IHByb3BzO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpLCBjaGlsZHJlbik7XG59O1xuXG4vKipcclxuICogVGV4dC5cclxuICovXG5cbnZhciBUZXh0ID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGRlY29yYXRpb25zLFxuICAgIGlzTGFzdCxcbiAgICBwYXJlbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZixcbiAgICB0ZXh0XG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBsZWF2ZXMgPSBUZXh0JDEuZGVjb3JhdGlvbnModGV4dCwgZGVjb3JhdGlvbnMpO1xuICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIHRleHQpO1xuICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlYXZlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsZWFmID0gbGVhdmVzW2ldO1xuICAgIGNoaWxkcmVuLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkTGVhZiwge1xuICAgICAgaXNMYXN0OiBpc0xhc3QgJiYgaSA9PT0gbGVhdmVzLmxlbmd0aCAtIDEsXG4gICAgICBrZXk6IFwiXCIuY29uY2F0KGtleS5pZCwgXCItXCIpLmNvbmNhdChpKSxcbiAgICAgIHJlbmRlclBsYWNlaG9sZGVyOiByZW5kZXJQbGFjZWhvbGRlcixcbiAgICAgIGxlYWY6IGxlYWYsXG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICByZW5kZXJMZWFmOiByZW5kZXJMZWFmXG4gICAgfSkpO1xuICB9IC8vIFVwZGF0ZSBlbGVtZW50LXJlbGF0ZWQgd2VhayBtYXBzIHdpdGggdGhlIERPTSBlbGVtZW50IHJlZi5cblxuXG4gIHZhciBjYWxsYmFja1JlZiA9IHVzZUNhbGxiYWNrKHNwYW4gPT4ge1xuICAgIHZhciBLRVlfVE9fRUxFTUVOVCA9IEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcblxuICAgIGlmIChzcGFuKSB7XG4gICAgICBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogS0VZX1RPX0VMRU1FTlQuc2V0KGtleSwgc3Bhbik7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuc2V0KHRleHQsIHNwYW4pO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChzcGFuLCB0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULmRlbGV0ZShrZXkpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZSh0ZXh0KTtcblxuICAgICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICAgIEVMRU1FTlRfVE9fTk9ERS5kZWxldGUocmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlZi5jdXJyZW50ID0gc3BhbjtcbiAgfSwgW3JlZiwgZWRpdG9yLCBrZXksIHRleHRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJkYXRhLXNsYXRlLW5vZGVcIjogXCJ0ZXh0XCIsXG4gICAgcmVmOiBjYWxsYmFja1JlZlxuICB9LCBjaGlsZHJlbik7XG59O1xuXG52YXIgTWVtb2l6ZWRUZXh0ID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oVGV4dCwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIG5leHQucGFyZW50ID09PSBwcmV2LnBhcmVudCAmJiBuZXh0LmlzTGFzdCA9PT0gcHJldi5pc0xhc3QgJiYgbmV4dC5yZW5kZXJMZWFmID09PSBwcmV2LnJlbmRlckxlYWYgJiYgbmV4dC5yZW5kZXJQbGFjZWhvbGRlciA9PT0gcHJldi5yZW5kZXJQbGFjZWhvbGRlciAmJiBuZXh0LnRleHQgPT09IHByZXYudGV4dCAmJiBpc1RleHREZWNvcmF0aW9uc0VxdWFsKG5leHQuZGVjb3JhdGlvbnMsIHByZXYuZGVjb3JhdGlvbnMpO1xufSk7XG5cbi8qKlxyXG4gKiBFbGVtZW50LlxyXG4gKi9cblxudmFyIEVsZW1lbnQgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgZGVjb3JhdGlvbnMsXG4gICAgZWxlbWVudCxcbiAgICByZW5kZXJFbGVtZW50ID0gcCA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0RWxlbWVudCwgT2JqZWN0LmFzc2lnbih7fSwgcCkpLFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uXG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciByZWFkT25seSA9IHVzZVJlYWRPbmx5KCk7XG4gIHZhciBpc0lubGluZSA9IGVkaXRvci5pc0lubGluZShlbGVtZW50KTtcbiAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBlbGVtZW50KTtcbiAgdmFyIHJlZiA9IHVzZUNhbGxiYWNrKHJlZiA9PiB7XG4gICAgLy8gVXBkYXRlIGVsZW1lbnQtcmVsYXRlZCB3ZWFrIG1hcHMgd2l0aCB0aGUgRE9NIGVsZW1lbnQgcmVmLlxuICAgIHZhciBLRVlfVE9fRUxFTUVOVCA9IEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcblxuICAgIGlmIChyZWYpIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgPyB2b2lkIDAgOiBLRVlfVE9fRUxFTUVOVC5zZXQoa2V5LCByZWYpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldChlbGVtZW50LCByZWYpO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChyZWYsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogS0VZX1RPX0VMRU1FTlQuZGVsZXRlKGtleSk7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuZGVsZXRlKGVsZW1lbnQpO1xuICAgIH1cbiAgfSwgW2VkaXRvciwga2V5LCBlbGVtZW50XSk7XG4gIHZhciBjaGlsZHJlbiA9IHVzZUNoaWxkcmVuKHtcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBub2RlOiBlbGVtZW50LFxuICAgIHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb25cbiAgfSk7IC8vIEF0dHJpYnV0ZXMgdGhhdCB0aGUgZGV2ZWxvcGVyIG11c3QgbWl4IGludG8gdGhlIGVsZW1lbnQgaW4gdGhlaXJcbiAgLy8gY3VzdG9tIG5vZGUgcmVuZGVyZXIgY29tcG9uZW50LlxuXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICdkYXRhLXNsYXRlLW5vZGUnOiAnZWxlbWVudCcsXG4gICAgcmVmXG4gIH07XG5cbiAgaWYgKGlzSW5saW5lKSB7XG4gICAgYXR0cmlidXRlc1snZGF0YS1zbGF0ZS1pbmxpbmUnXSA9IHRydWU7XG4gIH0gLy8gSWYgaXQncyBhIGJsb2NrIG5vZGUgd2l0aCBpbmxpbmUgY2hpbGRyZW4sIGFkZCB0aGUgcHJvcGVyIGBkaXJgIGF0dHJpYnV0ZVxuICAvLyBmb3IgdGV4dCBkaXJlY3Rpb24uXG5cblxuICBpZiAoIWlzSW5saW5lICYmIEVkaXRvci5oYXNJbmxpbmVzKGVkaXRvciwgZWxlbWVudCkpIHtcbiAgICB2YXIgdGV4dCA9IE5vZGUuc3RyaW5nKGVsZW1lbnQpO1xuICAgIHZhciBkaXIgPSBnZXREaXJlY3Rpb24odGV4dCk7XG5cbiAgICBpZiAoZGlyID09PSAncnRsJykge1xuICAgICAgYXR0cmlidXRlcy5kaXIgPSBkaXI7XG4gICAgfVxuICB9IC8vIElmIGl0J3MgYSB2b2lkIG5vZGUsIHdyYXAgdGhlIGNoaWxkcmVuIGluIGV4dHJhIHZvaWQtc3BlY2lmaWMgZWxlbWVudHMuXG5cblxuICBpZiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIGVsZW1lbnQpKSB7XG4gICAgYXR0cmlidXRlc1snZGF0YS1zbGF0ZS12b2lkJ10gPSB0cnVlO1xuXG4gICAgaWYgKCFyZWFkT25seSAmJiBpc0lubGluZSkge1xuICAgICAgYXR0cmlidXRlcy5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgVGFnID0gaXNJbmxpbmUgPyAnc3BhbicgOiAnZGl2JztcbiAgICB2YXIgW1tfdGV4dF1dID0gTm9kZS50ZXh0cyhlbGVtZW50KTtcbiAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRhZywge1xuICAgICAgXCJkYXRhLXNsYXRlLXNwYWNlclwiOiB0cnVlLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgaGVpZ2h0OiAnMCcsXG4gICAgICAgIGNvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICB9XG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRUZXh0LCB7XG4gICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICBkZWNvcmF0aW9uczogW10sXG4gICAgICBpc0xhc3Q6IGZhbHNlLFxuICAgICAgcGFyZW50OiBlbGVtZW50LFxuICAgICAgdGV4dDogX3RleHRcbiAgICB9KSk7XG4gICAgTk9ERV9UT19JTkRFWC5zZXQoX3RleHQsIDApO1xuICAgIE5PREVfVE9fUEFSRU5ULnNldChfdGV4dCwgZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gcmVuZGVyRWxlbWVudCh7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50XG4gIH0pO1xufTtcblxudmFyIE1lbW9pemVkRWxlbWVudCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKEVsZW1lbnQsIChwcmV2LCBuZXh0KSA9PiB7XG4gIHJldHVybiBwcmV2LmVsZW1lbnQgPT09IG5leHQuZWxlbWVudCAmJiBwcmV2LnJlbmRlckVsZW1lbnQgPT09IG5leHQucmVuZGVyRWxlbWVudCAmJiBwcmV2LnJlbmRlckxlYWYgPT09IG5leHQucmVuZGVyTGVhZiAmJiBwcmV2LnJlbmRlclBsYWNlaG9sZGVyID09PSBuZXh0LnJlbmRlclBsYWNlaG9sZGVyICYmIGlzRWxlbWVudERlY29yYXRpb25zRXF1YWwocHJldi5kZWNvcmF0aW9ucywgbmV4dC5kZWNvcmF0aW9ucykgJiYgKHByZXYuc2VsZWN0aW9uID09PSBuZXh0LnNlbGVjdGlvbiB8fCAhIXByZXYuc2VsZWN0aW9uICYmICEhbmV4dC5zZWxlY3Rpb24gJiYgUmFuZ2UuZXF1YWxzKHByZXYuc2VsZWN0aW9uLCBuZXh0LnNlbGVjdGlvbikpO1xufSk7XG4vKipcclxuICogVGhlIGRlZmF1bHQgZWxlbWVudCByZW5kZXJlci5cclxuICovXG5cbnZhciBEZWZhdWx0RWxlbWVudCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnRcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIFRhZyA9IGVkaXRvci5pc0lubGluZShlbGVtZW50KSA/ICdzcGFuJyA6ICdkaXYnO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgfVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYGRlY29yYXRlYCBwcm9wIG9mIHRoZSBlZGl0YWJsZS5cclxuICovXG5cbnZhciBEZWNvcmF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCgoKSA9PiBbXSk7XG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGBkZWNvcmF0ZWAgcHJvcCBvZiB0aGUgZWRpdGFibGUuXHJcbiAqL1xuXG52YXIgdXNlRGVjb3JhdGUgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KERlY29yYXRlQ29udGV4dCk7XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgc2VsZWN0ZWRgIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAqL1xuXG52YXIgU2VsZWN0ZWRDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgc2VsZWN0ZWRgIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAqL1xuXG52YXIgdXNlU2VsZWN0ZWQgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KFNlbGVjdGVkQ29udGV4dCk7XG59O1xuXG4vKipcclxuICogQ2hpbGRyZW4uXHJcbiAqL1xuXG52YXIgdXNlQ2hpbGRyZW4gPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgZGVjb3JhdGlvbnMsXG4gICAgbm9kZSxcbiAgICByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uXG4gIH0gPSBwcm9wcztcbiAgdmFyIGRlY29yYXRlID0gdXNlRGVjb3JhdGUoKTtcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgdmFyIGNoaWxkcmVuID0gW107XG4gIHZhciBpc0xlYWZCbG9jayA9IEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSAmJiBFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gcGF0aC5jb25jYXQoaSk7XG4gICAgdmFyIG4gPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgbik7XG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcCk7XG4gICAgdmFyIHNlbCA9IHNlbGVjdGlvbiAmJiBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UsIHNlbGVjdGlvbik7XG4gICAgdmFyIGRzID0gZGVjb3JhdGUoW24sIHBdKTtcblxuICAgIGZvciAodmFyIGRlYyBvZiBkZWNvcmF0aW9ucykge1xuICAgICAgdmFyIGQgPSBSYW5nZS5pbnRlcnNlY3Rpb24oZGVjLCByYW5nZSk7XG5cbiAgICAgIGlmIChkKSB7XG4gICAgICAgIGRzLnB1c2goZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobikpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNlbGVjdGVkQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICBrZXk6IFwicHJvdmlkZXItXCIuY29uY2F0KGtleS5pZCksXG4gICAgICAgIHZhbHVlOiAhIXNlbFxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRFbGVtZW50LCB7XG4gICAgICAgIGRlY29yYXRpb25zOiBkcyxcbiAgICAgICAgZWxlbWVudDogbixcbiAgICAgICAga2V5OiBrZXkuaWQsXG4gICAgICAgIHJlbmRlckVsZW1lbnQ6IHJlbmRlckVsZW1lbnQsXG4gICAgICAgIHJlbmRlclBsYWNlaG9sZGVyOiByZW5kZXJQbGFjZWhvbGRlcixcbiAgICAgICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZixcbiAgICAgICAgc2VsZWN0aW9uOiBzZWxcbiAgICAgIH0pKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkVGV4dCwge1xuICAgICAgICBkZWNvcmF0aW9uczogZHMsXG4gICAgICAgIGtleToga2V5LmlkLFxuICAgICAgICBpc0xhc3Q6IGlzTGVhZkJsb2NrICYmIGkgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSxcbiAgICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgICAgIHRleHQ6IG5cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBOT0RFX1RPX0lOREVYLnNldChuLCBpKTtcbiAgICBOT0RFX1RPX1BBUkVOVC5zZXQobiwgbm9kZSk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgcmVhZE9ubHlgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgUmVhZE9ubHlDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgcmVhZE9ubHlgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgdXNlUmVhZE9ubHkgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KFJlYWRPbmx5Q29udGV4dCk7XG59O1xuXG52YXIgU2xhdGVDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBvYmplY3QgZnJvbSB0aGUgUmVhY3QgY29udGV4dC5cclxuICovXG5cbnZhciB1c2VTbGF0ZSA9ICgpID0+IHtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFNsYXRlQ29udGV4dCk7XG5cbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VTbGF0ZWAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG5cbiAgdmFyIHtcbiAgICBlZGl0b3JcbiAgfSA9IGNvbnRleHQ7XG4gIHJldHVybiBlZGl0b3I7XG59O1xudmFyIHVzZVNsYXRlV2l0aFYgPSAoKSA9PiB7XG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChTbGF0ZUNvbnRleHQpO1xuXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufTtcblxudmFyIFRSSVBMRV9DTElDSyA9IDM7XG5cbi8qKlxyXG4gKiBIb3RrZXkgbWFwcGluZ3MgZm9yIGVhY2ggcGxhdGZvcm0uXHJcbiAqL1xuXG52YXIgSE9US0VZUyA9IHtcbiAgYm9sZDogJ21vZCtiJyxcbiAgY29tcG9zZTogWydkb3duJywgJ2xlZnQnLCAncmlnaHQnLCAndXAnLCAnYmFja3NwYWNlJywgJ2VudGVyJ10sXG4gIG1vdmVCYWNrd2FyZDogJ2xlZnQnLFxuICBtb3ZlRm9yd2FyZDogJ3JpZ2h0JyxcbiAgbW92ZVdvcmRCYWNrd2FyZDogJ2N0cmwrbGVmdCcsXG4gIG1vdmVXb3JkRm9yd2FyZDogJ2N0cmwrcmlnaHQnLFxuICBkZWxldGVCYWNrd2FyZDogJ3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVGb3J3YXJkOiAnc2hpZnQ/K2RlbGV0ZScsXG4gIGV4dGVuZEJhY2t3YXJkOiAnc2hpZnQrbGVmdCcsXG4gIGV4dGVuZEZvcndhcmQ6ICdzaGlmdCtyaWdodCcsXG4gIGl0YWxpYzogJ21vZCtpJyxcbiAgaW5zZXJ0U29mdEJyZWFrOiAnc2hpZnQrZW50ZXInLFxuICBzcGxpdEJsb2NrOiAnZW50ZXInLFxuICB1bmRvOiAnbW9kK3onXG59O1xudmFyIEFQUExFX0hPVEtFWVMgPSB7XG4gIG1vdmVMaW5lQmFja3dhcmQ6ICdvcHQrdXAnLFxuICBtb3ZlTGluZUZvcndhcmQ6ICdvcHQrZG93bicsXG4gIG1vdmVXb3JkQmFja3dhcmQ6ICdvcHQrbGVmdCcsXG4gIG1vdmVXb3JkRm9yd2FyZDogJ29wdCtyaWdodCcsXG4gIGRlbGV0ZUJhY2t3YXJkOiBbJ2N0cmwrYmFja3NwYWNlJywgJ2N0cmwraCddLFxuICBkZWxldGVGb3J3YXJkOiBbJ2N0cmwrZGVsZXRlJywgJ2N0cmwrZCddLFxuICBkZWxldGVMaW5lQmFja3dhcmQ6ICdjbWQrc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZUxpbmVGb3J3YXJkOiBbJ2NtZCtzaGlmdD8rZGVsZXRlJywgJ2N0cmwrayddLFxuICBkZWxldGVXb3JkQmFja3dhcmQ6ICdvcHQrc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZVdvcmRGb3J3YXJkOiAnb3B0K3NoaWZ0PytkZWxldGUnLFxuICBleHRlbmRMaW5lQmFja3dhcmQ6ICdvcHQrc2hpZnQrdXAnLFxuICBleHRlbmRMaW5lRm9yd2FyZDogJ29wdCtzaGlmdCtkb3duJyxcbiAgcmVkbzogJ2NtZCtzaGlmdCt6JyxcbiAgdHJhbnNwb3NlQ2hhcmFjdGVyOiAnY3RybCt0J1xufTtcbnZhciBXSU5ET1dTX0hPVEtFWVMgPSB7XG4gIGRlbGV0ZVdvcmRCYWNrd2FyZDogJ2N0cmwrc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZVdvcmRGb3J3YXJkOiAnY3RybCtzaGlmdD8rZGVsZXRlJyxcbiAgcmVkbzogWydjdHJsK3knLCAnY3RybCtzaGlmdCt6J11cbn07XG4vKipcclxuICogQ3JlYXRlIGEgcGxhdGZvcm0tYXdhcmUgaG90a2V5IGNoZWNrZXIuXHJcbiAqL1xuXG52YXIgY3JlYXRlID0ga2V5ID0+IHtcbiAgdmFyIGdlbmVyaWMgPSBIT1RLRVlTW2tleV07XG4gIHZhciBhcHBsZSA9IEFQUExFX0hPVEtFWVNba2V5XTtcbiAgdmFyIHdpbmRvd3MgPSBXSU5ET1dTX0hPVEtFWVNba2V5XTtcbiAgdmFyIGlzR2VuZXJpYyA9IGdlbmVyaWMgJiYgaXNLZXlIb3RrZXkoZ2VuZXJpYyk7XG4gIHZhciBpc0FwcGxlID0gYXBwbGUgJiYgaXNLZXlIb3RrZXkoYXBwbGUpO1xuICB2YXIgaXNXaW5kb3dzID0gd2luZG93cyAmJiBpc0tleUhvdGtleSh3aW5kb3dzKTtcbiAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICBpZiAoaXNHZW5lcmljICYmIGlzR2VuZXJpYyhldmVudCkpIHJldHVybiB0cnVlO1xuICAgIGlmIChJU19BUFBMRSAmJiBpc0FwcGxlICYmIGlzQXBwbGUoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIUlTX0FQUExFICYmIGlzV2luZG93cyAmJiBpc1dpbmRvd3MoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59O1xuLyoqXHJcbiAqIEhvdGtleXMuXHJcbiAqL1xuXG5cbnZhciBIb3RrZXlzID0ge1xuICBpc0JvbGQ6IGNyZWF0ZSgnYm9sZCcpLFxuICBpc0NvbXBvc2U6IGNyZWF0ZSgnY29tcG9zZScpLFxuICBpc01vdmVCYWNrd2FyZDogY3JlYXRlKCdtb3ZlQmFja3dhcmQnKSxcbiAgaXNNb3ZlRm9yd2FyZDogY3JlYXRlKCdtb3ZlRm9yd2FyZCcpLFxuICBpc0RlbGV0ZUJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZUJhY2t3YXJkJyksXG4gIGlzRGVsZXRlRm9yd2FyZDogY3JlYXRlKCdkZWxldGVGb3J3YXJkJyksXG4gIGlzRGVsZXRlTGluZUJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZUxpbmVCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZUxpbmVGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZUxpbmVGb3J3YXJkJyksXG4gIGlzRGVsZXRlV29yZEJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZVdvcmRCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZVdvcmRGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZVdvcmRGb3J3YXJkJyksXG4gIGlzRXh0ZW5kQmFja3dhcmQ6IGNyZWF0ZSgnZXh0ZW5kQmFja3dhcmQnKSxcbiAgaXNFeHRlbmRGb3J3YXJkOiBjcmVhdGUoJ2V4dGVuZEZvcndhcmQnKSxcbiAgaXNFeHRlbmRMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnZXh0ZW5kTGluZUJhY2t3YXJkJyksXG4gIGlzRXh0ZW5kTGluZUZvcndhcmQ6IGNyZWF0ZSgnZXh0ZW5kTGluZUZvcndhcmQnKSxcbiAgaXNJdGFsaWM6IGNyZWF0ZSgnaXRhbGljJyksXG4gIGlzTW92ZUxpbmVCYWNrd2FyZDogY3JlYXRlKCdtb3ZlTGluZUJhY2t3YXJkJyksXG4gIGlzTW92ZUxpbmVGb3J3YXJkOiBjcmVhdGUoJ21vdmVMaW5lRm9yd2FyZCcpLFxuICBpc01vdmVXb3JkQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZVdvcmRCYWNrd2FyZCcpLFxuICBpc01vdmVXb3JkRm9yd2FyZDogY3JlYXRlKCdtb3ZlV29yZEZvcndhcmQnKSxcbiAgaXNSZWRvOiBjcmVhdGUoJ3JlZG8nKSxcbiAgaXNTb2Z0QnJlYWs6IGNyZWF0ZSgnaW5zZXJ0U29mdEJyZWFrJyksXG4gIGlzU3BsaXRCbG9jazogY3JlYXRlKCdzcGxpdEJsb2NrJyksXG4gIGlzVHJhbnNwb3NlQ2hhcmFjdGVyOiBjcmVhdGUoJ3RyYW5zcG9zZUNoYXJhY3RlcicpLFxuICBpc1VuZG86IGNyZWF0ZSgndW5kbycpXG59O1xuXG52YXIgY3JlYXRlUmVzdG9yZURvbU1hbmFnZXIgPSAoZWRpdG9yLCByZWNlaXZlZFVzZXJJbnB1dCkgPT4ge1xuICB2YXIgYnVmZmVyZWRNdXRhdGlvbnMgPSBbXTtcblxuICB2YXIgY2xlYXIgPSAoKSA9PiB7XG4gICAgYnVmZmVyZWRNdXRhdGlvbnMgPSBbXTtcbiAgfTtcblxuICB2YXIgcmVnaXN0ZXJNdXRhdGlvbnMgPSBtdXRhdGlvbnMgPT4ge1xuICAgIGlmICghcmVjZWl2ZWRVc2VySW5wdXQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0cmFja2VkTXV0YXRpb25zID0gbXV0YXRpb25zLmZpbHRlcihtdXRhdGlvbiA9PiBpc1RyYWNrZWRNdXRhdGlvbihlZGl0b3IsIG11dGF0aW9uLCBtdXRhdGlvbnMpKTtcbiAgICBidWZmZXJlZE11dGF0aW9ucy5wdXNoKC4uLnRyYWNrZWRNdXRhdGlvbnMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlc3RvcmVET00oKSB7XG4gICAgaWYgKGJ1ZmZlcmVkTXV0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGJ1ZmZlcmVkTXV0YXRpb25zLnJldmVyc2UoKS5mb3JFYWNoKG11dGF0aW9uID0+IHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJykge1xuICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmVzdG9yZSB0aGUgRE9NIGZvciBjaGFyYWN0ZXJEYXRhIG11dGF0aW9uc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhpcyBpbnRlcnJ1cHRzIHRoZSBjb21wb3NpdGlvbi5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtdXRhdGlvbi5yZW1vdmVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICBtdXRhdGlvbi50YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIG11dGF0aW9uLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG11dGF0aW9uLmFkZGVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICBtdXRhdGlvbi50YXJnZXQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7IC8vIENsZWFyIGJ1ZmZlcmVkIG11dGF0aW9ucyB0byBlbnN1cmUgd2UgZG9uJ3QgdW5kbyB0aGVtIHR3aWNlXG5cbiAgICAgIGNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZWdpc3Rlck11dGF0aW9ucyxcbiAgICByZXN0b3JlRE9NLFxuICAgIGNsZWFyXG4gIH07XG59O1xuXG52YXIgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHJDEgPSB7XG4gIHN1YnRyZWU6IHRydWUsXG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlXG59OyAvLyBXZSBoYXZlIHRvIHVzZSBhIGNsYXNzIGNvbXBvbmVudCBoZXJlIHNpbmNlIHdlIHJlbHkgb24gYGdldFNuYXBzaG90QmVmb3JlVXBkYXRlYCB3aGljaCBoYXMgbm8gRkMgZXF1aXZhbGVudFxuLy8gdG8gcnVuIGNvZGUgc3luY2hyb25vdXNseSBpbW1lZGlhdGVseSBiZWZvcmUgcmVhY3QgY29tbWl0cyB0aGUgY29tcG9uZW50IHVwZGF0ZSB0byB0aGUgRE9NLlxuXG5jbGFzcyBSZXN0b3JlRE9NQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcbiAgfVxuXG4gIG9ic2VydmUoKSB7XG4gICAgdmFyIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTtcblxuICAgIHZhciB7XG4gICAgICBub2RlXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoIW5vZGUuY3VycmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXR0YWNoIE11dGF0aW9uT2JzZXJ2ZXIsIGBub2RlYCBpcyB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICAoX3RoaXMkbXV0YXRpb25PYnNlcnZlID0gdGhpcy5tdXRhdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfdGhpcyRtdXRhdGlvbk9ic2VydmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uT2JzZXJ2ZS5vYnNlcnZlKG5vZGUuY3VycmVudCwgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHJDEpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIHtcbiAgICAgIHJlY2VpdmVkVXNlcklucHV0XG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGVkaXRvciA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLm1hbmFnZXIgPSBjcmVhdGVSZXN0b3JlRG9tTWFuYWdlcihlZGl0b3IsIHJlY2VpdmVkVXNlcklucHV0KTtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLm1hbmFnZXIucmVnaXN0ZXJNdXRhdGlvbnMpO1xuICAgIHRoaXMub2JzZXJ2ZSgpO1xuICB9XG5cbiAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSB7XG4gICAgdmFyIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIsIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMsIF90aGlzJG1hbmFnZXIyO1xuXG4gICAgdmFyIHBlbmRpbmdNdXRhdGlvbnMgPSAoX3RoaXMkbXV0YXRpb25PYnNlcnZlMiA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25PYnNlcnZlMi50YWtlUmVjb3JkcygpO1xuXG4gICAgaWYgKHBlbmRpbmdNdXRhdGlvbnMgIT09IG51bGwgJiYgcGVuZGluZ011dGF0aW9ucyAhPT0gdm9pZCAwICYmIHBlbmRpbmdNdXRhdGlvbnMubGVuZ3RoKSB7XG4gICAgICB2YXIgX3RoaXMkbWFuYWdlcjtcblxuICAgICAgKF90aGlzJG1hbmFnZXIgPSB0aGlzLm1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJG1hbmFnZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG1hbmFnZXIucmVnaXN0ZXJNdXRhdGlvbnMocGVuZGluZ011dGF0aW9ucyk7XG4gICAgfVxuXG4gICAgKF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMuZGlzY29ubmVjdCgpO1xuICAgIChfdGhpcyRtYW5hZ2VyMiA9IHRoaXMubWFuYWdlcikgPT09IG51bGwgfHwgX3RoaXMkbWFuYWdlcjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG1hbmFnZXIyLnJlc3RvcmVET00oKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkbWFuYWdlcjM7XG5cbiAgICAoX3RoaXMkbWFuYWdlcjMgPSB0aGlzLm1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJG1hbmFnZXIzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtYW5hZ2VyMy5jbGVhcigpO1xuICAgIHRoaXMub2JzZXJ2ZSgpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdmFyIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQ7XG5cbiAgICAoX3RoaXMkbXV0YXRpb25PYnNlcnZlNCA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25PYnNlcnZlNC5kaXNjb25uZWN0KCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cblxufVxuXG5SZXN0b3JlRE9NQ29tcG9uZW50LmNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcbnZhciBSZXN0b3JlRE9NID0gSVNfQU5EUk9JRCA/IFJlc3RvcmVET01Db21wb25lbnQgOiBfcmVmID0+IHtcbiAgdmFyIHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59O1xuXG4vKipcclxuICogQ2hlY2sgd2hldGhlciBhIHRleHQgZGlmZiB3YXMgYXBwbGllZCBpbiBhIHdheSB3ZSBjYW4gcGVyZm9ybSB0aGUgcGVuZGluZyBhY3Rpb24gb24gL1xyXG4gKiByZWNvdmVyIHRoZSBwZW5kaW5nIHNlbGVjdGlvbi5cclxuICovXG5cbmZ1bmN0aW9uIHZlcmlmeURpZmZTdGF0ZShlZGl0b3IsIHRleHREaWZmKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjtcblxuICBpZiAoIUVkaXRvci5oYXNQYXRoKGVkaXRvciwgcGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG5cbiAgaWYgKCFUZXh0JDEuaXNUZXh0KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGRpZmYuc3RhcnQgIT09IG5vZGUudGV4dC5sZW5ndGggfHwgZGlmZi50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBub2RlLnRleHQuc2xpY2UoZGlmZi5zdGFydCwgZGlmZi5zdGFydCArIGRpZmYudGV4dC5sZW5ndGgpID09PSBkaWZmLnRleHQ7XG4gIH1cblxuICB2YXIgbmV4dFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG5cbiAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIG5leHRQYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBuZXh0Tm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgbmV4dFBhdGgpO1xuICByZXR1cm4gVGV4dCQxLmlzVGV4dChuZXh0Tm9kZSkgJiYgbmV4dE5vZGUudGV4dC5zdGFydHNXaXRoKGRpZmYudGV4dCk7XG59XG5mdW5jdGlvbiBhcHBseVN0cmluZ0RpZmYodGV4dCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZGlmZnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGRpZmZzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBkaWZmcy5yZWR1Y2UoKHRleHQsIGRpZmYpID0+IHRleHQuc2xpY2UoMCwgZGlmZi5zdGFydCkgKyBkaWZmLnRleHQgKyB0ZXh0LnNsaWNlKGRpZmYuZW5kKSwgdGV4dCk7XG59XG5cbmZ1bmN0aW9uIGxvbmdlc3RDb21tb25QcmVmaXhMZW5ndGgoc3RyLCBhbm90aGVyKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHIuY2hhckF0KGkpICE9PSBhbm90aGVyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuZnVuY3Rpb24gbG9uZ2VzdENvbW1vblN1ZmZpeExlbmd0aChzdHIsIGFub3RoZXIsIG1heCkge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgsIG1heCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHIuY2hhckF0KHN0ci5sZW5ndGggLSBpIC0gMSkgIT09IGFub3RoZXIuY2hhckF0KGFub3RoZXIubGVuZ3RoIC0gaSAtIDEpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGVuZ3RoO1xufVxuLyoqXHJcbiAqIFJlbW92ZSByZWR1bmRhbnQgY2hhbmdlcyBmcm9tIHRoZSBkaWZmIHNvIHRoYXQgaXQgc3BhbnMgdGhlIG1pbmltYWwgcG9zc2libGUgcmFuZ2VcclxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nRGlmZih0YXJnZXRUZXh0LCBkaWZmKSB7XG4gIHZhciB7XG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIHRleHRcbiAgfSA9IGRpZmY7XG4gIHZhciByZW1vdmVkVGV4dCA9IHRhcmdldFRleHQuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIHZhciBwcmVmaXhMZW5ndGggPSBsb25nZXN0Q29tbW9uUHJlZml4TGVuZ3RoKHJlbW92ZWRUZXh0LCB0ZXh0KTtcbiAgdmFyIG1heCA9IE1hdGgubWluKHJlbW92ZWRUZXh0Lmxlbmd0aCAtIHByZWZpeExlbmd0aCwgdGV4dC5sZW5ndGggLSBwcmVmaXhMZW5ndGgpO1xuICB2YXIgc3VmZml4TGVuZ3RoID0gbG9uZ2VzdENvbW1vblN1ZmZpeExlbmd0aChyZW1vdmVkVGV4dCwgdGV4dCwgbWF4KTtcbiAgdmFyIG5vcm1hbGl6ZWQgPSB7XG4gICAgc3RhcnQ6IHN0YXJ0ICsgcHJlZml4TGVuZ3RoLFxuICAgIGVuZDogZW5kIC0gc3VmZml4TGVuZ3RoLFxuICAgIHRleHQ6IHRleHQuc2xpY2UocHJlZml4TGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIHN1ZmZpeExlbmd0aClcbiAgfTtcblxuICBpZiAobm9ybWFsaXplZC5zdGFydCA9PT0gbm9ybWFsaXplZC5lbmQgJiYgbm9ybWFsaXplZC50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG4vKipcclxuICogUmV0dXJuIGEgc3RyaW5nIGRpZmYgdGhhdCBpcyBlcXVpdmFsZW50IHRvIGFwcGx5aW5nIGIgYWZ0ZXIgYSBzcGFubmluZyB0aGUgcmFuZ2Ugb2ZcclxuICogYm90aCBjaGFuZ2VzXHJcbiAqL1xuXG5mdW5jdGlvbiBtZXJnZVN0cmluZ0RpZmZzKHRhcmdldFRleHQsIGEsIGIpIHtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4oYS5zdGFydCwgYi5zdGFydCk7XG4gIHZhciBvdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYS5zdGFydCArIGEudGV4dC5sZW5ndGgsIGIuZW5kKSAtIGIuc3RhcnQpO1xuICB2YXIgYXBwbGllZCA9IGFwcGx5U3RyaW5nRGlmZih0YXJnZXRUZXh0LCBhLCBiKTtcbiAgdmFyIHNsaWNlRW5kID0gTWF0aC5tYXgoYi5zdGFydCArIGIudGV4dC5sZW5ndGgsIGEuc3RhcnQgKyBhLnRleHQubGVuZ3RoICsgKGEuc3RhcnQgKyBhLnRleHQubGVuZ3RoID4gYi5zdGFydCA/IGIudGV4dC5sZW5ndGggOiAwKSAtIG92ZXJsYXApO1xuICB2YXIgdGV4dCA9IGFwcGxpZWQuc2xpY2Uoc3RhcnQsIHNsaWNlRW5kKTtcbiAgdmFyIGVuZCA9IE1hdGgubWF4KGEuZW5kLCBiLmVuZCAtIGEudGV4dC5sZW5ndGggKyAoYS5lbmQgLSBhLnN0YXJ0KSk7XG4gIHJldHVybiBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldFRleHQsIHtcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgdGV4dFxuICB9KTtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIHNsYXRlIHJhbmdlIHRoZSB0ZXh0IGRpZmYgc3BhbnMuXHJcbiAqL1xuXG5mdW5jdGlvbiB0YXJnZXRSYW5nZSh0ZXh0RGlmZikge1xuICB2YXIge1xuICAgIHBhdGgsXG4gICAgZGlmZlxuICB9ID0gdGV4dERpZmY7XG4gIHJldHVybiB7XG4gICAgYW5jaG9yOiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLnN0YXJ0XG4gICAgfSxcbiAgICBmb2N1czoge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5lbmRcbiAgICB9XG4gIH07XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgJ3BlbmRpbmcgcG9pbnQnIGEuay5hIGEgcG9pbnQgYmFzZWQgb24gdGhlIGRvbSBzdGF0ZSBiZWZvcmUgYXBwbHlpbmdcclxuICogdGhlIHBlbmRpbmcgZGlmZnMuIFNpbmNlIHRoZSBwZW5kaW5nIGRpZmZzIG1pZ2h0IGhhdmUgYmVlbiBpbnNlcnRlZCB3aXRoIGRpZmZlcmVudFxyXG4gKiBtYXJrcyB3ZSBoYXZlIHRvICd3YWxrJyB0aGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIHRvIGVuc3VyZSB3ZSBzdGlsbFxyXG4gKiBoYXZlIGEgdmFsaWQgcG9pbnQgaW5zaWRlIHRoZSBkb2N1bWVudFxyXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCBwb2ludCkge1xuICB2YXIge1xuICAgIHBhdGgsXG4gICAgb2Zmc2V0XG4gIH0gPSBwb2ludDtcblxuICBpZiAoIUVkaXRvci5oYXNQYXRoKGVkaXRvciwgcGF0aCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsZWFmID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcblxuICBpZiAoIVRleHQkMS5pc1RleHQobGVhZikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwYXJlbnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICBtYXRjaDogbiA9PiBFbGVtZW50JDEuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgYXQ6IHBhdGhcbiAgfSk7XG5cbiAgaWYgKCFwYXJlbnRCbG9jaykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgd2hpbGUgKG9mZnNldCA+IGxlYWYudGV4dC5sZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBFZGl0b3IubmV4dChlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgbWF0Y2g6IFRleHQkMS5pc1RleHRcbiAgICB9KTtcblxuICAgIGlmICghZW50cnkgfHwgIVBhdGguaXNEZXNjZW5kYW50KGVudHJ5WzFdLCBwYXJlbnRCbG9ja1sxXSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9mZnNldCAtPSBsZWFmLnRleHQubGVuZ3RoO1xuICAgIGxlYWYgPSBlbnRyeVswXTtcbiAgICBwYXRoID0gZW50cnlbMV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGgsXG4gICAgb2Zmc2V0XG4gIH07XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgJ3BlbmRpbmcgc2VsZWN0aW9uJyB0byBlbnN1cmUgaXQncyB2YWxpZCBpbiB0aGUgY3VycmVudCBkb2N1bWVudCBzdGF0ZS5cclxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgdmFyIGFuY2hvciA9IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcmFuZ2UuYW5jaG9yKTtcblxuICBpZiAoIWFuY2hvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1czogYW5jaG9yXG4gICAgfTtcbiAgfVxuXG4gIHZhciBmb2N1cyA9IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcmFuZ2UuZm9jdXMpO1xuXG4gIGlmICghZm9jdXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZWRpdG9yLCBwb2ludCwgb3ApIHtcbiAgdmFyIHBlbmRpbmdEaWZmcyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpO1xuICB2YXIgdGV4dERpZmYgPSBwZW5kaW5nRGlmZnMgPT09IG51bGwgfHwgcGVuZGluZ0RpZmZzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nRGlmZnMuZmluZChfcmVmID0+IHtcbiAgICB2YXIge1xuICAgICAgcGF0aFxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhwYXRoLCBwb2ludC5wYXRoKTtcbiAgfSk7XG5cbiAgaWYgKCF0ZXh0RGlmZiB8fCBwb2ludC5vZmZzZXQgPD0gdGV4dERpZmYuZGlmZi5zdGFydCkge1xuICAgIHJldHVybiBQb2ludC50cmFuc2Zvcm0ocG9pbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHtcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjsgLy8gUG9pbnQgcmVmZXJlbmNlcyBsb2NhdGlvbiBpbnNpZGUgdGhlIGRpZmYgPT4gdHJhbnNmb3JtIHRoZSBwb2ludCBiYXNlZCBvbiB0aGUgbG9jYXRpb25cbiAgLy8gdGhlIGRpZmYgd2lsbCBiZSBhcHBsaWVkIHRvIGFuZCBhZGQgdGhlIG9mZnNldCBpbnNpZGUgdGhlIGRpZmYuXG5cbiAgaWYgKHBvaW50Lm9mZnNldCA8PSBkaWZmLnN0YXJ0ICsgZGlmZi50ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBfYW5jaG9yID0ge1xuICAgICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5zdGFydFxuICAgIH07XG5cbiAgICB2YXIgX3RyYW5zZm9ybWVkID0gUG9pbnQudHJhbnNmb3JtKF9hbmNob3IsIG9wLCB7XG4gICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuXG4gICAgaWYgKCFfdHJhbnNmb3JtZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBfdHJhbnNmb3JtZWQucGF0aCxcbiAgICAgIG9mZnNldDogX3RyYW5zZm9ybWVkLm9mZnNldCArIHBvaW50Lm9mZnNldCAtIGRpZmYuc3RhcnRcbiAgICB9O1xuICB9IC8vIFBvaW50IHJlZmVyZW5jZXMgbG9jYXRpb24gYWZ0ZXIgdGhlIGRpZmZcblxuXG4gIHZhciBhbmNob3IgPSB7XG4gICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICBvZmZzZXQ6IHBvaW50Lm9mZnNldCAtIGRpZmYudGV4dC5sZW5ndGggKyBkaWZmLmVuZCAtIGRpZmYuc3RhcnRcbiAgfTtcbiAgdmFyIHRyYW5zZm9ybWVkID0gUG9pbnQudHJhbnNmb3JtKGFuY2hvciwgb3AsIHtcbiAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICB9KTtcblxuICBpZiAoIXRyYW5zZm9ybWVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAob3AudHlwZSA9PT0gJ3NwbGl0X25vZGUnICYmIFBhdGguZXF1YWxzKG9wLnBhdGgsIHBvaW50LnBhdGgpICYmIGFuY2hvci5vZmZzZXQgPCBvcC5wb3NpdGlvbiAmJiBkaWZmLnN0YXJ0IDwgb3AucG9zaXRpb24pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHRyYW5zZm9ybWVkLnBhdGgsXG4gICAgb2Zmc2V0OiB0cmFuc2Zvcm1lZC5vZmZzZXQgKyBkaWZmLnRleHQubGVuZ3RoIC0gZGlmZi5lbmQgKyBkaWZmLnN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZWRpdG9yLCByYW5nZSwgb3ApIHtcbiAgdmFyIGFuY2hvciA9IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlZGl0b3IsIHJhbmdlLmFuY2hvciwgb3ApO1xuXG4gIGlmICghYW5jaG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzOiBhbmNob3JcbiAgICB9O1xuICB9XG5cbiAgdmFyIGZvY3VzID0gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcmFuZ2UuZm9jdXMsIG9wKTtcblxuICBpZiAoIWZvY3VzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtVGV4dERpZmYodGV4dERpZmYsIG9wKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmLFxuICAgIGlkXG4gIH0gPSB0ZXh0RGlmZjtcblxuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3Aub2Zmc2V0ID49IGRpZmYuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHREaWZmO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wLm9mZnNldCA8PSBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IG9wLnRleHQubGVuZ3RoICsgZGlmZi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBvcC50ZXh0Lmxlbmd0aCArIGRpZmYuZW5kLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgKyBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IG9wLm9mZnNldCA+PSBkaWZmLmVuZCkge1xuICAgICAgICAgIHJldHVybiB0ZXh0RGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcC5vZmZzZXQgKyBvcC50ZXh0Lmxlbmd0aCA8PSBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3AucG9zaXRpb24gPj0gZGlmZi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aDogUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIHtcbiAgICAgICAgICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcC5wb3NpdGlvbiA+IGRpZmYuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBNYXRoLm1pbihvcC5wb3NpdGlvbiwgZGlmZi5lbmQpLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCAtIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwge1xuICAgICAgICAgICAgYWZmaW5pdHk6ICdmb3J3YXJkJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCArIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCArIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgfVxuXG4gIHZhciBuZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuXG4gIGlmICghbmV3UGF0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkaWZmLFxuICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgaWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyQzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vLyBXaGVuIHVzaW5nIGtleWJvYXJkIEVuZ2xpc2ggYXNzb2NpYXRpb24gZnVuY3Rpb24sIGNvbnBvc2l0aW9uRW5kIHRyaWdnZXJlZCB0b28gZmFzdCwgcmVzdWx0aW5nIGluIGFmdGVyIGBpbnNlcnRUZXh0YCBzdGlsbCBtYWludGFpbiBhc3NvY2lhdGlvbiBzdGF0ZS5cblxudmFyIFJFU09MVkVfREVMQVkgPSAyNTsgLy8gVGltZSB3aXRoIG5vIHVzZXIgaW50ZXJhY3Rpb24gYmVmb3JlIHRoZSBjdXJyZW50IHVzZXIgYWN0aW9uIGlzIGNvbnNpZGVyZWQgYXMgZG9uZS5cblxudmFyIEZMVVNIX0RFTEFZID0gMjAwOyAvLyBSZXBsYWNlIHdpdGggYGNvbnN0IGRlYnVnID0gY29uc29sZS5sb2dgIHRvIGRlYnVnXG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307IC8vIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIERhdGFUcmFuc2ZlclxuXG5cbnZhciBpc0RhdGFUcmFuc2ZlciA9IHZhbHVlID0+ICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuY29uc3RydWN0b3IubmFtZSkgPT09ICdEYXRhVHJhbnNmZXInO1xuXG5mdW5jdGlvbiBjcmVhdGVBbmRyb2lkSW5wdXRNYW5hZ2VyKF9yZWYpIHtcbiAgdmFyIHtcbiAgICBlZGl0b3IsXG4gICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSxcbiAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZVxuICB9ID0gX3JlZjtcbiAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gIHZhciBjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCA9IG51bGw7XG4gIHZhciBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gIHZhciBhY3Rpb25UaW1lb3V0SWQgPSBudWxsO1xuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgdmFyIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuXG4gIHZhciBhcHBseVBlbmRpbmdTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgdmFyIHBlbmRpbmdTZWxlY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZ2V0KGVkaXRvcik7XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuXG4gICAgaWYgKHBlbmRpbmdTZWxlY3Rpb24pIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcbiAgICAgIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplUmFuZ2UoZWRpdG9yLCBwZW5kaW5nU2VsZWN0aW9uKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWQgJiYgKCFzZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhub3JtYWxpemVkLCBzZWxlY3Rpb24pKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIG5vcm1hbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcGVyZm9ybUFjdGlvbiA9ICgpID0+IHtcbiAgICB2YXIgYWN0aW9uID0gRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmdldChlZGl0b3IpO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5kZWxldGUoZWRpdG9yKTtcblxuICAgIGlmICghYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi5hdCkge1xuICAgICAgdmFyIHRhcmdldCA9IFBvaW50LmlzUG9pbnQoYWN0aW9uLmF0KSA/IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgYWN0aW9uLmF0KSA6IG5vcm1hbGl6ZVJhbmdlKGVkaXRvciwgYWN0aW9uLmF0KTtcblxuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RhcmdldFJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgdGFyZ2V0KTtcblxuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbiwgX3RhcmdldFJhbmdlKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9uLnJ1bigpO1xuICB9O1xuXG4gIHZhciBmbHVzaCA9ICgpID0+IHtcbiAgICBpZiAoZmx1c2hUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChmbHVzaFRpbWVvdXRJZCk7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGFjdGlvblRpbWVvdXRJZCk7XG4gICAgICBhY3Rpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghaGFzUGVuZGluZ0RpZmZzKCkgJiYgIWhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgYXBwbHlQZW5kaW5nU2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBmbHVzaGluZyA9IGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBmbHVzaGluZyA9ICdhY3Rpb24nO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3Rpb25SZWYgPSBlZGl0b3Iuc2VsZWN0aW9uICYmIEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIHtcbiAgICAgIGFmZmluaXR5OiAnZm9yd2FyZCdcbiAgICB9KTtcbiAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5zZXQoZWRpdG9yLCBlZGl0b3IubWFya3MpO1xuICAgIGRlYnVnKCdmbHVzaCcsIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZWRpdG9yKSwgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpO1xuICAgIHZhciBzY2hlZHVsZVNlbGVjdGlvbkNoYW5nZSA9IGhhc1BlbmRpbmdEaWZmcygpO1xuICAgIHZhciBkaWZmO1xuXG4gICAgd2hpbGUgKGRpZmYgPSAoX0VESVRPUl9UT19QRU5ESU5HX0RJID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fUEVORElOR19ESSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19QRU5ESU5HX0RJWzBdKSB7XG4gICAgICB2YXIgX0VESVRPUl9UT19QRU5ESU5HX0RJLCBfRURJVE9SX1RPX1BFTkRJTkdfREkyO1xuXG4gICAgICB2YXIgcGVuZGluZ01hcmtzID0gRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlZGl0b3IpO1xuXG4gICAgICBpZiAocGVuZGluZ01hcmtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IubWFya3MgPSBwZW5kaW5nTWFya3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChwZW5kaW5nTWFya3MgJiYgaW5zZXJ0UG9zaXRpb25IaW50ID09PSBmYWxzZSkge1xuICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFuZ2UgPSB0YXJnZXRSYW5nZShkaWZmKTtcblxuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbiwgcmFuZ2UpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlmZi5kaWZmLnRleHQpIHtcbiAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkaWZmLmRpZmYudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgIH0gLy8gUmVtb3ZlIGRpZmYgb25seSBhZnRlciB3ZSBoYXZlIGFwcGxpZWQgaXQgdG8gYWNjb3VudCBmb3IgaXQgd2hlbiB0cmFuc2Zvcm1pbmdcbiAgICAgIC8vIHBlbmRpbmcgcmFuZ2VzLlxuXG5cbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLnNldChlZGl0b3IsIChfRURJVE9SX1RPX1BFTkRJTkdfREkyID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fUEVORElOR19ESTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fUEVORElOR19ESTIuZmlsdGVyKF9yZWYyID0+IHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBpZCAhPT0gZGlmZi5pZDtcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKCF2ZXJpZnlEaWZmU3RhdGUoZWRpdG9yLCBkaWZmKSkge1xuICAgICAgICBzY2hlZHVsZVNlbGVjdGlvbkNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBmbHVzaGluZyA9ICdhY3Rpb24nOyAvLyBFbnN1cmUgd2UgZG9uJ3QgcmVzdG9yZSB0aGUgcGVuZGluZyB1c2VyIChkb20pIHNlbGVjdGlvblxuICAgICAgICAvLyBzaW5jZSB0aGUgZG9jdW1lbnQgYW5kIGRvbSBzdGF0ZSBkbyBub3QgbWF0Y2guXG5cbiAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICAgICAgc2VsZWN0aW9uUmVmID09PSBudWxsIHx8IHNlbGVjdGlvblJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0aW9uUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvblJlZiA9PT0gbnVsbCB8fCBzZWxlY3Rpb25SZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvblJlZi51bnJlZigpO1xuXG4gICAgaWYgKHNlbGVjdGlvbiAmJiAhRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmdldChlZGl0b3IpICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKHNlbGVjdGlvbiwgZWRpdG9yLnNlbGVjdGlvbikpKSB7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgcGVyZm9ybUFjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ09NUEFUOiBUaGUgc2VsZWN0aW9uQ2hhbmdlIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBhY3Rpb24gaXMgcGVyZm9ybWVkLFxuICAgIC8vIHNvIHdlIGhhdmUgdG8gbWFudWFsbHkgc2NoZWR1bGUgaXQgdG8gZW5zdXJlIHdlIGRvbid0ICd0aHJvdyBhd2F5JyB0aGUgc2VsZWN0aW9uXG4gICAgLy8gd2hpbGUgcmVuZGVyaW5nIGlmIHdlIGhhdmUgcGVuZGluZyBjaGFuZ2VzLlxuXG5cbiAgICBpZiAoc2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UpIHtcbiAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuZmx1c2goKTtcbiAgICBhcHBseVBlbmRpbmdTZWxlY3Rpb24oKTtcbiAgICB2YXIgdXNlck1hcmtzID0gRURJVE9SX1RPX1VTRVJfTUFSS1MuZ2V0KGVkaXRvcik7XG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGVkaXRvcik7XG5cbiAgICBpZiAodXNlck1hcmtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVkaXRvci5tYXJrcyA9IHVzZXJNYXJrcztcbiAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlQ29tcG9zaXRpb25FbmQgPSBfZXZlbnQgPT4ge1xuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBvc2l0aW9uRW5kVGltZW91dElkKTtcbiAgICB9XG5cbiAgICBjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgIGZsdXNoKCk7XG4gICAgfSwgUkVTT0xWRV9ERUxBWSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQgPSBfZXZlbnQgPT4ge1xuICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCB0cnVlKTtcblxuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBvc2l0aW9uRW5kVGltZW91dElkKTtcbiAgICAgIGNvbXBvc2l0aW9uRW5kVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSgpIHtcbiAgICB2YXIgZm9yY2VIaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgcGxhY2Vob2xkZXJFbGVtZW50ID0gRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXBsYWNlaG9sZGVyRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nRGlmZnMoKSB8fCBmb3JjZUhpZGUpIHtcbiAgICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnZGlzcGxheScpO1xuICB9O1xuXG4gIHZhciBzdG9yZURpZmYgPSAocGF0aCwgZGlmZikgPT4ge1xuICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREkzO1xuICAgIHZhciBwZW5kaW5nRGlmZnMgPSAoX0VESVRPUl9UT19QRU5ESU5HX0RJMyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkzICE9PSB2b2lkIDAgPyBfRURJVE9SX1RPX1BFTkRJTkdfREkzIDogW107XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGVkaXRvciwgcGVuZGluZ0RpZmZzKTtcbiAgICB2YXIgdGFyZ2V0ID0gTm9kZS5sZWFmKGVkaXRvciwgcGF0aCk7XG4gICAgdmFyIGlkeCA9IHBlbmRpbmdEaWZmcy5maW5kSW5kZXgoY2hhbmdlID0+IFBhdGguZXF1YWxzKGNoYW5nZS5wYXRoLCBwYXRoKSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldC50ZXh0LCBkaWZmKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcGVuZGluZ0RpZmZzLnB1c2goe1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgZGlmZixcbiAgICAgICAgICBpZDogaWRDb3VudGVyKytcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZXJnZWQgPSBtZXJnZVN0cmluZ0RpZmZzKHRhcmdldC50ZXh0LCBwZW5kaW5nRGlmZnNbaWR4XS5kaWZmLCBkaWZmKTtcblxuICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICBwZW5kaW5nRGlmZnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwZW5kaW5nRGlmZnNbaWR4XSA9IF9vYmplY3RTcHJlYWQkMyhfb2JqZWN0U3ByZWFkJDMoe30sIHBlbmRpbmdEaWZmc1tpZHhdKSwge30sIHtcbiAgICAgIGRpZmY6IG1lcmdlZFxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzY2hlZHVsZUFjdGlvbiA9IGZ1bmN0aW9uIHNjaGVkdWxlQWN0aW9uKHJ1bikge1xuICAgIHZhciB7XG4gICAgICBhdFxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuXG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgZmx1c2goKTtcbiAgICB9XG5cbiAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uc2V0KGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBydW5cbiAgICB9KTsgLy8gQ09NUEFUOiBXaGVuIGRlbGV0aW5nIGJlZm9yZSBhIG5vbi1jb250ZW50ZWRpdGFibGUgZWxlbWVudCBjaHJvbWUgb25seSBmaXJlcyBhIGJlZm9yZWlucHV0LFxuICAgIC8vIChubyBpbnB1dCkgYW5kIGRvZXNuJ3QgcGVyZm9ybSBhbnkgZG9tIG11dGF0aW9ucy4gV2l0aG91dCBhIGZsdXNoIHRpbWVvdXQgd2Ugd291bGQgbmV2ZXIgZmx1c2hcbiAgICAvLyBpbiB0aGlzIGNhc2UgYW5kIHRodXMgbmV2ZXIgYWN0dWFsbHkgcGVyZm9ybSB0aGUgYWN0aW9uLlxuXG4gICAgYWN0aW9uVGltZW91dElkID0gc2V0VGltZW91dChmbHVzaCk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZURPTUJlZm9yZUlucHV0ID0gZXZlbnQgPT4ge1xuICAgIHZhciBfdGFyZ2V0UmFuZ2UyO1xuXG4gICAgaWYgKGZsdXNoVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZmx1c2hUaW1lb3V0SWQpO1xuICAgICAgZmx1c2hUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBpbnB1dFR5cGU6IHR5cGVcbiAgICB9ID0gZXZlbnQ7XG4gICAgdmFyIHRhcmdldFJhbmdlID0gbnVsbDtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFUcmFuc2ZlciB8fCBldmVudC5kYXRhIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmIChpbnNlcnRQb3NpdGlvbkhpbnQgIT09IGZhbHNlICYmIHR5cGUgIT09ICdpbnNlcnRUZXh0JyAmJiB0eXBlICE9PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0Jykge1xuICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIFtuYXRpdmVUYXJnZXRSYW5nZV0gPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKTtcblxuICAgIGlmIChuYXRpdmVUYXJnZXRSYW5nZSkge1xuICAgICAgdGFyZ2V0UmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBuYXRpdmVUYXJnZXRSYW5nZSwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSAvLyBDT01QQVQ6IFNlbGVjdGlvbkNoYW5nZSBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgYWN0aW9uIGlzIHBlcmZvcm1lZCwgc28gd2VcbiAgICAvLyBoYXZlIHRvIG1hbnVhbGx5IGdldCB0aGUgc2VsZWN0aW9uIGhlcmUgdG8gZW5zdXJlIGl0J3MgdXAtdG8tZGF0ZS5cblxuXG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIXRhcmdldFJhbmdlICYmIGRvbVNlbGVjdGlvbikge1xuICAgICAgbmF0aXZlVGFyZ2V0UmFuZ2UgPSBkb21TZWxlY3Rpb247XG4gICAgICB0YXJnZXRSYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGFyZ2V0UmFuZ2UgPSAoX3RhcmdldFJhbmdlMiA9IHRhcmdldFJhbmdlKSAhPT0gbnVsbCAmJiBfdGFyZ2V0UmFuZ2UyICE9PSB2b2lkIDAgPyBfdGFyZ2V0UmFuZ2UyIDogZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgIGlmICghdGFyZ2V0UmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEJ5IGRlZmF1bHQsIHRoZSBpbnB1dCBtYW5hZ2VyIHRyaWVzIHRvIHN0b3JlIHRleHQgZGlmZnMgc28gdGhhdCB3ZSBjYW5cbiAgICAvLyBkZWZlciBmbHVzaGluZyB0aGVtIGF0IGEgbGF0ZXIgcG9pbnQgaW4gdGltZS4gV2UgZG9uJ3Qgd2FudCB0byBmbHVzaFxuICAgIC8vIGZvciBldmVyeSBpbnB1dCBldmVudCBhcyB0aGlzIGNhbiBiZSBleHBlbnNpdmUuIEhvd2V2ZXIsIHRoZXJlIGFyZSBzb21lXG4gICAgLy8gc2NlbmFyaW9zIHdoZXJlIHdlIGNhbm5vdCBzYWZlbHkgc3RvcmUgdGhlIHRleHQgZGlmZiBhbmQgbXVzdCBpbnN0ZWFkXG4gICAgLy8gc2NoZWR1bGUgYW4gYWN0aW9uIHRvIGxldCBTbGF0ZSBub3JtYWxpemUgdGhlIGVkaXRvciBzdGF0ZS5cblxuXG4gICAgdmFyIGNhblN0b3JlRGlmZiA9IHRydWU7XG5cbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSkge1xuICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQodGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgIHZhciBbX3N0YXJ0LCBfZW5kXSA9IFJhbmdlLmVkZ2VzKHRhcmdldFJhbmdlKTtcblxuICAgICAgICB2YXIgX2xlYWYgPSBOb2RlLmxlYWYoZWRpdG9yLCBfc3RhcnQucGF0aCk7XG5cbiAgICAgICAgaWYgKF9sZWFmLnRleHQubGVuZ3RoID09PSBfc3RhcnQub2Zmc2V0ICYmIF9lbmQub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBFZGl0b3IubmV4dChlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBfc3RhcnQucGF0aCxcbiAgICAgICAgICAgIG1hdGNoOiBUZXh0JDEuaXNUZXh0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAobmV4dCAmJiBQYXRoLmVxdWFscyhuZXh0WzFdLCBfZW5kLnBhdGgpKSB7XG4gICAgICAgICAgICB0YXJnZXRSYW5nZSA9IHtcbiAgICAgICAgICAgICAgYW5jaG9yOiBfZW5kLFxuICAgICAgICAgICAgICBmb2N1czogX2VuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRpcmVjdGlvbiA9IHR5cGUuZW5kc1dpdGgoJ0JhY2t3YXJkJykgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnO1xuICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHRhcmdldFJhbmdlKTtcbiAgICAgIHZhciBbbGVhZiwgcGF0aF0gPSBFZGl0b3IubGVhZihlZGl0b3IsIHN0YXJ0LnBhdGgpO1xuICAgICAgdmFyIGRpZmYgPSB7XG4gICAgICAgIHRleHQ6ICcnLFxuICAgICAgICBzdGFydDogc3RhcnQub2Zmc2V0LFxuICAgICAgICBlbmQ6IGVuZC5vZmZzZXRcbiAgICAgIH07XG4gICAgICB2YXIgcGVuZGluZ0RpZmZzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcik7XG4gICAgICB2YXIgcmVsZXZhbnRQZW5kaW5nRGlmZnMgPSBwZW5kaW5nRGlmZnMgPT09IG51bGwgfHwgcGVuZGluZ0RpZmZzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nRGlmZnMuZmluZChjaGFuZ2UgPT4gUGF0aC5lcXVhbHMoY2hhbmdlLnBhdGgsIHBhdGgpKTtcbiAgICAgIHZhciBkaWZmcyA9IHJlbGV2YW50UGVuZGluZ0RpZmZzID8gW3JlbGV2YW50UGVuZGluZ0RpZmZzLmRpZmYsIGRpZmZdIDogW2RpZmZdO1xuICAgICAgdmFyIHRleHQgPSBhcHBseVN0cmluZ0RpZmYobGVhZi50ZXh0LCAuLi5kaWZmcyk7XG5cbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBUZXh0IGxlYWYgd2lsbCBiZSByZW1vdmVkLCBzbyB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuXG4gICAgICAgIC8vIGFjdGlvbiB0byByZW1vdmUgaXQgc28gdGhhdCBTbGF0ZSBjYW4gbm9ybWFsaXplIGluc3RlYWRcbiAgICAgICAgLy8gb2Ygc3RvcmluZyBhcyBhIGRpZmZcbiAgICAgICAgY2FuU3RvcmVEaWZmID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHRhcmdldFJhbmdlKSkge1xuICAgICAgICBpZiAoY2FuU3RvcmVEaWZmICYmIFBhdGguZXF1YWxzKHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLCB0YXJnZXRSYW5nZS5mb2N1cy5wYXRoKSkge1xuICAgICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICAgIHBhdGg6IHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydC5vZmZzZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBvaW50LCBwb2ludCk7XG4gICAgICAgICAgaGFuZGxlVXNlclNlbGVjdChyYW5nZSk7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlRGlmZih0YXJnZXRSYW5nZS5hbmNob3IucGF0aCwge1xuICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICBlbmQ6IGVuZC5vZmZzZXQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQub2Zmc2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgIGRpcmVjdGlvblxuICAgICAgICB9KSwge1xuICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q29tcG9zaXRpb24nOlxuICAgICAgY2FzZSAnZGVsZXRlQnlDdXQnOlxuICAgICAgY2FzZSAnZGVsZXRlQnlEcmFnJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudCc6XG4gICAgICBjYXNlICdkZWxldGVDb250ZW50Rm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgYW5jaG9yXG4gICAgICAgICAgfSA9IHRhcmdldFJhbmdlO1xuXG4gICAgICAgICAgaWYgKGNhblN0b3JlRGlmZiAmJiBSYW5nZS5pc0NvbGxhcHNlZCh0YXJnZXRSYW5nZSkpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gTm9kZS5sZWFmKGVkaXRvciwgYW5jaG9yLnBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoYW5jaG9yLm9mZnNldCA8IHRhcmdldE5vZGUudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlRGlmZihhbmNob3IucGF0aCwge1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBhbmNob3Iub2Zmc2V0LFxuICAgICAgICAgICAgICAgIGVuZDogYW5jaG9yLm9mZnNldCArIDFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX25hdGl2ZVRhcmdldFJhbmdlO1xuXG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIGFuY2hvcjogX2FuY2hvclxuICAgICAgICAgIH0gPSB0YXJnZXRSYW5nZTsgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoIGJldHdlZW4gdGhlIG5hdGl2ZSBhbmQgc2xhdGUgc2VsZWN0aW9uIGJlaW5nIGNvbGxhcHNlZFxuICAgICAgICAgIC8vIHdlIGFyZSBtb3N0IGxpa2VseSBkZWxldGluZyBhIHplcm8td2lkdGggcGxhY2Vob2xkZXIgYW5kIHRodXMgc2hvdWxkIHBlcmZvcm0gaXRcbiAgICAgICAgICAvLyBhcyBhbiBhY3Rpb24gdG8gZW5zdXJlIGNvcnJlY3QgYmVoYXZpb3IgKG1vc3RseSBoYXBwZW5zIHdpdGggbWFyayBwbGFjZWhvbGRlcnMpXG5cbiAgICAgICAgICB2YXIgbmF0aXZlQ29sbGFwc2VkID0gaXNET01TZWxlY3Rpb24obmF0aXZlVGFyZ2V0UmFuZ2UpID8gbmF0aXZlVGFyZ2V0UmFuZ2UuaXNDb2xsYXBzZWQgOiAhISgoX25hdGl2ZVRhcmdldFJhbmdlID0gbmF0aXZlVGFyZ2V0UmFuZ2UpICE9PSBudWxsICYmIF9uYXRpdmVUYXJnZXRSYW5nZSAhPT0gdm9pZCAwICYmIF9uYXRpdmVUYXJnZXRSYW5nZS5jb2xsYXBzZWQpO1xuXG4gICAgICAgICAgaWYgKGNhblN0b3JlRGlmZiAmJiBuYXRpdmVDb2xsYXBzZWQgJiYgUmFuZ2UuaXNDb2xsYXBzZWQodGFyZ2V0UmFuZ2UpICYmIF9hbmNob3Iub2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlRGlmZihfYW5jaG9yLnBhdGgsIHtcbiAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgIHN0YXJ0OiBfYW5jaG9yLm9mZnNldCAtIDEsXG4gICAgICAgICAgICAgIGVuZDogX2FuY2hvci5vZmZzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlRW50aXJlU29mdExpbmUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lRm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lRm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlV29yZEJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlV29yZEZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydExpbmVCcmVhayc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmluc2VydFNvZnRCcmVhayhlZGl0b3IpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRQYXJhZ3JhcGgnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5pbnNlcnRCcmVhayhlZGl0b3IpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRDb21wb3NpdGlvblRleHQnOlxuICAgICAgY2FzZSAnZGVsZXRlQ29tcG9zaXRpb25UZXh0JzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21Db21wb3NpdGlvbic6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tRHJvcCc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGUnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbVlhbmsnOlxuICAgICAgY2FzZSAnaW5zZXJ0UmVwbGFjZW1lbnRUZXh0JzpcbiAgICAgIGNhc2UgJ2luc2VydFRleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGlzRGF0YVRyYW5zZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpLCB7XG4gICAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF90ZXh0ID0gZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB2b2lkIDAgPyBkYXRhIDogJyc7IC8vIENPTVBBVDogSWYgd2UgYXJlIHdyaXRpbmcgaW5zaWRlIGEgcGxhY2Vob2xkZXIsIHRoZSBpbWUgaW5zZXJ0cyB0aGUgdGV4dCBpbnNpZGVcbiAgICAgICAgICAvLyB0aGUgcGxhY2Vob2xkZXIgaXRzZWxmIGFuZCB0aHVzIGluY2x1ZGVzIHRoZSB6ZXJvLXdpZHRoIHNwYWNlIGluc2lkZSBlZGl0IGV2ZW50cy5cblxuXG4gICAgICAgICAgaWYgKEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZWRpdG9yKSkge1xuICAgICAgICAgICAgX3RleHQgPSBfdGV4dC5yZXBsYWNlKCdcXHVGRUZGJywgJycpO1xuICAgICAgICAgIH0gLy8gUGFzdGVzIGZyb20gdGhlIEFuZHJvaWQgY2xpcGJvYXJkIHdpbGwgZ2VuZXJhdGUgYGluc2VydFRleHRgIGV2ZW50cy5cbiAgICAgICAgICAvLyBJZiB0aGUgY29waWVkIHRleHQgY29udGFpbnMgYW55IG5ld2xpbmVzLCBBbmRyb2lkIHdpbGwgYXBwZW5kIGFuXG4gICAgICAgICAgLy8gZXh0cmEgbmV3bGluZSB0byB0aGUgZW5kIG9mIHRoZSBjb3BpZWQgdGV4dC5cblxuXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdpbnNlcnRUZXh0JyAmJiAvLipcXG4uKlxcbiQvLnRlc3QoX3RleHQpKSB7XG4gICAgICAgICAgICBfdGV4dCA9IF90ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICB9IC8vIElmIHRoZSB0ZXh0IGluY2x1ZGVzIGEgbmV3bGluZSwgc3BsaXQgaXQgYXQgbmV3bGluZXMgYW5kIHBhc3RlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgLy8gc3RyaW5nLCB3aXRoIHNvZnQgYnJlYWtzIGluIGJldHdlZW4gZWFjaC5cblxuXG4gICAgICAgICAgaWYgKF90ZXh0LmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIHBhcnRzID0gX3RleHQuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICAgIHBhcnRzLmZvckVhY2goKGxpbmUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gcGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgRWRpdG9yLmluc2VydFNvZnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLCB0YXJnZXRSYW5nZS5mb2N1cy5wYXRoKSkge1xuICAgICAgICAgICAgdmFyIFtfc3RhcnQyLCBfZW5kMl0gPSBSYW5nZS5lZGdlcyh0YXJnZXRSYW5nZSk7XG4gICAgICAgICAgICB2YXIgX2RpZmYgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBfc3RhcnQyLm9mZnNldCxcbiAgICAgICAgICAgICAgZW5kOiBfZW5kMi5vZmZzZXQsXG4gICAgICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgICAgICB9OyAvLyBDT01QQVQ6IFN3aWZ0a2V5IGhhcyBhIHdlaXJkIGJ1ZyB3aGVyZSB0aGUgdGFyZ2V0IHJhbmdlIG9mIHRoZSAybmQgd29yZFxuICAgICAgICAgICAgLy8gaW5zZXJ0ZWQgYWZ0ZXIgYSBtYXJrIHBsYWNlaG9sZGVyIGlzIGluc2VydGVkIHdpdGggYW4gYW5jaG9yIG9mZnNldCBvZmYgYnkgMS5cbiAgICAgICAgICAgIC8vIFNvIHdyaXRpbmcgJ3NvbWUgdGV4dCcgd2lsbCByZXN1bHQgaW4gJ3NvbWUgdHRleHQnLiBMdWNraWx5IGFsbCAnbm9ybWFsJyBpbnNlcnRcbiAgICAgICAgICAgIC8vIHRleHQgZXZlbnRzIGFyZSBmaXJlZCB3aXRoIHRoZSBjb3JyZWN0IHRhcmdldCByYW5nZXMsIG9ubHkgdGhlIGZpbmFsICdpbnNlcnRDb21wb3NpdGlvbidcbiAgICAgICAgICAgIC8vIGlzbid0LCBzbyB3ZSBjYW4gYWRqdXN0IHRoZSB0YXJnZXQgcmFuZ2Ugc3RhcnQgb2Zmc2V0IGlmIHdlIGFyZSBjb25maWRlbnQgdGhpcyBpcyB0aGVcbiAgICAgICAgICAgIC8vIHN3aWZ0a2V5IGluc2VydCBjYXVzaW5nIHRoZSBpc3N1ZS5cblxuICAgICAgICAgICAgaWYgKF90ZXh0ICYmIGluc2VydFBvc2l0aW9uSGludCAmJiB0eXBlID09PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0Jykge1xuICAgICAgICAgICAgICB2YXIgaGludFBvc2l0aW9uID0gaW5zZXJ0UG9zaXRpb25IaW50LnN0YXJ0ICsgaW5zZXJ0UG9zaXRpb25IaW50LnRleHQuc2VhcmNoKC9cXFN8JC8pO1xuXG4gICAgICAgICAgICAgIHZhciBkaWZmUG9zaXRpb24gPSBfZGlmZi5zdGFydCArIF9kaWZmLnRleHQuc2VhcmNoKC9cXFN8JC8pO1xuXG4gICAgICAgICAgICAgIGlmIChkaWZmUG9zaXRpb24gPT09IGhpbnRQb3NpdGlvbiArIDEgJiYgX2RpZmYuZW5kID09PSBpbnNlcnRQb3NpdGlvbkhpbnQuc3RhcnQgKyBpbnNlcnRQb3NpdGlvbkhpbnQudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfZGlmZi5zdGFydCAtPSAxO1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnNlcnRUZXh0Jykge1xuICAgICAgICAgICAgICBpZiAoaW5zZXJ0UG9zaXRpb25IaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gX2RpZmY7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5zZXJ0UG9zaXRpb25IaW50ICYmIFJhbmdlLmlzQ29sbGFwc2VkKHRhcmdldFJhbmdlKSAmJiBpbnNlcnRQb3NpdGlvbkhpbnQuZW5kICsgaW5zZXJ0UG9zaXRpb25IaW50LnRleHQubGVuZ3RoID09PSBfc3RhcnQyLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IF9vYmplY3RTcHJlYWQkMyhfb2JqZWN0U3ByZWFkJDMoe30sIGluc2VydFBvc2l0aW9uSGludCksIHt9LCB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBpbnNlcnRQb3NpdGlvbkhpbnQudGV4dCArIF90ZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FuU3RvcmVEaWZmKSB7XG4gICAgICAgICAgICAgIHN0b3JlRGlmZihfc3RhcnQyLnBhdGgsIF9kaWZmKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIF90ZXh0KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhc1BlbmRpbmdBY3Rpb24gPSAoKSA9PiB7XG4gICAgcmV0dXJuICEhRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmdldChlZGl0b3IpO1xuICB9O1xuXG4gIHZhciBoYXNQZW5kaW5nRGlmZnMgPSAoKSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTQ7XG5cbiAgICByZXR1cm4gISEoKF9FRElUT1JfVE9fUEVORElOR19ESTQgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJNCAhPT0gdm9pZCAwICYmIF9FRElUT1JfVE9fUEVORElOR19ESTQubGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgaGFzUGVuZGluZ0NoYW5nZXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGhhc1BlbmRpbmdBY3Rpb24oKSB8fCBoYXNQZW5kaW5nRGlmZnMoKTtcbiAgfTtcblxuICB2YXIgaXNGbHVzaGluZyA9ICgpID0+IHtcbiAgICByZXR1cm4gZmx1c2hpbmc7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVVzZXJTZWxlY3QgPSByYW5nZSA9PiB7XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLnNldChlZGl0b3IsIHJhbmdlKTtcblxuICAgIGlmIChmbHVzaFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGZsdXNoVGltZW91dElkKTtcbiAgICAgIGZsdXNoVGltZW91dElkID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aENoYW5nZWQgPSAhc2VsZWN0aW9uIHx8ICFQYXRoLmVxdWFscyhzZWxlY3Rpb24uYW5jaG9yLnBhdGgsIHJhbmdlLmFuY2hvci5wYXRoKTtcbiAgICB2YXIgcGFyZW50UGF0aENoYW5nZWQgPSAhc2VsZWN0aW9uIHx8ICFQYXRoLmVxdWFscyhzZWxlY3Rpb24uYW5jaG9yLnBhdGguc2xpY2UoMCwgLTEpLCByYW5nZS5hbmNob3IucGF0aC5zbGljZSgwLCAtMSkpO1xuXG4gICAgaWYgKHBhdGhDaGFuZ2VkICYmIGluc2VydFBvc2l0aW9uSGludCB8fCBwYXJlbnRQYXRoQ2hhbmdlZCkge1xuICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHBhdGhDaGFuZ2VkIHx8IGhhc1BlbmRpbmdEaWZmcygpKSB7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZmx1c2gsIEZMVVNIX0RFTEFZKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUlucHV0ID0gKCkgPT4ge1xuICAgIGlmIChoYXNQZW5kaW5nQWN0aW9uKCkgfHwgIWhhc1BlbmRpbmdEaWZmcygpKSB7XG4gICAgICBmbHVzaCgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlS2V5RG93biA9IF8gPT4ge1xuICAgIC8vIENPTVBBVDogU3dpZnRrZXkgY2xvc2VzIHRoZSBrZXlib2FyZCB3aGVuIHR5cGluZyBpbnNpZGUgYSBlbXB0eSBub2RlXG4gICAgLy8gZGlyZWN0bHkgbmV4dCB0byBhIG5vbi1jb250ZW50ZWRpdGFibGUgZWxlbWVudCAoPSB0aGUgcGxhY2Vob2xkZXIpLlxuICAgIC8vIFRoZSBvbmx5IGV2ZW50IGZpcmVkIHNvb24gZW5vdWdoIGZvciB1cyB0byBhbGxvdyBoaWRpbmcgdGhlIHBsYWNlaG9sZGVyXG4gICAgLy8gd2l0aG91dCBzd2lmdGtleSBwaWNraW5nIGl0IHVwIGlzIHRoZSBrZXlkb3duIGV2ZW50LCBzbyB3ZSBoYXZlIHRvIGhpZGUgaXRcbiAgICAvLyBoZXJlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL3B1bGwvNDk4OCNpc3N1ZWNvbW1lbnQtMTIwMTA1MDUzNVxuICAgIGlmICghaGFzUGVuZGluZ0RpZmZzKCkpIHtcbiAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSh0cnVlKTtcbiAgICAgIHNldFRpbWVvdXQodXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNjaGVkdWxlRmx1c2ggPSAoKSA9PiB7XG4gICAgaWYgKCFoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGFjdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZmx1c2gpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlRG9tTXV0YXRpb25zID0gbXV0YXRpb25zID0+IHtcbiAgICBpZiAoaGFzUGVuZGluZ0RpZmZzKCkgfHwgaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG11dGF0aW9ucy5zb21lKG11dGF0aW9uID0+IGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgbXV0YXRpb24sIG11dGF0aW9ucykpKSB7XG4gICAgICB2YXIgX0VESVRPUl9UT19GT1JDRV9SRU5EO1xuXG4gICAgICAvLyBDYXVzZSBhIHJlLXJlbmRlciB0byByZXN0b3JlIHRoZSBkb20gc3RhdGUgaWYgd2UgZW5jb3VudGVyIHRyYWNrZWQgbXV0YXRpb25zIHdpdGhvdXRcbiAgICAgIC8vIGEgY29ycmVzcG9uZGluZyBwZW5kaW5nIGFjdGlvbi5cbiAgICAgIChfRURJVE9SX1RPX0ZPUkNFX1JFTkQgPSBFRElUT1JfVE9fRk9SQ0VfUkVOREVSLmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX0ZPUkNFX1JFTkQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fRk9SQ0VfUkVORCgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGZsdXNoLFxuICAgIHNjaGVkdWxlRmx1c2gsXG4gICAgaGFzUGVuZGluZ0RpZmZzLFxuICAgIGhhc1BlbmRpbmdBY3Rpb24sXG4gICAgaGFzUGVuZGluZ0NoYW5nZXMsXG4gICAgaXNGbHVzaGluZyxcbiAgICBoYW5kbGVVc2VyU2VsZWN0LFxuICAgIGhhbmRsZUNvbXBvc2l0aW9uRW5kLFxuICAgIGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQsXG4gICAgaGFuZGxlRE9NQmVmb3JlSW5wdXQsXG4gICAgaGFuZGxlS2V5RG93bixcbiAgICBoYW5kbGVEb21NdXRhdGlvbnMsXG4gICAgaGFuZGxlSW5wdXRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlSXNNb3VudGVkKCkge1xuICB2YXIgaXNNb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gaXNNb3VudGVkUmVmLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIobm9kZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIFttdXRhdGlvbk9ic2VydmVyXSA9IHVzZVN0YXRlKCgpID0+IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIC8vIERpc2NhcmQgbXV0YXRpb25zIGNhdXNlZCBkdXJpbmcgcmVuZGVyIHBoYXNlLiBUaGlzIHdvcmtzIGR1ZSB0byByZWFjdCBjYWxsaW5nXG4gICAgLy8gdXNlTGF5b3V0RWZmZWN0IHN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIHJlbmRlciBwaGFzZSBiZWZvcmUgdGhlIG5leHQgdGljay5cbiAgICBtdXRhdGlvbk9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbm9kZS5jdXJyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhdHRhY2ggTXV0YXRpb25PYnNlcnZlciwgYG5vZGVgIGlzIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIG11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShub2RlLmN1cnJlbnQsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfSwgW10pO1xufVxuXG52YXIgX2V4Y2x1ZGVkJDIgPSBbXCJub2RlXCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBNVVRBVElPTl9PQlNFUlZFUl9DT05GSUcgPSB7XG4gIHN1YnRyZWU6IHRydWUsXG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxufTtcbmZ1bmN0aW9uIHVzZUFuZHJvaWRJbnB1dE1hbmFnZXIoX3JlZikge1xuICB2YXIge1xuICAgIG5vZGVcbiAgfSA9IF9yZWYsXG4gICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCQyKTtcblxuICBpZiAoIUlTX0FORFJPSUQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gIHZhciBbaW5wdXRNYW5hZ2VyXSA9IHVzZVN0YXRlKCgpID0+IGNyZWF0ZUFuZHJvaWRJbnB1dE1hbmFnZXIoX29iamVjdFNwcmVhZCQyKHtcbiAgICBlZGl0b3JcbiAgfSwgb3B0aW9ucykpKTtcbiAgdXNlTXV0YXRpb25PYnNlcnZlcihub2RlLCBpbnB1dE1hbmFnZXIuaGFuZGxlRG9tTXV0YXRpb25zLCBNVVRBVElPTl9PQlNFUlZFUl9DT05GSUcpO1xuICBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0guc2V0KGVkaXRvciwgaW5wdXRNYW5hZ2VyLnNjaGVkdWxlRmx1c2gpO1xuXG4gIGlmIChpc01vdW50ZWQpIHtcbiAgICBpbnB1dE1hbmFnZXIuZmx1c2goKTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dE1hbmFnZXI7XG59XG5cbmZ1bmN0aW9uIHVzZVRyYWNrVXNlcklucHV0KCkge1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHJlY2VpdmVkVXNlcklucHV0ID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIGFuaW1hdGlvbkZyYW1lSWRSZWYgPSB1c2VSZWYoMCk7XG4gIHZhciBvblVzZXJJbnB1dCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocmVjZWl2ZWRVc2VySW5wdXQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQgPSB0cnVlO1xuICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZFJlZi5jdXJyZW50KTtcbiAgICBhbmltYXRpb25GcmFtZUlkUmVmLmN1cnJlbnQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZFJlZi5jdXJyZW50KSwgW10pO1xuICByZXR1cm4ge1xuICAgIHJlY2VpdmVkVXNlcklucHV0LFxuICAgIG9uVXNlcklucHV0XG4gIH07XG59XG5cbnZhciBfZXhjbHVkZWQkMSA9IFtcImF1dG9Gb2N1c1wiLCBcImRlY29yYXRlXCIsIFwib25ET01CZWZvcmVJbnB1dFwiLCBcInBsYWNlaG9sZGVyXCIsIFwicmVhZE9ubHlcIiwgXCJyZW5kZXJFbGVtZW50XCIsIFwicmVuZGVyTGVhZlwiLCBcInJlbmRlclBsYWNlaG9sZGVyXCIsIFwic2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXdcIiwgXCJzdHlsZVwiLCBcImFzXCIsIFwiZGlzYWJsZURlZmF1bHRTdHlsZXNcIl0sXG4gICAgX2V4Y2x1ZGVkMiA9IFtcInRleHRcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgQ2hpbGRyZW4gPSBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgdXNlQ2hpbGRyZW4ocHJvcHMpKTtcbi8qKlxyXG4gKiBFZGl0YWJsZS5cclxuICovXG5cblxudmFyIEVkaXRhYmxlID0gcHJvcHMgPT4ge1xuICB2YXIgX0VESVRPUl9UT19QTEFDRUhPTERFLCBfRURJVE9SX1RPX1BMQUNFSE9MREUyO1xuXG4gIHZhciBkZWZhdWx0UmVuZGVyUGxhY2Vob2xkZXIgPSB1c2VDYWxsYmFjayhwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0UGxhY2Vob2xkZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSksIFtdKTtcblxuICB2YXIge1xuICAgIGF1dG9Gb2N1cyxcbiAgICBkZWNvcmF0ZSA9IGRlZmF1bHREZWNvcmF0ZSxcbiAgICBvbkRPTUJlZm9yZUlucHV0OiBwcm9wc09uRE9NQmVmb3JlSW5wdXQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgcmVhZE9ubHkgPSBmYWxzZSxcbiAgICByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlckxlYWYsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIgPSBkZWZhdWx0UmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcgPSBkZWZhdWx0U2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcsXG4gICAgc3R5bGU6IHVzZXJTdHlsZSA9IHt9LFxuICAgIGFzOiBDb21wb25lbnQgPSAnZGl2JyxcbiAgICBkaXNhYmxlRGVmYXVsdFN0eWxlcyA9IGZhbHNlXG4gIH0gPSBwcm9wcyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCQxKTtcblxuICB2YXIgZWRpdG9yID0gdXNlU2xhdGUoKTsgLy8gUmVyZW5kZXIgZWRpdG9yIHdoZW4gY29tcG9zaXRpb24gc3RhdHVzIGNoYW5nZWRcblxuICB2YXIgW2lzQ29tcG9zaW5nLCBzZXRJc0NvbXBvc2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBkZWZlcnJlZE9wZXJhdGlvbnMgPSB1c2VSZWYoW10pO1xuICB2YXIge1xuICAgIG9uVXNlcklucHV0LFxuICAgIHJlY2VpdmVkVXNlcklucHV0XG4gIH0gPSB1c2VUcmFja1VzZXJJbnB1dCgpO1xuICB2YXIgWywgZm9yY2VSZW5kZXJdID0gdXNlUmVkdWNlcihzID0+IHMgKyAxLCAwKTtcbiAgRURJVE9SX1RPX0ZPUkNFX1JFTkRFUi5zZXQoZWRpdG9yLCBmb3JjZVJlbmRlcik7IC8vIFVwZGF0ZSBpbnRlcm5hbCBzdGF0ZSBvbiBlYWNoIHJlbmRlci5cblxuICBJU19SRUFEX09OTFkuc2V0KGVkaXRvciwgcmVhZE9ubHkpOyAvLyBLZWVwIHRyYWNrIG9mIHNvbWUgc3RhdGUgZm9yIHRoZSBldmVudCBoYW5kbGVyIGxvZ2ljLlxuXG4gIHZhciBzdGF0ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpc0RyYWdnaW5nSW50ZXJuYWxseTogZmFsc2UsXG4gICAgaXNVcGRhdGluZ1NlbGVjdGlvbjogZmFsc2UsXG4gICAgbGF0ZXN0RWxlbWVudDogbnVsbCxcbiAgICBoYXNNYXJrUGxhY2Vob2xkZXI6IGZhbHNlXG4gIH0pLCBbXSk7IC8vIFRoZSBhdXRvRm9jdXMgVGV4dGFyZWFIVE1MQXR0cmlidXRlIGRvZXNuJ3QgZG8gYW55dGhpbmcgb24gYSBkaXYsIHNvIGl0XG4gIC8vIG5lZWRzIHRvIGJlIG1hbnVhbGx5IGZvY3VzZWQuXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQgJiYgYXV0b0ZvY3VzKSB7XG4gICAgICByZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cbiAgfSwgW2F1dG9Gb2N1c10pOyAvLyBMaXN0ZW4gb24gdGhlIG5hdGl2ZSBgc2VsZWN0aW9uY2hhbmdlYCBldmVudCB0byBiZSBhYmxlIHRvIHVwZGF0ZSBhbnkgdGltZVxuICAvLyB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBSZWFjdCdzIGBvblNlbGVjdGAgaXMgbGVha3lcbiAgLy8gYW5kIG5vbi1zdGFuZGFyZCBzbyBpdCBkb2Vzbid0IGZpcmUgdW50aWwgYWZ0ZXIgYSBzZWxlY3Rpb24gaGFzIGJlZW5cbiAgLy8gcmVsZWFzZWQuIFRoaXMgY2F1c2VzIGlzc3VlcyBpbiBzaXR1YXRpb25zIHdoZXJlIGFub3RoZXIgY2hhbmdlIGhhcHBlbnNcbiAgLy8gd2hpbGUgYSBzZWxlY3Rpb24gaXMgYmVpbmcgZHJhZ2dlZC5cblxuICB2YXIgb25ET01TZWxlY3Rpb25DaGFuZ2UgPSB1c2VDYWxsYmFjayh0aHJvdHRsZSgoKSA9PiB7XG4gICAgaWYgKChJU19BTkRST0lEIHx8ICFSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSAmJiAoIXN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gfHwgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gbnVsbCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSB2b2lkIDAgJiYgYW5kcm9pZElucHV0TWFuYWdlci5pc0ZsdXNoaW5nKCkpICYmICFzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSkge1xuICAgICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICAgIHZhciB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICAgIH0gPSByb290O1xuICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgIHZhciBkb21TZWxlY3Rpb24gPSByb290LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZWwpIHtcbiAgICAgICAgc3RhdGUubGF0ZXN0RWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBJU19GT0NVU0VELmRlbGV0ZShlZGl0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRvbVNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICBhbmNob3JOb2RlLFxuICAgICAgICBmb2N1c05vZGVcbiAgICAgIH0gPSBkb21TZWxlY3Rpb247XG4gICAgICB2YXIgYW5jaG9yTm9kZVNlbGVjdGFibGUgPSBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGFuY2hvck5vZGUpIHx8IFJlYWN0RWRpdG9yLmlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkKGVkaXRvciwgYW5jaG9yTm9kZSk7XG4gICAgICB2YXIgZm9jdXNOb2RlU2VsZWN0YWJsZSA9IFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZm9jdXNOb2RlKSB8fCBSZWFjdEVkaXRvci5pc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZChlZGl0b3IsIGZvY3VzTm9kZSk7XG5cbiAgICAgIGlmIChhbmNob3JOb2RlU2VsZWN0YWJsZSAmJiBmb2N1c05vZGVTZWxlY3RhYmxlKSB7XG4gICAgICAgIHZhciByYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgaWYgKCFSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpICYmICEoYW5kcm9pZElucHV0TWFuYWdlciAhPT0gbnVsbCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSB2b2lkIDAgJiYgYW5kcm9pZElucHV0TWFuYWdlci5oYXNQZW5kaW5nQ2hhbmdlcygpKSAmJiAhKGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IG51bGwgJiYgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gdm9pZCAwICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIuaXNGbHVzaGluZygpKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IG51bGwgfHwgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5kcm9pZElucHV0TWFuYWdlci5oYW5kbGVVc2VyU2VsZWN0KHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRGVzZWxlY3QgdGhlIGVkaXRvciBpZiB0aGUgZG9tIHNlbGVjdGlvbiBpcyBub3Qgc2VsZWN0YWJsZSBpbiByZWFkb25seSBtb2RlXG5cblxuICAgICAgaWYgKHJlYWRPbmx5ICYmICghYW5jaG9yTm9kZVNlbGVjdGFibGUgfHwgIWZvY3VzTm9kZVNlbGVjdGFibGUpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIDEwMCksIFtyZWFkT25seV0pO1xuICB2YXIgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSA9IHVzZU1lbW8oKCkgPT4gZGVib3VuY2Uob25ET01TZWxlY3Rpb25DaGFuZ2UsIDApLCBbb25ET01TZWxlY3Rpb25DaGFuZ2VdKTtcbiAgdmFyIGFuZHJvaWRJbnB1dE1hbmFnZXIgPSB1c2VBbmRyb2lkSW5wdXRNYW5hZ2VyKHtcbiAgICBub2RlOiByZWYsXG4gICAgb25ET01TZWxlY3Rpb25DaGFuZ2UsXG4gICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZVxuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgLy8gVXBkYXRlIGVsZW1lbnQtcmVsYXRlZCB3ZWFrIG1hcHMgd2l0aCB0aGUgRE9NIGVsZW1lbnQgcmVmLlxuICAgIHZhciB3aW5kb3c7XG5cbiAgICBpZiAocmVmLmN1cnJlbnQgJiYgKHdpbmRvdyA9IGdldERlZmF1bHRWaWV3KHJlZi5jdXJyZW50KSkpIHtcbiAgICAgIEVESVRPUl9UT19XSU5ET1cuc2V0KGVkaXRvciwgd2luZG93KTtcbiAgICAgIEVESVRPUl9UT19FTEVNRU5ULnNldChlZGl0b3IsIHJlZi5jdXJyZW50KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5zZXQoZWRpdG9yLCByZWYuY3VycmVudCk7XG4gICAgICBFTEVNRU5UX1RPX05PREUuc2V0KHJlZi5jdXJyZW50LCBlZGl0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgfSAvLyBNYWtlIHN1cmUgdGhlIERPTSBzZWxlY3Rpb24gc3RhdGUgaXMgaW4gc3luYy5cblxuXG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICB2YXIgZG9tU2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghZG9tU2VsZWN0aW9uIHx8ICFSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSB8fCBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSBudWxsICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IHZvaWQgMCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZXREb21TZWxlY3Rpb24gPSBmb3JjZUNoYW5nZSA9PiB7XG4gICAgICB2YXIgaGFzRG9tU2VsZWN0aW9uID0gZG9tU2VsZWN0aW9uLnR5cGUgIT09ICdOb25lJzsgLy8gSWYgdGhlIERPTSBzZWxlY3Rpb24gaXMgcHJvcGVybHkgdW5zZXQsIHdlJ3JlIGRvbmUuXG5cbiAgICAgIGlmICghc2VsZWN0aW9uICYmICFoYXNEb21TZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyB2ZXJpZnkgdGhhdCB0aGUgZG9tIHNlbGVjdGlvbiBpcyBpbiB0aGUgZWRpdG9yXG5cblxuICAgICAgdmFyIGVkaXRvckVsZW1lbnQgPSBFRElUT1JfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICAgIHZhciBoYXNEb21TZWxlY3Rpb25JbkVkaXRvciA9IGZhbHNlO1xuXG4gICAgICBpZiAoZWRpdG9yRWxlbWVudC5jb250YWlucyhkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSkgJiYgZWRpdG9yRWxlbWVudC5jb250YWlucyhkb21TZWxlY3Rpb24uZm9jdXNOb2RlKSkge1xuICAgICAgICBoYXNEb21TZWxlY3Rpb25JbkVkaXRvciA9IHRydWU7XG4gICAgICB9IC8vIElmIHRoZSBET00gc2VsZWN0aW9uIGlzIGluIHRoZSBlZGl0b3IgYW5kIHRoZSBlZGl0b3Igc2VsZWN0aW9uIGlzIGFscmVhZHkgY29ycmVjdCwgd2UncmUgZG9uZS5cblxuXG4gICAgICBpZiAoaGFzRG9tU2VsZWN0aW9uICYmIGhhc0RvbVNlbGVjdGlvbkluRWRpdG9yICYmIHNlbGVjdGlvbiAmJiAhZm9yY2VDaGFuZ2UpIHtcbiAgICAgICAgdmFyIHNsYXRlUmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21TZWxlY3Rpb24sIHtcbiAgICAgICAgICBleGFjdE1hdGNoOiB0cnVlLFxuICAgICAgICAgIC8vIGRvbVNlbGVjdGlvbiBpcyBub3QgbmVjZXNzYXJpbHkgYSB2YWxpZCBTbGF0ZSByYW5nZVxuICAgICAgICAgIC8vIChlLmcuIHdoZW4gY2xpY2tpbmcgb24gY29udGVudEVkaXRhYmxlOmZhbHNlIGVsZW1lbnQpXG4gICAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2xhdGVSYW5nZSAmJiBSYW5nZS5lcXVhbHMoc2xhdGVSYW5nZSwgc2VsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBfYW5jaG9yTm9kZSRwYXJlbnRFbGU7XG5cbiAgICAgICAgICBpZiAoIXN0YXRlLmhhc01hcmtQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gRW5zdXJlIHNlbGVjdGlvbiBpcyBpbnNpZGUgdGhlIG1hcmsgcGxhY2Vob2xkZXJcblxuXG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIGFuY2hvck5vZGVcbiAgICAgICAgICB9ID0gZG9tU2VsZWN0aW9uO1xuXG4gICAgICAgICAgaWYgKGFuY2hvck5vZGUgIT09IG51bGwgJiYgYW5jaG9yTm9kZSAhPT0gdm9pZCAwICYmIChfYW5jaG9yTm9kZSRwYXJlbnRFbGUgPSBhbmNob3JOb2RlLnBhcmVudEVsZW1lbnQpICE9PSBudWxsICYmIF9hbmNob3JOb2RlJHBhcmVudEVsZSAhPT0gdm9pZCAwICYmIF9hbmNob3JOb2RlJHBhcmVudEVsZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbWFyay1wbGFjZWhvbGRlcicpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIHdoZW4gPEVkaXRhYmxlLz4gaXMgYmVpbmcgY29udHJvbGxlZCB0aHJvdWdoIGV4dGVybmFsIHZhbHVlXG4gICAgICAvLyB0aGVuIGl0cyBjaGlsZHJlbiBtaWdodCBqdXN0IGNoYW5nZSAtIERPTSByZXNwb25kcyB0byBpdCBvbiBpdHMgb3duXG4gICAgICAvLyBidXQgU2xhdGUncyB2YWx1ZSBpcyBub3QgYmVpbmcgdXBkYXRlZCB0aHJvdWdoIGFueSBvcGVyYXRpb25cbiAgICAgIC8vIGFuZCB0aHVzIGl0IGRvZXNuJ3QgdHJhbnNmb3JtIHNlbGVjdGlvbiBvbiBpdHMgb3duXG5cblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiAhUmVhY3RFZGl0b3IuaGFzUmFuZ2UoZWRpdG9yLCBzZWxlY3Rpb24pKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21TZWxlY3Rpb24sIHtcbiAgICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIE90aGVyd2lzZSB0aGUgRE9NIHNlbGVjdGlvbiBpcyBvdXQgb2Ygc3luYywgc28gdXBkYXRlIGl0LlxuXG5cbiAgICAgIHN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgdmFyIG5ld0RvbVJhbmdlID0gc2VsZWN0aW9uICYmIFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCBzZWxlY3Rpb24pO1xuXG4gICAgICBpZiAobmV3RG9tUmFuZ2UpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5zZXRCYXNlQW5kRXh0ZW50KG5ld0RvbVJhbmdlLmVuZENvbnRhaW5lciwgbmV3RG9tUmFuZ2UuZW5kT2Zmc2V0LCBuZXdEb21SYW5nZS5zdGFydENvbnRhaW5lciwgbmV3RG9tUmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5zZXRCYXNlQW5kRXh0ZW50KG5ld0RvbVJhbmdlLnN0YXJ0Q29udGFpbmVyLCBuZXdEb21SYW5nZS5zdGFydE9mZnNldCwgbmV3RG9tUmFuZ2UuZW5kQ29udGFpbmVyLCBuZXdEb21SYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcoZWRpdG9yLCBuZXdEb21SYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdEb21SYW5nZTtcbiAgICB9O1xuXG4gICAgdmFyIG5ld0RvbVJhbmdlID0gc2V0RG9tU2VsZWN0aW9uKCk7XG4gICAgdmFyIGVuc3VyZVNlbGVjdGlvbiA9IChhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSBudWxsIHx8IGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuZHJvaWRJbnB1dE1hbmFnZXIuaXNGbHVzaGluZygpKSA9PT0gJ2FjdGlvbic7XG5cbiAgICBpZiAoIUlTX0FORFJPSUQgfHwgIWVuc3VyZVNlbGVjdGlvbikge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vIENPTVBBVDogSW4gRmlyZWZveCwgaXQncyBub3QgZW5vdWdoIHRvIGNyZWF0ZSBhIHJhbmdlLCB5b3UgYWxzbyBuZWVkXG4gICAgICAgIC8vIHRvIGZvY3VzIHRoZSBjb250ZW50ZWRpdGFibGUgZWxlbWVudCB0b28uICgyMDE2LzExLzE2KVxuICAgICAgICBpZiAobmV3RG9tUmFuZ2UgJiYgSVNfRklSRUZPWCkge1xuICAgICAgICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0aW1lb3V0SWQgPSBudWxsO1xuICAgIHZhciBhbmltYXRpb25GcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmIChlbnN1cmVTZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGVuc3VyZURvbVNlbGVjdGlvbiA9IGZvcmNlQ2hhbmdlID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgICAgICBzZXREb21TZWxlY3Rpb24oZm9yY2VDaGFuZ2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHsvLyBJZ25vcmUsIGRvbSBhbmQgc3RhdGUgbWlnaHQgYmUgb3V0IG9mIHN5bmNcbiAgICAgICAgICB9XG4gICAgICAgIH07IC8vIENvbXBhdDogQW5kcm9pZCBJTUVzIHRyeSB0byBmb3JjZSB0aGVpciBzZWxlY3Rpb24gYnkgbWFudWFsbHkgcmUtYXBwbHlpbmcgaXQgZXZlbiBhZnRlciB3ZSBzZXQgaXQuXG4gICAgICAgIC8vIFRoaXMgZXNzZW50aWFsbHkgd291bGQgbWFrZSBzZXR0aW5nIHRoZSBzbGF0ZSBzZWxlY3Rpb24gZHVyaW5nIGFuIHVwZGF0ZSBtZWFuaW5nbGVzcywgc28gd2UgZm9yY2UgaXRcbiAgICAgICAgLy8gYWdhaW4gaGVyZS4gV2UgY2FuJ3Qgb25seSBkbyBpdCBpbiB0aGUgc2V0VGltZW91dCBhZnRlciB0aGUgYW5pbWF0aW9uIGZyYW1lIHNpbmNlIHRoYXQgd291bGQgY2F1c2UgYVxuICAgICAgICAvLyB2aXNpYmxlIGZsaWNrZXIuXG5cblxuICAgICAgICBlbnN1cmVEb21TZWxlY3Rpb24oKTtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgLy8gQ09NUEFUOiBXaGlsZSBzZXR0aW5nIHRoZSBzZWxlY3Rpb24gaW4gYW4gYW5pbWF0aW9uIGZyYW1lIHZpc3VhbGx5IGNvcnJlY3RseSBzZXRzIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgICAgLy8gaXQgZG9lc24ndCB1cGRhdGUgR0JvYXJkcyBzcGVsbGNoZWNrZXIgc3RhdGUuIFdlIGhhdmUgdG8gbWFudWFsbHkgdHJpZ2dlciBhIHNlbGVjdGlvbiBjaGFuZ2UgYWZ0ZXJcbiAgICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIGZyYW1lIHRvIGVuc3VyZSBpdCBkaXNwbGF5cyB0aGUgY29ycmVjdCBzdGF0ZS5cbiAgICAgICAgICBlbnN1cmVEb21TZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZCk7XG5cbiAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7IC8vIExpc3RlbiBvbiB0aGUgbmF0aXZlIGBiZWZvcmVpbnB1dGAgZXZlbnQgdG8gZ2V0IHJlYWwgXCJMZXZlbCAyXCIgZXZlbnRzLiBUaGlzXG4gIC8vIGlzIHJlcXVpcmVkIGJlY2F1c2UgUmVhY3QncyBgYmVmb3JlaW5wdXRgIGlzIGZha2UgYW5kIG5ldmVyIHJlYWxseSBhdHRhY2hlc1xuICAvLyB0byB0aGUgcmVhbCBldmVudCBzYWRseS4gKDIwMTkvMTEvMDEpXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTEyMTFcblxuICB2YXIgb25ET01CZWZvcmVJbnB1dCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBvblVzZXJJbnB1dCgpO1xuXG4gICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRE9NRXZlbnRIYW5kbGVkKGV2ZW50LCBwcm9wc09uRE9NQmVmb3JlSW5wdXQpKSB7XG4gICAgICB2YXIgX0VESVRPUl9UT19VU0VSX1NFTEVDO1xuXG4gICAgICAvLyBDT01QQVQ6IEJlZm9yZUlucHV0IGV2ZW50cyBhcmVuJ3QgY2FuY2VsYWJsZSBvbiBhbmRyb2lkLCBzbyB3ZSBoYXZlIHRvIGhhbmRsZSB0aGVtIGRpZmZlcmVudGx5IHVzaW5nIHRoZSBhbmRyb2lkIGlucHV0IG1hbmFnZXIuXG4gICAgICBpZiAoYW5kcm9pZElucHV0TWFuYWdlcikge1xuICAgICAgICByZXR1cm4gYW5kcm9pZElucHV0TWFuYWdlci5oYW5kbGVET01CZWZvcmVJbnB1dChldmVudCk7XG4gICAgICB9IC8vIFNvbWUgSU1Fcy9DaHJvbWUgZXh0ZW5zaW9ucyBsaWtlIGUuZy4gR3JhbW1hcmx5IHNldCB0aGUgc2VsZWN0aW9uIGltbWVkaWF0ZWx5IGJlZm9yZVxuICAgICAgLy8gdHJpZ2dlcmluZyBhIGBiZWZvcmVpbnB1dGAgZXhwZWN0aW5nIHRoZSBjaGFuZ2UgdG8gYmUgYXBwbGllZCB0byB0aGUgaW1tZWRpYXRlbHkgYmVmb3JlXG4gICAgICAvLyBzZXQgc2VsZWN0aW9uLlxuXG5cbiAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UuZmx1c2goKTtcbiAgICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG4gICAgICB2YXIge1xuICAgICAgICBpbnB1dFR5cGU6IHR5cGVcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YVRyYW5zZmVyIHx8IGV2ZW50LmRhdGEgfHwgdW5kZWZpbmVkO1xuICAgICAgdmFyIGlzQ29tcG9zaXRpb25DaGFuZ2UgPSB0eXBlID09PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0JyB8fCB0eXBlID09PSAnZGVsZXRlQ29tcG9zaXRpb25UZXh0JzsgLy8gQ09NUEFUOiB1c2UgY29tcG9zaXRpb24gY2hhbmdlIGV2ZW50cyBhcyBhIGhpbnQgdG8gd2hlcmUgd2Ugc2hvdWxkIGluc2VydFxuICAgICAgLy8gY29tcG9zaXRpb24gdGV4dCBpZiB3ZSBhcmVuJ3QgY29tcG9zaW5nIHRvIHdvcmsgYXJvdW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9pc3N1ZXMvNTAzOFxuXG4gICAgICBpZiAoaXNDb21wb3NpdGlvbkNoYW5nZSAmJiBSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hdGl2ZSA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2luc2VydFRleHQnICYmIHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pICYmIC8vIE9ubHkgdXNlIG5hdGl2ZSBjaGFyYWN0ZXIgaW5zZXJ0aW9uIGZvciBzaW5nbGUgY2hhcmFjdGVycyBhLXogb3Igc3BhY2UgZm9yIG5vdy5cbiAgICAgIC8vIExvbmctcHJlc3MgZXZlbnRzIChob2xkIGEgKyBwcmVzcyA0ID0gw6QpIHRvIGNob29zZSBhIHNwZWNpYWwgY2hhcmFjdGVyIG90aGVyd2lzZVxuICAgICAgLy8gY2F1c2VzIGR1cGxpY2F0ZSBpbnNlcnRzLlxuICAgICAgZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLmxlbmd0aCA9PT0gMSAmJiAvW2EteiBdL2kudGVzdChldmVudC5kYXRhKSAmJiAvLyBDaHJvbWUgaGFzIGlzc3VlcyBjb3JyZWN0bHkgZWRpdGluZyB0aGUgc3RhcnQgb2Ygbm9kZXM6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyNDk0MDVcbiAgICAgIC8vIFdoZW4gdGhlcmUgaXMgYW4gaW5saW5lIGVsZW1lbnQsIGUuZy4gYSBsaW5rLCBhbmQgeW91IHNlbGVjdFxuICAgICAgLy8gcmlnaHQgYWZ0ZXIgaXQgKHRoZSBzdGFydCBvZiB0aGUgbmV4dCBub2RlKS5cbiAgICAgIHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIHZhciBfbm9kZSRwYXJlbnRFbGVtZW50LCBfd2luZG93JGdldENvbXB1dGVkU3Q7XG5cbiAgICAgICAgbmF0aXZlID0gdHJ1ZTsgLy8gU2tpcCBuYXRpdmUgaWYgdGhlcmUgYXJlIG1hcmtzLCBhc1xuICAgICAgICAvLyBgaW5zZXJ0VGV4dGAgd2lsbCBpbnNlcnQgYSBub2RlLCBub3QganVzdCB0ZXh0LlxuXG4gICAgICAgIGlmIChlZGl0b3IubWFya3MpIHtcbiAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfSAvLyBDaHJvbWUgYWxzbyBoYXMgaXNzdWVzIGNvcnJlY3RseSBlZGl0aW5nIHRoZSBlbmQgb2YgYW5jaG9yIGVsZW1lbnRzOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjU5MTAwXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBkb24ndCBhbGxvdyBuYXRpdmUgZXZlbnRzIHRvIGluc2VydCB0ZXh0IGF0IHRoZSBlbmQgb2YgYW5jaG9yIG5vZGVzLlxuXG5cbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBhbmNob3JcbiAgICAgICAgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgdmFyIFtub2RlLCBvZmZzZXRdID0gUmVhY3RFZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGFuY2hvcik7XG4gICAgICAgIHZhciBhbmNob3JOb2RlID0gKF9ub2RlJHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9ub2RlJHBhcmVudEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJHBhcmVudEVsZW1lbnQuY2xvc2VzdCgnYScpO1xuICAgICAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG5cbiAgICAgICAgaWYgKG5hdGl2ZSAmJiBhbmNob3JOb2RlICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCBhbmNob3JOb2RlKSkge1xuICAgICAgICAgIHZhciBfbGFzdFRleHQkdGV4dENvbnRlbnQ7XG5cbiAgICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHRleHQgbm9kZSBpbnNpZGUgdGhlIGFuY2hvci5cbiAgICAgICAgICB2YXIgbGFzdFRleHQgPSB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihhbmNob3JOb2RlLCBOb2RlRmlsdGVyLlNIT1dfVEVYVCkubGFzdENoaWxkKCk7XG5cbiAgICAgICAgICBpZiAobGFzdFRleHQgPT09IG5vZGUgJiYgKChfbGFzdFRleHQkdGV4dENvbnRlbnQgPSBsYXN0VGV4dC50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgX2xhc3RUZXh0JHRleHRDb250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGFzdFRleHQkdGV4dENvbnRlbnQubGVuZ3RoKSA9PT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ2hyb21lIGhhcyBpc3N1ZXMgd2l0aCB0aGUgcHJlc2VuY2Ugb2YgdGFiIGNoYXJhY3RlcnMgaW5zaWRlIGVsZW1lbnRzIHdpdGggd2hpdGVTcGFjZSA9ICdwcmUnXG4gICAgICAgIC8vIGNhdXNpbmcgYWJub3JtYWwgaW5zZXJ0IGJlaGF2aW9yOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjE5MTM5XG5cblxuICAgICAgICBpZiAobmF0aXZlICYmIG5vZGUucGFyZW50RWxlbWVudCAmJiAod2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF93aW5kb3ckZ2V0Q29tcHV0ZWRTdCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUucGFyZW50RWxlbWVudCkpID09PSBudWxsIHx8IF93aW5kb3ckZ2V0Q29tcHV0ZWRTdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvdyRnZXRDb21wdXRlZFN0LndoaXRlU3BhY2UpID09PSAncHJlJykge1xuICAgICAgICAgIHZhciBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBhbmNob3IucGF0aCxcbiAgICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGJsb2NrICYmIE5vZGUuc3RyaW5nKGJsb2NrWzBdKS5pbmNsdWRlcygnXFx0JykpIHtcbiAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDT01QQVQ6IEZvciB0aGUgZGVsZXRpbmcgZm9yd2FyZC9iYWNrd2FyZCBpbnB1dCB0eXBlcyB3ZSBkb24ndCB3YW50XG4gICAgICAvLyB0byBjaGFuZ2UgdGhlIHNlbGVjdGlvbiBiZWNhdXNlIGl0IGlzIHRoZSByYW5nZSB0aGF0IHdpbGwgYmUgZGVsZXRlZCxcbiAgICAgIC8vIGFuZCB0aG9zZSBjb21tYW5kcyBkZXRlcm1pbmUgdGhhdCBmb3IgdGhlbXNlbHZlcy5cblxuXG4gICAgICBpZiAoIXR5cGUuc3RhcnRzV2l0aCgnZGVsZXRlJykgfHwgdHlwZS5zdGFydHNXaXRoKCdkZWxldGVCeScpKSB7XG4gICAgICAgIHZhciBbdGFyZ2V0UmFuZ2VdID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKCk7XG5cbiAgICAgICAgaWYgKHRhcmdldFJhbmdlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgdGFyZ2V0UmFuZ2UsIHtcbiAgICAgICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoc2VsZWN0aW9uLCByYW5nZSkpIHtcbiAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblJlZiA9ICFpc0NvbXBvc2l0aW9uQ2hhbmdlICYmIGVkaXRvci5zZWxlY3Rpb24gJiYgRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvblJlZikge1xuICAgICAgICAgICAgICBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uc2V0KGVkaXRvciwgc2VsZWN0aW9uUmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ29tcG9zaXRpb24gY2hhbmdlIHR5cGVzIG9jY3VyIHdoaWxlIGEgdXNlciBpcyBjb21wb3NpbmcgdGV4dCBhbmQgY2FuJ3QgYmVcbiAgICAgIC8vIGNhbmNlbGxlZC4gTGV0IHRoZW0gdGhyb3VnaCBhbmQgd2FpdCBmb3IgdGhlIGNvbXBvc2l0aW9uIHRvIGVuZC5cblxuXG4gICAgICBpZiAoaXNDb21wb3NpdGlvbkNoYW5nZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbmF0aXZlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IC8vIENPTVBBVDogSWYgdGhlIHNlbGVjdGlvbiBpcyBleHBhbmRlZCwgZXZlbiBpZiB0aGUgY29tbWFuZCBzZWVtcyBsaWtlXG4gICAgICAvLyBhIGRlbGV0ZSBmb3J3YXJkL2JhY2t3YXJkIGNvbW1hbmQgaXQgc2hvdWxkIGRlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuXG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pICYmIHR5cGUuc3RhcnRzV2l0aCgnZGVsZXRlJykpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHR5cGUuZW5kc1dpdGgoJ0JhY2t3YXJkJykgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnO1xuICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgZGlyZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkZWxldGVCeUNvbXBvc2l0aW9uJzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQnlDdXQnOlxuICAgICAgICBjYXNlICdkZWxldGVCeURyYWcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnQnOlxuICAgICAgICBjYXNlICdkZWxldGVDb250ZW50Rm9yd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVDb250ZW50QmFja3dhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZUVudGlyZVNvZnRMaW5lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVIYXJkTGluZUJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lQmFja3dhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVIYXJkTGluZUZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnNlcnRMaW5lQnJlYWsnOlxuICAgICAgICAgIEVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpbnNlcnRQYXJhZ3JhcGgnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5pbnNlcnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21Db21wb3NpdGlvbic6XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21Ecm9wJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbVlhbmsnOlxuICAgICAgICBjYXNlICdpbnNlcnRSZXBsYWNlbWVudFRleHQnOlxuICAgICAgICBjYXNlICdpbnNlcnRUZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2luc2VydEZyb21Db21wb3NpdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQ09NUEFUOiBpbiBTYWZhcmksIGBjb21wb3NpdGlvbmVuZGAgaXMgZGlzcGF0Y2hlZCBhZnRlciB0aGVcbiAgICAgICAgICAgICAgLy8gYGJlZm9yZWlucHV0YCBmb3IgXCJpbnNlcnRGcm9tQ29tcG9zaXRpb25cIi4gQnV0IGlmIHdlIHdhaXQgZm9yIGl0XG4gICAgICAgICAgICAgIC8vIHRoZW4gd2Ugd2lsbCBhYm9ydCBiZWNhdXNlIHdlJ3JlIHN0aWxsIGNvbXBvc2luZyBhbmQgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAvLyB3b24ndCBiZSB1cGRhdGVkIHByb3Blcmx5LlxuICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaW5wdXQtZXZlbnRzLTIvXG4gICAgICAgICAgICAgIGlmIChSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgc2V0SXNDb21wb3NpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gdXNlIGEgd2VhayBjb21wYXJpc29uIGluc3RlYWQgb2YgJ2luc3RhbmNlb2YnIHRvIGFsbG93XG4gICAgICAgICAgICAvLyBwcm9ncmFtbWF0aWMgYWNjZXNzIG9mIHBhc3RlIGV2ZW50cyBjb21pbmcgZnJvbSBleHRlcm5hbCB3aW5kb3dzXG4gICAgICAgICAgICAvLyBsaWtlIGN5cHJlc3Mgd2hlcmUgY3kud2luZG93IGRvZXMgbm90IHdvcmsgcmVhbGlibHlcblxuXG4gICAgICAgICAgICBpZiAoKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb25zdHJ1Y3Rvci5uYW1lKSA9PT0gJ0RhdGFUcmFuc2ZlcicpIHtcbiAgICAgICAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgLy8gT25seSBpbnNlcnRUZXh0IG9wZXJhdGlvbnMgdXNlIHRoZSBuYXRpdmUgZnVuY3Rpb25hbGl0eSwgZm9yIG5vdy5cbiAgICAgICAgICAgICAgLy8gUG90ZW50aWFsbHkgZXhwYW5kIHRvIHNpbmdsZSBjaGFyYWN0ZXIgZGVsZXRlcywgYXMgd2VsbC5cbiAgICAgICAgICAgICAgaWYgKG5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkT3BlcmF0aW9ucy5jdXJyZW50LnB1c2goKCkgPT4gRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkYXRhKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9IC8vIFJlc3RvcmUgdGhlIGFjdHVhbCB1c2VyIHNlY3Rpb24gaWYgbm90aGluZyBtYW51YWxseSBzZXQgaXQuXG5cblxuICAgICAgdmFyIHRvUmVzdG9yZSA9IChfRURJVE9SX1RPX1VTRVJfU0VMRUMgPSBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19VU0VSX1NFTEVDLnVucmVmKCk7XG4gICAgICBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZGVsZXRlKGVkaXRvcik7XG5cbiAgICAgIGlmICh0b1Jlc3RvcmUgJiYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbiwgdG9SZXN0b3JlKSkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB0b1Jlc3RvcmUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3JlYWRPbmx5LCBwcm9wc09uRE9NQmVmb3JlSW5wdXRdKTtcbiAgdmFyIGNhbGxiYWNrUmVmID0gdXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG4gICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgRURJVE9SX1RPX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG5cbiAgICAgIGlmIChyZWYuY3VycmVudCAmJiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBUaGUgYGJlZm9yZWlucHV0YCBldmVudCBpc24ndCByZWNvZ25pemVkLlxuICAgICAgICByZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIG9uRE9NQmVmb3JlSW5wdXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdHRhY2ggYSBuYXRpdmUgRE9NIGV2ZW50IGhhbmRsZXIgZm9yIGBiZWZvcmVpbnB1dGAgZXZlbnRzLCBiZWNhdXNlIFJlYWN0J3NcbiAgICAgIC8vIGJ1aWx0LWluIGBvbkJlZm9yZUlucHV0YCBpcyBhY3R1YWxseSBhIGxlYWt5IHBvbHlmaWxsIHRoYXQgZG9lc24ndCBleHBvc2VcbiAgICAgIC8vIHJlYWwgYGJlZm9yZWlucHV0YCBldmVudHMgc2FkbHkuLi4gKDIwMTkvMTEvMDQpXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExMjExXG4gICAgICBpZiAoSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgVGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQgaXNuJ3QgcmVjb2duaXplZC5cbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIG9uRE9NQmVmb3JlSW5wdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlZi5jdXJyZW50ID0gbm9kZTtcbiAgfSwgW3JlZiwgb25ET01CZWZvcmVJbnB1dCwgb25ET01TZWxlY3Rpb25DaGFuZ2UsIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2VdKTsgLy8gQXR0YWNoIGEgbmF0aXZlIERPTSBldmVudCBoYW5kbGVyIGZvciBgc2VsZWN0aW9uY2hhbmdlYCwgYmVjYXVzZSBSZWFjdCdzXG4gIC8vIGJ1aWx0LWluIGBvblNlbGVjdGAgaGFuZGxlciBkb2Vzbid0IGZpcmUgZm9yIGFsbCBzZWxlY3Rpb24gY2hhbmdlcy4gSXQncyBhXG4gIC8vIGxlYWt5IHBvbHlmaWxsIHRoYXQgb25seSBmaXJlcyBvbiBrZXlwcmVzc2VzIG9yIGNsaWNrcy4gSW5zdGVhZCwgd2Ugd2FudCB0b1xuICAvLyBmaXJlIGZvciBhbnkgY2hhbmdlIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBlZGl0b3IuICgyMDE5LzExLzA0KVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzU3ODVcblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW3NjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2VdKTtcbiAgdmFyIGRlY29yYXRpb25zID0gZGVjb3JhdGUoW2VkaXRvciwgW11dKTtcblxuICBpZiAocGxhY2Vob2xkZXIgJiYgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5mcm9tKE5vZGUudGV4dHMoZWRpdG9yKSkubGVuZ3RoID09PSAxICYmIE5vZGUuc3RyaW5nKGVkaXRvcikgPT09ICcnICYmICFpc0NvbXBvc2luZykge1xuICAgIHZhciBzdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKTtcbiAgICBkZWNvcmF0aW9ucy5wdXNoKHtcbiAgICAgIFtQTEFDRUhPTERFUl9TWU1CT0xdOiB0cnVlLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBhbmNob3I6IHN0YXJ0LFxuICAgICAgZm9jdXM6IHN0YXJ0XG4gICAgfSk7XG4gIH1cblxuICB2YXIge1xuICAgIG1hcmtzXG4gIH0gPSBlZGl0b3I7XG4gIHN0YXRlLmhhc01hcmtQbGFjZWhvbGRlciA9IGZhbHNlO1xuXG4gIGlmIChlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pICYmIG1hcmtzKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvclxuICAgIH0gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgIHZhciBsZWFmID0gTm9kZS5sZWFmKGVkaXRvciwgYW5jaG9yLnBhdGgpO1xuXG4gICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobGVhZiwgX2V4Y2x1ZGVkMik7IC8vIFdoaWxlIG1hcmtzIGlzbid0IGEgJ2NvbXBsZXRlJyB0ZXh0LCB3ZSBjYW4gc3RpbGwgdXNlIGxvb3NlIFRleHQuZXF1YWxzXG4gICAgLy8gaGVyZSB3aGljaCBvbmx5IGNvbXBhcmVzIG1hcmtzIGFueXdheS5cblxuXG4gICAgaWYgKCFUZXh0JDEuZXF1YWxzKGxlYWYsIG1hcmtzLCB7XG4gICAgICBsb29zZTogdHJ1ZVxuICAgIH0pKSB7XG4gICAgICBzdGF0ZS5oYXNNYXJrUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgdmFyIHVuc2V0ID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKHJlc3QpLm1hcChtYXJrID0+IFttYXJrLCBudWxsXSkpO1xuICAgICAgZGVjb3JhdGlvbnMucHVzaChfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7XG4gICAgICAgIFtNQVJLX1BMQUNFSE9MREVSX1NZTUJPTF06IHRydWVcbiAgICAgIH0sIHVuc2V0KSwgbWFya3MpLCB7fSwge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzOiBhbmNob3JcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0gLy8gVXBkYXRlIEVESVRPUl9UT19NQVJLX1BMQUNFSE9MREVSX01BUktTIGluIHNldFRpbWVvdXQgdXNlRWZmZWN0IHRvIGVuc3VyZSB3ZSBkb24ndCBzZXQgaXRcbiAgLy8gYmVmb3JlIHdlIHJlY2VpdmUgdGhlIGNvbXBvc2l0aW9uIGVuZCBldmVudC5cblxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBhbmNob3I6IF9hbmNob3JcbiAgICAgICAgfSA9IHNlbGVjdGlvbjtcblxuICAgICAgICB2YXIgX3RleHQgPSBOb2RlLmxlYWYoZWRpdG9yLCBfYW5jaG9yLnBhdGgpOyAvLyBXaGlsZSBtYXJrcyBpc24ndCBhICdjb21wbGV0ZScgdGV4dCwgd2UgY2FuIHN0aWxsIHVzZSBsb29zZSBUZXh0LmVxdWFsc1xuICAgICAgICAvLyBoZXJlIHdoaWNoIG9ubHkgY29tcGFyZXMgbWFya3MgYW55d2F5LlxuXG5cbiAgICAgICAgaWYgKG1hcmtzICYmICFUZXh0JDEuZXF1YWxzKF90ZXh0LCBtYXJrcywge1xuICAgICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLnNldChlZGl0b3IsIG1hcmtzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgIH0pO1xuICB9KTtcbiAgdmFyIHBsYWNlaG9sZGVySGVpZ2h0ID0gKF9FRElUT1JfVE9fUExBQ0VIT0xERSA9IEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1BMQUNFSE9MREUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfRURJVE9SX1RPX1BMQUNFSE9MREUyID0gX0VESVRPUl9UT19QTEFDRUhPTERFLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1BMQUNFSE9MREUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1BMQUNFSE9MREUyLmhlaWdodDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWRPbmx5Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiByZWFkT25seVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWNvcmF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZGVjb3JhdGVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzdG9yZURPTSwge1xuICAgIG5vZGU6IHJlZixcbiAgICByZWNlaXZlZFVzZXJJbnB1dDogcmVjZWl2ZWRVc2VySW5wdXRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBPYmplY3QuYXNzaWduKHtcbiAgICByb2xlOiByZWFkT25seSA/IHVuZGVmaW5lZCA6ICd0ZXh0Ym94JyxcbiAgICBcImFyaWEtbXVsdGlsaW5lXCI6IHJlYWRPbmx5ID8gdW5kZWZpbmVkIDogdHJ1ZVxuICB9LCBhdHRyaWJ1dGVzLCB7XG4gICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlJ2RcbiAgICAvLyBoYXZlIHRvIHVzZSBoYWNrcyB0byBtYWtlIHRoZXNlIHJlcGxhY2VtZW50LWJhc2VkIGZlYXR1cmVzIHdvcmsuXG4gICAgLy8gRm9yIFNTUiBzaXR1YXRpb25zIEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCBpcyBmYWxzZSBhbmQgcmVzdWx0cyBpbiBwcm9wXG4gICAgLy8gbWlzbWF0Y2ggd2FybmluZyBhcHAgbW92ZXMgdG8gYnJvd3Nlci4gUGFzcy10aHJvdWdoIGNvbnN1bWVyIHByb3BzIHdoZW5cbiAgICAvLyBub3QgQ0FOX1VTRV9ET00gKFNTUikgYW5kIGRlZmF1bHQgdG8gZmFsc3kgdmFsdWVcbiAgICBzcGVsbENoZWNrOiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgIUNBTl9VU0VfRE9NID8gYXR0cmlidXRlcy5zcGVsbENoZWNrIDogZmFsc2UsXG4gICAgYXV0b0NvcnJlY3Q6IEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCB8fCAhQ0FOX1VTRV9ET00gPyBhdHRyaWJ1dGVzLmF1dG9Db3JyZWN0IDogJ2ZhbHNlJyxcbiAgICBhdXRvQ2FwaXRhbGl6ZTogSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8ICFDQU5fVVNFX0RPTSA/IGF0dHJpYnV0ZXMuYXV0b0NhcGl0YWxpemUgOiAnZmFsc2UnLFxuICAgIFwiZGF0YS1zbGF0ZS1lZGl0b3JcIjogdHJ1ZSxcbiAgICBcImRhdGEtc2xhdGUtbm9kZVwiOiBcInZhbHVlXCIsXG4gICAgLy8gZXhwbGljaXRseSBzZXQgdGhpc1xuICAgIGNvbnRlbnRFZGl0YWJsZTogIXJlYWRPbmx5LFxuICAgIC8vIGluIHNvbWUgY2FzZXMsIGEgZGVjb3JhdGlvbiBuZWVkcyBhY2Nlc3MgdG8gdGhlIHJhbmdlIC8gc2VsZWN0aW9uIHRvIGRlY29yYXRlIGEgdGV4dCBub2RlLFxuICAgIC8vIHRoZW4geW91IHdpbGwgc2VsZWN0IHRoZSB3aG9sZSB0ZXh0IG5vZGUgd2hlbiB5b3Ugc2VsZWN0IHBhcnQgdGhlIG9mIHRleHRcbiAgICAvLyB0aGlzIG1hZ2ljIHpJbmRleD1cIi0xXCIgd2lsbCBmaXggaXRcbiAgICB6aW5kZXg6IC0xLFxuICAgIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgICByZWY6IGNhbGxiYWNrUmVmLFxuICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHt9LCBkaXNhYmxlRGVmYXVsdFN0eWxlcyA/IHt9IDogX29iamVjdFNwcmVhZCQxKHtcbiAgICAgIC8vIEFsbG93IHBvc2l0aW9uaW5nIHJlbGF0aXZlIHRvIHRoZSBlZGl0YWJsZSBlbGVtZW50LlxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAvLyBQcmV2ZW50IHRoZSBkZWZhdWx0IG91dGxpbmUgc3R5bGVzLlxuICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgLy8gUHJlc2VydmUgYWRqYWNlbnQgd2hpdGVzcGFjZSBhbmQgbmV3IGxpbmVzLlxuICAgICAgd2hpdGVTcGFjZTogJ3ByZS13cmFwJyxcbiAgICAgIC8vIEFsbG93IHdvcmRzIHRvIGJyZWFrIGlmIHRoZXkgYXJlIHRvbyBsb25nLlxuICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJ1xuICAgIH0sIHBsYWNlaG9sZGVySGVpZ2h0ID8ge1xuICAgICAgbWluSGVpZ2h0OiBwbGFjZWhvbGRlckhlaWdodFxuICAgIH0gOiB7fSkpLCB1c2VyU3R5bGUpLFxuICAgIG9uQmVmb3JlSW5wdXQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZVxuICAgICAgLy8gZmFsbCBiYWNrIHRvIFJlYWN0J3MgbGVha3kgcG9seWZpbGwgaW5zdGVhZCBqdXN0IGZvciBpdC4gSXRcbiAgICAgIC8vIG9ubHkgd29ya3MgZm9yIHRoZSBgaW5zZXJ0VGV4dGAgaW5wdXQgdHlwZS5cbiAgICAgIGlmICghSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUICYmICFyZWFkT25seSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25CZWZvcmVJbnB1dCkgJiYgUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICB2YXIgX3RleHQyID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIF90ZXh0Mik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHldKSxcbiAgICBvbklucHV0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25JbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5kcm9pZElucHV0TWFuYWdlcikge1xuICAgICAgICBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhbmRsZUlucHV0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRmx1c2ggbmF0aXZlIG9wZXJhdGlvbnMsIGFzIG5hdGl2ZSBldmVudHMgd2lsbCBoYXZlIHByb3BvZ2F0ZWRcbiAgICAgIC8vIGFuZCB3ZSBjYW4gY29ycmVjdGx5IGNvbXBhcmUgRE9NIHRleHQgdmFsdWVzIGluIGNvbXBvbmVudHNcbiAgICAgIC8vIHRvIHN0b3AgcmVuZGVyaW5nLCBzbyB0aGF0IGJyb3dzZXIgZnVuY3Rpb25zIGxpa2UgYXV0b2NvcnJlY3RcbiAgICAgIC8vIGFuZCBzcGVsbGNoZWNrIHdvcmsgYXMgZXhwZWN0ZWQuXG5cblxuICAgICAgZm9yICh2YXIgb3Agb2YgZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQpIHtcbiAgICAgICAgb3AoKTtcbiAgICAgIH1cblxuICAgICAgZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQgPSBbXTtcbiAgICB9LCBbXSksXG4gICAgb25CbHVyOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAocmVhZE9ubHkgfHwgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiB8fCAhUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgfHwgaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25CbHVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENPTVBBVDogSWYgdGhlIGN1cnJlbnQgYGFjdGl2ZUVsZW1lbnRgIGlzIHN0aWxsIHRoZSBwcmV2aW91c1xuICAgICAgLy8gb25lLCB0aGlzIGlzIGR1ZSB0byB0aGUgd2luZG93IGJlaW5nIGJsdXJyZWQgd2hlbiB0aGUgdGFiXG4gICAgICAvLyBpdHNlbGYgYmVjb21lcyB1bmZvY3VzZWQsIHNvIHdlIHdhbnQgdG8gYWJvcnQgZWFybHkgdG8gYWxsb3cgdG9cbiAgICAgIC8vIGVkaXRvciB0byBzdGF5IGZvY3VzZWQgd2hlbiB0aGUgdGFiIGJlY29tZXMgZm9jdXNlZCBhZ2Fpbi5cblxuXG4gICAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuXG4gICAgICBpZiAoc3RhdGUubGF0ZXN0RWxlbWVudCA9PT0gcm9vdC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTsgLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIHJldHVybmluZ1xuICAgICAgLy8gdG8gdGhlIGVkaXRvciBmcm9tIGFuIGVtYmVkZGVkIGVkaXRhYmxlIGVsZW1lbnQgKGVnLiBhbiA8aW5wdXQ+XG4gICAgICAvLyBlbGVtZW50IGluc2lkZSBhIHZvaWQgbm9kZSkuXG5cbiAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ID09PSBlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENPTVBBVDogVGhlIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkIGlmIHRoZSBmb2N1cyBpcyBtb3ZpbmcgZnJvbVxuICAgICAgLy8gdGhlIGVkaXRvciB0byBpbnNpZGUgYSB2b2lkIG5vZGUncyBzcGFjZXIgZWxlbWVudC5cblxuXG4gICAgICBpZiAoaXNET01FbGVtZW50KHJlbGF0ZWRUYXJnZXQpICYmIHJlbGF0ZWRUYXJnZXQuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLXNwYWNlcicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIG1vdmluZyB0byBhXG4gICAgICAvLyBub24tIGVkaXRhYmxlIHNlY3Rpb24gb2YgYW4gZWxlbWVudCB0aGF0IGlzbid0IGEgdm9pZCBub2RlIChlZy5cbiAgICAgIC8vIGEgbGlzdCBpdGVtIG9mIHRoZSBjaGVjayBsaXN0IGV4YW1wbGUpLlxuXG5cbiAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ICE9IG51bGwgJiYgaXNET01Ob2RlKHJlbGF0ZWRUYXJnZXQpICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCByZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgcmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc1ZvaWQobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ09NUEFUOiBTYWZhcmkgZG9lc24ndCBhbHdheXMgcmVtb3ZlIHRoZSBzZWxlY3Rpb24gZXZlbiBpZiB0aGUgY29udGVudC1cbiAgICAgIC8vIGVkaXRhYmxlIGVsZW1lbnQgbm8gbG9uZ2VyIGhhcyBmb2N1cy4gUmVmZXIgdG86XG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjM1MzI0Ny9mb3JjZS1jb250ZW50ZWRpdGFibGUtZGl2LXRvLXN0b3AtYWNjZXB0aW5nLWlucHV0LWFmdGVyLWl0LWxvc2VzLWZvY3VzLXVuZGVyLXdlYlxuXG5cbiAgICAgIGlmIChJU19TQUZBUkkpIHtcbiAgICAgICAgdmFyIGRvbVNlbGVjdGlvbiA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGRvbVNlbGVjdGlvbiA9PT0gbnVsbCB8fCBkb21TZWxlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cblxuICAgICAgSVNfRk9DVVNFRC5kZWxldGUoZWRpdG9yKTtcbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25CbHVyXSksXG4gICAgb25DbGljazogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ2xpY2spICYmIGlzRE9NTm9kZShldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgICAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7IC8vIEF0IHRoaXMgdGltZSwgdGhlIFNsYXRlIGRvY3VtZW50IG1heSBiZSBhcmJpdHJhcmlseSBkaWZmZXJlbnQsXG4gICAgICAgIC8vIGJlY2F1c2Ugb25DbGljayBoYW5kbGVycyBjYW4gY2hhbmdlIHRoZSBkb2N1bWVudCBiZWZvcmUgd2UgZ2V0IGhlcmUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhpcyBwYXRoIGFjdHVhbGx5IGV4aXN0cyxcbiAgICAgICAgLy8gYW5kIHRoYXQgaXQgc3RpbGwgcmVmZXJzIHRvIHRoZSBzYW1lIG5vZGUuXG5cbiAgICAgICAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpIHx8IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCkgIT09IG5vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGV0YWlsID09PSBUUklQTEVfQ0xJQ0sgJiYgcGF0aC5sZW5ndGggPj0gMSkge1xuICAgICAgICAgIHZhciBibG9ja1BhdGggPSBwYXRoO1xuXG4gICAgICAgICAgaWYgKCEoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG5vZGUpKSkge1xuICAgICAgICAgICAgdmFyIF9ibG9jayQ7XG5cbiAgICAgICAgICAgIHZhciBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudCQxLmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBibG9ja1BhdGggPSAoX2Jsb2NrJCA9IGJsb2NrID09PSBudWxsIHx8IGJsb2NrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9ja1sxXSkgIT09IG51bGwgJiYgX2Jsb2NrJCAhPT0gdm9pZCAwID8gX2Jsb2NrJCA6IHBhdGguc2xpY2UoMCwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYmxvY2tQYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVhZE9ubHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIHN0YXJ0Vm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBfc3RhcnRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbmRWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3RhcnRWb2lkICYmIGVuZFZvaWQgJiYgUGF0aC5lcXVhbHMoc3RhcnRWb2lkWzFdLCBlbmRWb2lkWzFdKSkge1xuICAgICAgICAgIHZhciBfcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBfc3RhcnQpO1xuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uQ2xpY2tdKSxcbiAgICBvbkNvbXBvc2l0aW9uRW5kOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyhmYWxzZSk7XG4gICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IG51bGwgfHwgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5kcm9pZElucHV0TWFuYWdlci5oYW5kbGVDb21wb3NpdGlvbkVuZChldmVudCk7XG5cbiAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25FbmQpIHx8IElTX0FORFJPSUQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBJbiBDaHJvbWUsIGBiZWZvcmVpbnB1dGAgZXZlbnRzIGZvciBjb21wb3NpdGlvbnNcbiAgICAgICAgLy8gYXJlbid0IGNvcnJlY3QgYW5kIG5ldmVyIGZpcmUgdGhlIFwiaW5zZXJ0RnJvbUNvbXBvc2l0aW9uXCJcbiAgICAgICAgLy8gdHlwZSB0aGF0IHdlIG5lZWQuIFNvIGluc3RlYWQsIGluc2VydCB3aGVuZXZlciBhIGNvbXBvc2l0aW9uXG4gICAgICAgIC8vIGVuZHMgc2luY2UgaXQgd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiBjb21taXR0ZWQgdG8gdGhlIERPTS5cblxuXG4gICAgICAgIGlmICghSVNfU0FGQVJJICYmICFJU19GSVJFRk9YX0xFR0FDWSAmJiAhSVNfSU9TICYmICFJU19XRUNIQVRCUk9XU0VSICYmICFJU19VQ19NT0JJTEUgJiYgZXZlbnQuZGF0YSkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlck1hcmtzID0gRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlZGl0b3IpO1xuICAgICAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5kZWxldGUoZWRpdG9yKTsgLy8gRW5zdXJlIHdlIGluc2VydCB0ZXh0IHdpdGggdGhlIG1hcmtzIHRoZSB1c2VyIHdhcyBhY3R1YWxseSBzZWVpbmdcblxuICAgICAgICAgIGlmIChwbGFjZWhvbGRlck1hcmtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEVESVRPUl9UT19VU0VSX01BUktTLnNldChlZGl0b3IsIGVkaXRvci5tYXJrcyk7XG4gICAgICAgICAgICBlZGl0b3IubWFya3MgPSBwbGFjZWhvbGRlck1hcmtzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgdmFyIHVzZXJNYXJrcyA9IEVESVRPUl9UT19VU0VSX01BUktTLmdldChlZGl0b3IpO1xuICAgICAgICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuXG4gICAgICAgICAgaWYgKHVzZXJNYXJrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0b3IubWFya3MgPSB1c2VyTWFya3M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db21wb3NpdGlvbkVuZF0pLFxuICAgIG9uQ29tcG9zaXRpb25VcGRhdGU6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db21wb3NpdGlvblVwZGF0ZSkpIHtcbiAgICAgICAgaWYgKCFSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgc2V0SXNDb21wb3NpbmcodHJ1ZSk7XG4gICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db21wb3NpdGlvblVwZGF0ZV0pLFxuICAgIG9uQ29tcG9zaXRpb25TdGFydDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IG51bGwgfHwgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5kcm9pZElucHV0TWFuYWdlci5oYW5kbGVDb21wb3NpdGlvblN0YXJ0KGV2ZW50KTtcblxuICAgICAgICBpZiAoaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db21wb3NpdGlvblN0YXJ0KSB8fCBJU19BTkRST0lEKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SXNDb21wb3NpbmcodHJ1ZSk7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbmxpbmUgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50JDEuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoaW5saW5lKSB7XG4gICAgICAgICAgICB2YXIgWywgaW5saW5lUGF0aF0gPSBpbmxpbmU7XG5cbiAgICAgICAgICAgIGlmIChFZGl0b3IuaXNFbmQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLCBpbmxpbmVQYXRoKSkge1xuICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBpbmxpbmVQYXRoKTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYW5jaG9yOiBwb2ludCxcbiAgICAgICAgICAgICAgICBmb2N1czogcG9pbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db21wb3NpdGlvblN0YXJ0XSksXG4gICAgb25Db3B5OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29weSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgUmVhY3RFZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZXZlbnQuY2xpcGJvYXJkRGF0YSwgJ2NvcHknKTtcbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvcHldKSxcbiAgICBvbkN1dDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25DdXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEsICdjdXQnKTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLnBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uQ3V0XSksXG4gICAgb25EcmFnT3ZlcjogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJhZ092ZXIpKSB7XG4gICAgICAgIC8vIE9ubHkgd2hlbiB0aGUgdGFyZ2V0IGlzIHZvaWQsIGNhbGwgYHByZXZlbnREZWZhdWx0YCB0byBzaWduYWxcbiAgICAgICAgLy8gdGhhdCBkcm9wcyBhcmUgYWxsb3dlZC4gRWRpdGFibGUgY29udGVudCBpcyBkcm9wcGFibGUgYnlcbiAgICAgICAgLy8gZGVmYXVsdCwgYW5kIGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBoaWRlcyB0aGUgY3Vyc29yLlxuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcblxuICAgICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25EcmFnT3Zlcl0pLFxuICAgIG9uRHJhZ1N0YXJ0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJhZ1N0YXJ0KSkge1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpO1xuICAgICAgICB2YXIgdm9pZE1hdGNoID0gRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkgfHwgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgfSk7IC8vIElmIHN0YXJ0aW5nIGEgZHJhZyBvbiBhIHZvaWQgbm9kZSwgbWFrZSBzdXJlIGl0IGlzIHNlbGVjdGVkXG4gICAgICAgIC8vIHNvIHRoYXQgaXQgc2hvd3MgdXAgaW4gdGhlIHNlbGVjdGlvbidzIGZyYWdtZW50LlxuXG4gICAgICAgIGlmICh2b2lkTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5ID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZXZlbnQuZGF0YVRyYW5zZmVyLCAnZHJhZycpO1xuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgYXR0cmlidXRlcy5vbkRyYWdTdGFydF0pLFxuICAgIG9uRHJvcDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkRyb3ApKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGRyYWdnZWQgcmFuZ2UgYmVmb3JlIHVwZGF0aW5nIHNlbGVjdGlvblxuXG4gICAgICAgIHZhciBkcmFnZ2VkUmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uOyAvLyBGaW5kIHRoZSByYW5nZSB3aGVyZSB0aGUgZHJvcCBoYXBwZW5lZFxuXG4gICAgICAgIHZhciByYW5nZSA9IFJlYWN0RWRpdG9yLmZpbmRFdmVudFJhbmdlKGVkaXRvciwgZXZlbnQpO1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5KSB7XG4gICAgICAgICAgaWYgKGRyYWdnZWRSYW5nZSAmJiAhUmFuZ2UuZXF1YWxzKGRyYWdnZWRSYW5nZSwgcmFuZ2UpICYmICFFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogZHJhZ2dlZFJhbmdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWFjdEVkaXRvci5pbnNlcnREYXRhKGVkaXRvciwgZGF0YSk7IC8vIFdoZW4gZHJhZ2dpbmcgZnJvbSBhbm90aGVyIHNvdXJjZSBpbnRvIHRoZSBlZGl0b3IsIGl0J3MgcG9zc2libGVcbiAgICAgICAgLy8gdGhhdCB0aGUgY3VycmVudCBlZGl0b3IgZG9lcyBub3QgaGF2ZSBmb2N1cy5cblxuICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpKSB7XG4gICAgICAgICAgUmVhY3RFZGl0b3IuZm9jdXMoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSA9IGZhbHNlO1xuICAgIH0sIFtyZWFkT25seSwgYXR0cmlidXRlcy5vbkRyb3BdKSxcbiAgICBvbkRyYWdFbmQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgJiYgYXR0cmlidXRlcy5vbkRyYWdFbmQgJiYgUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICBhdHRyaWJ1dGVzLm9uRHJhZ0VuZChldmVudCk7XG4gICAgICB9IC8vIFdoZW4gZHJvcHBpbmcgb24gYSBkaWZmZXJlbnQgZHJvcHBhYmxlIGVsZW1lbnQgdGhhbiB0aGUgY3VycmVudCBlZGl0b3IsXG4gICAgICAvLyBgb25Ecm9wYCBpcyBub3QgY2FsbGVkLiBTbyB3ZSBuZWVkIHRvIGNsZWFuIHVwIGluIGBvbkRyYWdFbmRgIGluc3RlYWQuXG4gICAgICAvLyBOb3RlOiBgb25EcmFnRW5kYCBpcyBvbmx5IGNhbGxlZCB3aGVuIGBvbkRyb3BgIGlzIG5vdCBjYWxsZWRcblxuXG4gICAgICBzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSA9IGZhbHNlO1xuICAgIH0sIFtyZWFkT25seSwgYXR0cmlidXRlcy5vbkRyYWdFbmRdKSxcbiAgICBvbkZvY3VzOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmICFzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Gb2N1cykpIHtcbiAgICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICAgICAgc3RhdGUubGF0ZXN0RWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDsgLy8gQ09NUEFUOiBJZiB0aGUgZWRpdG9yIGhhcyBuZXN0ZWQgZWRpdGFibGUgZWxlbWVudHMsIHRoZSBmb2N1c1xuICAgICAgICAvLyBjYW4gZ28gdG8gdGhlbS4gSW4gRmlyZWZveCwgdGhpcyBtdXN0IGJlIHByZXZlbnRlZCBiZWNhdXNlIGl0XG4gICAgICAgIC8vIHJlc3VsdHMgaW4gaXNzdWVzIHdpdGgga2V5Ym9hcmQgbmF2aWdhdGlvbi4gKDIwMTcvMDMvMzApXG5cbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZXZlbnQudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25Gb2N1c10pLFxuICAgIG9uS2V5RG93bjogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gbnVsbCB8fCBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhbmRsZUtleURvd24oZXZlbnQpO1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgIH0gPSBldmVudDsgLy8gQ09NUEFUOiBUaGUgY29tcG9zaXRpb24gZW5kIGV2ZW50IGlzbid0IGZpcmVkIHJlbGlhYmx5IGluIGFsbCBicm93c2VycyxcbiAgICAgICAgLy8gc28gd2Ugc29tZXRpbWVzIG1pZ2h0IGVuZCB1cCBzdHVjayBpbiBhIGNvbXBvc2l0aW9uIHN0YXRlIGV2ZW4gdGhvdWdoIHdlXG4gICAgICAgIC8vIGFyZW4ndCBjb21wb3NpbmcgYW55IG1vcmUuXG5cbiAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikgJiYgbmF0aXZlRXZlbnQuaXNDb21wb3NpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyhmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25LZXlEb3duKSB8fCBSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBlZGl0b3IuY2hpbGRyZW5bc2VsZWN0aW9uICE9PSBudWxsID8gc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0gOiAwXTtcbiAgICAgICAgdmFyIGlzUlRMID0gZ2V0RGlyZWN0aW9uKE5vZGUuc3RyaW5nKGVsZW1lbnQpKSA9PT0gJ3J0bCc7IC8vIENPTVBBVDogU2luY2Ugd2UgcHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvblxuICAgICAgICAvLyBgYmVmb3JlaW5wdXRgIGV2ZW50cywgdGhlIGJyb3dzZXIgZG9lc24ndCB0aGluayB0aGVyZSdzIGV2ZXJcbiAgICAgICAgLy8gYW55IGhpc3Rvcnkgc3RhY2sgdG8gdW5kbyBvciByZWRvLCBzbyB3ZSBoYXZlIHRvIG1hbmFnZSB0aGVzZVxuICAgICAgICAvLyBob3RrZXlzIG91cnNlbHZlcy4gKDIwMTkvMTEvMDYpXG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNSZWRvKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIG1heWJlSGlzdG9yeUVkaXRvciA9IGVkaXRvcjtcblxuICAgICAgICAgIGlmICh0eXBlb2YgbWF5YmVIaXN0b3J5RWRpdG9yLnJlZG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlSGlzdG9yeUVkaXRvci5yZWRvKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNVbmRvKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIF9tYXliZUhpc3RvcnlFZGl0b3IgPSBlZGl0b3I7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIF9tYXliZUhpc3RvcnlFZGl0b3IudW5kbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgX21heWJlSGlzdG9yeUVkaXRvci51bmRvKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBoYW5kbGUgdGhlIHNlbGVjdGlvbiB1cGRhdGVzXG4gICAgICAgIC8vIHByb3Blcmx5LiBJbiBDaHJvbWUsIHRoZSBzZWxlY3Rpb24gaXNuJ3QgcHJvcGVybHkgZXh0ZW5kZWQuXG4gICAgICAgIC8vIEFuZCBpbiBGaXJlZm94LCB0aGUgc2VsZWN0aW9uIGlzbid0IHByb3Blcmx5IGNvbGxhcHNlZC5cbiAgICAgICAgLy8gKDIwMTcvMTAvMTcpXG5cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVMaW5lQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZScsXG4gICAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc0V4dGVuZExpbmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJyxcbiAgICAgICAgICAgIGVkZ2U6ICdmb2N1cycsXG4gICAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNFeHRlbmRMaW5lRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJyxcbiAgICAgICAgICAgIGVkZ2U6ICdmb2N1cydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBJZiBhIHZvaWQgbm9kZSBpcyBzZWxlY3RlZCwgb3IgYSB6ZXJvLXdpZHRoIHRleHQgbm9kZVxuICAgICAgICAvLyBhZGphY2VudCB0byBhbiBpbmxpbmUgaXMgc2VsZWN0ZWQsIHdlIG5lZWQgdG8gaGFuZGxlIHRoZXNlXG4gICAgICAgIC8vIGhvdGtleXMgbWFudWFsbHkgYmVjYXVzZSBicm93c2VycyB3b24ndCBiZSBhYmxlIHRvIHNraXAgb3ZlclxuICAgICAgICAvLyB0aGUgdm9pZCBub2RlIHdpdGggdGhlIHplcm8td2lkdGggc3BhY2Ugbm90IGJlaW5nIGFuIGVtcHR5XG4gICAgICAgIC8vIHN0cmluZy5cblxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgcmV2ZXJzZTogIWlzUlRMXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHJldmVyc2U6IGlzUlRMXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ2VuZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZVdvcmRCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuY29sbGFwc2UoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGVkZ2U6ICdmb2N1cydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJyxcbiAgICAgICAgICAgIHJldmVyc2U6ICFpc1JUTFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZVdvcmRGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnLFxuICAgICAgICAgICAgcmV2ZXJzZTogaXNSVExcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBndWVzc2luZyBhdCB0aGUgaW5wdXQgaW50ZW50aW9uIGZvciBob3RrZXlzLlxuICAgICAgICAvLyBDT01QQVQ6IEluIGlPUywgc29tZSBvZiB0aGVzZSBob3RrZXlzIGFyZSBoYW5kbGVkIGluIHRoZVxuXG5cbiAgICAgICAgaWYgKCFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQpIHtcbiAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGEgY29yZSBiZWhhdmlvciBmb3IgdGhlc2UsIGJ1dCB0aGV5IGNoYW5nZSB0aGVcbiAgICAgICAgICAvLyBET00gaWYgd2UgZG9uJ3QgcHJldmVudCB0aGVtLCBzbyB3ZSBoYXZlIHRvLlxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzQm9sZChuYXRpdmVFdmVudCkgfHwgSG90a2V5cy5pc0l0YWxpYyhuYXRpdmVFdmVudCkgfHwgSG90a2V5cy5pc1RyYW5zcG9zZUNoYXJhY3RlcihuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNTb2Z0QnJlYWsobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydFNvZnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzU3BsaXRCbG9jayhuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBFZGl0b3IuaW5zZXJ0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlTGluZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUxpbmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVXb3JkQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlV29yZEZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKElTX0NIUk9NRSB8fCBJU19TQUZBUkkpIHtcbiAgICAgICAgICAgIC8vIENPTVBBVDogQ2hyb21lIGFuZCBTYWZhcmkgc3VwcG9ydCBgYmVmb3JlaW5wdXRgIGV2ZW50IGJ1dCBkbyBub3QgZmlyZVxuICAgICAgICAgICAgLy8gYW4gZXZlbnQgd2hlbiBkZWxldGluZyBiYWNrd2FyZHMgaW4gYSBzZWxlY3RlZCB2b2lkIGlubGluZSBub2RlXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIChIb3RrZXlzLmlzRGVsZXRlQmFja3dhcmQobmF0aXZlRXZlbnQpIHx8IEhvdGtleXMuaXNEZWxldGVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBOb2RlLnBhcmVudChlZGl0b3IsIHNlbGVjdGlvbi5hbmNob3IucGF0aCk7XG5cbiAgICAgICAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQoY3VycmVudE5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBjdXJyZW50Tm9kZSkgJiYgKEVkaXRvci5pc0lubGluZShlZGl0b3IsIGN1cnJlbnROb2RlKSB8fCBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIGN1cnJlbnROb2RlKSkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25LZXlEb3duXSksXG4gICAgb25QYXN0ZTogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uUGFzdGUpKSB7XG4gICAgICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZVxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gUmVhY3QncyBgb25QYXN0ZWAgaGVyZSBpbnN0ZWFkLlxuICAgICAgICAvLyBDT01QQVQ6IEZpcmVmb3gsIENocm9tZSBhbmQgU2FmYXJpIGRvbid0IGVtaXQgYGJlZm9yZWlucHV0YCBldmVudHNcbiAgICAgICAgLy8gd2hlbiBcInBhc3RlIHdpdGhvdXQgZm9ybWF0dGluZ1wiIGlzIHVzZWQsIHNvIGZhbGxiYWNrLiAoMjAyMC8wMi8yMClcbiAgICAgICAgLy8gQ09NUEFUOiBTYWZhcmkgSW5wdXRFdmVudHMgZ2VuZXJhdGVkIGJ5IHBhc3Rpbmcgd29uJ3QgaW5jbHVkZVxuICAgICAgICAvLyBhcHBsaWNhdGlvbi94LXNsYXRlLWZyYWdtZW50IGl0ZW1zLCBzbyB1c2UgdGhlXG4gICAgICAgIC8vIENsaXBib2FyZEV2ZW50IGhlcmUuICgyMDIzLzAzLzE1KVxuICAgICAgICBpZiAoIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCB8fCBpc1BsYWluVGV4dE9ubHlQYXN0ZShldmVudC5uYXRpdmVFdmVudCkgfHwgSVNfU0FGQVJJKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBSZWFjdEVkaXRvci5pbnNlcnREYXRhKGVkaXRvciwgZXZlbnQuY2xpcGJvYXJkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25QYXN0ZV0pXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGlsZHJlbiwge1xuICAgIGRlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICBub2RlOiBlZGl0b3IsXG4gICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb246IGVkaXRvci5zZWxlY3Rpb25cbiAgfSkpKSkpO1xufTtcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBwbGFjZWhvbGRlciBlbGVtZW50XHJcbiAqL1xuXG52YXIgRGVmYXVsdFBsYWNlaG9sZGVyID0gX3JlZiA9PiB7XG4gIHZhciB7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIChcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgLy8gQ09NUEFUOiBBcnRpZmljaWFsbHkgYWRkIGEgbGluZS1icmVhayB0byB0aGUgZW5kIG9uIHRoZSBwbGFjZWhvbGRlciBlbGVtZW50XG4gICAgLy8gdG8gcHJldmVudCBBbmRyb2lkIElNRXMgdG8gcGljayB1cCBpdHMgY29udGVudCBpbiBhdXRvY29ycmVjdCBhbmQgdG8gYXV0by1jYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXJcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgY2hpbGRyZW4sIElTX0FORFJPSUQgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKSlcbiAgKTtcbn07XG4vKipcclxuICogQSBkZWZhdWx0IG1lbW9pemVkIGRlY29yYXRlIGZ1bmN0aW9uLlxyXG4gKi9cblxudmFyIGRlZmF1bHREZWNvcmF0ZSA9ICgpID0+IFtdO1xuLyoqXHJcbiAqIEEgZGVmYXVsdCBpbXBsZW1lbnQgdG8gc2Nyb2xsIGRvbSByYW5nZSBpbnRvIHZpZXcuXHJcbiAqL1xuXG52YXIgZGVmYXVsdFNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID0gKGVkaXRvciwgZG9tUmFuZ2UpID0+IHtcbiAgLy8gVGhpcyB3YXMgYWZmZWN0aW5nIHRoZSBzZWxlY3Rpb24gb2YgbXVsdGlwbGUgYmxvY2tzIGFuZCBkcmFnZ2luZyBiZWhhdmlvcixcbiAgLy8gc28gZW5hYmxlZCBvbmx5IGlmIHRoZSBzZWxlY3Rpb24gaGFzIGJlZW4gY29sbGFwc2VkLlxuICBpZiAoZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSkge1xuICAgIHZhciBsZWFmRWwgPSBkb21SYW5nZS5zdGFydENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgIGxlYWZFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBkb21SYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QuYmluZChkb21SYW5nZSk7XG4gICAgc2Nyb2xsSW50b1ZpZXcobGVhZkVsLCB7XG4gICAgICBzY3JvbGxNb2RlOiAnaWYtbmVlZGVkJ1xuICAgIH0pOyAvLyBAdHMtZXhwZWN0LWVycm9yIGFuIHVub3J0aG9kb3ggZGVsZXRlIEQ6XG5cbiAgICBkZWxldGUgbGVhZkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgfVxufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhbiBldmVudCBpcyBvdmVycmlkZWQgYnkgYSBoYW5kbGVyLlxyXG4gKi9cblxuXG52YXIgaXNFdmVudEhhbmRsZWQgPSAoZXZlbnQsIGhhbmRsZXIpID0+IHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRoZSBjdXN0b20gZXZlbnQgaGFuZGxlciBtYXkgcmV0dXJuIGEgYm9vbGVhbiB0byBzcGVjaWZ5IHdoZXRoZXIgdGhlIGV2ZW50XG4gIC8vIHNoYWxsIGJlIHRyZWF0ZWQgYXMgYmVpbmcgaGFuZGxlZCBvciBub3QuXG5cblxuICB2YXIgc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCA9IGhhbmRsZXIoZXZlbnQpO1xuXG4gIGlmIChzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkICE9IG51bGwpIHtcbiAgICByZXR1cm4gc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZDtcbiAgfVxuXG4gIHJldHVybiBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIERPTSBldmVudCBpcyBvdmVycmlkZWQgYnkgYSBoYW5kbGVyLlxyXG4gKi9cblxudmFyIGlzRE9NRXZlbnRIYW5kbGVkID0gKGV2ZW50LCBoYW5kbGVyKSA9PiB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUaGUgY3VzdG9tIGV2ZW50IGhhbmRsZXIgbWF5IHJldHVybiBhIGJvb2xlYW4gdG8gc3BlY2lmeSB3aGV0aGVyIHRoZSBldmVudFxuICAvLyBzaGFsbCBiZSB0cmVhdGVkIGFzIGJlaW5nIGhhbmRsZWQgb3Igbm90LlxuXG5cbiAgdmFyIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQgPSBoYW5kbGVyKGV2ZW50KTtcblxuICBpZiAoc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQ7XG4gIH1cblxuICByZXR1cm4gZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbn07XG5cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGBmb2N1c2VkYCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxyXG4gKi9cblxudmFyIEZvY3VzZWRDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgZm9jdXNlZGAgc3RhdGUgb2YgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciB1c2VGb2N1c2VkID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChGb2N1c2VkQ29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiBpc0Vycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yO1xufVxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgZWRpdG9yIHNlbGVjdG9yIGNvbnRleHQgaW4gYSB3YXkgdG8gY29udHJvbCByZXJlbmRlcnNcclxuICovXG5cblxudmFyIFNsYXRlU2VsZWN0b3JDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoe30pO1xuXG52YXIgcmVmRXF1YWxpdHkgPSAoYSwgYikgPT4gYSA9PT0gYjtcbi8qKlxyXG4gKiB1c2UgcmVkdXggc3R5bGUgc2VsZWN0b3JzIHRvIHByZXZlbnQgcmVyZW5kZXJpbmcgb24gZXZlcnkga2V5c3Ryb2tlLlxyXG4gKiBCZWFyIGluIG1pbmQgcmVyZW5kZXJpbmcgY2FuIG9ubHkgcHJldmVudGVkIGlmIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhIHZhbHVlIHR5cGUgb3IgZm9yIHJlZmVyZW5jZSB0eXBlcyAoZS5nLiBvYmplY3RzIGFuZCBhcnJheXMpIGFkZCBhIGN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvbi5cclxuICpcclxuICogRXhhbXBsZTpcclxuICogYGBgXHJcbiAqICBjb25zdCBpc1NlbGVjdGlvbkFjdGl2ZSA9IHVzZVNsYXRlU2VsZWN0b3IoZWRpdG9yID0+IEJvb2xlYW4oZWRpdG9yLnNlbGVjdGlvbikpO1xyXG4gKiBgYGBcclxuICovXG5cblxuZnVuY3Rpb24gdXNlU2xhdGVTZWxlY3RvcihzZWxlY3Rvcikge1xuICB2YXIgZXF1YWxpdHlGbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcmVmRXF1YWxpdHk7XG4gIHZhciBbLCBmb3JjZVJlbmRlcl0gPSB1c2VSZWR1Y2VyKHMgPT4gcyArIDEsIDApO1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoU2xhdGVTZWxlY3RvckNvbnRleHQpO1xuXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVTZWxlY3RvcmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG5cbiAgdmFyIHtcbiAgICBnZXRTbGF0ZSxcbiAgICBhZGRFdmVudExpc3RlbmVyXG4gIH0gPSBjb250ZXh0O1xuICB2YXIgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IHVzZVJlZigpO1xuICB2YXIgbGF0ZXN0U2VsZWN0b3IgPSB1c2VSZWYoKCkgPT4gbnVsbCk7XG4gIHZhciBsYXRlc3RTZWxlY3RlZFN0YXRlID0gdXNlUmVmKG51bGwpO1xuICB2YXIgc2VsZWN0ZWRTdGF0ZTtcblxuICB0cnkge1xuICAgIGlmIChzZWxlY3RvciAhPT0gbGF0ZXN0U2VsZWN0b3IuY3VycmVudCB8fCBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgIHNlbGVjdGVkU3RhdGUgPSBzZWxlY3RvcihnZXRTbGF0ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0ZWRTdGF0ZSA9IGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgJiYgaXNFcnJvcihlcnIpKSB7XG4gICAgICBlcnIubWVzc2FnZSArPSBcIlxcblRoZSBlcnJvciBtYXkgYmUgY29ycmVsYXRlZCB3aXRoIHRoaXMgcHJldmlvdXMgZXJyb3I6XFxuXCIuY29uY2F0KGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudC5zdGFjaywgXCJcXG5cXG5cIik7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgbGF0ZXN0U2VsZWN0b3IuY3VycmVudCA9IHNlbGVjdG9yO1xuICAgIGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudCA9IHNlbGVjdGVkU3RhdGU7XG4gICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgZnVuY3Rpb24gY2hlY2tGb3JVcGRhdGVzKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5ld1NlbGVjdGVkU3RhdGUgPSBsYXRlc3RTZWxlY3Rvci5jdXJyZW50KGdldFNsYXRlKCkpO1xuXG4gICAgICAgIGlmIChlcXVhbGl0eUZuKG5ld1NlbGVjdGVkU3RhdGUsIGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQgPSBuZXdTZWxlY3RlZFN0YXRlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHdlIGlnbm9yZSBhbGwgZXJyb3JzIGhlcmUsIHNpbmNlIHdoZW4gdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyBpcyByZS1yZW5kZXJlZCwgdGhlIHNlbGVjdG9ycyBhcmUgY2FsbGVkIGFnYWluLCBhbmRcbiAgICAgICAgLy8gd2lsbCB0aHJvdyBhZ2FpbiwgaWYgbmVpdGhlciBwcm9wcyBub3Igc3RvcmUgc3RhdGVcbiAgICAgICAgLy8gY2hhbmdlZFxuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSBlcnI7XG4gICAgICB9XG5cbiAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgfVxuXG4gICAgdmFyIHVuc3Vic2NyaWJlID0gYWRkRXZlbnRMaXN0ZW5lcihjaGVja0ZvclVwZGF0ZXMpO1xuICAgIGNoZWNrRm9yVXBkYXRlcygpO1xuICAgIHJldHVybiAoKSA9PiB1bnN1YnNjcmliZSgpO1xuICB9LCAvLyBkb24ndCByZXJlbmRlciBvbiBlcXVhbGl0eUZuIGNoYW5nZSBzaW5jZSB3ZSB3YW50IHRvIGJlIGFibGUgdG8gZGVmaW5lIGl0IGlubGluZVxuICBbYWRkRXZlbnRMaXN0ZW5lciwgZ2V0U2xhdGVdKTtcbiAgcmV0dXJuIHNlbGVjdGVkU3RhdGU7XG59XG4vKipcclxuICogQ3JlYXRlIHNlbGVjdG9yIGNvbnRleHQgd2l0aCBlZGl0b3IgdXBkYXRpbmcgb24gZXZlcnkgZWRpdG9yIGNoYW5nZVxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0U2VsZWN0b3JDb250ZXh0KGVkaXRvcikge1xuICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSB1c2VSZWYoW10pLmN1cnJlbnQ7XG4gIHZhciBzbGF0ZVJlZiA9IHVzZVJlZih7XG4gICAgZWRpdG9yXG4gIH0pLmN1cnJlbnQ7XG4gIHZhciBvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKGVkaXRvciA9PiB7XG4gICAgc2xhdGVSZWYuZWRpdG9yID0gZWRpdG9yO1xuICAgIGV2ZW50TGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoZWRpdG9yKSk7XG4gIH0sIFtdKTtcbiAgdmFyIHNlbGVjdG9yQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRTbGF0ZTogKCkgPT4gc2xhdGVSZWYuZWRpdG9yLFxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogY2FsbGJhY2sgPT4ge1xuICAgICAgICBldmVudExpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBldmVudExpc3RlbmVycy5zcGxpY2UoZXZlbnRMaXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtldmVudExpc3RlbmVycywgc2xhdGVSZWZdKTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RvckNvbnRleHQsXG4gICAgb25DaGFuZ2VcbiAgfTtcbn1cblxudmFyIF9leGNsdWRlZCA9IFtcImVkaXRvclwiLCBcImNoaWxkcmVuXCIsIFwib25DaGFuZ2VcIiwgXCJ2YWx1ZVwiXTtcbi8qKlxyXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBwcm92aWRlciB0byBoYW5kbGUgYG9uQ2hhbmdlYCBldmVudHMsIGJlY2F1c2UgdGhlIGVkaXRvclxyXG4gKiBpcyBhIG11dGFibGUgc2luZ2xldG9uIHNvIGl0IHdvbid0IGV2ZXIgcmVnaXN0ZXIgYXMgXCJjaGFuZ2VkXCIgb3RoZXJ3aXNlLlxyXG4gKi9cblxudmFyIFNsYXRlID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGVkaXRvcixcbiAgICBjaGlsZHJlbixcbiAgICBvbkNoYW5nZSxcbiAgICB2YWx1ZVxuICB9ID0gcHJvcHMsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuXG4gIHZhciB1bm1vdW50UmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIFtjb250ZXh0LCBzZXRDb250ZXh0XSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICBpZiAoIU5vZGUuaXNOb2RlTGlzdCh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltTbGF0ZV0gdmFsdWUgaXMgaW52YWxpZCEgRXhwZWN0ZWQgYSBsaXN0IG9mIGVsZW1lbnRzIGJ1dCBnb3Q6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkodmFsdWUpKSk7XG4gICAgfVxuXG4gICAgaWYgKCFFZGl0b3IuaXNFZGl0b3IoZWRpdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1NsYXRlXSBlZGl0b3IgaXMgaW52YWxpZCEgWW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShlZGl0b3IpKSk7XG4gICAgfVxuXG4gICAgZWRpdG9yLmNoaWxkcmVuID0gdmFsdWU7XG4gICAgT2JqZWN0LmFzc2lnbihlZGl0b3IsIHJlc3QpO1xuICAgIHJldHVybiB7XG4gICAgICB2OiAwLFxuICAgICAgZWRpdG9yXG4gICAgfTtcbiAgfSk7XG4gIHZhciB7XG4gICAgc2VsZWN0b3JDb250ZXh0LFxuICAgIG9uQ2hhbmdlOiBoYW5kbGVTZWxlY3RvckNoYW5nZVxuICB9ID0gZ2V0U2VsZWN0b3JDb250ZXh0KGVkaXRvcik7XG4gIHZhciBvbkNvbnRleHRDaGFuZ2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICBvbkNoYW5nZShlZGl0b3IuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHNldENvbnRleHQocHJldkNvbnRleHQgPT4gKHtcbiAgICAgIHY6IHByZXZDb250ZXh0LnYgKyAxLFxuICAgICAgZWRpdG9yXG4gICAgfSkpO1xuICAgIGhhbmRsZVNlbGVjdG9yQ2hhbmdlKGVkaXRvcik7XG4gIH0sIFtvbkNoYW5nZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIEVESVRPUl9UT19PTl9DSEFOR0Uuc2V0KGVkaXRvciwgb25Db250ZXh0Q2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgRURJVE9SX1RPX09OX0NIQU5HRS5zZXQoZWRpdG9yLCAoKSA9PiB7fSk7XG4gICAgICB1bm1vdW50UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH07XG4gIH0sIFtvbkNvbnRleHRDaGFuZ2VdKTtcbiAgdmFyIFtpc0ZvY3VzZWQsIHNldElzRm9jdXNlZF0gPSB1c2VTdGF0ZShSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SXNGb2N1c2VkKFJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpKTtcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBmbiA9ICgpID0+IHNldElzRm9jdXNlZChSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSk7XG5cbiAgICBpZiAoSVNfUkVBQ1RfVkVSU0lPTl8xN19PUl9BQk9WRSkge1xuICAgICAgLy8gSW4gUmVhY3QgPj0gMTcgb25Gb2N1cyBhbmQgb25CbHVyIGxpc3RlbiB0byB0aGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgZXZlbnRzIGR1cmluZyB0aGUgYnViYmxpbmcgcGhhc2UuXG4gICAgICAvLyBUaGVyZWZvcmUgaW4gb3JkZXIgZm9yIDxFZGl0YWJsZSAvPidzIGhhbmRsZXJzIHRvIHJ1biBmaXJzdCwgd2hpY2ggaXMgbmVjZXNzYXJ5IGZvciBSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKVxuICAgICAgLy8gdG8gcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlLCB3ZSBoYXZlIHRvIGxpc3RlbiB0byB0aGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgZXZlbnRzIHdpdGhvdXQgdXNlQ2FwdHVyZSBoZXJlLlxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGZuKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZm4pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGZuKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBmbik7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZuLCB0cnVlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmbiwgdHJ1ZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGZuLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGZuLCB0cnVlKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTbGF0ZVNlbGVjdG9yQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzZWxlY3RvckNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2xhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRWRpdG9yQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0LmVkaXRvclxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c2VkQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBpc0ZvY3VzZWRcbiAgfSwgY2hpbGRyZW4pKSkpO1xufTtcblxuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBlZGl0b3Igb2JqZWN0IGZyb20gdGhlIFJlYWN0IGNvbnRleHQuXHJcbiAqIEBkZXByZWNhdGVkIFVzZSB1c2VTbGF0ZVN0YXRpYyBpbnN0ZWFkLlxyXG4gKi9cblxudmFyIHVzZUVkaXRvciA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG5cbiAgaWYgKCFlZGl0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZUVkaXRvcmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5cbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgc2xhdGUgc2VsZWN0aW9uLlxyXG4gKiBPbmx5IHRyaWdnZXJzIGEgcmVyZW5kZXIgd2hlbiB0aGUgc2VsZWN0aW9uIGFjdHVhbGx5IGNoYW5nZXNcclxuICovXG5cbnZhciB1c2VTbGF0ZVNlbGVjdGlvbiA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZVNsYXRlU2VsZWN0b3IoZWRpdG9yID0+IGVkaXRvci5zZWxlY3Rpb24sIGlzU2VsZWN0aW9uRXF1YWwpO1xufTtcblxudmFyIGlzU2VsZWN0aW9uRXF1YWwgPSAoYSwgYikgPT4ge1xuICBpZiAoIWEgJiYgIWIpIHJldHVybiB0cnVlO1xuICBpZiAoIWEgfHwgIWIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFJhbmdlLmVxdWFscyhhLCBiKTtcbn07XG5cbi8qKlxyXG4gKiBVdGlsaXRpZXMgZm9yIHNpbmdsZS1saW5lIGRlbGV0aW9uXHJcbiAqL1xuXG52YXIgZG9SZWN0c0ludGVyc2VjdCA9IChyZWN0LCBjb21wYXJlUmVjdCkgPT4ge1xuICB2YXIgbWlkZGxlID0gKGNvbXBhcmVSZWN0LnRvcCArIGNvbXBhcmVSZWN0LmJvdHRvbSkgLyAyO1xuICByZXR1cm4gcmVjdC50b3AgPD0gbWlkZGxlICYmIHJlY3QuYm90dG9tID49IG1pZGRsZTtcbn07XG5cbnZhciBhcmVSYW5nZXNTYW1lTGluZSA9IChlZGl0b3IsIHJhbmdlMSwgcmFuZ2UyKSA9PiB7XG4gIHZhciByZWN0MSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCByYW5nZTEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgcmVjdDIgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgcmFuZ2UyKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIGRvUmVjdHNJbnRlcnNlY3QocmVjdDEsIHJlY3QyKSAmJiBkb1JlY3RzSW50ZXJzZWN0KHJlY3QyLCByZWN0MSk7XG59O1xuLyoqXHJcbiAqIEEgaGVscGVyIHV0aWxpdHkgdGhhdCByZXR1cm5zIHRoZSBlbmQgcG9ydGlvbiBvZiBhIGBSYW5nZWBcclxuICogd2hpY2ggaXMgbG9jYXRlZCBvbiBhIHNpbmdsZSBsaW5lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VkaXRvcn0gZWRpdG9yIFRoZSBlZGl0b3Igb2JqZWN0IHRvIGNvbXBhcmUgYWdhaW5zdFxyXG4gKiBAcGFyYW0ge1JhbmdlfSBwYXJlbnRSYW5nZSBUaGUgcGFyZW50IHJhbmdlIHRvIGNvbXBhcmUgYWdhaW5zdFxyXG4gKiBAcmV0dXJucyB7UmFuZ2V9IEEgdmFsaWQgcG9ydGlvbiBvZiB0aGUgcGFyZW50UmFuZ2Ugd2hpY2ggaXMgb25lIGEgc2luZ2xlIGxpbmVcclxuICovXG5cblxudmFyIGZpbmRDdXJyZW50TGluZVJhbmdlID0gKGVkaXRvciwgcGFyZW50UmFuZ2UpID0+IHtcbiAgdmFyIHBhcmVudFJhbmdlQm91bmRhcnkgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBSYW5nZS5lbmQocGFyZW50UmFuZ2UpKTtcbiAgdmFyIHBvc2l0aW9ucyA9IEFycmF5LmZyb20oRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIHtcbiAgICBhdDogcGFyZW50UmFuZ2VcbiAgfSkpO1xuICB2YXIgbGVmdCA9IDA7XG4gIHZhciByaWdodCA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKHJpZ2h0IC8gMik7XG5cbiAgaWYgKGFyZVJhbmdlc1NhbWVMaW5lKGVkaXRvciwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW2xlZnRdKSwgcGFyZW50UmFuZ2VCb3VuZGFyeSkpIHtcbiAgICByZXR1cm4gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW2xlZnRdLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KTtcbiAgfVxuXG4gIGlmIChwb3NpdGlvbnMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aCAtIDFdLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KTtcbiAgfVxuXG4gIHdoaWxlIChtaWRkbGUgIT09IHBvc2l0aW9ucy5sZW5ndGggJiYgbWlkZGxlICE9PSBsZWZ0KSB7XG4gICAgaWYgKGFyZVJhbmdlc1NhbWVMaW5lKGVkaXRvciwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW21pZGRsZV0pLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KSkge1xuICAgICAgcmlnaHQgPSBtaWRkbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBtaWRkbGU7XG4gICAgfVxuXG4gICAgbWlkZGxlID0gTWF0aC5mbG9vcigobGVmdCArIHJpZ2h0KSAvIDIpO1xuICB9XG5cbiAgcmV0dXJuIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tyaWdodF0sIHBhcmVudFJhbmdlQm91bmRhcnkpO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuLyoqXHJcbiAqIGB3aXRoUmVhY3RgIGFkZHMgUmVhY3QgYW5kIERPTSBzcGVjaWZpYyBiZWhhdmlvcnMgdG8gdGhlIGVkaXRvci5cclxuICpcclxuICogSWYgeW91IGFyZSB1c2luZyBUeXBlU2NyaXB0LCB5b3UgbXVzdCBleHRlbmQgU2xhdGUncyBDdXN0b21UeXBlcyB0byB1c2VcclxuICogdGhpcyBwbHVnaW4uXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2RvY3Muc2xhdGVqcy5vcmcvY29uY2VwdHMvMTEtdHlwZXNjcmlwdCB0byBsZWFybiBob3cuXHJcbiAqL1xuXG52YXIgd2l0aFJlYWN0ID0gZnVuY3Rpb24gd2l0aFJlYWN0KGVkaXRvcikge1xuICB2YXIgY2xpcGJvYXJkRm9ybWF0S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAneC1zbGF0ZS1mcmFnbWVudCc7XG4gIHZhciBlID0gZWRpdG9yO1xuICB2YXIge1xuICAgIGFwcGx5LFxuICAgIG9uQ2hhbmdlLFxuICAgIGRlbGV0ZUJhY2t3YXJkLFxuICAgIGFkZE1hcmssXG4gICAgcmVtb3ZlTWFya1xuICB9ID0gZTsgLy8gVGhlIFdlYWtNYXAgd2hpY2ggbWFwcyBhIGtleSB0byBhIHNwZWNpZmljIEhUTUxFbGVtZW50IG11c3QgYmUgc2NvcGVkIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UgdG9cbiAgLy8gYXZvaWQgY29sbGlzaW9ucyBiZXR3ZWVuIGVkaXRvcnMgaW4gdGhlIERPTSB0aGF0IHNoYXJlIHRoZSBzYW1lIHZhbHVlLlxuXG4gIEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5zZXQoZSwgbmV3IFdlYWtNYXAoKSk7XG5cbiAgZS5hZGRNYXJrID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19TQ0hFRFVMRV9GLCBfRURJVE9SX1RPX1BFTkRJTkdfREk7XG5cbiAgICAoX0VESVRPUl9UT19TQ0hFRFVMRV9GID0gRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILmdldChlKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19TQ0hFRFVMRV9GID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1NDSEVEVUxFX0YoKTtcblxuICAgIGlmICghRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlKSAmJiAoX0VESVRPUl9UT19QRU5ESU5HX0RJID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGUpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkubGVuZ3RoKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIGN1cnJlbnQgcGVuZGluZyBkaWZmcyBvcmlnaW5hdGluZyBmcm9tIGNoYW5nZXMgYmVmb3JlIHRoZSBhZGRNYXJrXG4gICAgICAvLyBhcmUgYXBwbGllZCB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdHRpbmdcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGUpO1xuICAgIGFkZE1hcmsoa2V5LCB2YWx1ZSk7XG4gIH07XG5cbiAgZS5yZW1vdmVNYXJrID0ga2V5ID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19QRU5ESU5HX0RJMjtcblxuICAgIGlmICghRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlKSAmJiAoX0VESVRPUl9UT19QRU5ESU5HX0RJMiA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJMiAhPT0gdm9pZCAwICYmIF9FRElUT1JfVE9fUEVORElOR19ESTIubGVuZ3RoKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIGN1cnJlbnQgcGVuZGluZyBkaWZmcyBvcmlnaW5hdGluZyBmcm9tIGNoYW5nZXMgYmVmb3JlIHRoZSBhZGRNYXJrXG4gICAgICAvLyBhcmUgYXBwbGllZCB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdHRpbmdcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGUpO1xuICAgIHJlbW92ZU1hcmsoa2V5KTtcbiAgfTtcblxuICBlLmRlbGV0ZUJhY2t3YXJkID0gdW5pdCA9PiB7XG4gICAgaWYgKHVuaXQgIT09ICdsaW5lJykge1xuICAgICAgcmV0dXJuIGRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICAgIH1cblxuICAgIGlmIChlLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlLnNlbGVjdGlvbikpIHtcbiAgICAgIHZhciBwYXJlbnRCbG9ja0VudHJ5ID0gRWRpdG9yLmFib3ZlKGUsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudCQxLmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlLCBuKSxcbiAgICAgICAgYXQ6IGUuc2VsZWN0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKHBhcmVudEJsb2NrRW50cnkpIHtcbiAgICAgICAgdmFyIFssIHBhcmVudEJsb2NrUGF0aF0gPSBwYXJlbnRCbG9ja0VudHJ5O1xuICAgICAgICB2YXIgcGFyZW50RWxlbWVudFJhbmdlID0gRWRpdG9yLnJhbmdlKGUsIHBhcmVudEJsb2NrUGF0aCwgZS5zZWxlY3Rpb24uYW5jaG9yKTtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lUmFuZ2UgPSBmaW5kQ3VycmVudExpbmVSYW5nZShlLCBwYXJlbnRFbGVtZW50UmFuZ2UpO1xuXG4gICAgICAgIGlmICghUmFuZ2UuaXNDb2xsYXBzZWQoY3VycmVudExpbmVSYW5nZSkpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlLCB7XG4gICAgICAgICAgICBhdDogY3VycmVudExpbmVSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBUaGlzIGF0dGVtcHRzIHRvIHJlc2V0IHRoZSBOT0RFX1RPX0tFWSBlbnRyeSB0byB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBhcyBhcHBseSgpIGNoYW5nZXMgdGhlIG9iamVjdCByZWZlcmVuY2UgYW5kIGhlbmNlIGludmFsaWRhdGVzIHRoZSBOT0RFX1RPX0tFWSBlbnRyeVxuXG5cbiAgZS5hcHBseSA9IG9wID0+IHtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBwZW5kaW5nRGlmZnMgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZSk7XG5cbiAgICBpZiAocGVuZGluZ0RpZmZzICE9PSBudWxsICYmIHBlbmRpbmdEaWZmcyAhPT0gdm9pZCAwICYmIHBlbmRpbmdEaWZmcy5sZW5ndGgpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHBlbmRpbmdEaWZmcy5tYXAodGV4dERpZmYgPT4gdHJhbnNmb3JtVGV4dERpZmYodGV4dERpZmYsIG9wKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGUsIHRyYW5zZm9ybWVkKTtcbiAgICB9XG5cbiAgICB2YXIgcGVuZGluZ1NlbGVjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5nZXQoZSk7XG5cbiAgICBpZiAocGVuZGluZ1NlbGVjdGlvbikge1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLnNldChlLCB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZSwgcGVuZGluZ1NlbGVjdGlvbiwgb3ApKTtcbiAgICB9XG5cbiAgICB2YXIgcGVuZGluZ0FjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZSk7XG5cbiAgICBpZiAocGVuZGluZ0FjdGlvbiAhPT0gbnVsbCAmJiBwZW5kaW5nQWN0aW9uICE9PSB2b2lkIDAgJiYgcGVuZGluZ0FjdGlvbi5hdCkge1xuICAgICAgdmFyIGF0ID0gUG9pbnQuaXNQb2ludChwZW5kaW5nQWN0aW9uID09PSBudWxsIHx8IHBlbmRpbmdBY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlbmRpbmdBY3Rpb24uYXQpID8gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGUsIHBlbmRpbmdBY3Rpb24uYXQsIG9wKSA6IHRyYW5zZm9ybVBlbmRpbmdSYW5nZShlLCBwZW5kaW5nQWN0aW9uLmF0LCBvcCk7XG4gICAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uc2V0KGUsIGF0ID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwZW5kaW5nQWN0aW9uKSwge30sIHtcbiAgICAgICAgYXRcbiAgICAgIH0pIDogbnVsbCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIG9wLnBhdGgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfRURJVE9SX1RPX1VTRVJfU0VMRUM7XG5cbiAgICAgICAgICAvLyBTZWxlY3Rpb24gd2FzIG1hbnVhbGx5IHNldCwgZG9uJ3QgcmVzdG9yZSB0aGUgdXNlciBzZWxlY3Rpb24gYWZ0ZXIgdGhlIGNoYW5nZS5cbiAgICAgICAgICAoX0VESVRPUl9UT19VU0VSX1NFTEVDID0gRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLmdldChlKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19VU0VSX1NFTEVDID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1VTRVJfU0VMRUMudW5yZWYoKTtcbiAgICAgICAgICBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZGVsZXRlKGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIFBhdGgucGFyZW50KG9wLnBhdGgpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJldlBhdGggPSBQYXRoLnByZXZpb3VzKG9wLnBhdGgpO1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIHByZXZQYXRoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5jb21tb24oUGF0aC5wYXJlbnQob3AucGF0aCksIFBhdGgucGFyZW50KG9wLm5ld1BhdGgpKTtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBjb21tb25QYXRoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhcHBseShvcCk7XG5cbiAgICBmb3IgKHZhciBbcGF0aCwga2V5XSBvZiBtYXRjaGVzKSB7XG4gICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZSwgcGF0aCk7XG4gICAgICBOT0RFX1RPX0tFWS5zZXQobm9kZSwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZS5zZXRGcmFnbWVudERhdGEgPSBkYXRhID0+IHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGU7XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgIHZhciBzdGFydFZvaWQgPSBFZGl0b3Iudm9pZChlLCB7XG4gICAgICBhdDogc3RhcnQucGF0aFxuICAgIH0pO1xuICAgIHZhciBlbmRWb2lkID0gRWRpdG9yLnZvaWQoZSwge1xuICAgICAgYXQ6IGVuZC5wYXRoXG4gICAgfSk7XG5cbiAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDcmVhdGUgYSBmYWtlIHNlbGVjdGlvbiBzbyB0aGF0IHdlIGNhbiBhZGQgYSBCYXNlNjQtZW5jb2RlZCBjb3B5IG9mIHRoZVxuICAgIC8vIGZyYWdtZW50IHRvIHRoZSBIVE1MLCB0byBkZWNvZGUgb24gZnV0dXJlIHBhc3Rlcy5cblxuXG4gICAgdmFyIGRvbVJhbmdlID0gUmVhY3RFZGl0b3IudG9ET01SYW5nZShlLCBzZWxlY3Rpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGRvbVJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICB2YXIgYXR0YWNoID0gY29udGVudHMuY2hpbGROb2Rlc1swXTsgLy8gTWFrZSBzdXJlIGF0dGFjaCBpcyBub24tZW1wdHksIHNpbmNlIGVtcHR5IG5vZGVzIHdpbGwgbm90IGdldCBjb3BpZWQuXG5cbiAgICBjb250ZW50cy5jaGlsZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBpZiAobm9kZS50ZXh0Q29udGVudCAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgYXR0YWNoID0gbm9kZTtcbiAgICAgIH1cbiAgICB9KTsgLy8gQ09NUEFUOiBJZiB0aGUgZW5kIG5vZGUgaXMgYSB2b2lkIG5vZGUsIHdlIG5lZWQgdG8gbW92ZSB0aGUgZW5kIG9mIHRoZVxuICAgIC8vIHJhbmdlIGZyb20gdGhlIHZvaWQgbm9kZSdzIHNwYWNlciBzcGFuLCB0byB0aGUgZW5kIG9mIHRoZSB2b2lkIG5vZGUnc1xuICAgIC8vIGNvbnRlbnQsIHNpbmNlIHRoZSBzcGFjZXIgaXMgYmVmb3JlIHZvaWQncyBjb250ZW50IGluIHRoZSBET00uXG5cbiAgICBpZiAoZW5kVm9pZCkge1xuICAgICAgdmFyIFt2b2lkTm9kZV0gPSBlbmRWb2lkO1xuICAgICAgdmFyIHIgPSBkb21SYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlLCB2b2lkTm9kZSk7XG4gICAgICByLnNldEVuZEFmdGVyKGRvbU5vZGUpO1xuICAgICAgY29udGVudHMgPSByLmNsb25lQ29udGVudHMoKTtcbiAgICB9IC8vIENPTVBBVDogSWYgdGhlIHN0YXJ0IG5vZGUgaXMgYSB2b2lkIG5vZGUsIHdlIG5lZWQgdG8gYXR0YWNoIHRoZSBlbmNvZGVkXG4gICAgLy8gZnJhZ21lbnQgdG8gdGhlIHZvaWQgbm9kZSdzIGNvbnRlbnQgbm9kZSBpbnN0ZWFkIG9mIHRoZSBzcGFjZXIsIGJlY2F1c2VcbiAgICAvLyBhdHRhY2hpbmcgaXQgdG8gZW1wdHkgYDxkaXY+LzxzcGFuPmAgbm9kZXMgd2lsbCBlbmQgdXAgaGF2aW5nIGl0IGVyYXNlZCBieVxuICAgIC8vIG1vc3QgYnJvd3NlcnMuICgyMDE4LzA0LzI3KVxuXG5cbiAgICBpZiAoc3RhcnRWb2lkKSB7XG4gICAgICBhdHRhY2ggPSBjb250ZW50cy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zbGF0ZS1zcGFjZXJdJyk7XG4gICAgfSAvLyBSZW1vdmUgYW55IHplcm8td2lkdGggc3BhY2Ugc3BhbnMgZnJvbSB0aGUgY2xvbmVkIERPTSBzbyB0aGF0IHRoZXkgZG9uJ3RcbiAgICAvLyBzaG93IHVwIGVsc2V3aGVyZSB3aGVuIHBhc3RlZC5cblxuXG4gICAgQXJyYXkuZnJvbShjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpKS5mb3JFYWNoKHp3ID0+IHtcbiAgICAgIHZhciBpc05ld2xpbmUgPSB6dy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpID09PSAnbic7XG4gICAgICB6dy50ZXh0Q29udGVudCA9IGlzTmV3bGluZSA/ICdcXG4nIDogJyc7XG4gICAgfSk7IC8vIFNldCBhIGBkYXRhLXNsYXRlLWZyYWdtZW50YCBhdHRyaWJ1dGUgb24gYSBub24tZW1wdHkgbm9kZSwgc28gaXQgc2hvd3MgdXBcbiAgICAvLyBpbiB0aGUgSFRNTCwgYW5kIGNhbiBiZSB1c2VkIGZvciBpbnRyYS1TbGF0ZSBwYXN0aW5nLiBJZiBpdCdzIGEgdGV4dFxuICAgIC8vIG5vZGUsIHdyYXAgaXQgaW4gYSBgPHNwYW4+YCBzbyB3ZSBoYXZlIHNvbWV0aGluZyB0byBzZXQgYW4gYXR0cmlidXRlIG9uLlxuXG4gICAgaWYgKGlzRE9NVGV4dChhdHRhY2gpKSB7XG4gICAgICB2YXIgc3BhbiA9IGF0dGFjaC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTsgLy8gQ09NUEFUOiBJbiBDaHJvbWUgYW5kIFNhZmFyaSwgaWYgd2UgZG9uJ3QgYWRkIHRoZSBgd2hpdGUtc3BhY2VgIHN0eWxlXG4gICAgICAvLyB0aGVuIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlcyB3aWxsIGJlIGlnbm9yZWQuICgyMDE3LzA5LzIxKVxuXG4gICAgICBzcGFuLnN0eWxlLndoaXRlU3BhY2UgPSAncHJlJztcbiAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoYXR0YWNoKTtcbiAgICAgIGNvbnRlbnRzLmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgYXR0YWNoID0gc3BhbjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnQgPSBlLmdldEZyYWdtZW50KCk7XG4gICAgdmFyIHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGZyYWdtZW50KTtcbiAgICB2YXIgZW5jb2RlZCA9IHdpbmRvdy5idG9hKGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpKTtcbiAgICBhdHRhY2guc2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLWZyYWdtZW50JywgZW5jb2RlZCk7XG4gICAgZGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24vXCIuY29uY2F0KGNsaXBib2FyZEZvcm1hdEtleSksIGVuY29kZWQpOyAvLyBBZGQgdGhlIGNvbnRlbnQgdG8gYSA8ZGl2PiBzbyB0aGF0IHdlIGNhbiBnZXQgaXRzIGlubmVyIEhUTUwuXG5cbiAgICB2YXIgZGl2ID0gY29udGVudHMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoY29udGVudHMpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICd0cnVlJyk7XG4gICAgY29udGVudHMub3duZXJEb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgZGF0YS5zZXREYXRhKCd0ZXh0L2h0bWwnLCBkaXYuaW5uZXJIVE1MKTtcbiAgICBkYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBnZXRQbGFpblRleHQoZGl2KSk7XG4gICAgY29udGVudHMub3duZXJEb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgZS5pbnNlcnREYXRhID0gZGF0YSA9PiB7XG4gICAgaWYgKCFlLmluc2VydEZyYWdtZW50RGF0YShkYXRhKSkge1xuICAgICAgZS5pbnNlcnRUZXh0RGF0YShkYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgZS5pbnNlcnRGcmFnbWVudERhdGEgPSBkYXRhID0+IHtcbiAgICAvKipcclxuICAgICAqIENoZWNraW5nIGNvcGllZCBmcmFnbWVudCBmcm9tIGFwcGxpY2F0aW9uL3gtc2xhdGUtZnJhZ21lbnQgb3IgZGF0YS1zbGF0ZS1mcmFnbWVudFxyXG4gICAgICovXG4gICAgdmFyIGZyYWdtZW50ID0gZGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vXCIuY29uY2F0KGNsaXBib2FyZEZvcm1hdEtleSkpIHx8IGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUoZGF0YSk7XG5cbiAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgIHZhciBkZWNvZGVkID0gZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5hdG9iKGZyYWdtZW50KSk7XG4gICAgICB2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShkZWNvZGVkKTtcbiAgICAgIGUuaW5zZXJ0RnJhZ21lbnQocGFyc2VkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBlLmluc2VydFRleHREYXRhID0gZGF0YSA9PiB7XG4gICAgdmFyIHRleHQgPSBkYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblxuICAgIGlmICh0ZXh0KSB7XG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xuICAgICAgdmFyIHNwbGl0ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGUsIHtcbiAgICAgICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5pbnNlcnRUZXh0KGxpbmUpO1xuICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBlLm9uQ2hhbmdlID0gb3B0aW9ucyA9PiB7XG4gICAgLy8gQ09NUEFUOiBSZWFjdCBkb2Vzbid0IGJhdGNoIGBzZXRTdGF0ZWAgaG9vayBjYWxscywgd2hpY2ggbWVhbnMgdGhhdCB0aGVcbiAgICAvLyBjaGlsZHJlbiBhbmQgc2VsZWN0aW9uIGNhbiBnZXQgb3V0IG9mIHN5bmMgZm9yIG9uZSByZW5kZXIgcGFzcy4gU28gd2VcbiAgICAvLyBoYXZlIHRvIHVzZSB0aGlzIHVuc3RhYmxlIEFQSSB0byBlbnN1cmUgaXQgYmF0Y2hlcyB0aGVtLiAoMjAxOS8xMi8wMylcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0MjU5I2lzc3VlY29tbWVudC00Mzk3MDIzNjdcbiAgICBSZWFjdERPTS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICB2YXIgb25Db250ZXh0Q2hhbmdlID0gRURJVE9SX1RPX09OX0NIQU5HRS5nZXQoZSk7XG5cbiAgICAgIGlmIChvbkNvbnRleHRDaGFuZ2UpIHtcbiAgICAgICAgb25Db250ZXh0Q2hhbmdlKCk7XG4gICAgICB9XG5cbiAgICAgIG9uQ2hhbmdlKG9wdGlvbnMpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBlO1xufTtcblxudmFyIGdldE1hdGNoZXMgPSAoZSwgcGF0aCkgPT4ge1xuICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gIGZvciAodmFyIFtuLCBwXSBvZiBFZGl0b3IubGV2ZWxzKGUsIHtcbiAgICBhdDogcGF0aFxuICB9KSkge1xuICAgIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGUsIG4pO1xuICAgIG1hdGNoZXMucHVzaChbcCwga2V5XSk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn07XG5cbmV4cG9ydCB7IERlZmF1bHRFbGVtZW50LCBEZWZhdWx0TGVhZiwgRGVmYXVsdFBsYWNlaG9sZGVyLCBFZGl0YWJsZSwgUmVhY3RFZGl0b3IsIFNsYXRlLCB1c2VFZGl0b3IsIHVzZUZvY3VzZWQsIHVzZVJlYWRPbmx5LCB1c2VTZWxlY3RlZCwgdXNlU2xhdGUsIHVzZVNsYXRlU2VsZWN0aW9uLCB1c2VTbGF0ZVNlbGVjdG9yLCB1c2VTbGF0ZVN0YXRpYywgdXNlU2xhdGVXaXRoViwgd2l0aFJlYWN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnZXREaXJlY3Rpb24iLCJkZWJvdW5jZSIsInRocm90dGxlIiwiUmVhY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIm1lbW8iLCJmb3J3YXJkUmVmIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VDYWxsYmFjayIsIkNvbXBvbmVudCIsInVzZVJlZHVjZXIiLCJ1c2VNZW1vIiwic2Nyb2xsSW50b1ZpZXciLCJFZGl0b3IiLCJTY3J1YmJlciIsIlRyYW5zZm9ybXMiLCJSYW5nZSIsIkVsZW1lbnQiLCJFbGVtZW50JDEiLCJQYXRoIiwiTm9kZSIsIlRleHQiLCJUZXh0JDEiLCJQb2ludCIsIlJlc2l6ZU9ic2VydmVyIiwiaXNLZXlIb3RrZXkiLCJSZWFjdERPTSIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0Iiwic291cmNlS2V5cyIsImtleXMiLCJpIiwibGVuZ3RoIiwiaW5kZXhPZiIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJwcm90b3R5cGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNhbGwiLCJuIiwiS2V5IiwiY29uc3RydWN0b3IiLCJpZCIsImNvbmNhdCIsIk5PREVfVE9fSU5ERVgiLCJXZWFrTWFwIiwiTk9ERV9UT19QQVJFTlQiLCJFRElUT1JfVE9fV0lORE9XIiwiRURJVE9SX1RPX0VMRU1FTlQiLCJFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVCIsIkVMRU1FTlRfVE9fTk9ERSIsIk5PREVfVE9fRUxFTUVOVCIsIk5PREVfVE9fS0VZIiwiRURJVE9SX1RPX0tFWV9UT19FTEVNRU5UIiwiSVNfUkVBRF9PTkxZIiwiSVNfRk9DVVNFRCIsIklTX0NPTVBPU0lORyIsIkVESVRPUl9UT19VU0VSX1NFTEVDVElPTiIsIkVESVRPUl9UT19PTl9DSEFOR0UiLCJFRElUT1JfVE9fU0NIRURVTEVfRkxVU0giLCJFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MiLCJFRElUT1JfVE9fVVNFUl9NQVJLUyIsIkVESVRPUl9UT19QRU5ESU5HX0RJRkZTIiwiRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OIiwiRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OIiwiRURJVE9SX1RPX0ZPUkNFX1JFTkRFUiIsIlBMQUNFSE9MREVSX1NZTUJPTCIsIlN5bWJvbCIsIk1BUktfUExBQ0VIT0xERVJfU1lNQk9MIiwiRE9NVGV4dCIsImdsb2JhbFRoaXMiLCJnZXREZWZhdWx0VmlldyIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImlzRE9NQ29tbWVudCIsImlzRE9NTm9kZSIsIm5vZGVUeXBlIiwiaXNET01FbGVtZW50Iiwid2luZG93IiwiaXNET01TZWxlY3Rpb24iLCJhbmNob3JOb2RlIiwiU2VsZWN0aW9uIiwiaXNET01UZXh0IiwiaXNQbGFpblRleHRPbmx5UGFzdGUiLCJldmVudCIsImNsaXBib2FyZERhdGEiLCJnZXREYXRhIiwidHlwZXMiLCJub3JtYWxpemVET01Qb2ludCIsImRvbVBvaW50Iiwibm9kZSIsIm9mZnNldCIsImNoaWxkTm9kZXMiLCJpc0xhc3QiLCJpbmRleCIsImdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleCIsImdldEVkaXRhYmxlQ2hpbGQiLCJ0ZXh0Q29udGVudCIsImhhc1NoYWRvd1Jvb3QiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwidG9TdHJpbmciLCJkaXJlY3Rpb24iLCJjaGlsZCIsInRyaWVkRm9yd2FyZCIsInRyaWVkQmFja3dhcmQiLCJnZXRBdHRyaWJ1dGUiLCJnZXRQbGFpblRleHQiLCJkb21Ob2RlIiwidGV4dCIsIm5vZGVWYWx1ZSIsImNoaWxkTm9kZSIsIkFycmF5IiwiZnJvbSIsImRpc3BsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInRhZ05hbWUiLCJjYXRjaFNsYXRlRnJhZ21lbnQiLCJnZXRTbGF0ZUZyYWdtZW50QXR0cmlidXRlIiwiZGF0YVRyYW5zZmVyIiwiaHRtbERhdGEiLCJmcmFnbWVudCIsIm1hdGNoIiwiaXNUcmFja2VkTXV0YXRpb24iLCJlZGl0b3IiLCJtdXRhdGlvbiIsImJhdGNoIiwibWF0Y2hlcyIsImRvY3VtZW50IiwiUmVhY3RFZGl0b3IiLCJnZXRXaW5kb3ciLCJjb250YWlucyIsImhhc0RPTU5vZGUiLCJlZGl0YWJsZSIsInBhcmVudE11dGF0aW9uIiwiZmluZCIsIl9yZWYiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwiX25vZGUiLCJJU19SRUFDVF9WRVJTSU9OXzE3X09SX0FCT1ZFIiwicGFyc2VJbnQiLCJ2ZXJzaW9uIiwic3BsaXQiLCJJU19JT1MiLCJuYXZpZ2F0b3IiLCJ0ZXN0IiwidXNlckFnZW50IiwiTVNTdHJlYW0iLCJJU19BUFBMRSIsIklTX0FORFJPSUQiLCJJU19GSVJFRk9YIiwiSVNfU0FGQVJJIiwiSVNfRURHRV9MRUdBQ1kiLCJJU19DSFJPTUUiLCJJU19DSFJPTUVfTEVHQUNZIiwiSVNfQU5EUk9JRF9DSFJPTUVfTEVHQUNZIiwiSVNfRklSRUZPWF9MRUdBQ1kiLCJJU19VQ19NT0JJTEUiLCJJU19XRUNIQVRCUk9XU0VSIiwiQ0FOX1VTRV9ET00iLCJjcmVhdGVFbGVtZW50IiwiSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIiwiSW5wdXRFdmVudCIsImdldFRhcmdldFJhbmdlcyIsImlzQ29tcG9zaW5nIiwiZ2V0IiwiRXJyb3IiLCJmaW5kS2V5Iiwic2V0IiwiZmluZFBhdGgiLCJwYXRoIiwiaXNFZGl0b3IiLCJ1bnNoaWZ0Iiwic3RyaW5naWZ5IiwiZmluZERvY3VtZW50T3JTaGFkb3dSb290IiwiZWwiLCJ0b0RPTU5vZGUiLCJyb290IiwiZ2V0Um9vdE5vZGUiLCJEb2N1bWVudCIsIlNoYWRvd1Jvb3QiLCJnZXRTZWxlY3Rpb24iLCJpc0ZvY3VzZWQiLCJpc1JlYWRPbmx5IiwiYmx1ciIsImFjdGl2ZUVsZW1lbnQiLCJmb2N1cyIsInByZXZlbnRTY3JvbGwiLCJkZXNlbGVjdCIsInNlbGVjdGlvbiIsImRvbVNlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJyZW1vdmVBbGxSYW5nZXMiLCJvcHRpb25zIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiZWRpdG9yRWwiLCJ0YXJnZXRFbCIsInBhcmVudEVsZW1lbnQiLCJlcnIiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJjbG9zZXN0IiwiaXNDb250ZW50RWRpdGFibGUiLCJpbnNlcnREYXRhIiwiZGF0YSIsImluc2VydEZyYWdtZW50RGF0YSIsImluc2VydFRleHREYXRhIiwic2V0RnJhZ21lbnREYXRhIiwib3JpZ2luRXZlbnQiLCJLRVlfVE9fRUxFTUVOVCIsInRvRE9NUG9pbnQiLCJwb2ludCIsInZvaWQiLCJhdCIsInNlbGVjdG9yIiwidGV4dHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwic3RhcnQiLCJhdHRyIiwidHJ1ZUxlbmd0aCIsImVuZCIsIm5leHRUZXh0IiwiaGFzQXR0cmlidXRlIiwiX25leHRUZXh0JHRleHRDb250ZW50IiwiZG9tVGV4dCIsInN0YXJ0c1dpdGgiLCJNYXRoIiwibWluIiwibWF4IiwidG9ET01SYW5nZSIsInJhbmdlIiwiYW5jaG9yIiwiaXNCYWNrd2FyZCIsImRvbUFuY2hvciIsImRvbUZvY3VzIiwiaXNDb2xsYXBzZWQiLCJkb21SYW5nZSIsImNyZWF0ZVJhbmdlIiwic3RhcnROb2RlIiwic3RhcnRPZmZzZXQiLCJlbmROb2RlIiwiZW5kT2Zmc2V0Iiwic3RhcnRFbCIsImlzU3RhcnRBdFplcm9XaWR0aCIsImVuZEVsIiwiaXNFbmRBdFplcm9XaWR0aCIsInNldFN0YXJ0Iiwic2V0RW5kIiwidG9TbGF0ZU5vZGUiLCJkb21FbCIsImZpbmRFdmVudFJhbmdlIiwibmF0aXZlRXZlbnQiLCJjbGllbnRYIiwieCIsImNsaWVudFkiLCJ5IiwiaXNFbGVtZW50IiwiaXNWb2lkIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImlzUHJldiIsImlzSW5saW5lIiwibGVmdCIsIndpZHRoIiwidG9wIiwiaGVpZ2h0IiwiZWRnZSIsImJlZm9yZSIsImFmdGVyIiwiX3JhbmdlIiwiY2FyZXRSYW5nZUZyb21Qb2ludCIsInBvc2l0aW9uIiwiY2FyZXRQb3NpdGlvbkZyb21Qb2ludCIsIm9mZnNldE5vZGUiLCJ0b1NsYXRlUmFuZ2UiLCJleGFjdE1hdGNoIiwic3VwcHJlc3NUaHJvdyIsInRvU2xhdGVQb2ludCIsIm5lYXJlc3ROb2RlIiwibmVhcmVzdE9mZnNldCIsInRleHROb2RlIiwiX2RvbU5vZGUkdGV4dENvbnRlbnQiLCJfZG9tTm9kZSR0ZXh0Q29udGVudDIiLCJwb3RlbnRpYWxWb2lkTm9kZSIsInZvaWROb2RlIiwibGVhZk5vZGUiLCJjb250ZW50cyIsImNsb25lQ29udGVudHMiLCJyZW1vdmFscyIsInNsaWNlIiwiZm9yRWFjaCIsInRleHRDb250ZXh0IiwicmVtb3ZlQ2hpbGQiLCJsZWFmTm9kZXMiLCJjdXJyZW50IiwiZW5kc1dpdGgiLCJfc2xhdGVOb2RlIiwiX3BhdGgiLCJfb2Zmc2V0IiwicXVlcnlTZWxlY3RvciIsInNsYXRlTm9kZSIsInN0YXJ0Q29udGFpbmVyIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNOb2RlIiwiZm9jdXNPZmZzZXQiLCJlbmRDb250YWluZXIiLCJjb2xsYXBzZWQiLCJfYW5jaG9yTm9kZSR0ZXh0Q29udGUiLCJpc0VuZCIsImlzU3RhcnQiLCJpc0V4cGFuZGVkIiwiaXNGb3J3YXJkIiwibW9kZSIsInVuaGFuZ1JhbmdlIiwidm9pZHMiLCJoYXNSYW5nZSIsImhhc1BhdGgiLCJoYXNUYXJnZXQiLCJoYXNFZGl0YWJsZVRhcmdldCIsImhhc1NlbGVjdGFibGVUYXJnZXQiLCJpc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZCIsImFuZHJvaWRTY2hlZHVsZUZsdXNoIiwiX0VESVRPUl9UT19TQ0hFRFVMRV9GIiwiYW5kcm9pZFBlbmRpbmdEaWZmcyIsIl9leGNsdWRlZCQzIiwiX2V4Y2x1ZGVkMiQxIiwic2hhbGxvd0NvbXBhcmUiLCJvYmoxIiwib2JqMiIsImV2ZXJ5IiwiaGFzT3duUHJvcGVydHkiLCJpc0RlY29yYXRpb25GbGFnc0VxdWFsIiwib3RoZXIiLCJyYW5nZU93blByb3BzIiwib3RoZXJPd25Qcm9wcyIsImlzRWxlbWVudERlY29yYXRpb25zRXF1YWwiLCJsaXN0IiwiYW5vdGhlciIsImVxdWFscyIsImlzVGV4dERlY29yYXRpb25zRXF1YWwiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiU3RyaW5nIiwicHJvcHMiLCJsZWFmIiwidXNlU2xhdGVTdGF0aWMiLCJwYXJlbnRQYXRoIiwiaXNNYXJrUGxhY2Vob2xkZXIiLCJaZXJvV2lkdGhTdHJpbmciLCJzdHJpbmciLCJjaGlsZHJlbiIsImlzTGluZUJyZWFrIiwiVGV4dFN0cmluZyIsImlzVHJhaWxpbmciLCJyZWYiLCJnZXRUZXh0Q29udGVudCIsImluaXRpYWxUZXh0IiwidGV4dFdpdGhUcmFpbGluZyIsIk1lbW9pemVkVGV4dCQxIiwiYXR0cmlidXRlcyIsImFzc2lnbiIsIkVkaXRvckNvbnRleHQiLCJMZWFmIiwicmVuZGVyUGxhY2Vob2xkZXIiLCJyZW5kZXJMZWFmIiwiRGVmYXVsdExlYWYiLCJsYXN0UGxhY2Vob2xkZXJSZWYiLCJwbGFjZWhvbGRlclJlZiIsInBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwicGxhY2Vob2xkZXJFbCIsImRlbGV0ZSIsIm9ic2VydmUiLCJSZXNpemVPYnNlcnZlciQxIiwiZm9yY2VSZW5kZXIiLCJwbGFjZWhvbGRlclByb3BzIiwicGxhY2Vob2xkZXIiLCJzdHlsZSIsInBvaW50ZXJFdmVudHMiLCJtYXhXaWR0aCIsIm9wYWNpdHkiLCJ1c2VyU2VsZWN0IiwidGV4dERlY29yYXRpb24iLCJjb250ZW50RWRpdGFibGUiLCJGcmFnbWVudCIsIk1lbW9pemVkTGVhZiIsInByZXYiLCJuZXh0IiwiZGVjb3JhdGlvbnMiLCJsZWF2ZXMiLCJwdXNoIiwiY2FsbGJhY2tSZWYiLCJzcGFuIiwiTWVtb2l6ZWRUZXh0IiwiZWxlbWVudCIsInJlbmRlckVsZW1lbnQiLCJwIiwiRGVmYXVsdEVsZW1lbnQiLCJyZWFkT25seSIsInVzZVJlYWRPbmx5IiwidXNlQ2hpbGRyZW4iLCJoYXNJbmxpbmVzIiwiZGlyIiwiVGFnIiwiX3RleHQiLCJjb2xvciIsIm91dGxpbmUiLCJNZW1vaXplZEVsZW1lbnQiLCJEZWNvcmF0ZUNvbnRleHQiLCJ1c2VEZWNvcmF0ZSIsIlNlbGVjdGVkQ29udGV4dCIsInVzZVNlbGVjdGVkIiwiZGVjb3JhdGUiLCJpc0xlYWZCbG9jayIsInNlbCIsImludGVyc2VjdGlvbiIsImRzIiwiZGVjIiwiZCIsIlByb3ZpZGVyIiwiUmVhZE9ubHlDb250ZXh0IiwiU2xhdGVDb250ZXh0IiwidXNlU2xhdGUiLCJjb250ZXh0IiwidXNlU2xhdGVXaXRoViIsIlRSSVBMRV9DTElDSyIsIkhPVEtFWVMiLCJib2xkIiwiY29tcG9zZSIsIm1vdmVCYWNrd2FyZCIsIm1vdmVGb3J3YXJkIiwibW92ZVdvcmRCYWNrd2FyZCIsIm1vdmVXb3JkRm9yd2FyZCIsImRlbGV0ZUJhY2t3YXJkIiwiZGVsZXRlRm9yd2FyZCIsImV4dGVuZEJhY2t3YXJkIiwiZXh0ZW5kRm9yd2FyZCIsIml0YWxpYyIsImluc2VydFNvZnRCcmVhayIsInNwbGl0QmxvY2siLCJ1bmRvIiwiQVBQTEVfSE9US0VZUyIsIm1vdmVMaW5lQmFja3dhcmQiLCJtb3ZlTGluZUZvcndhcmQiLCJkZWxldGVMaW5lQmFja3dhcmQiLCJkZWxldGVMaW5lRm9yd2FyZCIsImRlbGV0ZVdvcmRCYWNrd2FyZCIsImRlbGV0ZVdvcmRGb3J3YXJkIiwiZXh0ZW5kTGluZUJhY2t3YXJkIiwiZXh0ZW5kTGluZUZvcndhcmQiLCJyZWRvIiwidHJhbnNwb3NlQ2hhcmFjdGVyIiwiV0lORE9XU19IT1RLRVlTIiwiY3JlYXRlIiwiZ2VuZXJpYyIsImFwcGxlIiwid2luZG93cyIsImlzR2VuZXJpYyIsImlzQXBwbGUiLCJpc1dpbmRvd3MiLCJIb3RrZXlzIiwiaXNCb2xkIiwiaXNDb21wb3NlIiwiaXNNb3ZlQmFja3dhcmQiLCJpc01vdmVGb3J3YXJkIiwiaXNEZWxldGVCYWNrd2FyZCIsImlzRGVsZXRlRm9yd2FyZCIsImlzRGVsZXRlTGluZUJhY2t3YXJkIiwiaXNEZWxldGVMaW5lRm9yd2FyZCIsImlzRGVsZXRlV29yZEJhY2t3YXJkIiwiaXNEZWxldGVXb3JkRm9yd2FyZCIsImlzRXh0ZW5kQmFja3dhcmQiLCJpc0V4dGVuZEZvcndhcmQiLCJpc0V4dGVuZExpbmVCYWNrd2FyZCIsImlzRXh0ZW5kTGluZUZvcndhcmQiLCJpc0l0YWxpYyIsImlzTW92ZUxpbmVCYWNrd2FyZCIsImlzTW92ZUxpbmVGb3J3YXJkIiwiaXNNb3ZlV29yZEJhY2t3YXJkIiwiaXNNb3ZlV29yZEZvcndhcmQiLCJpc1JlZG8iLCJpc1NvZnRCcmVhayIsImlzU3BsaXRCbG9jayIsImlzVHJhbnNwb3NlQ2hhcmFjdGVyIiwiaXNVbmRvIiwiY3JlYXRlUmVzdG9yZURvbU1hbmFnZXIiLCJyZWNlaXZlZFVzZXJJbnB1dCIsImJ1ZmZlcmVkTXV0YXRpb25zIiwiY2xlYXIiLCJyZWdpc3Rlck11dGF0aW9ucyIsIm11dGF0aW9ucyIsInRyYWNrZWRNdXRhdGlvbnMiLCJmaWx0ZXIiLCJyZXN0b3JlRE9NIiwicmV2ZXJzZSIsInR5cGUiLCJpbnNlcnRCZWZvcmUiLCJuZXh0U2libGluZyIsIk1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyQxIiwic3VidHJlZSIsImNoaWxkTGlzdCIsImNoYXJhY3RlckRhdGEiLCJjaGFyYWN0ZXJEYXRhT2xkVmFsdWUiLCJSZXN0b3JlRE9NQ29tcG9uZW50IiwibWFuYWdlciIsIm11dGF0aW9uT2JzZXJ2ZXIiLCJfdGhpcyRtdXRhdGlvbk9ic2VydmUiLCJjb21wb25lbnREaWRNb3VudCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsIl90aGlzJG11dGF0aW9uT2JzZXJ2ZTIiLCJfdGhpcyRtdXRhdGlvbk9ic2VydmUzIiwiX3RoaXMkbWFuYWdlcjIiLCJwZW5kaW5nTXV0YXRpb25zIiwidGFrZVJlY29yZHMiLCJfdGhpcyRtYW5hZ2VyIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiX3RoaXMkbWFuYWdlcjMiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIl90aGlzJG11dGF0aW9uT2JzZXJ2ZTQiLCJyZW5kZXIiLCJjb250ZXh0VHlwZSIsIlJlc3RvcmVET00iLCJ2ZXJpZnlEaWZmU3RhdGUiLCJ0ZXh0RGlmZiIsImRpZmYiLCJpc1RleHQiLCJuZXh0UGF0aCIsIm5leHROb2RlIiwiYXBwbHlTdHJpbmdEaWZmIiwiX2xlbiIsImRpZmZzIiwiX2tleSIsInJlZHVjZSIsImxvbmdlc3RDb21tb25QcmVmaXhMZW5ndGgiLCJzdHIiLCJjaGFyQXQiLCJsb25nZXN0Q29tbW9uU3VmZml4TGVuZ3RoIiwibm9ybWFsaXplU3RyaW5nRGlmZiIsInRhcmdldFRleHQiLCJyZW1vdmVkVGV4dCIsInByZWZpeExlbmd0aCIsInN1ZmZpeExlbmd0aCIsIm5vcm1hbGl6ZWQiLCJtZXJnZVN0cmluZ0RpZmZzIiwiYSIsImIiLCJvdmVybGFwIiwiYXBwbGllZCIsInNsaWNlRW5kIiwidGFyZ2V0UmFuZ2UiLCJub3JtYWxpemVQb2ludCIsInBhcmVudEJsb2NrIiwiYWJvdmUiLCJpc0Jsb2NrIiwiZW50cnkiLCJpc0Rlc2NlbmRhbnQiLCJub3JtYWxpemVSYW5nZSIsInRyYW5zZm9ybVBlbmRpbmdQb2ludCIsIm9wIiwicGVuZGluZ0RpZmZzIiwidHJhbnNmb3JtIiwiYWZmaW5pdHkiLCJfYW5jaG9yIiwiX3RyYW5zZm9ybWVkIiwidHJhbnNmb3JtZWQiLCJ0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UiLCJ0cmFuc2Zvcm1UZXh0RGlmZiIsIm5ld1BhdGgiLCJvd25LZXlzJDMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsInN5bWJvbHMiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJhcHBseSIsIl9vYmplY3RTcHJlYWQkMyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiUkVTT0xWRV9ERUxBWSIsIkZMVVNIX0RFTEFZIiwiZGVidWciLCJpc0RhdGFUcmFuc2ZlciIsIm5hbWUiLCJjcmVhdGVBbmRyb2lkSW5wdXRNYW5hZ2VyIiwic2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSIsIm9uRE9NU2VsZWN0aW9uQ2hhbmdlIiwiZmx1c2hpbmciLCJjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCIsImZsdXNoVGltZW91dElkIiwiYWN0aW9uVGltZW91dElkIiwiaWRDb3VudGVyIiwiaW5zZXJ0UG9zaXRpb25IaW50IiwiYXBwbHlQZW5kaW5nU2VsZWN0aW9uIiwicGVuZGluZ1NlbGVjdGlvbiIsInNlbGVjdCIsInBlcmZvcm1BY3Rpb24iLCJhY3Rpb24iLCJpc1BvaW50IiwiX3RhcmdldFJhbmdlIiwicnVuIiwiZmx1c2giLCJjbGVhclRpbWVvdXQiLCJoYXNQZW5kaW5nRGlmZnMiLCJoYXNQZW5kaW5nQWN0aW9uIiwic2V0VGltZW91dCIsInNlbGVjdGlvblJlZiIsInJhbmdlUmVmIiwibWFya3MiLCJzY2hlZHVsZVNlbGVjdGlvbkNoYW5nZSIsIl9FRElUT1JfVE9fUEVORElOR19ESSIsIl9FRElUT1JfVE9fUEVORElOR19ESTIiLCJwZW5kaW5nTWFya3MiLCJpbnNlcnRUZXh0IiwiZGVsZXRlRnJhZ21lbnQiLCJfcmVmMiIsImNhbmNlbCIsInVucmVmIiwidXNlck1hcmtzIiwib25DaGFuZ2UiLCJoYW5kbGVDb21wb3NpdGlvbkVuZCIsIl9ldmVudCIsImhhbmRsZUNvbXBvc2l0aW9uU3RhcnQiLCJ1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkiLCJmb3JjZUhpZGUiLCJwbGFjZWhvbGRlckVsZW1lbnQiLCJyZW1vdmVQcm9wZXJ0eSIsInN0b3JlRGlmZiIsIl9FRElUT1JfVE9fUEVORElOR19ESTMiLCJpZHgiLCJmaW5kSW5kZXgiLCJjaGFuZ2UiLCJtZXJnZWQiLCJzcGxpY2UiLCJzY2hlZHVsZUFjdGlvbiIsImhhbmRsZURPTUJlZm9yZUlucHV0IiwiX3RhcmdldFJhbmdlMiIsImlucHV0VHlwZSIsIm5hdGl2ZVRhcmdldFJhbmdlIiwiY2FuU3RvcmVEaWZmIiwiX3N0YXJ0IiwiX2VuZCIsImVkZ2VzIiwiX2xlYWYiLCJyZWxldmFudFBlbmRpbmdEaWZmcyIsImhhbmRsZVVzZXJTZWxlY3QiLCJ0YXJnZXROb2RlIiwiX25hdGl2ZVRhcmdldFJhbmdlIiwibmF0aXZlQ29sbGFwc2VkIiwidW5pdCIsImluc2VydEJyZWFrIiwicmVwbGFjZSIsInBhcnRzIiwibGluZSIsIl9zdGFydDIiLCJfZW5kMiIsIl9kaWZmIiwiaGludFBvc2l0aW9uIiwic2VhcmNoIiwiZGlmZlBvc2l0aW9uIiwic2NoZWR1bGVGbHVzaCIsIl9FRElUT1JfVE9fUEVORElOR19ESTQiLCJoYXNQZW5kaW5nQ2hhbmdlcyIsImlzRmx1c2hpbmciLCJwYXRoQ2hhbmdlZCIsInBhcmVudFBhdGhDaGFuZ2VkIiwiaGFuZGxlSW5wdXQiLCJoYW5kbGVLZXlEb3duIiwiXyIsImhhbmRsZURvbU11dGF0aW9ucyIsInNvbWUiLCJfRURJVE9SX1RPX0ZPUkNFX1JFTkQiLCJ1c2VJc01vdW50ZWQiLCJpc01vdW50ZWRSZWYiLCJ1c2VNdXRhdGlvbk9ic2VydmVyIiwiY2FsbGJhY2siLCJfZXhjbHVkZWQkMiIsIm93bktleXMkMiIsIl9vYmplY3RTcHJlYWQkMiIsIk1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyIsInVzZUFuZHJvaWRJbnB1dE1hbmFnZXIiLCJpc01vdW50ZWQiLCJpbnB1dE1hbmFnZXIiLCJ1c2VUcmFja1VzZXJJbnB1dCIsImFuaW1hdGlvbkZyYW1lSWRSZWYiLCJvblVzZXJJbnB1dCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX2V4Y2x1ZGVkJDEiLCJfZXhjbHVkZWQyIiwib3duS2V5cyQxIiwiX29iamVjdFNwcmVhZCQxIiwiQ2hpbGRyZW4iLCJFZGl0YWJsZSIsIl9FRElUT1JfVE9fUExBQ0VIT0xERSIsIl9FRElUT1JfVE9fUExBQ0VIT0xERTIiLCJkZWZhdWx0UmVuZGVyUGxhY2Vob2xkZXIiLCJEZWZhdWx0UGxhY2Vob2xkZXIiLCJhdXRvRm9jdXMiLCJkZWZhdWx0RGVjb3JhdGUiLCJvbkRPTUJlZm9yZUlucHV0IiwicHJvcHNPbkRPTUJlZm9yZUlucHV0Iiwic2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXciLCJkZWZhdWx0U2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXciLCJ1c2VyU3R5bGUiLCJhcyIsImRpc2FibGVEZWZhdWx0U3R5bGVzIiwic2V0SXNDb21wb3NpbmciLCJkZWZlcnJlZE9wZXJhdGlvbnMiLCJzIiwic3RhdGUiLCJpc0RyYWdnaW5nSW50ZXJuYWxseSIsImlzVXBkYXRpbmdTZWxlY3Rpb24iLCJsYXRlc3RFbGVtZW50IiwiaGFzTWFya1BsYWNlaG9sZGVyIiwiYW5kcm9pZElucHV0TWFuYWdlciIsImFuY2hvck5vZGVTZWxlY3RhYmxlIiwiZm9jdXNOb2RlU2VsZWN0YWJsZSIsInNldERvbVNlbGVjdGlvbiIsImZvcmNlQ2hhbmdlIiwiaGFzRG9tU2VsZWN0aW9uIiwiZWRpdG9yRWxlbWVudCIsImhhc0RvbVNlbGVjdGlvbkluRWRpdG9yIiwic2xhdGVSYW5nZSIsIl9hbmNob3JOb2RlJHBhcmVudEVsZSIsIm5ld0RvbVJhbmdlIiwic2V0QmFzZUFuZEV4dGVudCIsImVuc3VyZVNlbGVjdGlvbiIsInRpbWVvdXRJZCIsImFuaW1hdGlvbkZyYW1lSWQiLCJlbnN1cmVEb21TZWxlY3Rpb24iLCJlIiwiaXNET01FdmVudEhhbmRsZWQiLCJfRURJVE9SX1RPX1VTRVJfU0VMRUMiLCJpc0NvbXBvc2l0aW9uQ2hhbmdlIiwibmF0aXZlIiwiX25vZGUkcGFyZW50RWxlbWVudCIsIl93aW5kb3ckZ2V0Q29tcHV0ZWRTdCIsIl9sYXN0VGV4dCR0ZXh0Q29udGVudCIsImxhc3RUZXh0IiwiY3JlYXRlVHJlZVdhbGtlciIsIk5vZGVGaWx0ZXIiLCJTSE9XX1RFWFQiLCJsYXN0Q2hpbGQiLCJ3aGl0ZVNwYWNlIiwiYmxvY2siLCJwcmV2ZW50RGVmYXVsdCIsInRvUmVzdG9yZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVzdCIsImxvb3NlIiwidW5zZXQiLCJmcm9tRW50cmllcyIsIm1hcCIsIm1hcmsiLCJwbGFjZWhvbGRlckhlaWdodCIsInJvbGUiLCJzcGVsbENoZWNrIiwiYXV0b0NvcnJlY3QiLCJhdXRvQ2FwaXRhbGl6ZSIsInppbmRleCIsInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyIsIndvcmRXcmFwIiwibWluSGVpZ2h0Iiwib25CZWZvcmVJbnB1dCIsImlzRXZlbnRIYW5kbGVkIiwiX3RleHQyIiwib25JbnB1dCIsIm9uQmx1ciIsInJlbGF0ZWRUYXJnZXQiLCJvbkNsaWNrIiwiZGV0YWlsIiwiYmxvY2tQYXRoIiwiX2Jsb2NrJCIsInN0YXJ0Vm9pZCIsImVuZFZvaWQiLCJvbkNvbXBvc2l0aW9uRW5kIiwicGxhY2Vob2xkZXJNYXJrcyIsIm9uQ29tcG9zaXRpb25VcGRhdGUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJpbmxpbmUiLCJpbmxpbmVQYXRoIiwic2V0U2VsZWN0aW9uIiwib25Db3B5Iiwib25DdXQiLCJvbkRyYWdPdmVyIiwib25EcmFnU3RhcnQiLCJ2b2lkTWF0Y2giLCJvbkRyb3AiLCJkcmFnZ2VkUmFuZ2UiLCJvbkRyYWdFbmQiLCJvbkZvY3VzIiwib25LZXlEb3duIiwiaXNSVEwiLCJtYXliZUhpc3RvcnlFZGl0b3IiLCJfbWF5YmVIaXN0b3J5RWRpdG9yIiwibW92ZSIsImNvbGxhcHNlIiwiY3VycmVudE5vZGUiLCJvblBhc3RlIiwibGVhZkVsIiwiYmluZCIsInNjcm9sbE1vZGUiLCJoYW5kbGVyIiwic2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsIkZvY3VzZWRDb250ZXh0IiwidXNlRm9jdXNlZCIsImlzRXJyb3IiLCJlcnJvciIsIlNsYXRlU2VsZWN0b3JDb250ZXh0IiwicmVmRXF1YWxpdHkiLCJ1c2VTbGF0ZVNlbGVjdG9yIiwiZXF1YWxpdHlGbiIsImdldFNsYXRlIiwibGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciIsImxhdGVzdFNlbGVjdG9yIiwibGF0ZXN0U2VsZWN0ZWRTdGF0ZSIsInNlbGVjdGVkU3RhdGUiLCJzdGFjayIsImNoZWNrRm9yVXBkYXRlcyIsIm5ld1NlbGVjdGVkU3RhdGUiLCJ1bnN1YnNjcmliZSIsImdldFNlbGVjdG9yQ29udGV4dCIsImV2ZW50TGlzdGVuZXJzIiwic2xhdGVSZWYiLCJsaXN0ZW5lciIsInNlbGVjdG9yQ29udGV4dCIsIl9leGNsdWRlZCIsIlNsYXRlIiwidW5tb3VudFJlZiIsInNldENvbnRleHQiLCJpc05vZGVMaXN0IiwidiIsImhhbmRsZVNlbGVjdG9yQ2hhbmdlIiwib25Db250ZXh0Q2hhbmdlIiwicHJldkNvbnRleHQiLCJzZXRJc0ZvY3VzZWQiLCJmbiIsInVzZUVkaXRvciIsInVzZVNsYXRlU2VsZWN0aW9uIiwiaXNTZWxlY3Rpb25FcXVhbCIsImRvUmVjdHNJbnRlcnNlY3QiLCJjb21wYXJlUmVjdCIsIm1pZGRsZSIsImJvdHRvbSIsImFyZVJhbmdlc1NhbWVMaW5lIiwicmFuZ2UxIiwicmFuZ2UyIiwicmVjdDEiLCJyZWN0MiIsImZpbmRDdXJyZW50TGluZVJhbmdlIiwicGFyZW50UmFuZ2UiLCJwYXJlbnRSYW5nZUJvdW5kYXJ5IiwicG9zaXRpb25zIiwicmlnaHQiLCJmbG9vciIsIm93bktleXMiLCJfb2JqZWN0U3ByZWFkIiwid2l0aFJlYWN0IiwiY2xpcGJvYXJkRm9ybWF0S2V5IiwiYWRkTWFyayIsInJlbW92ZU1hcmsiLCJwYXJlbnRCbG9ja0VudHJ5IiwicGFyZW50QmxvY2tQYXRoIiwicGFyZW50RWxlbWVudFJhbmdlIiwiY3VycmVudExpbmVSYW5nZSIsIkJvb2xlYW4iLCJwZW5kaW5nQWN0aW9uIiwiZ2V0TWF0Y2hlcyIsInByZXZQYXRoIiwicHJldmlvdXMiLCJjb21tb25QYXRoIiwiY29tbW9uIiwiYXR0YWNoIiwidHJpbSIsInIiLCJjbG9uZVJhbmdlIiwic2V0RW5kQWZ0ZXIiLCJ6dyIsImlzTmV3bGluZSIsImFwcGVuZENoaWxkIiwiZ2V0RnJhZ21lbnQiLCJKU09OIiwiZW5jb2RlZCIsImJ0b2EiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzZXRBdHRyaWJ1dGUiLCJzZXREYXRhIiwiZGl2IiwiYm9keSIsImlubmVySFRNTCIsImRlY29kZWQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJhdG9iIiwicGFyc2VkIiwicGFyc2UiLCJpbnNlcnRGcmFnbWVudCIsImxpbmVzIiwic3BsaXROb2RlcyIsImFsd2F5cyIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwibGV2ZWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-react/dist/index.es.js\n");

/***/ })

};
;