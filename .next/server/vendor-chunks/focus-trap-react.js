"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/focus-trap-react";
exports.ids = ["vendor-chunks/focus-trap-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/focus-trap-react/dist/focus-trap-react.js":
/*!****************************************************************!*\
  !*** ./node_modules/focus-trap-react/dist/focus-trap-react.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (_typeof(input) !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (_typeof(res) !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar PropTypes = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\nvar _require = __webpack_require__(/*! focus-trap */ \"(ssr)/./node_modules/focus-trap/dist/focus-trap.esm.js\"), createFocusTrap = _require.createFocusTrap;\nvar _require2 = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\"), isFocusable = _require2.isFocusable;\nvar FocusTrap = /*#__PURE__*/ function(_React$Component) {\n    _inherits(FocusTrap, _React$Component);\n    var _super = _createSuper(FocusTrap);\n    function FocusTrap(props) {\n        var _this;\n        _classCallCheck(this, FocusTrap);\n        _this = _super.call(this, props);\n        /**\n     * Gets the node for the given option, which is expected to be an option that\n     *  can be either a DOM node, a string that is a selector to get a node, `false`\n     *  (if a node is explicitly NOT given), or a function that returns any of these\n     *  values.\n     * @param {string} optionName\n     * @returns {undefined | false | HTMLElement | SVGElement} Returns\n     *  `undefined` if the option is not specified; `false` if the option\n     *  resolved to `false` (node explicitly not given); otherwise, the resolved\n     *  DOM node.\n     * @throws {Error} If the option is set, not `false`, and is not, or does not\n     *  resolve to a node.\n     */ _defineProperty(_assertThisInitialized(_this), \"getNodeForOption\", function(optionName) {\n            var _this$internalOptions;\n            // use internal options first, falling back to original options\n            var optionValue = (_this$internalOptions = this.internalOptions[optionName]) !== null && _this$internalOptions !== void 0 ? _this$internalOptions : this.originalOptions[optionName];\n            if (typeof optionValue === \"function\") {\n                for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    params[_key - 1] = arguments[_key];\n                }\n                optionValue = optionValue.apply(void 0, params);\n            }\n            if (optionValue === true) {\n                optionValue = undefined; // use default value\n            }\n            if (!optionValue) {\n                if (optionValue === undefined || optionValue === false) {\n                    return optionValue;\n                }\n                // else, empty string (invalid), null (invalid), 0 (invalid)\n                throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n            }\n            var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n            if (typeof optionValue === \"string\") {\n                var _this$getDocument;\n                node = (_this$getDocument = this.getDocument()) === null || _this$getDocument === void 0 ? void 0 : _this$getDocument.querySelector(optionValue); // resolve to node, or null if fails\n                if (!node) {\n                    throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n                }\n            }\n            return node;\n        });\n        _this.handleDeactivate = _this.handleDeactivate.bind(_assertThisInitialized(_this));\n        _this.handlePostDeactivate = _this.handlePostDeactivate.bind(_assertThisInitialized(_this));\n        _this.handleClickOutsideDeactivates = _this.handleClickOutsideDeactivates.bind(_assertThisInitialized(_this));\n        // focus-trap options used internally when creating the trap\n        _this.internalOptions = {\n            // We need to hijack the returnFocusOnDeactivate option,\n            // because React can move focus into the element before we arrived at\n            // this lifecycle hook (e.g. with autoFocus inputs). So the component\n            // captures the previouslyFocusedElement in componentWillMount,\n            // then (optionally) returns focus to it in componentWillUnmount.\n            returnFocusOnDeactivate: false,\n            // the rest of these are also related to deactivation of the trap, and we\n            //  need to use them and control them as well\n            checkCanReturnFocus: null,\n            onDeactivate: _this.handleDeactivate,\n            onPostDeactivate: _this.handlePostDeactivate,\n            // we need to special-case this setting as well so that we can know if we should\n            //  NOT return focus if the trap gets auto-deactivated as the result of an\n            //  outside click (otherwise, we'll always think we should return focus because\n            //  of how we manage that flag internally here)\n            clickOutsideDeactivates: _this.handleClickOutsideDeactivates\n        };\n        // original options provided by the consumer\n        _this.originalOptions = {\n            // because of the above `internalOptions`, we maintain our own flag for\n            //  this option, and default it to `true` because that's focus-trap's default\n            returnFocusOnDeactivate: true,\n            // because of the above `internalOptions`, we keep these separate since\n            //  they're part of the deactivation process which we configure (internally) to\n            //  be shared between focus-trap and focus-trap-react\n            onDeactivate: null,\n            onPostDeactivate: null,\n            checkCanReturnFocus: null,\n            // the user's setting, defaulted to false since focus-trap defaults this to false\n            clickOutsideDeactivates: false\n        };\n        var focusTrapOptions = props.focusTrapOptions;\n        for(var optionName in focusTrapOptions){\n            if (!Object.prototype.hasOwnProperty.call(focusTrapOptions, optionName)) {\n                continue;\n            }\n            if (optionName === \"returnFocusOnDeactivate\" || optionName === \"onDeactivate\" || optionName === \"onPostDeactivate\" || optionName === \"checkCanReturnFocus\" || optionName === \"clickOutsideDeactivates\") {\n                _this.originalOptions[optionName] = focusTrapOptions[optionName];\n                continue; // exclude from internalOptions\n            }\n            _this.internalOptions[optionName] = focusTrapOptions[optionName];\n        }\n        // if set, `{ target: Node, allowDeactivation: boolean }` where `target` is the outside\n        //  node that was clicked, and `allowDeactivation` is the result of the consumer's\n        //  option (stored in `this.originalOptions.clickOutsideDeactivates`, which may be a\n        //  function) whether to allow or deny auto-deactivation on click on this outside node\n        _this.outsideClick = null;\n        // elements from which to create the focus trap on mount; if a child is used\n        //  instead of the `containerElements` prop, we'll get the child's related\n        //  element when the trap renders and then is declared 'mounted'\n        _this.focusTrapElements = props.containerElements || [];\n        // now we remember what the currently focused element is, not relying on focus-trap\n        _this.updatePreviousElement();\n        return _this;\n    }\n    /**\n   * Gets the configured document.\n   * @returns {Document|undefined} Configured document, falling back to the main\n   *  document, if it exists. During SSR, `undefined` is returned since the\n   *  document doesn't exist.\n   */ _createClass(FocusTrap, [\n        {\n            key: \"getDocument\",\n            value: function getDocument() {\n                // SSR: careful to check if `document` exists before accessing it as a variable\n                return this.props.focusTrapOptions.document || (typeof document !== \"undefined\" ? document : undefined);\n            }\n        },\n        {\n            key: \"getReturnFocusNode\",\n            value: function getReturnFocusNode() {\n                var node = this.getNodeForOption(\"setReturnFocus\", this.previouslyFocusedElement);\n                return node ? node : node === false ? false : this.previouslyFocusedElement;\n            }\n        },\n        {\n            key: \"updatePreviousElement\",\n            value: function updatePreviousElement() {\n                var currentDocument = this.getDocument();\n                if (currentDocument) {\n                    this.previouslyFocusedElement = currentDocument.activeElement;\n                }\n            }\n        },\n        {\n            key: \"deactivateTrap\",\n            value: function deactivateTrap() {\n                // NOTE: it's possible the focus trap has already been deactivated without our knowing it,\n                //  especially if the user set the `clickOutsideDeactivates: true` option on the trap,\n                //  and the mouse was clicked on some element outside the trap; at that point, focus-trap\n                //  will initiate its auto-deactivation process, which will call our own\n                //  handleDeactivate(), which will call into this method\n                if (!this.focusTrap || !this.focusTrap.active) {\n                    return;\n                }\n                this.focusTrap.deactivate({\n                    // NOTE: we never let the trap return the focus since we do that ourselves\n                    returnFocus: false,\n                    // we'll call this in our own post deactivate handler so make sure the trap doesn't\n                    //  do it prematurely\n                    checkCanReturnFocus: null,\n                    // let it call the user's original deactivate handler, if any, instead of\n                    //  our own which calls back into this function\n                    onDeactivate: this.originalOptions.onDeactivate\n                });\n            }\n        },\n        {\n            key: \"handleClickOutsideDeactivates\",\n            value: function handleClickOutsideDeactivates(event) {\n                // use consumer's option (or call their handler) as the permission or denial\n                var allowDeactivation = typeof this.originalOptions.clickOutsideDeactivates === \"function\" ? this.originalOptions.clickOutsideDeactivates.call(null, event) // call out of context\n                 : this.originalOptions.clickOutsideDeactivates; // boolean\n                if (allowDeactivation) {\n                    // capture the outside target that was clicked so we can use it in the deactivation\n                    //  process since the consumer allowed it to cause auto-deactivation\n                    this.outsideClick = {\n                        target: event.target,\n                        allowDeactivation: allowDeactivation\n                    };\n                }\n                return allowDeactivation;\n            }\n        },\n        {\n            key: \"handleDeactivate\",\n            value: function handleDeactivate() {\n                if (this.originalOptions.onDeactivate) {\n                    this.originalOptions.onDeactivate.call(null); // call user's handler out of context\n                }\n                this.deactivateTrap();\n            }\n        },\n        {\n            key: \"handlePostDeactivate\",\n            value: function handlePostDeactivate() {\n                var _this2 = this;\n                var finishDeactivation = function finishDeactivation() {\n                    var returnFocusNode = _this2.getReturnFocusNode();\n                    var canReturnFocus = !!// did the consumer allow it?\n                    (_this2.originalOptions.returnFocusOnDeactivate && // can we actually focus the node?\n                    returnFocusNode !== null && returnFocusNode !== void 0 && returnFocusNode.focus && // was there an outside click that allowed deactivation?\n                    (!_this2.outsideClick || // did the consumer allow deactivation when the outside node was clicked?\n                    _this2.outsideClick.allowDeactivation && // is the outside node NOT focusable (implying that it did NOT receive focus\n                    //  as a result of the click-through) -- in which case do NOT restore focus\n                    //  to `returnFocusNode` because focus should remain on the outside node\n                    !isFocusable(_this2.outsideClick.target, _this2.internalOptions.tabbableOptions)));\n                    var _this2$internalOption = _this2.internalOptions.preventScroll, preventScroll = _this2$internalOption === void 0 ? false : _this2$internalOption;\n                    if (canReturnFocus) {\n                        // return focus to the element that had focus when the trap was activated\n                        returnFocusNode.focus({\n                            preventScroll: preventScroll\n                        });\n                    }\n                    if (_this2.originalOptions.onPostDeactivate) {\n                        _this2.originalOptions.onPostDeactivate.call(null); // don't call it in context of \"this\"\n                    }\n                    _this2.outsideClick = null; // reset: no longer needed\n                };\n                if (this.originalOptions.checkCanReturnFocus) {\n                    this.originalOptions.checkCanReturnFocus.call(null, this.getReturnFocusNode()) // call out of context\n                    .then(finishDeactivation, finishDeactivation);\n                } else {\n                    finishDeactivation();\n                }\n            }\n        },\n        {\n            key: \"setupFocusTrap\",\n            value: function setupFocusTrap() {\n                if (this.focusTrap) {\n                    // trap already exists: it's possible we're in StrictMode and we're being remounted,\n                    //  in which case, we will have deactivated the trap when we got unmounted (remember,\n                    //  StrictMode, in development, purposely unmounts and remounts components after\n                    //  mounting them the first time to make sure they have reusable state,\n                    //  @see https://reactjs.org/docs/strict-mode.html#ensuring-reusable-state) so now\n                    //  we need to restore the state of the trap according to our component state\n                    // NOTE: Strict mode __violates__ assumptions about the `componentWillUnmount()` API\n                    //  which clearly states -- even for React 18 -- that, \"Once a component instance is\n                    //  unmounted, __it will never be mounted again.__\" (emphasis ours). So when we get\n                    //  unmounted, we assume we're gone forever and we deactivate the trap. But then\n                    //  we get remounted and we're supposed to restore state. But if you had paused,\n                    //  we've now deactivated (we don't know we're amount to get remounted again)\n                    //  which means we need to reactivate and then pause. Otherwise, do nothing.\n                    if (this.props.active && !this.focusTrap.active) {\n                        this.focusTrap.activate();\n                        if (this.props.paused) {\n                            this.focusTrap.pause();\n                        }\n                    }\n                } else {\n                    var nodesExist = this.focusTrapElements.some(Boolean);\n                    if (nodesExist) {\n                        // eslint-disable-next-line react/prop-types -- _createFocusTrap is an internal prop\n                        this.focusTrap = this.props._createFocusTrap(this.focusTrapElements, this.internalOptions);\n                        if (this.props.active) {\n                            this.focusTrap.activate();\n                        }\n                        if (this.props.paused) {\n                            this.focusTrap.pause();\n                        }\n                    }\n                }\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                if (this.props.active) {\n                    this.setupFocusTrap();\n                }\n            // else, wait for later activation in case the `focusTrapOptions` will be updated\n            //  again before the trap is activated (e.g. if waiting to know what the document\n            //  object will be, so the Trap must be rendered, but the consumer is waiting to\n            //  activate until they have obtained the document from a ref)\n            //  @see https://github.com/focus-trap/focus-trap-react/issues/539\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate(prevProps) {\n                if (this.focusTrap) {\n                    if (prevProps.containerElements !== this.props.containerElements) {\n                        this.focusTrap.updateContainerElements(this.props.containerElements);\n                    }\n                    var hasActivated = !prevProps.active && this.props.active;\n                    var hasDeactivated = prevProps.active && !this.props.active;\n                    var hasPaused = !prevProps.paused && this.props.paused;\n                    var hasUnpaused = prevProps.paused && !this.props.paused;\n                    if (hasActivated) {\n                        this.updatePreviousElement();\n                        this.focusTrap.activate();\n                    }\n                    if (hasDeactivated) {\n                        this.deactivateTrap();\n                        return; // un/pause does nothing on an inactive trap\n                    }\n                    if (hasPaused) {\n                        this.focusTrap.pause();\n                    }\n                    if (hasUnpaused) {\n                        this.focusTrap.unpause();\n                    }\n                } else {\n                    // NOTE: if we're in `componentDidUpdate` and we don't have a trap yet,\n                    //  it either means it shouldn't be active, or it should be but none of\n                    //  of given `containerElements` were present in the DOM the last time\n                    //  we tried to create the trap\n                    if (prevProps.containerElements !== this.props.containerElements) {\n                        this.focusTrapElements = this.props.containerElements;\n                    }\n                    // don't create the trap unless it should be active in case the consumer\n                    //  is still updating `focusTrapOptions`\n                    //  @see https://github.com/focus-trap/focus-trap-react/issues/539\n                    if (this.props.active) {\n                        this.updatePreviousElement();\n                        this.setupFocusTrap();\n                    }\n                }\n            }\n        },\n        {\n            key: \"componentWillUnmount\",\n            value: function componentWillUnmount() {\n                this.deactivateTrap();\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this3 = this;\n                var child = this.props.children ? React.Children.only(this.props.children) : undefined;\n                if (child) {\n                    if (child.type && child.type === React.Fragment) {\n                        throw new Error(\"A focus-trap cannot use a Fragment as its child container. Try replacing it with a <div> element.\");\n                    }\n                    var callbackRef = function callbackRef(element) {\n                        var containerElements = _this3.props.containerElements;\n                        if (child) {\n                            if (typeof child.ref === \"function\") {\n                                child.ref(element);\n                            } else if (child.ref) {\n                                child.ref.current = element;\n                            }\n                        }\n                        _this3.focusTrapElements = containerElements ? containerElements : [\n                            element\n                        ];\n                    };\n                    var childWithRef = React.cloneElement(child, {\n                        ref: callbackRef\n                    });\n                    return childWithRef;\n                }\n                return null;\n            }\n        }\n    ]);\n    return FocusTrap;\n}(React.Component); // support server-side rendering where `Element` will not be defined\nvar ElementType = typeof Element === \"undefined\" ? Function : Element;\nFocusTrap.propTypes = {\n    active: PropTypes.bool,\n    paused: PropTypes.bool,\n    focusTrapOptions: PropTypes.shape({\n        document: PropTypes.object,\n        onActivate: PropTypes.func,\n        onPostActivate: PropTypes.func,\n        checkCanFocusTrap: PropTypes.func,\n        onPause: PropTypes.func,\n        onPostPause: PropTypes.func,\n        onUnpause: PropTypes.func,\n        onPostUnpause: PropTypes.func,\n        onDeactivate: PropTypes.func,\n        onPostDeactivate: PropTypes.func,\n        checkCanReturnFocus: PropTypes.func,\n        initialFocus: PropTypes.oneOfType([\n            PropTypes.instanceOf(ElementType),\n            PropTypes.string,\n            PropTypes.bool,\n            PropTypes.func\n        ]),\n        fallbackFocus: PropTypes.oneOfType([\n            PropTypes.instanceOf(ElementType),\n            PropTypes.string,\n            // NOTE: does not support `false` as value (or return value from function)\n            PropTypes.func\n        ]),\n        escapeDeactivates: PropTypes.oneOfType([\n            PropTypes.bool,\n            PropTypes.func\n        ]),\n        clickOutsideDeactivates: PropTypes.oneOfType([\n            PropTypes.bool,\n            PropTypes.func\n        ]),\n        returnFocusOnDeactivate: PropTypes.bool,\n        setReturnFocus: PropTypes.oneOfType([\n            PropTypes.instanceOf(ElementType),\n            PropTypes.string,\n            PropTypes.bool,\n            PropTypes.func\n        ]),\n        allowOutsideClick: PropTypes.oneOfType([\n            PropTypes.bool,\n            PropTypes.func\n        ]),\n        preventScroll: PropTypes.bool,\n        tabbableOptions: PropTypes.shape({\n            displayCheck: PropTypes.oneOf([\n                \"full\",\n                \"legacy-full\",\n                \"non-zero-area\",\n                \"none\"\n            ]),\n            getShadowRoot: PropTypes.oneOfType([\n                PropTypes.bool,\n                PropTypes.func\n            ])\n        }),\n        trapStack: PropTypes.array,\n        isKeyForward: PropTypes.func,\n        isKeyBackward: PropTypes.func\n    }),\n    containerElements: PropTypes.arrayOf(PropTypes.instanceOf(ElementType)),\n    // DOM element ONLY\n    children: PropTypes.oneOfType([\n        PropTypes.element,\n        // React element\n        PropTypes.instanceOf(ElementType) // DOM element\n    ])\n};\nFocusTrap.defaultProps = {\n    active: true,\n    paused: false,\n    focusTrapOptions: {},\n    _createFocusTrap: createFocusTrap\n};\nmodule.exports = FocusTrap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC1yZWFjdC9kaXN0L2ZvY3VzLXRyYXAtcmVhY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ssZ0JBQWdCQyxRQUFRLEVBQUVDLFdBQVc7SUFBSSxJQUFJLENBQUVELENBQUFBLG9CQUFvQkMsV0FBVSxHQUFJO1FBQUUsTUFBTSxJQUFJQyxVQUFVO0lBQXNDO0FBQUU7QUFDeEosU0FBU0Msa0JBQWtCQyxNQUFNLEVBQUVDLEtBQUs7SUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsTUFBTUUsTUFBTSxFQUFFRCxJQUFLO1FBQUUsSUFBSUUsYUFBYUgsS0FBSyxDQUFDQyxFQUFFO1FBQUVFLFdBQVdDLFVBQVUsR0FBR0QsV0FBV0MsVUFBVSxJQUFJO1FBQU9ELFdBQVdFLFlBQVksR0FBRztRQUFNLElBQUksV0FBV0YsWUFBWUEsV0FBV0csUUFBUSxHQUFHO1FBQU1DLE9BQU9DLGNBQWMsQ0FBQ1QsUUFBUVUsZUFBZU4sV0FBV08sR0FBRyxHQUFHUDtJQUFhO0FBQUU7QUFDNVUsU0FBU1EsYUFBYWYsV0FBVyxFQUFFZ0IsVUFBVSxFQUFFQyxXQUFXO0lBQUksSUFBSUQsWUFBWWQsa0JBQWtCRixZQUFZSCxTQUFTLEVBQUVtQjtJQUFhLElBQUlDLGFBQWFmLGtCQUFrQkYsYUFBYWlCO0lBQWNOLE9BQU9DLGNBQWMsQ0FBQ1osYUFBYSxhQUFhO1FBQUVV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SCxPQUFPLENBQUMxSCxVQUFVNkcsVUFBVSxDQUFDakI7SUFDMUQsbUJBQW1CO0lBQ25CWixVQUFVaEYsVUFBVTRHLFNBQVMsQ0FBQztRQUFDNUcsVUFBVXNGLE9BQU87UUFDaEQsZ0JBQWdCO1FBQ2hCdEYsVUFBVTZHLFVBQVUsQ0FBQ2pCLGFBQWEsY0FBYztLQUMvQztBQUtIO0FBRUF2RixVQUFVc0gsWUFBWSxHQUFHO0lBQ3ZCN0UsUUFBUTtJQUNSZ0IsUUFBUTtJQUNSOUIsa0JBQWtCLENBQUM7SUFDbkJrQyxrQkFBa0JoRTtBQUNwQjtBQUNBMEgsT0FBT0MsT0FBTyxHQUFHeEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWdjb21tZXJjZS8uL25vZGVfbW9kdWxlcy9mb2N1cy10cmFwLXJlYWN0L2Rpc3QvZm9jdXMtdHJhcC1yZWFjdC5qcz9jOTI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdmb2N1cy10cmFwJyksXG4gIGNyZWF0ZUZvY3VzVHJhcCA9IF9yZXF1aXJlLmNyZWF0ZUZvY3VzVHJhcDtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd0YWJiYWJsZScpLFxuICBpc0ZvY3VzYWJsZSA9IF9yZXF1aXJlMi5pc0ZvY3VzYWJsZTtcbnZhciBGb2N1c1RyYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEZvY3VzVHJhcCwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRm9jdXNUcmFwKTtcbiAgZnVuY3Rpb24gRm9jdXNUcmFwKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb2N1c1RyYXApO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5vZGUgZm9yIHRoZSBnaXZlbiBvcHRpb24sIHdoaWNoIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9wdGlvbiB0aGF0XG4gICAgICogIGNhbiBiZSBlaXRoZXIgYSBET00gbm9kZSwgYSBzdHJpbmcgdGhhdCBpcyBhIHNlbGVjdG9yIHRvIGdldCBhIG5vZGUsIGBmYWxzZWBcbiAgICAgKiAgKGlmIGEgbm9kZSBpcyBleHBsaWNpdGx5IE5PVCBnaXZlbiksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFueSBvZiB0aGVzZVxuICAgICAqICB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbk5hbWVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkIHwgZmFsc2UgfCBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IFJldHVybnNcbiAgICAgKiAgYHVuZGVmaW5lZGAgaWYgdGhlIG9wdGlvbiBpcyBub3Qgc3BlY2lmaWVkOyBgZmFsc2VgIGlmIHRoZSBvcHRpb25cbiAgICAgKiAgcmVzb2x2ZWQgdG8gYGZhbHNlYCAobm9kZSBleHBsaWNpdGx5IG5vdCBnaXZlbik7IG90aGVyd2lzZSwgdGhlIHJlc29sdmVkXG4gICAgICogIERPTSBub2RlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgb3B0aW9uIGlzIHNldCwgbm90IGBmYWxzZWAsIGFuZCBpcyBub3QsIG9yIGRvZXMgbm90XG4gICAgICogIHJlc29sdmUgdG8gYSBub2RlLlxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXROb2RlRm9yT3B0aW9uXCIsIGZ1bmN0aW9uIChvcHRpb25OYW1lKSB7XG4gICAgICB2YXIgX3RoaXMkaW50ZXJuYWxPcHRpb25zO1xuICAgICAgLy8gdXNlIGludGVybmFsIG9wdGlvbnMgZmlyc3QsIGZhbGxpbmcgYmFjayB0byBvcmlnaW5hbCBvcHRpb25zXG4gICAgICB2YXIgb3B0aW9uVmFsdWUgPSAoX3RoaXMkaW50ZXJuYWxPcHRpb25zID0gdGhpcy5pbnRlcm5hbE9wdGlvbnNbb3B0aW9uTmFtZV0pICE9PSBudWxsICYmIF90aGlzJGludGVybmFsT3B0aW9ucyAhPT0gdm9pZCAwID8gX3RoaXMkaW50ZXJuYWxPcHRpb25zIDogdGhpcy5vcmlnaW5hbE9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIHBhcmFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9uVmFsdWUgPSBvcHRpb25WYWx1ZS5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uVmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgb3B0aW9uVmFsdWUgPSB1bmRlZmluZWQ7IC8vIHVzZSBkZWZhdWx0IHZhbHVlXG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9uVmFsdWUpIHtcbiAgICAgICAgaWYgKG9wdGlvblZhbHVlID09PSB1bmRlZmluZWQgfHwgb3B0aW9uVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UsIGVtcHR5IHN0cmluZyAoaW52YWxpZCksIG51bGwgKGludmFsaWQpLCAwIChpbnZhbGlkKVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBcIi5jb25jYXQob3B0aW9uTmFtZSwgXCJgIHdhcyBzcGVjaWZpZWQgYnV0IHdhcyBub3QgYSBub2RlLCBvciBkaWQgbm90IHJldHVybiBhIG5vZGVcIikpO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUgPSBvcHRpb25WYWx1ZTsgLy8gY291bGQgYmUgSFRNTEVsZW1lbnQsIFNWR0VsZW1lbnQsIG9yIG5vbi1lbXB0eSBzdHJpbmcgYXQgdGhpcyBwb2ludFxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgX3RoaXMkZ2V0RG9jdW1lbnQ7XG4gICAgICAgIG5vZGUgPSAoX3RoaXMkZ2V0RG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KCkpID09PSBudWxsIHx8IF90aGlzJGdldERvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXREb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvblZhbHVlKTsgLy8gcmVzb2x2ZSB0byBub2RlLCBvciBudWxsIGlmIGZhaWxzXG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBcIi5jb25jYXQob3B0aW9uTmFtZSwgXCJgIGFzIHNlbGVjdG9yIHJlZmVycyB0byBubyBrbm93biBub2RlXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgX3RoaXMuaGFuZGxlRGVhY3RpdmF0ZSA9IF90aGlzLmhhbmRsZURlYWN0aXZhdGUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlUG9zdERlYWN0aXZhdGUgPSBfdGhpcy5oYW5kbGVQb3N0RGVhY3RpdmF0ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVDbGlja091dHNpZGVEZWFjdGl2YXRlcyA9IF90aGlzLmhhbmRsZUNsaWNrT3V0c2lkZURlYWN0aXZhdGVzLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgLy8gZm9jdXMtdHJhcCBvcHRpb25zIHVzZWQgaW50ZXJuYWxseSB3aGVuIGNyZWF0aW5nIHRoZSB0cmFwXG4gICAgX3RoaXMuaW50ZXJuYWxPcHRpb25zID0ge1xuICAgICAgLy8gV2UgbmVlZCB0byBoaWphY2sgdGhlIHJldHVybkZvY3VzT25EZWFjdGl2YXRlIG9wdGlvbixcbiAgICAgIC8vIGJlY2F1c2UgUmVhY3QgY2FuIG1vdmUgZm9jdXMgaW50byB0aGUgZWxlbWVudCBiZWZvcmUgd2UgYXJyaXZlZCBhdFxuICAgICAgLy8gdGhpcyBsaWZlY3ljbGUgaG9vayAoZS5nLiB3aXRoIGF1dG9Gb2N1cyBpbnB1dHMpLiBTbyB0aGUgY29tcG9uZW50XG4gICAgICAvLyBjYXB0dXJlcyB0aGUgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50IGluIGNvbXBvbmVudFdpbGxNb3VudCxcbiAgICAgIC8vIHRoZW4gKG9wdGlvbmFsbHkpIHJldHVybnMgZm9jdXMgdG8gaXQgaW4gY29tcG9uZW50V2lsbFVubW91bnQuXG4gICAgICByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTogZmFsc2UsXG4gICAgICAvLyB0aGUgcmVzdCBvZiB0aGVzZSBhcmUgYWxzbyByZWxhdGVkIHRvIGRlYWN0aXZhdGlvbiBvZiB0aGUgdHJhcCwgYW5kIHdlXG4gICAgICAvLyAgbmVlZCB0byB1c2UgdGhlbSBhbmQgY29udHJvbCB0aGVtIGFzIHdlbGxcbiAgICAgIGNoZWNrQ2FuUmV0dXJuRm9jdXM6IG51bGwsXG4gICAgICBvbkRlYWN0aXZhdGU6IF90aGlzLmhhbmRsZURlYWN0aXZhdGUsXG4gICAgICBvblBvc3REZWFjdGl2YXRlOiBfdGhpcy5oYW5kbGVQb3N0RGVhY3RpdmF0ZSxcbiAgICAgIC8vIHdlIG5lZWQgdG8gc3BlY2lhbC1jYXNlIHRoaXMgc2V0dGluZyBhcyB3ZWxsIHNvIHRoYXQgd2UgY2FuIGtub3cgaWYgd2Ugc2hvdWxkXG4gICAgICAvLyAgTk9UIHJldHVybiBmb2N1cyBpZiB0aGUgdHJhcCBnZXRzIGF1dG8tZGVhY3RpdmF0ZWQgYXMgdGhlIHJlc3VsdCBvZiBhblxuICAgICAgLy8gIG91dHNpZGUgY2xpY2sgKG90aGVyd2lzZSwgd2UnbGwgYWx3YXlzIHRoaW5rIHdlIHNob3VsZCByZXR1cm4gZm9jdXMgYmVjYXVzZVxuICAgICAgLy8gIG9mIGhvdyB3ZSBtYW5hZ2UgdGhhdCBmbGFnIGludGVybmFsbHkgaGVyZSlcbiAgICAgIGNsaWNrT3V0c2lkZURlYWN0aXZhdGVzOiBfdGhpcy5oYW5kbGVDbGlja091dHNpZGVEZWFjdGl2YXRlc1xuICAgIH07XG5cbiAgICAvLyBvcmlnaW5hbCBvcHRpb25zIHByb3ZpZGVkIGJ5IHRoZSBjb25zdW1lclxuICAgIF90aGlzLm9yaWdpbmFsT3B0aW9ucyA9IHtcbiAgICAgIC8vIGJlY2F1c2Ugb2YgdGhlIGFib3ZlIGBpbnRlcm5hbE9wdGlvbnNgLCB3ZSBtYWludGFpbiBvdXIgb3duIGZsYWcgZm9yXG4gICAgICAvLyAgdGhpcyBvcHRpb24sIGFuZCBkZWZhdWx0IGl0IHRvIGB0cnVlYCBiZWNhdXNlIHRoYXQncyBmb2N1cy10cmFwJ3MgZGVmYXVsdFxuICAgICAgcmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU6IHRydWUsXG4gICAgICAvLyBiZWNhdXNlIG9mIHRoZSBhYm92ZSBgaW50ZXJuYWxPcHRpb25zYCwgd2Uga2VlcCB0aGVzZSBzZXBhcmF0ZSBzaW5jZVxuICAgICAgLy8gIHRoZXkncmUgcGFydCBvZiB0aGUgZGVhY3RpdmF0aW9uIHByb2Nlc3Mgd2hpY2ggd2UgY29uZmlndXJlIChpbnRlcm5hbGx5KSB0b1xuICAgICAgLy8gIGJlIHNoYXJlZCBiZXR3ZWVuIGZvY3VzLXRyYXAgYW5kIGZvY3VzLXRyYXAtcmVhY3RcbiAgICAgIG9uRGVhY3RpdmF0ZTogbnVsbCxcbiAgICAgIG9uUG9zdERlYWN0aXZhdGU6IG51bGwsXG4gICAgICBjaGVja0NhblJldHVybkZvY3VzOiBudWxsLFxuICAgICAgLy8gdGhlIHVzZXIncyBzZXR0aW5nLCBkZWZhdWx0ZWQgdG8gZmFsc2Ugc2luY2UgZm9jdXMtdHJhcCBkZWZhdWx0cyB0aGlzIHRvIGZhbHNlXG4gICAgICBjbGlja091dHNpZGVEZWFjdGl2YXRlczogZmFsc2VcbiAgICB9O1xuICAgIHZhciBmb2N1c1RyYXBPcHRpb25zID0gcHJvcHMuZm9jdXNUcmFwT3B0aW9ucztcbiAgICBmb3IgKHZhciBvcHRpb25OYW1lIGluIGZvY3VzVHJhcE9wdGlvbnMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvY3VzVHJhcE9wdGlvbnMsIG9wdGlvbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbk5hbWUgPT09ICdyZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZScgfHwgb3B0aW9uTmFtZSA9PT0gJ29uRGVhY3RpdmF0ZScgfHwgb3B0aW9uTmFtZSA9PT0gJ29uUG9zdERlYWN0aXZhdGUnIHx8IG9wdGlvbk5hbWUgPT09ICdjaGVja0NhblJldHVybkZvY3VzJyB8fCBvcHRpb25OYW1lID09PSAnY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMnKSB7XG4gICAgICAgIF90aGlzLm9yaWdpbmFsT3B0aW9uc1tvcHRpb25OYW1lXSA9IGZvY3VzVHJhcE9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICAgIGNvbnRpbnVlOyAvLyBleGNsdWRlIGZyb20gaW50ZXJuYWxPcHRpb25zXG4gICAgICB9XG5cbiAgICAgIF90aGlzLmludGVybmFsT3B0aW9uc1tvcHRpb25OYW1lXSA9IGZvY3VzVHJhcE9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgfVxuXG4gICAgLy8gaWYgc2V0LCBgeyB0YXJnZXQ6IE5vZGUsIGFsbG93RGVhY3RpdmF0aW9uOiBib29sZWFuIH1gIHdoZXJlIGB0YXJnZXRgIGlzIHRoZSBvdXRzaWRlXG4gICAgLy8gIG5vZGUgdGhhdCB3YXMgY2xpY2tlZCwgYW5kIGBhbGxvd0RlYWN0aXZhdGlvbmAgaXMgdGhlIHJlc3VsdCBvZiB0aGUgY29uc3VtZXInc1xuICAgIC8vICBvcHRpb24gKHN0b3JlZCBpbiBgdGhpcy5vcmlnaW5hbE9wdGlvbnMuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXNgLCB3aGljaCBtYXkgYmUgYVxuICAgIC8vICBmdW5jdGlvbikgd2hldGhlciB0byBhbGxvdyBvciBkZW55IGF1dG8tZGVhY3RpdmF0aW9uIG9uIGNsaWNrIG9uIHRoaXMgb3V0c2lkZSBub2RlXG4gICAgX3RoaXMub3V0c2lkZUNsaWNrID0gbnVsbDtcblxuICAgIC8vIGVsZW1lbnRzIGZyb20gd2hpY2ggdG8gY3JlYXRlIHRoZSBmb2N1cyB0cmFwIG9uIG1vdW50OyBpZiBhIGNoaWxkIGlzIHVzZWRcbiAgICAvLyAgaW5zdGVhZCBvZiB0aGUgYGNvbnRhaW5lckVsZW1lbnRzYCBwcm9wLCB3ZSdsbCBnZXQgdGhlIGNoaWxkJ3MgcmVsYXRlZFxuICAgIC8vICBlbGVtZW50IHdoZW4gdGhlIHRyYXAgcmVuZGVycyBhbmQgdGhlbiBpcyBkZWNsYXJlZCAnbW91bnRlZCdcbiAgICBfdGhpcy5mb2N1c1RyYXBFbGVtZW50cyA9IHByb3BzLmNvbnRhaW5lckVsZW1lbnRzIHx8IFtdO1xuXG4gICAgLy8gbm93IHdlIHJlbWVtYmVyIHdoYXQgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQgaXMsIG5vdCByZWx5aW5nIG9uIGZvY3VzLXRyYXBcbiAgICBfdGhpcy51cGRhdGVQcmV2aW91c0VsZW1lbnQoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY29uZmlndXJlZCBkb2N1bWVudC5cbiAgICogQHJldHVybnMge0RvY3VtZW50fHVuZGVmaW5lZH0gQ29uZmlndXJlZCBkb2N1bWVudCwgZmFsbGluZyBiYWNrIHRvIHRoZSBtYWluXG4gICAqICBkb2N1bWVudCwgaWYgaXQgZXhpc3RzLiBEdXJpbmcgU1NSLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCBzaW5jZSB0aGVcbiAgICogIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRm9jdXNUcmFwLCBbe1xuICAgIGtleTogXCJnZXREb2N1bWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICAgIC8vIFNTUjogY2FyZWZ1bCB0byBjaGVjayBpZiBgZG9jdW1lbnRgIGV4aXN0cyBiZWZvcmUgYWNjZXNzaW5nIGl0IGFzIGEgdmFyaWFibGVcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmZvY3VzVHJhcE9wdGlvbnMuZG9jdW1lbnQgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJldHVybkZvY3VzTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZXR1cm5Gb2N1c05vZGUoKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZUZvck9wdGlvbignc2V0UmV0dXJuRm9jdXMnLCB0aGlzLnByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCk7XG4gICAgICByZXR1cm4gbm9kZSA/IG5vZGUgOiBub2RlID09PSBmYWxzZSA/IGZhbHNlIDogdGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqIFVwZGF0ZSB0aGUgcHJldmlvdXNseSBmb2N1c2VkIGVsZW1lbnQgd2l0aCB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudC4gKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVQcmV2aW91c0VsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUHJldmlvdXNFbGVtZW50KCkge1xuICAgICAgdmFyIGN1cnJlbnREb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoKTtcbiAgICAgIGlmIChjdXJyZW50RG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBjdXJyZW50RG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVhY3RpdmF0ZVRyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVhY3RpdmF0ZVRyYXAoKSB7XG4gICAgICAvLyBOT1RFOiBpdCdzIHBvc3NpYmxlIHRoZSBmb2N1cyB0cmFwIGhhcyBhbHJlYWR5IGJlZW4gZGVhY3RpdmF0ZWQgd2l0aG91dCBvdXIga25vd2luZyBpdCxcbiAgICAgIC8vICBlc3BlY2lhbGx5IGlmIHRoZSB1c2VyIHNldCB0aGUgYGNsaWNrT3V0c2lkZURlYWN0aXZhdGVzOiB0cnVlYCBvcHRpb24gb24gdGhlIHRyYXAsXG4gICAgICAvLyAgYW5kIHRoZSBtb3VzZSB3YXMgY2xpY2tlZCBvbiBzb21lIGVsZW1lbnQgb3V0c2lkZSB0aGUgdHJhcDsgYXQgdGhhdCBwb2ludCwgZm9jdXMtdHJhcFxuICAgICAgLy8gIHdpbGwgaW5pdGlhdGUgaXRzIGF1dG8tZGVhY3RpdmF0aW9uIHByb2Nlc3MsIHdoaWNoIHdpbGwgY2FsbCBvdXIgb3duXG4gICAgICAvLyAgaGFuZGxlRGVhY3RpdmF0ZSgpLCB3aGljaCB3aWxsIGNhbGwgaW50byB0aGlzIG1ldGhvZFxuICAgICAgaWYgKCF0aGlzLmZvY3VzVHJhcCB8fCAhdGhpcy5mb2N1c1RyYXAuYWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9jdXNUcmFwLmRlYWN0aXZhdGUoe1xuICAgICAgICAvLyBOT1RFOiB3ZSBuZXZlciBsZXQgdGhlIHRyYXAgcmV0dXJuIHRoZSBmb2N1cyBzaW5jZSB3ZSBkbyB0aGF0IG91cnNlbHZlc1xuICAgICAgICByZXR1cm5Gb2N1czogZmFsc2UsXG4gICAgICAgIC8vIHdlJ2xsIGNhbGwgdGhpcyBpbiBvdXIgb3duIHBvc3QgZGVhY3RpdmF0ZSBoYW5kbGVyIHNvIG1ha2Ugc3VyZSB0aGUgdHJhcCBkb2Vzbid0XG4gICAgICAgIC8vICBkbyBpdCBwcmVtYXR1cmVseVxuICAgICAgICBjaGVja0NhblJldHVybkZvY3VzOiBudWxsLFxuICAgICAgICAvLyBsZXQgaXQgY2FsbCB0aGUgdXNlcidzIG9yaWdpbmFsIGRlYWN0aXZhdGUgaGFuZGxlciwgaWYgYW55LCBpbnN0ZWFkIG9mXG4gICAgICAgIC8vICBvdXIgb3duIHdoaWNoIGNhbGxzIGJhY2sgaW50byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIG9uRGVhY3RpdmF0ZTogdGhpcy5vcmlnaW5hbE9wdGlvbnMub25EZWFjdGl2YXRlXG4gICAgICAgIC8vIE5PVEU6IGZvciBwb3N0IGRlYWN0aXZhdGUsIGRvbid0IHNwZWNpZnkgYW55dGhpbmcgc28gdGhhdCBpdCBjYWxscyB0aGVcbiAgICAgICAgLy8gIG9uUG9zdERlYWN0aXZhdGUgaGFuZGxlciBzcGVjaWZpZWQgb24gYHRoaXMuaW50ZXJuYWxPcHRpb25zYFxuICAgICAgICAvLyAgd2hpY2ggd2lsbCBhbHdheXMgYmUgb3VyIG93biBgaGFuZGxlUG9zdERlYWN0aXZhdGUoKWAgaGFuZGxlciwgd2hpY2hcbiAgICAgICAgLy8gIHdpbGwgZmluaXNoIHRoaW5ncyBvZmYgYnkgY2FsbGluZyB0aGUgdXNlcidzIHByb3ZpZGVkIG9uUG9zdERlYWN0aXZhdGVcbiAgICAgICAgLy8gIGhhbmRsZXIsIGlmIGFueSwgYXQgdGhlIHJpZ2h0IHRpbWVcbiAgICAgICAgLy8gb25Qb3N0RGVhY3RpdmF0ZTogTk9USElOR1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUNsaWNrT3V0c2lkZURlYWN0aXZhdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrT3V0c2lkZURlYWN0aXZhdGVzKGV2ZW50KSB7XG4gICAgICAvLyB1c2UgY29uc3VtZXIncyBvcHRpb24gKG9yIGNhbGwgdGhlaXIgaGFuZGxlcikgYXMgdGhlIHBlcm1pc3Npb24gb3IgZGVuaWFsXG4gICAgICB2YXIgYWxsb3dEZWFjdGl2YXRpb24gPSB0eXBlb2YgdGhpcy5vcmlnaW5hbE9wdGlvbnMuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMgPT09ICdmdW5jdGlvbicgPyB0aGlzLm9yaWdpbmFsT3B0aW9ucy5jbGlja091dHNpZGVEZWFjdGl2YXRlcy5jYWxsKG51bGwsIGV2ZW50KSAvLyBjYWxsIG91dCBvZiBjb250ZXh0XG4gICAgICA6IHRoaXMub3JpZ2luYWxPcHRpb25zLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzOyAvLyBib29sZWFuXG5cbiAgICAgIGlmIChhbGxvd0RlYWN0aXZhdGlvbikge1xuICAgICAgICAvLyBjYXB0dXJlIHRoZSBvdXRzaWRlIHRhcmdldCB0aGF0IHdhcyBjbGlja2VkIHNvIHdlIGNhbiB1c2UgaXQgaW4gdGhlIGRlYWN0aXZhdGlvblxuICAgICAgICAvLyAgcHJvY2VzcyBzaW5jZSB0aGUgY29uc3VtZXIgYWxsb3dlZCBpdCB0byBjYXVzZSBhdXRvLWRlYWN0aXZhdGlvblxuICAgICAgICB0aGlzLm91dHNpZGVDbGljayA9IHtcbiAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICBhbGxvd0RlYWN0aXZhdGlvbjogYWxsb3dEZWFjdGl2YXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxvd0RlYWN0aXZhdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRGVhY3RpdmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEZWFjdGl2YXRlKCkge1xuICAgICAgaWYgKHRoaXMub3JpZ2luYWxPcHRpb25zLm9uRGVhY3RpdmF0ZSkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsT3B0aW9ucy5vbkRlYWN0aXZhdGUuY2FsbChudWxsKTsgLy8gY2FsbCB1c2VyJ3MgaGFuZGxlciBvdXQgb2YgY29udGV4dFxuICAgICAgfVxuXG4gICAgICB0aGlzLmRlYWN0aXZhdGVUcmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVBvc3REZWFjdGl2YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVBvc3REZWFjdGl2YXRlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgZmluaXNoRGVhY3RpdmF0aW9uID0gZnVuY3Rpb24gZmluaXNoRGVhY3RpdmF0aW9uKCkge1xuICAgICAgICB2YXIgcmV0dXJuRm9jdXNOb2RlID0gX3RoaXMyLmdldFJldHVybkZvY3VzTm9kZSgpO1xuICAgICAgICB2YXIgY2FuUmV0dXJuRm9jdXMgPSAhIShcbiAgICAgICAgLy8gZGlkIHRoZSBjb25zdW1lciBhbGxvdyBpdD9cblxuICAgICAgICBfdGhpczIub3JpZ2luYWxPcHRpb25zLnJldHVybkZvY3VzT25EZWFjdGl2YXRlICYmIC8vIGNhbiB3ZSBhY3R1YWxseSBmb2N1cyB0aGUgbm9kZT9cbiAgICAgICAgcmV0dXJuRm9jdXNOb2RlICE9PSBudWxsICYmIHJldHVybkZvY3VzTm9kZSAhPT0gdm9pZCAwICYmIHJldHVybkZvY3VzTm9kZS5mb2N1cyAmJiAoXG4gICAgICAgIC8vIHdhcyB0aGVyZSBhbiBvdXRzaWRlIGNsaWNrIHRoYXQgYWxsb3dlZCBkZWFjdGl2YXRpb24/XG4gICAgICAgICFfdGhpczIub3V0c2lkZUNsaWNrIHx8XG4gICAgICAgIC8vIGRpZCB0aGUgY29uc3VtZXIgYWxsb3cgZGVhY3RpdmF0aW9uIHdoZW4gdGhlIG91dHNpZGUgbm9kZSB3YXMgY2xpY2tlZD9cbiAgICAgICAgX3RoaXMyLm91dHNpZGVDbGljay5hbGxvd0RlYWN0aXZhdGlvbiAmJlxuICAgICAgICAvLyBpcyB0aGUgb3V0c2lkZSBub2RlIE5PVCBmb2N1c2FibGUgKGltcGx5aW5nIHRoYXQgaXQgZGlkIE5PVCByZWNlaXZlIGZvY3VzXG4gICAgICAgIC8vICBhcyBhIHJlc3VsdCBvZiB0aGUgY2xpY2stdGhyb3VnaCkgLS0gaW4gd2hpY2ggY2FzZSBkbyBOT1QgcmVzdG9yZSBmb2N1c1xuICAgICAgICAvLyAgdG8gYHJldHVybkZvY3VzTm9kZWAgYmVjYXVzZSBmb2N1cyBzaG91bGQgcmVtYWluIG9uIHRoZSBvdXRzaWRlIG5vZGVcbiAgICAgICAgIWlzRm9jdXNhYmxlKF90aGlzMi5vdXRzaWRlQ2xpY2sudGFyZ2V0LCBfdGhpczIuaW50ZXJuYWxPcHRpb25zLnRhYmJhYmxlT3B0aW9ucykpXG5cbiAgICAgICAgLy8gaWYgbm8sIHRoZSByZXN0b3JlIGZvY3VzIHRvIGByZXR1cm5Gb2N1c05vZGVgIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgX3RoaXMyJGludGVybmFsT3B0aW9uID0gX3RoaXMyLmludGVybmFsT3B0aW9ucy5wcmV2ZW50U2Nyb2xsLFxuICAgICAgICAgIHByZXZlbnRTY3JvbGwgPSBfdGhpczIkaW50ZXJuYWxPcHRpb24gPT09IHZvaWQgMCA/IGZhbHNlIDogX3RoaXMyJGludGVybmFsT3B0aW9uO1xuICAgICAgICBpZiAoY2FuUmV0dXJuRm9jdXMpIHtcbiAgICAgICAgICAvLyByZXR1cm4gZm9jdXMgdG8gdGhlIGVsZW1lbnQgdGhhdCBoYWQgZm9jdXMgd2hlbiB0aGUgdHJhcCB3YXMgYWN0aXZhdGVkXG4gICAgICAgICAgcmV0dXJuRm9jdXNOb2RlLmZvY3VzKHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHByZXZlbnRTY3JvbGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMyLm9yaWdpbmFsT3B0aW9ucy5vblBvc3REZWFjdGl2YXRlKSB7XG4gICAgICAgICAgX3RoaXMyLm9yaWdpbmFsT3B0aW9ucy5vblBvc3REZWFjdGl2YXRlLmNhbGwobnVsbCk7IC8vIGRvbid0IGNhbGwgaXQgaW4gY29udGV4dCBvZiBcInRoaXNcIlxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLm91dHNpZGVDbGljayA9IG51bGw7IC8vIHJlc2V0OiBubyBsb25nZXIgbmVlZGVkXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcmlnaW5hbE9wdGlvbnMuY2hlY2tDYW5SZXR1cm5Gb2N1cykge1xuICAgICAgICB0aGlzLm9yaWdpbmFsT3B0aW9ucy5jaGVja0NhblJldHVybkZvY3VzLmNhbGwobnVsbCwgdGhpcy5nZXRSZXR1cm5Gb2N1c05vZGUoKSkgLy8gY2FsbCBvdXQgb2YgY29udGV4dFxuICAgICAgICAudGhlbihmaW5pc2hEZWFjdGl2YXRpb24sIGZpbmlzaERlYWN0aXZhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5pc2hEZWFjdGl2YXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBGb2N1c1RyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBGb2N1c1RyYXAoKSB7XG4gICAgICBpZiAodGhpcy5mb2N1c1RyYXApIHtcbiAgICAgICAgLy8gdHJhcCBhbHJlYWR5IGV4aXN0czogaXQncyBwb3NzaWJsZSB3ZSdyZSBpbiBTdHJpY3RNb2RlIGFuZCB3ZSdyZSBiZWluZyByZW1vdW50ZWQsXG4gICAgICAgIC8vICBpbiB3aGljaCBjYXNlLCB3ZSB3aWxsIGhhdmUgZGVhY3RpdmF0ZWQgdGhlIHRyYXAgd2hlbiB3ZSBnb3QgdW5tb3VudGVkIChyZW1lbWJlcixcbiAgICAgICAgLy8gIFN0cmljdE1vZGUsIGluIGRldmVsb3BtZW50LCBwdXJwb3NlbHkgdW5tb3VudHMgYW5kIHJlbW91bnRzIGNvbXBvbmVudHMgYWZ0ZXJcbiAgICAgICAgLy8gIG1vdW50aW5nIHRoZW0gdGhlIGZpcnN0IHRpbWUgdG8gbWFrZSBzdXJlIHRoZXkgaGF2ZSByZXVzYWJsZSBzdGF0ZSxcbiAgICAgICAgLy8gIEBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3N0cmljdC1tb2RlLmh0bWwjZW5zdXJpbmctcmV1c2FibGUtc3RhdGUpIHNvIG5vd1xuICAgICAgICAvLyAgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBzdGF0ZSBvZiB0aGUgdHJhcCBhY2NvcmRpbmcgdG8gb3VyIGNvbXBvbmVudCBzdGF0ZVxuICAgICAgICAvLyBOT1RFOiBTdHJpY3QgbW9kZSBfX3Zpb2xhdGVzX18gYXNzdW1wdGlvbnMgYWJvdXQgdGhlIGBjb21wb25lbnRXaWxsVW5tb3VudCgpYCBBUElcbiAgICAgICAgLy8gIHdoaWNoIGNsZWFybHkgc3RhdGVzIC0tIGV2ZW4gZm9yIFJlYWN0IDE4IC0tIHRoYXQsIFwiT25jZSBhIGNvbXBvbmVudCBpbnN0YW5jZSBpc1xuICAgICAgICAvLyAgdW5tb3VudGVkLCBfX2l0IHdpbGwgbmV2ZXIgYmUgbW91bnRlZCBhZ2Fpbi5fX1wiIChlbXBoYXNpcyBvdXJzKS4gU28gd2hlbiB3ZSBnZXRcbiAgICAgICAgLy8gIHVubW91bnRlZCwgd2UgYXNzdW1lIHdlJ3JlIGdvbmUgZm9yZXZlciBhbmQgd2UgZGVhY3RpdmF0ZSB0aGUgdHJhcC4gQnV0IHRoZW5cbiAgICAgICAgLy8gIHdlIGdldCByZW1vdW50ZWQgYW5kIHdlJ3JlIHN1cHBvc2VkIHRvIHJlc3RvcmUgc3RhdGUuIEJ1dCBpZiB5b3UgaGFkIHBhdXNlZCxcbiAgICAgICAgLy8gIHdlJ3ZlIG5vdyBkZWFjdGl2YXRlZCAod2UgZG9uJ3Qga25vdyB3ZSdyZSBhbW91bnQgdG8gZ2V0IHJlbW91bnRlZCBhZ2FpbilcbiAgICAgICAgLy8gIHdoaWNoIG1lYW5zIHdlIG5lZWQgdG8gcmVhY3RpdmF0ZSBhbmQgdGhlbiBwYXVzZS4gT3RoZXJ3aXNlLCBkbyBub3RoaW5nLlxuICAgICAgICBpZiAodGhpcy5wcm9wcy5hY3RpdmUgJiYgIXRoaXMuZm9jdXNUcmFwLmFjdGl2ZSkge1xuICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLmFjdGl2YXRlKCk7XG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5wYXVzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5vZGVzRXhpc3QgPSB0aGlzLmZvY3VzVHJhcEVsZW1lbnRzLnNvbWUoQm9vbGVhbik7XG4gICAgICAgIGlmIChub2Rlc0V4aXN0KSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3Byb3AtdHlwZXMgLS0gX2NyZWF0ZUZvY3VzVHJhcCBpcyBhbiBpbnRlcm5hbCBwcm9wXG4gICAgICAgICAgdGhpcy5mb2N1c1RyYXAgPSB0aGlzLnByb3BzLl9jcmVhdGVGb2N1c1RyYXAodGhpcy5mb2N1c1RyYXBFbGVtZW50cywgdGhpcy5pbnRlcm5hbE9wdGlvbnMpO1xuICAgICAgICAgIGlmICh0aGlzLnByb3BzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c1RyYXAuYWN0aXZhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5wYXVzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmFjdGl2ZSkge1xuICAgICAgICB0aGlzLnNldHVwRm9jdXNUcmFwKCk7XG4gICAgICB9XG4gICAgICAvLyBlbHNlLCB3YWl0IGZvciBsYXRlciBhY3RpdmF0aW9uIGluIGNhc2UgdGhlIGBmb2N1c1RyYXBPcHRpb25zYCB3aWxsIGJlIHVwZGF0ZWRcbiAgICAgIC8vICBhZ2FpbiBiZWZvcmUgdGhlIHRyYXAgaXMgYWN0aXZhdGVkIChlLmcuIGlmIHdhaXRpbmcgdG8ga25vdyB3aGF0IHRoZSBkb2N1bWVudFxuICAgICAgLy8gIG9iamVjdCB3aWxsIGJlLCBzbyB0aGUgVHJhcCBtdXN0IGJlIHJlbmRlcmVkLCBidXQgdGhlIGNvbnN1bWVyIGlzIHdhaXRpbmcgdG9cbiAgICAgIC8vICBhY3RpdmF0ZSB1bnRpbCB0aGV5IGhhdmUgb2J0YWluZWQgdGhlIGRvY3VtZW50IGZyb20gYSByZWYpXG4gICAgICAvLyAgQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC9mb2N1cy10cmFwLXJlYWN0L2lzc3Vlcy81MzlcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLmZvY3VzVHJhcCkge1xuICAgICAgICBpZiAocHJldlByb3BzLmNvbnRhaW5lckVsZW1lbnRzICE9PSB0aGlzLnByb3BzLmNvbnRhaW5lckVsZW1lbnRzKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyYXAudXBkYXRlQ29udGFpbmVyRWxlbWVudHModGhpcy5wcm9wcy5jb250YWluZXJFbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc0FjdGl2YXRlZCA9ICFwcmV2UHJvcHMuYWN0aXZlICYmIHRoaXMucHJvcHMuYWN0aXZlO1xuICAgICAgICB2YXIgaGFzRGVhY3RpdmF0ZWQgPSBwcmV2UHJvcHMuYWN0aXZlICYmICF0aGlzLnByb3BzLmFjdGl2ZTtcbiAgICAgICAgdmFyIGhhc1BhdXNlZCA9ICFwcmV2UHJvcHMucGF1c2VkICYmIHRoaXMucHJvcHMucGF1c2VkO1xuICAgICAgICB2YXIgaGFzVW5wYXVzZWQgPSBwcmV2UHJvcHMucGF1c2VkICYmICF0aGlzLnByb3BzLnBhdXNlZDtcbiAgICAgICAgaWYgKGhhc0FjdGl2YXRlZCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlUHJldmlvdXNFbGVtZW50KCk7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyYXAuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRGVhY3RpdmF0ZWQpIHtcbiAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVUcmFwKCk7XG4gICAgICAgICAgcmV0dXJuOyAvLyB1bi9wYXVzZSBkb2VzIG5vdGhpbmcgb24gYW4gaW5hY3RpdmUgdHJhcFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1BhdXNlZCkge1xuICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1VucGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyYXAudW5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOT1RFOiBpZiB3ZSdyZSBpbiBgY29tcG9uZW50RGlkVXBkYXRlYCBhbmQgd2UgZG9uJ3QgaGF2ZSBhIHRyYXAgeWV0LFxuICAgICAgICAvLyAgaXQgZWl0aGVyIG1lYW5zIGl0IHNob3VsZG4ndCBiZSBhY3RpdmUsIG9yIGl0IHNob3VsZCBiZSBidXQgbm9uZSBvZlxuICAgICAgICAvLyAgb2YgZ2l2ZW4gYGNvbnRhaW5lckVsZW1lbnRzYCB3ZXJlIHByZXNlbnQgaW4gdGhlIERPTSB0aGUgbGFzdCB0aW1lXG4gICAgICAgIC8vICB3ZSB0cmllZCB0byBjcmVhdGUgdGhlIHRyYXBcblxuICAgICAgICBpZiAocHJldlByb3BzLmNvbnRhaW5lckVsZW1lbnRzICE9PSB0aGlzLnByb3BzLmNvbnRhaW5lckVsZW1lbnRzKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyYXBFbGVtZW50cyA9IHRoaXMucHJvcHMuY29udGFpbmVyRWxlbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkb24ndCBjcmVhdGUgdGhlIHRyYXAgdW5sZXNzIGl0IHNob3VsZCBiZSBhY3RpdmUgaW4gY2FzZSB0aGUgY29uc3VtZXJcbiAgICAgICAgLy8gIGlzIHN0aWxsIHVwZGF0aW5nIGBmb2N1c1RyYXBPcHRpb25zYFxuICAgICAgICAvLyAgQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC9mb2N1cy10cmFwLXJlYWN0L2lzc3Vlcy81MzlcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVQcmV2aW91c0VsZW1lbnQoKTtcbiAgICAgICAgICB0aGlzLnNldHVwRm9jdXNUcmFwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLmRlYWN0aXZhdGVUcmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMucHJvcHMuY2hpbGRyZW4gPyBSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlICYmIGNoaWxkLnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGZvY3VzLXRyYXAgY2Fubm90IHVzZSBhIEZyYWdtZW50IGFzIGl0cyBjaGlsZCBjb250YWluZXIuIFRyeSByZXBsYWNpbmcgaXQgd2l0aCBhIDxkaXY+IGVsZW1lbnQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxiYWNrUmVmID0gZnVuY3Rpb24gY2FsbGJhY2tSZWYoZWxlbWVudCkge1xuICAgICAgICAgIHZhciBjb250YWluZXJFbGVtZW50cyA9IF90aGlzMy5wcm9wcy5jb250YWluZXJFbGVtZW50cztcbiAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnJlZihlbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQucmVmKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMzLmZvY3VzVHJhcEVsZW1lbnRzID0gY29udGFpbmVyRWxlbWVudHMgPyBjb250YWluZXJFbGVtZW50cyA6IFtlbGVtZW50XTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNoaWxkV2l0aFJlZiA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgIHJlZjogY2FsbGJhY2tSZWZcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGlsZFdpdGhSZWY7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZvY3VzVHJhcDtcbn0oUmVhY3QuQ29tcG9uZW50KTsgLy8gc3VwcG9ydCBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgd2hlcmUgYEVsZW1lbnRgIHdpbGwgbm90IGJlIGRlZmluZWRcbnZhciBFbGVtZW50VHlwZSA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyA/IEZ1bmN0aW9uIDogRWxlbWVudDtcbkZvY3VzVHJhcC5wcm9wVHlwZXMgPSB7XG4gIGFjdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIHBhdXNlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGZvY3VzVHJhcE9wdGlvbnM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZG9jdW1lbnQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgb25BY3RpdmF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Qb3N0QWN0aXZhdGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIGNoZWNrQ2FuRm9jdXNUcmFwOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBhdXNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBvc3RQYXVzZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25VbnBhdXNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBvc3RVbnBhdXNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkRlYWN0aXZhdGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUG9zdERlYWN0aXZhdGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIGNoZWNrQ2FuUmV0dXJuRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIGluaXRpYWxGb2N1czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmluc3RhbmNlT2YoRWxlbWVudFR5cGUpLCBQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBmYWxsYmFja0ZvY3VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuaW5zdGFuY2VPZihFbGVtZW50VHlwZSksIFByb3BUeXBlcy5zdHJpbmcsXG4gICAgLy8gTk9URTogZG9lcyBub3Qgc3VwcG9ydCBgZmFsc2VgIGFzIHZhbHVlIChvciByZXR1cm4gdmFsdWUgZnJvbSBmdW5jdGlvbilcbiAgICBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGVzY2FwZURlYWN0aXZhdGVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBjbGlja091dHNpZGVEZWFjdGl2YXRlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgcmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU6IFByb3BUeXBlcy5ib29sLFxuICAgIHNldFJldHVybkZvY3VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuaW5zdGFuY2VPZihFbGVtZW50VHlwZSksIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGFsbG93T3V0c2lkZUNsaWNrOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBwcmV2ZW50U2Nyb2xsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB0YWJiYWJsZU9wdGlvbnM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBkaXNwbGF5Q2hlY2s6IFByb3BUeXBlcy5vbmVPZihbJ2Z1bGwnLCAnbGVnYWN5LWZ1bGwnLCAnbm9uLXplcm8tYXJlYScsICdub25lJ10pLFxuICAgICAgZ2V0U2hhZG93Um9vdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSlcbiAgICB9KSxcbiAgICB0cmFwU3RhY2s6IFByb3BUeXBlcy5hcnJheSxcbiAgICBpc0tleUZvcndhcmQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIGlzS2V5QmFja3dhcmQ6IFByb3BUeXBlcy5mdW5jXG4gIH0pLFxuICBjb250YWluZXJFbGVtZW50czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmluc3RhbmNlT2YoRWxlbWVudFR5cGUpKSxcbiAgLy8gRE9NIGVsZW1lbnQgT05MWVxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnQsXG4gIC8vIFJlYWN0IGVsZW1lbnRcbiAgUHJvcFR5cGVzLmluc3RhbmNlT2YoRWxlbWVudFR5cGUpIC8vIERPTSBlbGVtZW50XG4gIF0pXG5cbiAgLy8gTk9URTogX2NyZWF0ZUZvY3VzVHJhcCBpcyBpbnRlcm5hbCwgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSwgc28gd2UgZG9uJ3RcbiAgLy8gIHNwZWNpZnkgaXQgaGVyZS4gSXQncyBleHBlY3RlZCB0byBiZSBzZXQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGZyb21cbiAgLy8gIHJlcXVpcmUoJ2ZvY3VzLXRyYXAnKSwgb3Igb25lIHdpdGggYSBjb21wYXRpYmxlIGludGVyZmFjZS5cbn07XG5cbkZvY3VzVHJhcC5kZWZhdWx0UHJvcHMgPSB7XG4gIGFjdGl2ZTogdHJ1ZSxcbiAgcGF1c2VkOiBmYWxzZSxcbiAgZm9jdXNUcmFwT3B0aW9uczoge30sXG4gIF9jcmVhdGVGb2N1c1RyYXA6IGNyZWF0ZUZvY3VzVHJhcFxufTtcbm1vZHVsZS5leHBvcnRzID0gRm9jdXNUcmFwOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsInZhbHVlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsInNldFByb3RvdHlwZU9mIiwiYmluZCIsIl9fcHJvdG9fXyIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9jcmVhdGVTdXBlckludGVybmFsIiwiU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJyZXN1bHQiLCJOZXdUYXJnZXQiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJjYWxsIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInZhbHVlT2YiLCJlIiwiZ2V0UHJvdG90eXBlT2YiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJhcmciLCJfdG9QcmltaXRpdmUiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJOdW1iZXIiLCJSZWFjdCIsInJlcXVpcmUiLCJQcm9wVHlwZXMiLCJfcmVxdWlyZSIsImNyZWF0ZUZvY3VzVHJhcCIsIl9yZXF1aXJlMiIsImlzRm9jdXNhYmxlIiwiRm9jdXNUcmFwIiwiX1JlYWN0JENvbXBvbmVudCIsIl9zdXBlciIsIl90aGlzIiwib3B0aW9uTmFtZSIsIl90aGlzJGludGVybmFsT3B0aW9ucyIsIm9wdGlvblZhbHVlIiwiaW50ZXJuYWxPcHRpb25zIiwib3JpZ2luYWxPcHRpb25zIiwiX2xlbiIsInBhcmFtcyIsIkFycmF5IiwiX2tleSIsIkVycm9yIiwiY29uY2F0Iiwibm9kZSIsIl90aGlzJGdldERvY3VtZW50IiwiZ2V0RG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiaGFuZGxlRGVhY3RpdmF0ZSIsImhhbmRsZVBvc3REZWFjdGl2YXRlIiwiaGFuZGxlQ2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMiLCJyZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSIsImNoZWNrQ2FuUmV0dXJuRm9jdXMiLCJvbkRlYWN0aXZhdGUiLCJvblBvc3REZWFjdGl2YXRlIiwiY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMiLCJmb2N1c1RyYXBPcHRpb25zIiwiaGFzT3duUHJvcGVydHkiLCJvdXRzaWRlQ2xpY2siLCJmb2N1c1RyYXBFbGVtZW50cyIsImNvbnRhaW5lckVsZW1lbnRzIiwidXBkYXRlUHJldmlvdXNFbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRSZXR1cm5Gb2N1c05vZGUiLCJnZXROb2RlRm9yT3B0aW9uIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiY3VycmVudERvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImRlYWN0aXZhdGVUcmFwIiwiZm9jdXNUcmFwIiwiYWN0aXZlIiwiZGVhY3RpdmF0ZSIsInJldHVybkZvY3VzIiwiZXZlbnQiLCJhbGxvd0RlYWN0aXZhdGlvbiIsIl90aGlzMiIsImZpbmlzaERlYWN0aXZhdGlvbiIsInJldHVybkZvY3VzTm9kZSIsImNhblJldHVybkZvY3VzIiwiZm9jdXMiLCJ0YWJiYWJsZU9wdGlvbnMiLCJfdGhpczIkaW50ZXJuYWxPcHRpb24iLCJwcmV2ZW50U2Nyb2xsIiwidGhlbiIsInNldHVwRm9jdXNUcmFwIiwiYWN0aXZhdGUiLCJwYXVzZWQiLCJwYXVzZSIsIm5vZGVzRXhpc3QiLCJzb21lIiwiX2NyZWF0ZUZvY3VzVHJhcCIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwidXBkYXRlQ29udGFpbmVyRWxlbWVudHMiLCJoYXNBY3RpdmF0ZWQiLCJoYXNEZWFjdGl2YXRlZCIsImhhc1BhdXNlZCIsImhhc1VucGF1c2VkIiwidW5wYXVzZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVuZGVyIiwiX3RoaXMzIiwiY2hpbGQiLCJjaGlsZHJlbiIsIkNoaWxkcmVuIiwib25seSIsInR5cGUiLCJGcmFnbWVudCIsImNhbGxiYWNrUmVmIiwiZWxlbWVudCIsInJlZiIsImN1cnJlbnQiLCJjaGlsZFdpdGhSZWYiLCJjbG9uZUVsZW1lbnQiLCJDb21wb25lbnQiLCJFbGVtZW50VHlwZSIsIkVsZW1lbnQiLCJGdW5jdGlvbiIsInByb3BUeXBlcyIsImJvb2wiLCJzaGFwZSIsIm9iamVjdCIsIm9uQWN0aXZhdGUiLCJmdW5jIiwib25Qb3N0QWN0aXZhdGUiLCJjaGVja0NhbkZvY3VzVHJhcCIsIm9uUGF1c2UiLCJvblBvc3RQYXVzZSIsIm9uVW5wYXVzZSIsIm9uUG9zdFVucGF1c2UiLCJpbml0aWFsRm9jdXMiLCJvbmVPZlR5cGUiLCJpbnN0YW5jZU9mIiwic3RyaW5nIiwiZmFsbGJhY2tGb2N1cyIsImVzY2FwZURlYWN0aXZhdGVzIiwic2V0UmV0dXJuRm9jdXMiLCJhbGxvd091dHNpZGVDbGljayIsImRpc3BsYXlDaGVjayIsIm9uZU9mIiwiZ2V0U2hhZG93Um9vdCIsInRyYXBTdGFjayIsImFycmF5IiwiaXNLZXlGb3J3YXJkIiwiaXNLZXlCYWNrd2FyZCIsImFycmF5T2YiLCJkZWZhdWx0UHJvcHMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/focus-trap-react/dist/focus-trap-react.js\n");

/***/ })

};
;