"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/polished";
exports.ids = ["vendor-chunks/polished"];
exports.modules = {

/***/ "(ssr)/./node_modules/polished/dist/polished.es.js":
/*!***************************************************!*\
  !*** ./node_modules/polished/dist/polished.es.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adjustHue: () => (/* binding */ curriedAdjustHue),\n/* harmony export */   animation: () => (/* binding */ animation),\n/* harmony export */   backgroundImages: () => (/* binding */ backgroundImages),\n/* harmony export */   backgrounds: () => (/* binding */ backgrounds),\n/* harmony export */   between: () => (/* binding */ between),\n/* harmony export */   border: () => (/* binding */ border),\n/* harmony export */   borderColor: () => (/* binding */ borderColor),\n/* harmony export */   borderRadius: () => (/* binding */ borderRadius),\n/* harmony export */   borderStyle: () => (/* binding */ borderStyle),\n/* harmony export */   borderWidth: () => (/* binding */ borderWidth),\n/* harmony export */   buttons: () => (/* binding */ buttons),\n/* harmony export */   clearFix: () => (/* binding */ clearFix),\n/* harmony export */   complement: () => (/* binding */ complement),\n/* harmony export */   cover: () => (/* binding */ cover),\n/* harmony export */   darken: () => (/* binding */ curriedDarken),\n/* harmony export */   desaturate: () => (/* binding */ curriedDesaturate),\n/* harmony export */   directionalProperty: () => (/* binding */ directionalProperty),\n/* harmony export */   ellipsis: () => (/* binding */ ellipsis),\n/* harmony export */   em: () => (/* binding */ em),\n/* harmony export */   fluidRange: () => (/* binding */ fluidRange),\n/* harmony export */   fontFace: () => (/* binding */ fontFace),\n/* harmony export */   getLuminance: () => (/* binding */ getLuminance),\n/* harmony export */   getValueAndUnit: () => (/* binding */ getValueAndUnit),\n/* harmony export */   grayscale: () => (/* binding */ grayscale),\n/* harmony export */   hiDPI: () => (/* binding */ hiDPI),\n/* harmony export */   hideText: () => (/* binding */ hideText),\n/* harmony export */   hideVisually: () => (/* binding */ hideVisually),\n/* harmony export */   hsl: () => (/* binding */ hsl),\n/* harmony export */   hslToColorString: () => (/* binding */ hslToColorString),\n/* harmony export */   hsla: () => (/* binding */ hsla),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   lighten: () => (/* binding */ curriedLighten),\n/* harmony export */   linearGradient: () => (/* binding */ linearGradient),\n/* harmony export */   margin: () => (/* binding */ margin),\n/* harmony export */   math: () => (/* binding */ math),\n/* harmony export */   mix: () => (/* binding */ curriedMix),\n/* harmony export */   modularScale: () => (/* binding */ modularScale),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   opacify: () => (/* binding */ curriedOpacify),\n/* harmony export */   padding: () => (/* binding */ padding),\n/* harmony export */   parseToHsl: () => (/* binding */ parseToHsl),\n/* harmony export */   parseToRgb: () => (/* binding */ parseToRgb),\n/* harmony export */   position: () => (/* binding */ position),\n/* harmony export */   radialGradient: () => (/* binding */ radialGradient),\n/* harmony export */   readableColor: () => (/* binding */ readableColor),\n/* harmony export */   rem: () => (/* binding */ rem),\n/* harmony export */   retinaImage: () => (/* binding */ retinaImage),\n/* harmony export */   rgb: () => (/* binding */ rgb),\n/* harmony export */   rgbToColorString: () => (/* binding */ rgbToColorString),\n/* harmony export */   rgba: () => (/* binding */ rgba),\n/* harmony export */   saturate: () => (/* binding */ curriedSaturate),\n/* harmony export */   setHue: () => (/* binding */ curriedSetHue),\n/* harmony export */   setLightness: () => (/* binding */ curriedSetLightness),\n/* harmony export */   setSaturation: () => (/* binding */ curriedSetSaturation),\n/* harmony export */   shade: () => (/* binding */ curriedShade),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   stripUnit: () => (/* binding */ stripUnit),\n/* harmony export */   textInputs: () => (/* binding */ textInputs),\n/* harmony export */   timingFunctions: () => (/* binding */ timingFunctions),\n/* harmony export */   tint: () => (/* binding */ curriedTint),\n/* harmony export */   toColorString: () => (/* binding */ toColorString),\n/* harmony export */   transitions: () => (/* binding */ transitions),\n/* harmony export */   transparentize: () => (/* binding */ curriedTransparentize),\n/* harmony export */   triangle: () => (/* binding */ triangle),\n/* harmony export */   wordWrap: () => (/* binding */ wordWrap)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/wrapNativeSuper */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/taggedTemplateLiteralLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js\");\n\n\n\n\n\nfunction last() {\n    var _ref;\n    return _ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref];\n}\nfunction negation(a) {\n    return -a;\n}\nfunction addition(a, b) {\n    return a + b;\n}\nfunction subtraction(a, b) {\n    return a - b;\n}\nfunction multiplication(a, b) {\n    return a * b;\n}\nfunction division(a, b) {\n    return a / b;\n}\nfunction factorial(a) {\n    if (a % 1 || !(+a >= 0)) return NaN;\n    if (a > 170) return Infinity;\n    else if (a === 0) return 1;\n    else {\n        return a * factorial(a - 1);\n    }\n}\nfunction power(a, b) {\n    return Math.pow(a, b);\n}\nfunction sqrt(a) {\n    return Math.sqrt(a);\n}\nfunction max() {\n    return Math.max.apply(Math, arguments);\n}\nfunction min() {\n    return Math.min.apply(Math, arguments);\n}\nfunction comma() {\n    return Array.of.apply(Array, arguments);\n}\nvar defaultMathSymbols = {\n    symbols: {\n        \"!\": {\n            postfix: {\n                symbol: \"!\",\n                f: factorial,\n                notation: \"postfix\",\n                precedence: 6,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"!\",\n            regSymbol: \"!\"\n        },\n        \"^\": {\n            infix: {\n                symbol: \"^\",\n                f: power,\n                notation: \"infix\",\n                precedence: 5,\n                rightToLeft: 1,\n                argCount: 2\n            },\n            symbol: \"^\",\n            regSymbol: \"\\\\^\"\n        },\n        \"*\": {\n            infix: {\n                symbol: \"*\",\n                f: multiplication,\n                notation: \"infix\",\n                precedence: 4,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \"*\",\n            regSymbol: \"\\\\*\"\n        },\n        \"/\": {\n            infix: {\n                symbol: \"/\",\n                f: division,\n                notation: \"infix\",\n                precedence: 4,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \"/\",\n            regSymbol: \"/\"\n        },\n        \"+\": {\n            infix: {\n                symbol: \"+\",\n                f: addition,\n                notation: \"infix\",\n                precedence: 2,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            prefix: {\n                symbol: \"+\",\n                f: last,\n                notation: \"prefix\",\n                precedence: 3,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"+\",\n            regSymbol: \"\\\\+\"\n        },\n        \"-\": {\n            infix: {\n                symbol: \"-\",\n                f: subtraction,\n                notation: \"infix\",\n                precedence: 2,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            prefix: {\n                symbol: \"-\",\n                f: negation,\n                notation: \"prefix\",\n                precedence: 3,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"-\",\n            regSymbol: \"-\"\n        },\n        \",\": {\n            infix: {\n                symbol: \",\",\n                f: comma,\n                notation: \"infix\",\n                precedence: 1,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \",\",\n            regSymbol: \",\"\n        },\n        \"(\": {\n            prefix: {\n                symbol: \"(\",\n                f: last,\n                notation: \"prefix\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"(\",\n            regSymbol: \"\\\\(\"\n        },\n        \")\": {\n            postfix: {\n                symbol: \")\",\n                f: undefined,\n                notation: \"postfix\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \")\",\n            regSymbol: \"\\\\)\"\n        },\n        min: {\n            func: {\n                symbol: \"min\",\n                f: min,\n                notation: \"func\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"min\",\n            regSymbol: \"min\\\\b\"\n        },\n        max: {\n            func: {\n                symbol: \"max\",\n                f: max,\n                notation: \"func\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"max\",\n            regSymbol: \"max\\\\b\"\n        },\n        sqrt: {\n            func: {\n                symbol: \"sqrt\",\n                f: sqrt,\n                notation: \"func\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"sqrt\",\n            regSymbol: \"sqrt\\\\b\"\n        }\n    }\n};\n// based on https://github.com/styled-components/styled-components/blob/fcf6f3804c57a14dd7984dfab7bc06ee2edca044/src/utils/error.js\n/**\n * Parse errors.md and turn it into a simple hash of code: message\n * @private\n */ var ERRORS = {\n    \"1\": \"Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\\n\\n\",\n    \"2\": \"Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\\n\\n\",\n    \"3\": \"Passed an incorrect argument to a color function, please pass a string representation of a color.\\n\\n\",\n    \"4\": \"Couldn't generate valid rgb string from %s, it returned %s.\\n\\n\",\n    \"5\": \"Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\\n\\n\",\n    \"6\": \"Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\\n\\n\",\n    \"7\": \"Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\\n\\n\",\n    \"8\": \"Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\\n\\n\",\n    \"9\": \"Please provide a number of steps to the modularScale helper.\\n\\n\",\n    \"10\": \"Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\\n\\n\",\n    \"11\": 'Invalid value passed as base to modularScale, expected number or em string but got \"%s\"\\n\\n',\n    \"12\": 'Expected a string ending in \"px\" or a number passed as the first argument to %s(), got \"%s\" instead.\\n\\n',\n    \"13\": 'Expected a string ending in \"px\" or a number passed as the second argument to %s(), got \"%s\" instead.\\n\\n',\n    \"14\": 'Passed invalid pixel value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"15\": 'Passed invalid base value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"16\": \"You must provide a template to this method.\\n\\n\",\n    \"17\": \"You passed an unsupported selector state to this method.\\n\\n\",\n    \"18\": \"minScreen and maxScreen must be provided as stringified numbers with the same units.\\n\\n\",\n    \"19\": \"fromSize and toSize must be provided as stringified numbers with the same units.\\n\\n\",\n    \"20\": \"expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\\n\\n\",\n    \"21\": \"expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n    \"22\": \"expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n    \"23\": \"fontFace expects a name of a font-family.\\n\\n\",\n    \"24\": \"fontFace expects either the path to the font file(s) or a name of a local copy.\\n\\n\",\n    \"25\": \"fontFace expects localFonts to be an array.\\n\\n\",\n    \"26\": \"fontFace expects fileFormats to be an array.\\n\\n\",\n    \"27\": \"radialGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"28\": \"Please supply a filename to retinaImage() as the first argument.\\n\\n\",\n    \"29\": \"Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\\n\\n\",\n    \"30\": \"Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\\n\\n\",\n    \"31\": \"The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\\n\\n\",\n    \"32\": \"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\\n\\n\",\n    \"33\": \"The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\\n\\n\",\n    \"34\": \"borderRadius expects a radius value as a string or number as the second argument.\\n\\n\",\n    \"35\": 'borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\\n\\n',\n    \"36\": \"Property must be a string value.\\n\\n\",\n    \"37\": \"Syntax Error at %s.\\n\\n\",\n    \"38\": \"Formula contains a function that needs parentheses at %s.\\n\\n\",\n    \"39\": \"Formula is missing closing parenthesis at %s.\\n\\n\",\n    \"40\": \"Formula has too many closing parentheses at %s.\\n\\n\",\n    \"41\": \"All values in a formula must have the same unit or be unitless.\\n\\n\",\n    \"42\": \"Please provide a number of steps to the modularScale helper.\\n\\n\",\n    \"43\": \"Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\\n\\n\",\n    \"44\": \"Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\\n\\n\",\n    \"45\": \"Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\\n\\n\",\n    \"46\": \"Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\\n\\n\",\n    \"47\": \"minScreen and maxScreen must be provided as stringified numbers with the same units.\\n\\n\",\n    \"48\": \"fromSize and toSize must be provided as stringified numbers with the same units.\\n\\n\",\n    \"49\": \"Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\\n\\n\",\n    \"50\": \"Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\\n\\n\",\n    \"51\": \"Expects the first argument object to have the properties prop, fromSize, and toSize.\\n\\n\",\n    \"52\": \"fontFace expects either the path to the font file(s) or a name of a local copy.\\n\\n\",\n    \"53\": \"fontFace expects localFonts to be an array.\\n\\n\",\n    \"54\": \"fontFace expects fileFormats to be an array.\\n\\n\",\n    \"55\": \"fontFace expects a name of a font-family.\\n\\n\",\n    \"56\": \"linearGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"57\": \"radialGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"58\": \"Please supply a filename to retinaImage() as the first argument.\\n\\n\",\n    \"59\": \"Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\\n\\n\",\n    \"60\": \"Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\\n\\n\",\n    \"61\": \"Property must be a string value.\\n\\n\",\n    \"62\": \"borderRadius expects a radius value as a string or number as the second argument.\\n\\n\",\n    \"63\": 'borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\\n\\n',\n    \"64\": \"The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\\n\\n\",\n    \"65\": \"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\\n\\n\",\n    \"66\": \"The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\\n\\n\",\n    \"67\": \"You must provide a template to this method.\\n\\n\",\n    \"68\": \"You passed an unsupported selector state to this method.\\n\\n\",\n    \"69\": 'Expected a string ending in \"px\" or a number passed as the first argument to %s(), got %s instead.\\n\\n',\n    \"70\": 'Expected a string ending in \"px\" or a number passed as the second argument to %s(), got %s instead.\\n\\n',\n    \"71\": 'Passed invalid pixel value %s to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"72\": 'Passed invalid base value %s to %s(), please pass a value like \"12px\" or 12.\\n'\n};\n/**\n * super basic version of sprintf\n * @private\n */ function format() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    var a = args[0];\n    var b = [];\n    var c;\n    for(c = 1; c < args.length; c += 1){\n        b.push(args[c]);\n    }\n    b.forEach(function(d) {\n        a = a.replace(/%[a-z]/, d);\n    });\n    return a;\n}\n/**\n * Create an error file out of errors.md for development and a simple web link to the full errors\n * in production mode.\n * @private\n */ var PolishedError = /*#__PURE__*/ function(_Error) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(PolishedError, _Error);\n    function PolishedError(code) {\n        var _this;\n        if (false) {} else {\n            for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                args[_key2 - 1] = arguments[_key2];\n            }\n            _this = _Error.call(this, format.apply(void 0, [\n                ERRORS[code]\n            ].concat(args))) || this;\n        }\n        return (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this);\n    }\n    return PolishedError;\n}(/*#__PURE__*/ (0,_babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(Error));\nvar unitRegExp = /((?!\\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\\D|$)|ged|darg?|nrut)/g; // Merges additional math functionality into the defaults.\nfunction mergeSymbolMaps(additionalSymbols) {\n    var symbolMap = {};\n    symbolMap.symbols = additionalSymbols ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, defaultMathSymbols.symbols, additionalSymbols.symbols) : (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, defaultMathSymbols.symbols);\n    return symbolMap;\n}\nfunction exec(operators, values) {\n    var _ref;\n    var op = operators.pop();\n    values.push(op.f.apply(op, (_ref = []).concat.apply(_ref, values.splice(-op.argCount))));\n    return op.precedence;\n}\nfunction calculate(expression, additionalSymbols) {\n    var symbolMap = mergeSymbolMaps(additionalSymbols);\n    var match;\n    var operators = [\n        symbolMap.symbols[\"(\"].prefix\n    ];\n    var values = [];\n    var pattern = new RegExp(\"\\\\d+(?:\\\\.\\\\d+)?|\" + // ...and patterns for individual operators/function names\n    Object.keys(symbolMap.symbols).map(function(key) {\n        return symbolMap.symbols[key];\n    }) // longer symbols should be listed first\n    // $FlowFixMe\n    .sort(function(a, b) {\n        return b.symbol.length - a.symbol.length;\n    }) // $FlowFixMe\n    .map(function(val) {\n        return val.regSymbol;\n    }).join(\"|\") + \"|(\\\\S)\", \"g\");\n    pattern.lastIndex = 0; // Reset regular expression object\n    var afterValue = false;\n    do {\n        match = pattern.exec(expression);\n        var _ref2 = match || [\n            \")\",\n            undefined\n        ], token = _ref2[0], bad = _ref2[1];\n        var notNumber = symbolMap.symbols[token];\n        var notNewValue = notNumber && !notNumber.prefix && !notNumber.func;\n        var notAfterValue = !notNumber || !notNumber.postfix && !notNumber.infix; // Check for syntax errors:\n        if (bad || (afterValue ? notAfterValue : notNewValue)) {\n            throw new PolishedError(37, match ? match.index : expression.length, expression);\n        }\n        if (afterValue) {\n            // We either have an infix or postfix operator (they should be mutually exclusive)\n            var curr = notNumber.postfix || notNumber.infix;\n            do {\n                var prev = operators[operators.length - 1];\n                if ((curr.precedence - prev.precedence || prev.rightToLeft) > 0) break; // Apply previous operator, since it has precedence over current one\n            }while (exec(operators, values)); // Exit loop after executing an opening parenthesis or function\n            afterValue = curr.notation === \"postfix\";\n            if (curr.symbol !== \")\") {\n                operators.push(curr); // Postfix always has precedence over any operator that follows after it\n                if (afterValue) exec(operators, values);\n            }\n        } else if (notNumber) {\n            // prefix operator or function\n            operators.push(notNumber.prefix || notNumber.func);\n            if (notNumber.func) {\n                // Require an opening parenthesis\n                match = pattern.exec(expression);\n                if (!match || match[0] !== \"(\") {\n                    throw new PolishedError(38, match ? match.index : expression.length, expression);\n                }\n            }\n        } else {\n            // number\n            values.push(+token);\n            afterValue = true;\n        }\n    }while (match && operators.length);\n    if (operators.length) {\n        throw new PolishedError(39, match ? match.index : expression.length, expression);\n    } else if (match) {\n        throw new PolishedError(40, match ? match.index : expression.length, expression);\n    } else {\n        return values.pop();\n    }\n}\nfunction reverseString(str) {\n    return str.split(\"\").reverse().join(\"\");\n}\n/**\n * Helper for doing math with CSS Units. Accepts a formula as a string. All values in the formula must have the same unit (or be unitless). Supports complex formulas utliziing addition, subtraction, multiplication, division, square root, powers, factorial, min, max, as well as parentheses for order of operation.\n *\n *In cases where you need to do calculations with mixed units where one unit is a [relative length unit](https://developer.mozilla.org/en-US/docs/Web/CSS/length#Relative_length_units), you will want to use [CSS Calc](https://developer.mozilla.org/en-US/docs/Web/CSS/calc).\n *\n * *warning* While we've done everything possible to ensure math safely evalutes formulas expressed as strings, you should always use extreme caution when passing `math` user provided values.\n * @example\n * // Styles as object usage\n * const styles = {\n *   fontSize: math('12rem + 8rem'),\n *   fontSize: math('(12px + 2px) * 3'),\n *   fontSize: math('3px^2 + sqrt(4)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   fontSize: ${math('12rem + 8rem')};\n *   fontSize: ${math('(12px + 2px) * 3')};\n *   fontSize: ${math('3px^2 + sqrt(4)')};\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   fontSize: '20rem',\n *   fontSize: '42px',\n *   fontSize: '11px',\n * }\n */ function math(formula, additionalSymbols) {\n    var reversedFormula = reverseString(formula);\n    var formulaMatch = reversedFormula.match(unitRegExp); // Check that all units are the same\n    if (formulaMatch && !formulaMatch.every(function(unit) {\n        return unit === formulaMatch[0];\n    })) {\n        throw new PolishedError(41);\n    }\n    var cleanFormula = reverseString(reversedFormula.replace(unitRegExp, \"\"));\n    return \"\" + calculate(cleanFormula, additionalSymbols) + (formulaMatch ? reverseString(formulaMatch[0]) : \"\");\n}\n// @private\nfunction capitalizeString(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nvar positionMap = [\n    \"Top\",\n    \"Right\",\n    \"Bottom\",\n    \"Left\"\n];\nfunction generateProperty(property, position) {\n    if (!property) return position.toLowerCase();\n    var splitProperty = property.split(\"-\");\n    if (splitProperty.length > 1) {\n        splitProperty.splice(1, 0, position);\n        return splitProperty.reduce(function(acc, val) {\n            return \"\" + acc + capitalizeString(val);\n        });\n    }\n    var joinedProperty = property.replace(/([a-z])([A-Z])/g, \"$1\" + position + \"$2\");\n    return property === joinedProperty ? \"\" + property + position : joinedProperty;\n}\nfunction generateStyles(property, valuesWithDefaults) {\n    var styles = {};\n    for(var i = 0; i < valuesWithDefaults.length; i += 1){\n        if (valuesWithDefaults[i] || valuesWithDefaults[i] === 0) {\n            styles[generateProperty(property, positionMap[i])] = valuesWithDefaults[i];\n        }\n    }\n    return styles;\n}\n/**\n * Enables shorthand for direction-based properties. It accepts a property (hyphenated or camelCased) and up to four values that map to top, right, bottom, and left, respectively. You can optionally pass an empty string to get only the directional values as properties. You can also optionally pass a null argument for a directional value to ignore it.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...directionalProperty('padding', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${directionalProperty('padding', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */ function directionalProperty(property) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    //  prettier-ignore\n    var firstValue = values[0], _values$ = values[1], secondValue = _values$ === void 0 ? firstValue : _values$, _values$2 = values[2], thirdValue = _values$2 === void 0 ? firstValue : _values$2, _values$3 = values[3], fourthValue = _values$3 === void 0 ? secondValue : _values$3;\n    var valuesWithDefaults = [\n        firstValue,\n        secondValue,\n        thirdValue,\n        fourthValue\n    ];\n    return generateStyles(property, valuesWithDefaults);\n}\nfunction endsWith(string, suffix) {\n    return string.substr(-suffix.length) === suffix;\n}\nvar cssRegex = /^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\n/**\n * Returns a given CSS value minus its unit (or the original value if an invalid string is passed). Optionally returns an array containing the stripped value and the original unit of measure.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': stripUnit('100px'),\n *   '--unit': stripUnit('100px')[1],\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${stripUnit('100px')};\n *   --unit: ${stripUnit('100px')[1]};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100,\n *   '--unit': 'px',\n * }\n */ function stripUnit(value, unitReturn) {\n    if (typeof value !== \"string\") return unitReturn ? [\n        value,\n        undefined\n    ] : value;\n    var matchedValue = value.match(cssRegex);\n    if (unitReturn) {\n        if (matchedValue) return [\n            parseFloat(value),\n            matchedValue[2]\n        ];\n        return [\n            value,\n            undefined\n        ];\n    }\n    if (matchedValue) return parseFloat(value);\n    return value;\n}\n/**\n * Factory function that creates pixel-to-x converters\n * @private\n */ var pxtoFactory = function pxtoFactory(to) {\n    return function(pxval, base) {\n        if (base === void 0) {\n            base = \"16px\";\n        }\n        var newPxval = pxval;\n        var newBase = base;\n        if (typeof pxval === \"string\") {\n            if (!endsWith(pxval, \"px\")) {\n                throw new PolishedError(69, to, pxval);\n            }\n            newPxval = stripUnit(pxval);\n        }\n        if (typeof base === \"string\") {\n            if (!endsWith(base, \"px\")) {\n                throw new PolishedError(70, to, base);\n            }\n            newBase = stripUnit(base);\n        }\n        if (typeof newPxval === \"string\") {\n            throw new PolishedError(71, pxval, to);\n        }\n        if (typeof newBase === \"string\") {\n            throw new PolishedError(72, base, to);\n        }\n        return \"\" + newPxval / newBase + to;\n    };\n};\n/**\n * Convert pixel value to ems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': em('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${em('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1em'\n * }\n */ var em = /*#__PURE__*/ pxtoFactory(\"em\");\nvar cssRegex$1 = /^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\n/**\n * Returns a given CSS value and its unit as elements of an array.\n *\n * @deprecated - getValueAndUnit has been marked for deprecation in polished 3.0 and will be fully deprecated in 4.0. It's functionality has been been moved to stripUnit as an optional return.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': getValueAndUnit('100px')[0],\n *   '--unit': getValueAndUnit('100px')[1],\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${getValueAndUnit('100px')[0]};\n *   --unit: ${getValueAndUnit('100px')[1]};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100,\n *   '--unit': 'px',\n * }\n */ function getValueAndUnit(value) {\n    // eslint-disable-next-line no-console\n    console.warn(\"getValueAndUnit has been marked for deprecation in polished 3.0 and will be fully deprecated in 4.0. It's functionality has been been moved to stripUnit as an optional return.\");\n    if (typeof value !== \"string\") return [\n        value,\n        \"\"\n    ];\n    var matchedValue = value.match(cssRegex$1);\n    if (matchedValue) return [\n        parseFloat(value),\n        matchedValue[2]\n    ];\n    return [\n        value,\n        undefined\n    ];\n}\nvar ratioNames = {\n    minorSecond: 1.067,\n    majorSecond: 1.125,\n    minorThird: 1.2,\n    majorThird: 1.25,\n    perfectFourth: 1.333,\n    augFourth: 1.414,\n    perfectFifth: 1.5,\n    minorSixth: 1.6,\n    goldenSection: 1.618,\n    majorSixth: 1.667,\n    minorSeventh: 1.778,\n    majorSeventh: 1.875,\n    octave: 2,\n    majorTenth: 2.5,\n    majorEleventh: 2.667,\n    majorTwelfth: 3,\n    doubleOctave: 4\n};\nfunction getRatio(ratioName) {\n    return ratioNames[ratioName];\n}\n/**\n * Establish consistent measurements and spacial relationships throughout your projects by incrementing an em or rem value up or down a defined scale. We provide a list of commonly used scales as pre-defined variables.\n * @example\n * // Styles as object usage\n * const styles = {\n *    // Increment two steps up the default scale\n *   'fontSize': modularScale(2)\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *    // Increment two steps up the default scale\n *   fontSize: ${modularScale(2)}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'fontSize': '1.77689em'\n * }\n */ function modularScale(steps, base, ratio) {\n    if (base === void 0) {\n        base = \"1em\";\n    }\n    if (ratio === void 0) {\n        ratio = \"perfectFourth\";\n    }\n    if (typeof steps !== \"number\") {\n        throw new PolishedError(42);\n    }\n    if (typeof ratio === \"string\" && !ratioNames[ratio]) {\n        throw new PolishedError(43);\n    }\n    var _ref = typeof base === \"string\" ? stripUnit(base, true) : [\n        base,\n        \"\"\n    ], realBase = _ref[0], unit = _ref[1];\n    var realRatio = typeof ratio === \"string\" ? getRatio(ratio) : ratio;\n    if (typeof realBase === \"string\" || unit !== \"em\" && unit !== \"rem\") {\n        throw new PolishedError(44, base);\n    }\n    return \"\" + realBase * Math.pow(realRatio, steps) + unit;\n}\n/**\n * Convert pixel value to rems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': rem('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${rem('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1rem'\n * }\n */ var rem = /*#__PURE__*/ pxtoFactory(\"rem\");\n/**\n * Returns a CSS calc formula for linear interpolation of a property between two values. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px').\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   fontSize: between('20px', '100px', '400px', '1000px'),\n *   fontSize: between('20px', '100px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   fontSize: ${between('20px', '100px', '400px', '1000px')};\n *   fontSize: ${between('20px', '100px')}\n * `\n *\n * // CSS as JS Output\n *\n * h1: {\n *   'fontSize': 'calc(-33.33333333333334px + 13.333333333333334vw)',\n *   'fontSize': 'calc(-9.090909090909093px + 9.090909090909092vw)'\n * }\n */ function between(fromSize, toSize, minScreen, maxScreen) {\n    if (minScreen === void 0) {\n        minScreen = \"320px\";\n    }\n    if (maxScreen === void 0) {\n        maxScreen = \"1200px\";\n    }\n    var _stripUnit = stripUnit(fromSize, true), unitlessFromSize = _stripUnit[0], fromSizeUnit = _stripUnit[1];\n    var _stripUnit2 = stripUnit(toSize, true), unitlessToSize = _stripUnit2[0], toSizeUnit = _stripUnit2[1];\n    var _stripUnit3 = stripUnit(minScreen, true), unitlessMinScreen = _stripUnit3[0], minScreenUnit = _stripUnit3[1];\n    var _stripUnit4 = stripUnit(maxScreen, true), unitlessMaxScreen = _stripUnit4[0], maxScreenUnit = _stripUnit4[1];\n    if (typeof unitlessMinScreen !== \"number\" || typeof unitlessMaxScreen !== \"number\" || !minScreenUnit || !maxScreenUnit || minScreenUnit !== maxScreenUnit) {\n        throw new PolishedError(47);\n    }\n    if (typeof unitlessFromSize !== \"number\" || typeof unitlessToSize !== \"number\" || !fromSizeUnit || !toSizeUnit || fromSizeUnit !== toSizeUnit) {\n        throw new PolishedError(48);\n    }\n    var slope = (unitlessFromSize - unitlessToSize) / (unitlessMinScreen - unitlessMaxScreen);\n    var base = unitlessToSize - slope * unitlessMaxScreen;\n    return \"calc(\" + base.toFixed(2) + fromSizeUnit + \" + \" + (100 * slope).toFixed(2) + \"vw)\";\n}\n/**\n * CSS to contain a float (credit to CSSMojo).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...clearFix(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${clearFix()}\n * `\n *\n * // CSS as JS Output\n *\n * '&::after': {\n *   'clear': 'both',\n *   'content': '\"\"',\n *   'display': 'table'\n * }\n */ function clearFix(parent) {\n    var _ref;\n    if (parent === void 0) {\n        parent = \"&\";\n    }\n    var pseudoSelector = parent + \"::after\";\n    return _ref = {}, _ref[pseudoSelector] = {\n        clear: \"both\",\n        content: '\"\"',\n        display: \"table\"\n    }, _ref;\n}\n/**\n * CSS to fully cover an area. Can optionally be passed an offset to act as a \"padding\".\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...cover()\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${cover()}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'position': 'absolute',\n *   'top': '0',\n *   'right: '0',\n *   'bottom': '0',\n *   'left: '0'\n * }\n */ function cover(offset) {\n    if (offset === void 0) {\n        offset = 0;\n    }\n    return {\n        position: \"absolute\",\n        top: offset,\n        right: offset,\n        bottom: offset,\n        left: offset\n    };\n}\n/**\n * CSS to represent truncated text with an ellipsis.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...ellipsis('250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${ellipsis('250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'display': 'inline-block',\n *   'maxWidth': '250px',\n *   'overflow': 'hidden',\n *   'textOverflow': 'ellipsis',\n *   'whiteSpace': 'nowrap',\n *   'wordWrap': 'normal'\n * }\n */ function ellipsis(width) {\n    if (width === void 0) {\n        width = \"100%\";\n    }\n    return {\n        display: \"inline-block\",\n        maxWidth: width,\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        whiteSpace: \"nowrap\",\n        wordWrap: \"normal\"\n    };\n}\n/**\n * Returns a set of media queries that resizes a property (or set of properties) between a provided fromSize and toSize. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px') to constrain the interpolation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...fluidRange(\n *    {\n *        prop: 'padding',\n *        fromSize: '20px',\n *        toSize: '100px',\n *      },\n *      '400px',\n *      '1000px',\n *    )\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${fluidRange(\n *      {\n *        prop: 'padding',\n *        fromSize: '20px',\n *        toSize: '100px',\n *      },\n *      '400px',\n *      '1000px',\n *    )}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   \"@media (min-width: 1000px)\": Object {\n *     \"padding\": \"100px\",\n *   },\n *   \"@media (min-width: 400px)\": Object {\n *     \"padding\": \"calc(-33.33333333333334px + 13.333333333333334vw)\",\n *   },\n *   \"padding\": \"20px\",\n * }\n */ function fluidRange(cssProp, minScreen, maxScreen) {\n    if (minScreen === void 0) {\n        minScreen = \"320px\";\n    }\n    if (maxScreen === void 0) {\n        maxScreen = \"1200px\";\n    }\n    if (!Array.isArray(cssProp) && typeof cssProp !== \"object\" || cssProp === null) {\n        throw new PolishedError(49);\n    }\n    if (Array.isArray(cssProp)) {\n        var mediaQueries = {};\n        var fallbacks = {};\n        for(var _iterator = cssProp, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;){\n            var _extends2, _extends3;\n            var _ref;\n            if (_isArray) {\n                if (_i >= _iterator.length) break;\n                _ref = _iterator[_i++];\n            } else {\n                _i = _iterator.next();\n                if (_i.done) break;\n                _ref = _i.value;\n            }\n            var obj = _ref;\n            if (!obj.prop || !obj.fromSize || !obj.toSize) {\n                throw new PolishedError(50);\n            }\n            fallbacks[obj.prop] = obj.fromSize;\n            mediaQueries[\"@media (min-width: \" + minScreen + \")\"] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, mediaQueries[\"@media (min-width: \" + minScreen + \")\"], (_extends2 = {}, _extends2[obj.prop] = between(obj.fromSize, obj.toSize, minScreen, maxScreen), _extends2));\n            mediaQueries[\"@media (min-width: \" + maxScreen + \")\"] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, mediaQueries[\"@media (min-width: \" + maxScreen + \")\"], (_extends3 = {}, _extends3[obj.prop] = obj.toSize, _extends3));\n        }\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, fallbacks, mediaQueries);\n    } else {\n        var _ref2, _ref3, _ref4;\n        if (!cssProp.prop || !cssProp.fromSize || !cssProp.toSize) {\n            throw new PolishedError(51);\n        }\n        return _ref4 = {}, _ref4[cssProp.prop] = cssProp.fromSize, _ref4[\"@media (min-width: \" + minScreen + \")\"] = (_ref2 = {}, _ref2[cssProp.prop] = between(cssProp.fromSize, cssProp.toSize, minScreen, maxScreen), _ref2), _ref4[\"@media (min-width: \" + maxScreen + \")\"] = (_ref3 = {}, _ref3[cssProp.prop] = cssProp.toSize, _ref3), _ref4;\n    }\n}\nfunction generateFileReferences(fontFilePath, fileFormats) {\n    var fileFontReferences = fileFormats.map(function(format) {\n        return 'url(\"' + fontFilePath + \".\" + format + '\")';\n    });\n    return fileFontReferences.join(\", \");\n}\nfunction generateLocalReferences(localFonts) {\n    var localFontReferences = localFonts.map(function(font) {\n        return 'local(\"' + font + '\")';\n    });\n    return localFontReferences.join(\", \");\n}\nfunction generateSources(fontFilePath, localFonts, fileFormats) {\n    var fontReferences = [];\n    if (localFonts) fontReferences.push(generateLocalReferences(localFonts));\n    if (fontFilePath) {\n        fontReferences.push(generateFileReferences(fontFilePath, fileFormats));\n    }\n    return fontReferences.join(\", \");\n}\n/**\n * CSS for a @font-face declaration.\n *\n * @example\n * // Styles as object basic usage\n * const styles = {\n *    ...fontFace({\n *      'fontFamily': 'Sans-Pro',\n *      'fontFilePath': 'path/to/file'\n *    })\n * }\n *\n * // styled-components basic usage\n * const GlobalStyle = createGlobalStyle`${\n *   fontFace({\n *     'fontFamily': 'Sans-Pro',\n *     'fontFilePath': 'path/to/file'\n *   }\n * )}`\n *\n * // CSS as JS Output\n *\n * '@font-face': {\n *   'fontFamily': 'Sans-Pro',\n *   'src': 'url(\"path/to/file.eot\"), url(\"path/to/file.woff2\"), url(\"path/to/file.woff\"), url(\"path/to/file.ttf\"), url(\"path/to/file.svg\")',\n * }\n */ function fontFace(_ref) {\n    var fontFamily = _ref.fontFamily, fontFilePath = _ref.fontFilePath, fontStretch = _ref.fontStretch, fontStyle = _ref.fontStyle, fontVariant = _ref.fontVariant, fontWeight = _ref.fontWeight, _ref$fileFormats = _ref.fileFormats, fileFormats = _ref$fileFormats === void 0 ? [\n        \"eot\",\n        \"woff2\",\n        \"woff\",\n        \"ttf\",\n        \"svg\"\n    ] : _ref$fileFormats, localFonts = _ref.localFonts, unicodeRange = _ref.unicodeRange, fontDisplay = _ref.fontDisplay, fontVariationSettings = _ref.fontVariationSettings, fontFeatureSettings = _ref.fontFeatureSettings;\n    // Error Handling\n    if (!fontFamily) throw new PolishedError(55);\n    if (!fontFilePath && !localFonts) {\n        throw new PolishedError(52);\n    }\n    if (localFonts && !Array.isArray(localFonts)) {\n        throw new PolishedError(53);\n    }\n    if (!Array.isArray(fileFormats)) {\n        throw new PolishedError(54);\n    }\n    var fontFaceDeclaration = {\n        \"@font-face\": {\n            fontFamily: fontFamily,\n            src: generateSources(fontFilePath, localFonts, fileFormats),\n            unicodeRange: unicodeRange,\n            fontStretch: fontStretch,\n            fontStyle: fontStyle,\n            fontVariant: fontVariant,\n            fontWeight: fontWeight,\n            fontDisplay: fontDisplay,\n            fontVariationSettings: fontVariationSettings,\n            fontFeatureSettings: fontFeatureSettings\n        } // Removes undefined fields for cleaner css object.\n    };\n    return JSON.parse(JSON.stringify(fontFaceDeclaration));\n}\n/**\n * CSS to hide text to show a background image in a SEO-friendly way.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'backgroundImage': 'url(logo.png)',\n *   ...hideText(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   backgroundImage: url(logo.png);\n *   ${hideText()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'backgroundImage': 'url(logo.png)',\n *   'textIndent': '101%',\n *   'overflow': 'hidden',\n *   'whiteSpace': 'nowrap',\n * }\n */ function hideText() {\n    return {\n        textIndent: \"101%\",\n        overflow: \"hidden\",\n        whiteSpace: \"nowrap\"\n    };\n}\n/**\n * CSS to hide content visually but remain accessible to screen readers.\n * from [HTML5 Boilerplate](https://github.com/h5bp/html5-boilerplate/blob/9a176f57af1cfe8ec70300da4621fb9b07e5fa31/src/css/main.css#L121)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...hideVisually(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hideVisually()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'border': '0',\n *   'clip': 'rect(0 0 0 0)',\n *   'clipPath': 'inset(50%)',\n *   'height': '1px',\n *   'margin': '-1px',\n *   'overflow': 'hidden',\n *   'padding': '0',\n *   'position': 'absolute',\n *   'whiteSpace': 'nowrap',\n *   'width': '1px',\n * }\n */ function hideVisually() {\n    return {\n        border: \"0\",\n        clip: \"rect(0 0 0 0)\",\n        clipPath: \"inset(50%)\",\n        height: \"1px\",\n        margin: \"-1px\",\n        overflow: \"hidden\",\n        padding: \"0\",\n        position: \"absolute\",\n        whiteSpace: \"nowrap\",\n        width: \"1px\"\n    };\n}\n/**\n * Generates a media query to target HiDPI devices.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  [hiDPI(1.5)]: {\n *    width: 200px;\n *  }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hiDPI(1.5)} {\n *     width: 200px;\n *   }\n * `\n *\n * // CSS as JS Output\n *\n * '@media only screen and (-webkit-min-device-pixel-ratio: 1.5),\n *  only screen and (min--moz-device-pixel-ratio: 1.5),\n *  only screen and (-o-min-device-pixel-ratio: 1.5/1),\n *  only screen and (min-resolution: 144dpi),\n *  only screen and (min-resolution: 1.5dppx)': {\n *   'width': '200px',\n * }\n */ function hiDPI(ratio) {\n    if (ratio === void 0) {\n        ratio = 1.3;\n    }\n    return \"\\n    @media only screen and (-webkit-min-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (min--moz-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (-o-min-device-pixel-ratio: \" + ratio + \"/1),\\n    only screen and (min-resolution: \" + Math.round(ratio * 96) + \"dpi),\\n    only screen and (min-resolution: \" + ratio + \"dppx)\\n  \";\n}\nfunction constructGradientValue(literals) {\n    var template = \"\";\n    for(var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        substitutions[_key - 1] = arguments[_key];\n    }\n    for(var i = 0; i < literals.length; i += 1){\n        template += literals[i];\n        if (i === substitutions.length - 1 && substitutions[i]) {\n            var definedValues = substitutions.filter(function(substitute) {\n                return !!substitute;\n            }); // Adds leading coma if properties preceed color-stops\n            if (definedValues.length > 1) {\n                template = template.slice(0, -1);\n                template += \", \" + substitutions[i]; // No trailing space if color-stops is the only param provided\n            } else if (definedValues.length === 1) {\n                template += \"\" + substitutions[i];\n            }\n        } else if (substitutions[i]) {\n            template += substitutions[i] + \" \";\n        }\n    }\n    return template.trim();\n}\nfunction _templateObject() {\n    var data = (0,_babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        \"linear-gradient(\",\n        \"\",\n        \")\"\n    ]);\n    _templateObject = function _templateObject() {\n        return data;\n    };\n    return data;\n}\n/**\n * CSS for declaring a linear gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...linearGradient({\n        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n        toDirection: 'to top right',\n        fallback: '#FFF',\n      })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${linearGradient({\n        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n        toDirection: 'to top right',\n        fallback: '#FFF',\n      })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#FFF',\n *   'backgroundImage': 'linear-gradient(to top right, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */ function linearGradient(_ref) {\n    var colorStops = _ref.colorStops, fallback = _ref.fallback, _ref$toDirection = _ref.toDirection, toDirection = _ref$toDirection === void 0 ? \"\" : _ref$toDirection;\n    if (!colorStops || colorStops.length < 2) {\n        throw new PolishedError(56);\n    }\n    return {\n        backgroundColor: fallback || colorStops[0].split(\" \")[0],\n        backgroundImage: constructGradientValue(_templateObject(), toDirection, colorStops.join(\", \"))\n    };\n}\n/**\n * CSS to normalize abnormalities across browsers (normalize.css v8.0.0 | MIT License | github.com/necolas/normalize.css)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...normalize(),\n * }\n *\n * // styled-components usage\n * const GlobalStyle = createGlobalStyle`${normalize()}`\n *\n * // CSS as JS Output\n *\n * html {\n *   lineHeight: 1.15,\n *   textSizeAdjust: 100%,\n * } ...\n */ function normalize() {\n    var _ref;\n    return [\n        (_ref = {\n            html: {\n                lineHeight: \"1.15\",\n                textSizeAdjust: \"100%\"\n            },\n            body: {\n                margin: \"0\"\n            },\n            h1: {\n                fontSize: \"2em\",\n                margin: \"0.67em 0\"\n            },\n            hr: {\n                boxSizing: \"content-box\",\n                height: \"0\",\n                overflow: \"visible\"\n            },\n            pre: {\n                fontFamily: \"monospace, monospace\",\n                fontSize: \"1em\"\n            },\n            a: {\n                backgroundColor: \"transparent\"\n            },\n            \"abbr[title]\": {\n                borderBottom: \"none\",\n                textDecoration: \"underline\"\n            }\n        }, _ref[\"b,\\n    strong\"] = {\n            fontWeight: \"bolder\"\n        }, _ref[\"code,\\n    kbd,\\n    samp\"] = {\n            fontFamily: \"monospace, monospace\",\n            fontSize: \"1em\"\n        }, _ref.small = {\n            fontSize: \"80%\"\n        }, _ref[\"sub,\\n    sup\"] = {\n            fontSize: \"75%\",\n            lineHeight: \"0\",\n            position: \"relative\",\n            verticalAlign: \"baseline\"\n        }, _ref.sub = {\n            bottom: \"-0.25em\"\n        }, _ref.sup = {\n            top: \"-0.5em\"\n        }, _ref.img = {\n            borderStyle: \"none\"\n        }, _ref[\"button,\\n    input,\\n    optgroup,\\n    select,\\n    textarea\"] = {\n            fontFamily: \"inherit\",\n            fontSize: \"100%\",\n            lineHeight: \"1.15\",\n            margin: \"0\"\n        }, _ref[\"button,\\n    input\"] = {\n            overflow: \"visible\"\n        }, _ref[\"button,\\n    select\"] = {\n            textTransform: \"none\"\n        }, _ref['button,\\n    html [type=\"button\"],\\n    [type=\"reset\"],\\n    [type=\"submit\"]'] = {\n            WebkitAppearance: \"button\"\n        }, _ref['button::-moz-focus-inner,\\n    [type=\"button\"]::-moz-focus-inner,\\n    [type=\"reset\"]::-moz-focus-inner,\\n    [type=\"submit\"]::-moz-focus-inner'] = {\n            borderStyle: \"none\",\n            padding: \"0\"\n        }, _ref['button:-moz-focusring,\\n    [type=\"button\"]:-moz-focusring,\\n    [type=\"reset\"]:-moz-focusring,\\n    [type=\"submit\"]:-moz-focusring'] = {\n            outline: \"1px dotted ButtonText\"\n        }, _ref.fieldset = {\n            padding: \"0.35em 0.625em 0.75em\"\n        }, _ref.legend = {\n            boxSizing: \"border-box\",\n            color: \"inherit\",\n            display: \"table\",\n            maxWidth: \"100%\",\n            padding: \"0\",\n            whiteSpace: \"normal\"\n        }, _ref.progress = {\n            verticalAlign: \"baseline\"\n        }, _ref.textarea = {\n            overflow: \"auto\"\n        }, _ref['[type=\"checkbox\"],\\n    [type=\"radio\"]'] = {\n            boxSizing: \"border-box\",\n            padding: \"0\"\n        }, _ref['[type=\"number\"]::-webkit-inner-spin-button,\\n    [type=\"number\"]::-webkit-outer-spin-button'] = {\n            height: \"auto\"\n        }, _ref['[type=\"search\"]'] = {\n            WebkitAppearance: \"textfield\",\n            outlineOffset: \"-2px\"\n        }, _ref['[type=\"search\"]::-webkit-search-decoration'] = {\n            WebkitAppearance: \"none\"\n        }, _ref[\"::-webkit-file-upload-button\"] = {\n            WebkitAppearance: \"button\",\n            font: \"inherit\"\n        }, _ref.details = {\n            display: \"block\"\n        }, _ref.summary = {\n            display: \"list-item\"\n        }, _ref.template = {\n            display: \"none\"\n        }, _ref[\"[hidden]\"] = {\n            display: \"none\"\n        }, _ref),\n        {\n            \"abbr[title]\": {\n                textDecoration: \"underline dotted\"\n            }\n        }\n    ];\n}\nfunction _templateObject$1() {\n    var data = (0,_babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        \"radial-gradient(\",\n        \"\",\n        \"\",\n        \"\",\n        \")\"\n    ]);\n    _templateObject$1 = function _templateObject() {\n        return data;\n    };\n    return data;\n}\n/**\n * CSS for declaring a radial gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#00FFFF',\n *   'backgroundImage': 'radial-gradient(center ellipse farthest-corner at 45px 45px, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */ function radialGradient(_ref) {\n    var colorStops = _ref.colorStops, _ref$extent = _ref.extent, extent = _ref$extent === void 0 ? \"\" : _ref$extent, fallback = _ref.fallback, _ref$position = _ref.position, position = _ref$position === void 0 ? \"\" : _ref$position, _ref$shape = _ref.shape, shape = _ref$shape === void 0 ? \"\" : _ref$shape;\n    if (!colorStops || colorStops.length < 2) {\n        throw new PolishedError(57);\n    }\n    return {\n        backgroundColor: fallback || colorStops[0].split(\" \")[0],\n        backgroundImage: constructGradientValue(_templateObject$1(), position, shape, extent, colorStops.join(\", \"))\n    };\n}\n/**\n * A helper to generate a retina background image and non-retina\n * background image. The retina background image will output to a HiDPI media query. The mixin uses\n * a _2x.png filename suffix by default.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  ...retinaImage('my-img')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${retinaImage('my-img')}\n * `\n *\n * // CSS as JS Output\n * div {\n *   backgroundImage: 'url(my-img.png)',\n *   '@media only screen and (-webkit-min-device-pixel-ratio: 1.3),\n *    only screen and (min--moz-device-pixel-ratio: 1.3),\n *    only screen and (-o-min-device-pixel-ratio: 1.3/1),\n *    only screen and (min-resolution: 144dpi),\n *    only screen and (min-resolution: 1.5dppx)': {\n *     backgroundImage: 'url(my-img_2x.png)',\n *   }\n * }\n */ function retinaImage(filename, backgroundSize, extension, retinaFilename, retinaSuffix) {\n    var _ref;\n    if (extension === void 0) {\n        extension = \"png\";\n    }\n    if (retinaSuffix === void 0) {\n        retinaSuffix = \"_2x\";\n    }\n    if (!filename) {\n        throw new PolishedError(58);\n    } // Replace the dot at the beginning of the passed extension if one exists\n    var ext = extension.replace(/^\\./, \"\");\n    var rFilename = retinaFilename ? retinaFilename + \".\" + ext : \"\" + filename + retinaSuffix + \".\" + ext;\n    return _ref = {\n        backgroundImage: \"url(\" + filename + \".\" + ext + \")\"\n    }, _ref[hiDPI()] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        backgroundImage: \"url(\" + rFilename + \")\"\n    }, backgroundSize ? {\n        backgroundSize: backgroundSize\n    } : {}), _ref;\n}\n/* eslint-disable key-spacing */ var functionsMap = {\n    easeInBack: \"cubic-bezier(0.600, -0.280, 0.735, 0.045)\",\n    easeInCirc: \"cubic-bezier(0.600,  0.040, 0.980, 0.335)\",\n    easeInCubic: \"cubic-bezier(0.550,  0.055, 0.675, 0.190)\",\n    easeInExpo: \"cubic-bezier(0.950,  0.050, 0.795, 0.035)\",\n    easeInQuad: \"cubic-bezier(0.550,  0.085, 0.680, 0.530)\",\n    easeInQuart: \"cubic-bezier(0.895,  0.030, 0.685, 0.220)\",\n    easeInQuint: \"cubic-bezier(0.755,  0.050, 0.855, 0.060)\",\n    easeInSine: \"cubic-bezier(0.470,  0.000, 0.745, 0.715)\",\n    easeOutBack: \"cubic-bezier(0.175,  0.885, 0.320, 1.275)\",\n    easeOutCubic: \"cubic-bezier(0.215,  0.610, 0.355, 1.000)\",\n    easeOutCirc: \"cubic-bezier(0.075,  0.820, 0.165, 1.000)\",\n    easeOutExpo: \"cubic-bezier(0.190,  1.000, 0.220, 1.000)\",\n    easeOutQuad: \"cubic-bezier(0.250,  0.460, 0.450, 0.940)\",\n    easeOutQuart: \"cubic-bezier(0.165,  0.840, 0.440, 1.000)\",\n    easeOutQuint: \"cubic-bezier(0.230,  1.000, 0.320, 1.000)\",\n    easeOutSine: \"cubic-bezier(0.390,  0.575, 0.565, 1.000)\",\n    easeInOutBack: \"cubic-bezier(0.680, -0.550, 0.265, 1.550)\",\n    easeInOutCirc: \"cubic-bezier(0.785,  0.135, 0.150, 0.860)\",\n    easeInOutCubic: \"cubic-bezier(0.645,  0.045, 0.355, 1.000)\",\n    easeInOutExpo: \"cubic-bezier(1.000,  0.000, 0.000, 1.000)\",\n    easeInOutQuad: \"cubic-bezier(0.455,  0.030, 0.515, 0.955)\",\n    easeInOutQuart: \"cubic-bezier(0.770,  0.000, 0.175, 1.000)\",\n    easeInOutQuint: \"cubic-bezier(0.860,  0.000, 0.070, 1.000)\",\n    easeInOutSine: \"cubic-bezier(0.445,  0.050, 0.550, 0.950)\"\n};\nfunction getTimingFunction(functionName) {\n    return functionsMap[functionName];\n}\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': timingFunctions('easeInQuad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${timingFunctions('easeInQuad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n * }\n */ function timingFunctions(timingFunction) {\n    return getTimingFunction(timingFunction);\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderColor('red', 'green', 'blue', 'yellow')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderColor('red', 'green', 'blue', 'yellow')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderRightColor': 'green',\n *   'borderBottomColor': 'blue',\n *   'borderLeftColor': 'yellow'\n * }\n */ function borderColor() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderColor\"\n    ].concat(values));\n}\nvar getBorderWidth = function getBorderWidth(pointingDirection, height, width) {\n    switch(pointingDirection){\n        case \"top\":\n            return \"0 \" + width[0] / 2 + width[1] + \" \" + height[0] + height[1] + \" \" + width[0] / 2 + width[1];\n        case \"left\":\n            return \"\" + height[0] / 2 + height[1] + \" \" + width[0] + width[1] + \" \" + height[0] / 2 + height[1] + \" 0\";\n        case \"bottom\":\n            return \"\" + height[0] + height[1] + \" \" + width[0] / 2 + width[1] + \" 0 \" + width[0] / 2 + width[1];\n        case \"right\":\n            return \"\" + height[0] / 2 + height[1] + \" 0 \" + height[0] / 2 + height[1] + \" \" + width[0] + width[1];\n        default:\n            throw new PolishedError(59);\n    }\n}; // needed for border-color\nvar reverseDirection = [\n    \"bottom\",\n    \"left\",\n    \"top\",\n    \"right\"\n];\nvar NUMBER_AND_FLOAT = /(\\d*\\.?\\d*)/;\n/**\n * CSS to represent triangle with any pointing direction with an optional background color. Accepts number or px values for height and width.\n *\n * @example\n * // Styles as object usage\n *\n * const styles = {\n *   ...triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })\n * }\n *\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })}\n *\n *\n * // CSS as JS Output\n *\n * div: {\n *  'borderColor': 'transparent',\n *  'borderLeftColor': 'red !important',\n *  'borderStyle': 'solid',\n *  'borderWidth': '50px 0 50px 100px',\n *  'height': '0',\n *  'width': '0',\n * }\n */ function triangle(_ref) {\n    var pointingDirection = _ref.pointingDirection, height = _ref.height, width = _ref.width, foregroundColor = _ref.foregroundColor, _ref$backgroundColor = _ref.backgroundColor, backgroundColor = _ref$backgroundColor === void 0 ? \"transparent\" : _ref$backgroundColor;\n    var widthAndUnit = [\n        parseFloat(width),\n        String(width).replace(NUMBER_AND_FLOAT, \"\") || \"px\"\n    ];\n    var heightAndUnit = [\n        parseFloat(height),\n        String(height).replace(NUMBER_AND_FLOAT, \"\") || \"px\"\n    ];\n    if (isNaN(heightAndUnit[0]) || isNaN(widthAndUnit[0])) {\n        throw new PolishedError(60);\n    }\n    var reverseDirectionIndex = reverseDirection.indexOf(pointingDirection);\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        width: \"0\",\n        height: \"0\",\n        borderWidth: getBorderWidth(pointingDirection, heightAndUnit, widthAndUnit),\n        borderStyle: \"solid\"\n    }, borderColor.apply(void 0, Array.from({\n        length: 4\n    }).map(function(_, index) {\n        return index === reverseDirectionIndex ? foregroundColor : backgroundColor;\n    })));\n}\n/**\n * Provides an easy way to change the `wordWrap` property.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...wordWrap('break-word')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${wordWrap('break-word')}\n * `\n *\n * // CSS as JS Output\n *\n * const styles = {\n *   overflowWrap: 'break-word',\n *   wordWrap: 'break-word',\n *   wordBreak: 'break-all',\n * }\n */ function wordWrap(wrap) {\n    if (wrap === void 0) {\n        wrap = \"break-word\";\n    }\n    var wordBreak = wrap === \"break-word\" ? \"break-all\" : wrap;\n    return {\n        overflowWrap: wrap,\n        wordWrap: wrap,\n        wordBreak: wordBreak\n    };\n}\nfunction colorToInt(color) {\n    return Math.round(color * 255);\n}\nfunction convertToInt(red, green, blue) {\n    return colorToInt(red) + \",\" + colorToInt(green) + \",\" + colorToInt(blue);\n}\nfunction hslToRgb(hue, saturation, lightness, convert) {\n    if (convert === void 0) {\n        convert = convertToInt;\n    }\n    if (saturation === 0) {\n        // achromatic\n        return convert(lightness, lightness, lightness);\n    } // formular from https://en.wikipedia.org/wiki/HSL_and_HSV\n    var huePrime = hue % 360 / 60;\n    var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;\n    var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));\n    var red = 0;\n    var green = 0;\n    var blue = 0;\n    if (huePrime >= 0 && huePrime < 1) {\n        red = chroma;\n        green = secondComponent;\n    } else if (huePrime >= 1 && huePrime < 2) {\n        red = secondComponent;\n        green = chroma;\n    } else if (huePrime >= 2 && huePrime < 3) {\n        green = chroma;\n        blue = secondComponent;\n    } else if (huePrime >= 3 && huePrime < 4) {\n        green = secondComponent;\n        blue = chroma;\n    } else if (huePrime >= 4 && huePrime < 5) {\n        red = secondComponent;\n        blue = chroma;\n    } else if (huePrime >= 5 && huePrime < 6) {\n        red = chroma;\n        blue = secondComponent;\n    }\n    var lightnessModification = lightness - chroma / 2;\n    var finalRed = red + lightnessModification;\n    var finalGreen = green + lightnessModification;\n    var finalBlue = blue + lightnessModification;\n    return convert(finalRed, finalGreen, finalBlue);\n}\nvar namedColorMap = {\n    aliceblue: \"f0f8ff\",\n    antiquewhite: \"faebd7\",\n    aqua: \"00ffff\",\n    aquamarine: \"7fffd4\",\n    azure: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"000\",\n    blanchedalmond: \"ffebcd\",\n    blue: \"0000ff\",\n    blueviolet: \"8a2be2\",\n    brown: \"a52a2a\",\n    burlywood: \"deb887\",\n    cadetblue: \"5f9ea0\",\n    chartreuse: \"7fff00\",\n    chocolate: \"d2691e\",\n    coral: \"ff7f50\",\n    cornflowerblue: \"6495ed\",\n    cornsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"00ffff\",\n    darkblue: \"00008b\",\n    darkcyan: \"008b8b\",\n    darkgoldenrod: \"b8860b\",\n    darkgray: \"a9a9a9\",\n    darkgreen: \"006400\",\n    darkgrey: \"a9a9a9\",\n    darkkhaki: \"bdb76b\",\n    darkmagenta: \"8b008b\",\n    darkolivegreen: \"556b2f\",\n    darkorange: \"ff8c00\",\n    darkorchid: \"9932cc\",\n    darkred: \"8b0000\",\n    darksalmon: \"e9967a\",\n    darkseagreen: \"8fbc8f\",\n    darkslateblue: \"483d8b\",\n    darkslategray: \"2f4f4f\",\n    darkslategrey: \"2f4f4f\",\n    darkturquoise: \"00ced1\",\n    darkviolet: \"9400d3\",\n    deeppink: \"ff1493\",\n    deepskyblue: \"00bfff\",\n    dimgray: \"696969\",\n    dimgrey: \"696969\",\n    dodgerblue: \"1e90ff\",\n    firebrick: \"b22222\",\n    floralwhite: \"fffaf0\",\n    forestgreen: \"228b22\",\n    fuchsia: \"ff00ff\",\n    gainsboro: \"dcdcdc\",\n    ghostwhite: \"f8f8ff\",\n    gold: \"ffd700\",\n    goldenrod: \"daa520\",\n    gray: \"808080\",\n    green: \"008000\",\n    greenyellow: \"adff2f\",\n    grey: \"808080\",\n    honeydew: \"f0fff0\",\n    hotpink: \"ff69b4\",\n    indianred: \"cd5c5c\",\n    indigo: \"4b0082\",\n    ivory: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavender: \"e6e6fa\",\n    lavenderblush: \"fff0f5\",\n    lawngreen: \"7cfc00\",\n    lemonchiffon: \"fffacd\",\n    lightblue: \"add8e6\",\n    lightcoral: \"f08080\",\n    lightcyan: \"e0ffff\",\n    lightgoldenrodyellow: \"fafad2\",\n    lightgray: \"d3d3d3\",\n    lightgreen: \"90ee90\",\n    lightgrey: \"d3d3d3\",\n    lightpink: \"ffb6c1\",\n    lightsalmon: \"ffa07a\",\n    lightseagreen: \"20b2aa\",\n    lightskyblue: \"87cefa\",\n    lightslategray: \"789\",\n    lightslategrey: \"789\",\n    lightsteelblue: \"b0c4de\",\n    lightyellow: \"ffffe0\",\n    lime: \"0f0\",\n    limegreen: \"32cd32\",\n    linen: \"faf0e6\",\n    magenta: \"f0f\",\n    maroon: \"800000\",\n    mediumaquamarine: \"66cdaa\",\n    mediumblue: \"0000cd\",\n    mediumorchid: \"ba55d3\",\n    mediumpurple: \"9370db\",\n    mediumseagreen: \"3cb371\",\n    mediumslateblue: \"7b68ee\",\n    mediumspringgreen: \"00fa9a\",\n    mediumturquoise: \"48d1cc\",\n    mediumvioletred: \"c71585\",\n    midnightblue: \"191970\",\n    mintcream: \"f5fffa\",\n    mistyrose: \"ffe4e1\",\n    moccasin: \"ffe4b5\",\n    navajowhite: \"ffdead\",\n    navy: \"000080\",\n    oldlace: \"fdf5e6\",\n    olive: \"808000\",\n    olivedrab: \"6b8e23\",\n    orange: \"ffa500\",\n    orangered: \"ff4500\",\n    orchid: \"da70d6\",\n    palegoldenrod: \"eee8aa\",\n    palegreen: \"98fb98\",\n    paleturquoise: \"afeeee\",\n    palevioletred: \"db7093\",\n    papayawhip: \"ffefd5\",\n    peachpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pink: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powderblue: \"b0e0e6\",\n    purple: \"800080\",\n    rebeccapurple: \"639\",\n    red: \"f00\",\n    rosybrown: \"bc8f8f\",\n    royalblue: \"4169e1\",\n    saddlebrown: \"8b4513\",\n    salmon: \"fa8072\",\n    sandybrown: \"f4a460\",\n    seagreen: \"2e8b57\",\n    seashell: \"fff5ee\",\n    sienna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyblue: \"87ceeb\",\n    slateblue: \"6a5acd\",\n    slategray: \"708090\",\n    slategrey: \"708090\",\n    snow: \"fffafa\",\n    springgreen: \"00ff7f\",\n    steelblue: \"4682b4\",\n    tan: \"d2b48c\",\n    teal: \"008080\",\n    thistle: \"d8bfd8\",\n    tomato: \"ff6347\",\n    turquoise: \"40e0d0\",\n    violet: \"ee82ee\",\n    wheat: \"f5deb3\",\n    white: \"fff\",\n    whitesmoke: \"f5f5f5\",\n    yellow: \"ff0\",\n    yellowgreen: \"9acd32\"\n};\nfunction nameToHex(color) {\n    if (typeof color !== \"string\") return color;\n    var normalizedColorName = color.toLowerCase();\n    return namedColorMap[normalizedColorName] ? \"#\" + namedColorMap[normalizedColorName] : color;\n}\nvar hexRegex = /^#[a-fA-F0-9]{6}$/;\nvar hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;\nvar reducedHexRegex = /^#[a-fA-F0-9]{3}$/;\nvar reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;\nvar rgbRegex = /^rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)$/;\nvar rgbaRegex = /^rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*([-+]?[0-9]*[.]?[0-9]+)\\s*\\)$/;\nvar hslRegex = /^hsl\\(\\s*(\\d{0,3}[.]?[0-9]+)\\s*,\\s*(\\d{1,3})%\\s*,\\s*(\\d{1,3})%\\s*\\)$/;\nvar hslaRegex = /^hsla\\(\\s*(\\d{0,3}[.]?[0-9]+)\\s*,\\s*(\\d{1,3})%\\s*,\\s*(\\d{1,3})%\\s*,\\s*([-+]?[0-9]*[.]?[0-9]+)\\s*\\)$/;\n/**\n * Returns an RgbColor or RgbaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a RgbColor or RgbaColor object back to a string.\n *\n * @example\n * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1\n * const color1 = parseToRgb('rgb(255, 0, 0)');\n * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2\n * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');\n */ function parseToRgb(color) {\n    if (typeof color !== \"string\") {\n        throw new PolishedError(3);\n    }\n    var normalizedColor = nameToHex(color);\n    if (normalizedColor.match(hexRegex)) {\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n            green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n            blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16)\n        };\n    }\n    if (normalizedColor.match(hexRgbaRegex)) {\n        var alpha = parseFloat((parseInt(\"\" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n            green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n            blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16),\n            alpha: alpha\n        };\n    }\n    if (normalizedColor.match(reducedHexRegex)) {\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n            green: parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n            blue: parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16)\n        };\n    }\n    if (normalizedColor.match(reducedRgbaHexRegex)) {\n        var _alpha = parseFloat((parseInt(\"\" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n            green: parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n            blue: parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16),\n            alpha: _alpha\n        };\n    }\n    var rgbMatched = rgbRegex.exec(normalizedColor);\n    if (rgbMatched) {\n        return {\n            red: parseInt(\"\" + rgbMatched[1], 10),\n            green: parseInt(\"\" + rgbMatched[2], 10),\n            blue: parseInt(\"\" + rgbMatched[3], 10)\n        };\n    }\n    var rgbaMatched = rgbaRegex.exec(normalizedColor);\n    if (rgbaMatched) {\n        return {\n            red: parseInt(\"\" + rgbaMatched[1], 10),\n            green: parseInt(\"\" + rgbaMatched[2], 10),\n            blue: parseInt(\"\" + rgbaMatched[3], 10),\n            alpha: parseFloat(\"\" + rgbaMatched[4])\n        };\n    }\n    var hslMatched = hslRegex.exec(normalizedColor);\n    if (hslMatched) {\n        var hue = parseInt(\"\" + hslMatched[1], 10);\n        var saturation = parseInt(\"\" + hslMatched[2], 10) / 100;\n        var lightness = parseInt(\"\" + hslMatched[3], 10) / 100;\n        var rgbColorString = \"rgb(\" + hslToRgb(hue, saturation, lightness) + \")\";\n        var hslRgbMatched = rgbRegex.exec(rgbColorString);\n        if (!hslRgbMatched) {\n            throw new PolishedError(4, normalizedColor, rgbColorString);\n        }\n        return {\n            red: parseInt(\"\" + hslRgbMatched[1], 10),\n            green: parseInt(\"\" + hslRgbMatched[2], 10),\n            blue: parseInt(\"\" + hslRgbMatched[3], 10)\n        };\n    }\n    var hslaMatched = hslaRegex.exec(normalizedColor);\n    if (hslaMatched) {\n        var _hue = parseInt(\"\" + hslaMatched[1], 10);\n        var _saturation = parseInt(\"\" + hslaMatched[2], 10) / 100;\n        var _lightness = parseInt(\"\" + hslaMatched[3], 10) / 100;\n        var _rgbColorString = \"rgb(\" + hslToRgb(_hue, _saturation, _lightness) + \")\";\n        var _hslRgbMatched = rgbRegex.exec(_rgbColorString);\n        if (!_hslRgbMatched) {\n            throw new PolishedError(4, normalizedColor, _rgbColorString);\n        }\n        return {\n            red: parseInt(\"\" + _hslRgbMatched[1], 10),\n            green: parseInt(\"\" + _hslRgbMatched[2], 10),\n            blue: parseInt(\"\" + _hslRgbMatched[3], 10),\n            alpha: parseFloat(\"\" + hslaMatched[4])\n        };\n    }\n    throw new PolishedError(5);\n}\nfunction rgbToHsl(color) {\n    // make sure rgb are contained in a set of [0, 255]\n    var red = color.red / 255;\n    var green = color.green / 255;\n    var blue = color.blue / 255;\n    var max = Math.max(red, green, blue);\n    var min = Math.min(red, green, blue);\n    var lightness = (max + min) / 2;\n    if (max === min) {\n        // achromatic\n        if (color.alpha !== undefined) {\n            return {\n                hue: 0,\n                saturation: 0,\n                lightness: lightness,\n                alpha: color.alpha\n            };\n        } else {\n            return {\n                hue: 0,\n                saturation: 0,\n                lightness: lightness\n            };\n        }\n    }\n    var hue;\n    var delta = max - min;\n    var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n    switch(max){\n        case red:\n            hue = (green - blue) / delta + (green < blue ? 6 : 0);\n            break;\n        case green:\n            hue = (blue - red) / delta + 2;\n            break;\n        default:\n            // blue case\n            hue = (red - green) / delta + 4;\n            break;\n    }\n    hue *= 60;\n    if (color.alpha !== undefined) {\n        return {\n            hue: hue,\n            saturation: saturation,\n            lightness: lightness,\n            alpha: color.alpha\n        };\n    }\n    return {\n        hue: hue,\n        saturation: saturation,\n        lightness: lightness\n    };\n}\n/**\n * Returns an HslColor or HslaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a HslColor or HslaColor object back to a string.\n *\n * @example\n * // Assigns `{ hue: 0, saturation: 1, lightness: 0.5 }` to color1\n * const color1 = parseToHsl('rgb(255, 0, 0)');\n * // Assigns `{ hue: 128, saturation: 1, lightness: 0.5, alpha: 0.75 }` to color2\n * const color2 = parseToHsl('hsla(128, 100%, 50%, 0.75)');\n */ function parseToHsl(color) {\n    // Note: At a later stage we can optimize this function as right now a hsl\n    // color would be parsed converted to rgb values and converted back to hsl.\n    return rgbToHsl(parseToRgb(color));\n}\n/**\n * Reduces hex values if possible e.g. #ff8866 to #f86\n * @private\n */ var reduceHexValue = function reduceHexValue(value) {\n    if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {\n        return \"#\" + value[1] + value[3] + value[5];\n    }\n    return value;\n};\nfunction numberToHex(value) {\n    var hex = value.toString(16);\n    return hex.length === 1 ? \"0\" + hex : hex;\n}\nfunction colorToHex(color) {\n    return numberToHex(Math.round(color * 255));\n}\nfunction convertToHex(red, green, blue) {\n    return reduceHexValue(\"#\" + colorToHex(red) + colorToHex(green) + colorToHex(blue));\n}\nfunction hslToHex(hue, saturation, lightness) {\n    return hslToRgb(hue, saturation, lightness, convertToHex);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsl(359, 0.75, 0.4),\n *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsl(359, 0.75, 0.4)};\n *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#b3191c\";\n *   background: \"#b3191c\";\n * }\n */ function hsl(value, saturation, lightness) {\n    if (typeof value === \"number\" && typeof saturation === \"number\" && typeof lightness === \"number\") {\n        return hslToHex(value, saturation, lightness);\n    } else if (typeof value === \"object\" && saturation === undefined && lightness === undefined) {\n        return hslToHex(value.hue, value.saturation, value.lightness);\n    }\n    throw new PolishedError(1);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsla(359, 0.75, 0.4, 0.7),\n *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),\n *   background: hsla(359, 0.75, 0.4, 1),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsla(359, 0.75, 0.4, 0.7)};\n *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};\n *   background: ${hsla(359, 0.75, 0.4, 1)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"#b3191c\";\n * }\n */ function hsla(value, saturation, lightness, alpha) {\n    if (typeof value === \"number\" && typeof saturation === \"number\" && typeof lightness === \"number\" && typeof alpha === \"number\") {\n        return alpha >= 1 ? hslToHex(value, saturation, lightness) : \"rgba(\" + hslToRgb(value, saturation, lightness) + \",\" + alpha + \")\";\n    } else if (typeof value === \"object\" && saturation === undefined && lightness === undefined && alpha === undefined) {\n        return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : \"rgba(\" + hslToRgb(value.hue, value.saturation, value.lightness) + \",\" + value.alpha + \")\";\n    }\n    throw new PolishedError(2);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgb(255, 205, 100),\n *   background: rgb({ red: 255, green: 205, blue: 100 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgb(255, 205, 100)};\n *   background: ${rgb({ red: 255, green: 205, blue: 100 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffcd64\";\n *   background: \"#ffcd64\";\n * }\n */ function rgb(value, green, blue) {\n    if (typeof value === \"number\" && typeof green === \"number\" && typeof blue === \"number\") {\n        return reduceHexValue(\"#\" + numberToHex(value) + numberToHex(green) + numberToHex(blue));\n    } else if (typeof value === \"object\" && green === undefined && blue === undefined) {\n        return reduceHexValue(\"#\" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));\n    }\n    throw new PolishedError(6);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgba(255, 205, 100, 0.7),\n *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),\n *   background: rgba(255, 205, 100, 1),\n *   background: rgba('#ffffff', 0.4),\n *   background: rgba('black', 0.7),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgba(255, 205, 100, 0.7)};\n *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};\n *   background: ${rgba(255, 205, 100, 1)};\n *   background: ${rgba('#ffffff', 0.4)};\n *   background: ${rgba('black', 0.7)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,255,255,0.4)\";\n *   background: \"rgba(0,0,0,0.7)\";\n * }\n */ function rgba(firstValue, secondValue, thirdValue, fourthValue) {\n    if (typeof firstValue === \"string\" && typeof secondValue === \"number\") {\n        var rgbValue = parseToRgb(firstValue);\n        return \"rgba(\" + rgbValue.red + \",\" + rgbValue.green + \",\" + rgbValue.blue + \",\" + secondValue + \")\";\n    } else if (typeof firstValue === \"number\" && typeof secondValue === \"number\" && typeof thirdValue === \"number\" && typeof fourthValue === \"number\") {\n        return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : \"rgba(\" + firstValue + \",\" + secondValue + \",\" + thirdValue + \",\" + fourthValue + \")\";\n    } else if (typeof firstValue === \"object\" && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {\n        return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : \"rgba(\" + firstValue.red + \",\" + firstValue.green + \",\" + firstValue.blue + \",\" + firstValue.alpha + \")\";\n    }\n    throw new PolishedError(7);\n}\nvar isRgb = function isRgb(color) {\n    return typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\" && (typeof color.alpha !== \"number\" || typeof color.alpha === \"undefined\");\n};\nvar isRgba = function isRgba(color) {\n    return typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\" && typeof color.alpha === \"number\";\n};\nvar isHsl = function isHsl(color) {\n    return typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\" && (typeof color.alpha !== \"number\" || typeof color.alpha === \"undefined\");\n};\nvar isHsla = function isHsla(color) {\n    return typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\" && typeof color.alpha === \"number\";\n};\n/**\n * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: toColorString({ red: 255, green: 205, blue: 100 }),\n *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */ function toColorString(color) {\n    if (typeof color !== \"object\") throw new PolishedError(8);\n    if (isRgba(color)) return rgba(color);\n    if (isRgb(color)) return rgb(color);\n    if (isHsla(color)) return hsla(color);\n    if (isHsl(color)) return hsl(color);\n    throw new PolishedError(8);\n}\n// Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js\n// eslint-disable-next-line no-unused-vars\n// eslint-disable-next-line no-unused-vars\n// eslint-disable-next-line no-redeclare\nfunction curried(f, length, acc) {\n    return function fn() {\n        // eslint-disable-next-line prefer-rest-params\n        var combined = acc.concat(Array.prototype.slice.call(arguments));\n        return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);\n    };\n} // eslint-disable-next-line no-redeclare\nfunction curry(f) {\n    // eslint-disable-line no-redeclare\n    return curried(f, f.length, []);\n}\n/**\n * Changes the hue of the color. Hue is a number between 0 to 360. The first\n * argument for adjustHue is the amount of degrees the color is rotated along\n * the color wheel.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: adjustHue(180, '#448'),\n *   background: adjustHue('180', 'rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${adjustHue(180, '#448')};\n *   background: ${adjustHue('180', 'rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#888844\";\n *   background: \"rgba(136,136,68,0.7)\";\n * }\n */ function adjustHue(degree, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        hue: (hslColor.hue + parseFloat(degree)) % 360\n    }));\n} // prettier-ignore\nvar curriedAdjustHue = /*#__PURE__*/ curry(adjustHue);\n/**\n * Returns the complement of the provided color. This is identical to adjustHue(180, <color>).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: complement('#448'),\n *   background: complement('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${complement('#448')};\n *   background: ${complement('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#884\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */ function complement(color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        hue: (hslColor.hue + 180) % 360\n    }));\n}\nfunction guard(lowerBoundary, upperBoundary, value) {\n    return Math.max(lowerBoundary, Math.min(upperBoundary, value));\n}\n/**\n * Returns a string value for the darkened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: darken(0.2, '#FFCD64'),\n *   background: darken('0.2', 'rgba(255,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${darken(0.2, '#FFCD64')};\n *   background: ${darken('0.2', 'rgba(255,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffbd31\";\n *   background: \"rgba(255,189,49,0.7)\";\n * }\n */ function darken(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))\n    }));\n} // prettier-ignore\nvar curriedDarken = /*#__PURE__*/ curry(darken);\n/**\n * Decreases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the desaturate function is the amount by how much the color\n * intensity should be decreased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: desaturate(0.2, '#CCCD64'),\n *   background: desaturate('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${desaturate(0.2, '#CCCD64')};\n *   background: ${desaturate('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#b8b979\";\n *   background: \"rgba(184,185,121,0.7)\";\n * }\n */ function desaturate(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))\n    }));\n} // prettier-ignore\nvar curriedDesaturate = /*#__PURE__*/ curry(desaturate);\n/**\n * Returns a number (float) representing the luminance of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff',\n *   background: getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)',\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff'};\n *   background: ${getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)'};\n *\n * // CSS in JS Output\n *\n * div {\n *   background: \"#CCCD64\";\n *   background: \"rgba(58, 133, 255, 1)\";\n * }\n */ function getLuminance(color) {\n    if (color === \"transparent\") return 0;\n    var rgbColor = parseToRgb(color);\n    var _Object$keys$map = Object.keys(rgbColor).map(function(key) {\n        var channel = rgbColor[key] / 255;\n        return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);\n    }), r = _Object$keys$map[0], g = _Object$keys$map[1], b = _Object$keys$map[2];\n    return parseFloat((0.2126 * r + 0.7152 * g + 0.0722 * b).toFixed(3));\n}\n/**\n * Converts the color to a grayscale, by reducing its saturation to 0.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: grayscale('#CCCD64'),\n *   background: grayscale('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${grayscale('#CCCD64')};\n *   background: ${grayscale('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#999\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */ function grayscale(color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        saturation: 0\n    }));\n}\n/**\n * Converts a HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */ function hslToColorString(color) {\n    if (typeof color === \"object\" && typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\") {\n        if (color.alpha && typeof color.alpha === \"number\") {\n            return hsla({\n                hue: color.hue,\n                saturation: color.saturation,\n                lightness: color.lightness,\n                alpha: color.alpha\n            });\n        }\n        return hsl({\n            hue: color.hue,\n            saturation: color.saturation,\n            lightness: color.lightness\n        });\n    }\n    throw new PolishedError(45);\n}\n/**\n * Inverts the red, green and blue values of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: invert('#CCCD64'),\n *   background: invert('rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${invert('#CCCD64')};\n *   background: ${invert('rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#33329b\";\n *   background: \"rgba(154,155,50,0.7)\";\n * }\n */ function invert(color) {\n    if (color === \"transparent\") return color; // parse color string to rgb\n    var value = parseToRgb(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, value, {\n        red: 255 - value.red,\n        green: 255 - value.green,\n        blue: 255 - value.blue\n    }));\n}\n/**\n * Returns a string value for the lightened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: lighten(0.2, '#CCCD64'),\n *   background: lighten('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${lighten(0.2, '#FFCD64')};\n *   background: ${lighten('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e5e6b1\";\n *   background: \"rgba(229,230,177,0.7)\";\n * }\n */ function lighten(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))\n    }));\n} // prettier-ignore\nvar curriedLighten = /*#__PURE__*/ curry(lighten);\n/**\n * Mixes the two provided colors together by calculating the average of each of the RGB components weighted to the first color by the provided weight.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: mix(0.5, '#f00', '#00f')\n *   background: mix(0.25, '#f00', '#00f')\n *   background: mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${mix(0.5, '#f00', '#00f')};\n *   background: ${mix(0.25, '#f00', '#00f')};\n *   background: ${mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#7f007f\";\n *   background: \"#3f00bf\";\n *   background: \"rgba(63, 0, 191, 0.75)\";\n * }\n */ function mix(weight, color, otherColor) {\n    if (color === \"transparent\") return otherColor;\n    if (otherColor === \"transparent\") return color;\n    var parsedColor1 = parseToRgb(color);\n    var color1 = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor1, {\n        alpha: typeof parsedColor1.alpha === \"number\" ? parsedColor1.alpha : 1\n    });\n    var parsedColor2 = parseToRgb(otherColor);\n    var color2 = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor2, {\n        alpha: typeof parsedColor2.alpha === \"number\" ? parsedColor2.alpha : 1 // The formular is copied from the original Sass implementation:\n    });\n    var alphaDelta = color1.alpha - color2.alpha;\n    var x = parseFloat(weight) * 2 - 1;\n    var y = x * alphaDelta === -1 ? x : x + alphaDelta;\n    var z = 1 + x * alphaDelta;\n    var weight1 = (y / z + 1) / 2.0;\n    var weight2 = 1 - weight1;\n    var mixedColor = {\n        red: Math.floor(color1.red * weight1 + color2.red * weight2),\n        green: Math.floor(color1.green * weight1 + color2.green * weight2),\n        blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),\n        alpha: color1.alpha + (color2.alpha - color1.alpha) * (parseFloat(weight) / 1.0)\n    };\n    return rgba(mixedColor);\n} // prettier-ignore\nvar curriedMix = /*#__PURE__*/ curry(mix);\n/**\n * Increases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: opacify(0.1, 'rgba(255, 255, 255, 0.9)');\n *   background: opacify(0.2, 'hsla(0, 0%, 100%, 0.5)'),\n *   background: opacify('0.5', 'rgba(255, 0, 0, 0.2)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${opacify(0.1, 'rgba(255, 255, 255, 0.9)')};\n *   background: ${opacify(0.2, 'hsla(0, 0%, 100%, 0.5)')},\n *   background: ${opacify('0.5', 'rgba(255, 0, 0, 0.2)')},\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#fff\";\n *   background: \"rgba(255,255,255,0.7)\";\n *   background: \"rgba(255,0,0,0.7)\";\n * }\n */ function opacify(amount, color) {\n    if (color === \"transparent\") return color;\n    var parsedColor = parseToRgb(color);\n    var alpha = typeof parsedColor.alpha === \"number\" ? parsedColor.alpha : 1;\n    var colorWithAlpha = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor, {\n        alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)\n    });\n    return rgba(colorWithAlpha);\n} // prettier-ignore\nvar curriedOpacify = /*#__PURE__*/ curry(opacify);\n/**\n * Returns black or white (or optional light and dark return colors) for best contrast depending on the luminosity of the given color.\n * Follows [W3C specs for readability](https://www.w3.org/TR/WCAG20-TECHS/G18.html).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   color: readableColor('#000'),\n *   color: readableColor('black', '#001', '#ff8'),\n *   color: readableColor('white', '#001', '#ff8'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   color: ${readableColor('#000')};\n *   color: ${readableColor('black', '#001', '#ff8')};\n *   color: ${readableColor('white', '#001', '#ff8')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   color: \"#fff\";\n *   color: \"#ff8\";\n *   color: \"#001\";\n * }\n */ function readableColor(color, lightReturnColor, darkReturnColor) {\n    if (lightReturnColor === void 0) {\n        lightReturnColor = \"#000\";\n    }\n    if (darkReturnColor === void 0) {\n        darkReturnColor = \"#fff\";\n    }\n    return getLuminance(color) > 0.179 ? lightReturnColor : darkReturnColor;\n}\n/**\n * Converts a RgbColor or RgbaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb` or `rgba`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgbToColorString({ red: 255, green: 205, blue: 100 }),\n *   background: rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n * }\n */ function rgbToColorString(color) {\n    if (typeof color === \"object\" && typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\") {\n        if (color.alpha && typeof color.alpha === \"number\") {\n            return rgba({\n                red: color.red,\n                green: color.green,\n                blue: color.blue,\n                alpha: color.alpha\n            });\n        }\n        return rgb({\n            red: color.red,\n            green: color.green,\n            blue: color.blue\n        });\n    }\n    throw new PolishedError(46);\n}\n/**\n * Increases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the saturate function is the amount by how much the color\n * intensity should be increased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: saturate(0.2, '#CCCD64'),\n *   background: saturate('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${saturate(0.2, '#FFCD64')};\n *   background: ${saturate('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e0e250\";\n *   background: \"rgba(224,226,80,0.7)\";\n * }\n */ function saturate(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))\n    }));\n} // prettier-ignore\nvar curriedSaturate = /*#__PURE__*/ curry(saturate);\n/**\n * Sets the hue of a color to the provided value. The hue range can be\n * from 0 and 359.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setHue(42, '#CCCD64'),\n *   background: setHue('244', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setHue(42, '#CCCD64')};\n *   background: ${setHue('244', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#cdae64\";\n *   background: \"rgba(107,100,205,0.7)\";\n * }\n */ function setHue(hue, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        hue: parseFloat(hue)\n    }));\n} // prettier-ignore\nvar curriedSetHue = /*#__PURE__*/ curry(setHue);\n/**\n * Sets the lightness of a color to the provided value. The lightness range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setLightness(0.2, '#CCCD64'),\n *   background: setLightness('0.75', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setLightness(0.2, '#CCCD64')};\n *   background: ${setLightness('0.75', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#4d4d19\";\n *   background: \"rgba(223,224,159,0.7)\";\n * }\n */ function setLightness(lightness, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        lightness: parseFloat(lightness)\n    }));\n} // prettier-ignore\nvar curriedSetLightness = /*#__PURE__*/ curry(setLightness);\n/**\n * Sets the saturation of a color to the provided value. The saturation range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setSaturation(0.2, '#CCCD64'),\n *   background: setSaturation('0.75', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setSaturation(0.2, '#CCCD64')};\n *   background: ${setSaturation('0.75', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#adad84\";\n *   background: \"rgba(228,229,76,0.7)\";\n * }\n */ function setSaturation(saturation, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        saturation: parseFloat(saturation)\n    }));\n} // prettier-ignore\nvar curriedSetSaturation = /*#__PURE__*/ curry(setSaturation);\n/**\n * Shades a color by mixing it with black. `shade` can produce\n * hue shifts, where as `darken` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: shade(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${shade(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#00003f\";\n * }\n */ function shade(percentage, color) {\n    if (color === \"transparent\") return color;\n    return curriedMix(parseFloat(percentage), \"rgb(0, 0, 0)\", color);\n} // prettier-ignore\nvar curriedShade = /*#__PURE__*/ curry(shade);\n/**\n * Tints a color by mixing it with white. `tint` can produce\n * hue shifts, where as `lighten` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: tint(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${tint(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#bfbfff\";\n * }\n */ function tint(percentage, color) {\n    if (color === \"transparent\") return color;\n    return curriedMix(parseFloat(percentage), \"rgb(255, 255, 255)\", color);\n} // prettier-ignore\nvar curriedTint = /*#__PURE__*/ curry(tint);\n/**\n * Decreases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: transparentize(0.1, '#fff');\n *   background: transparentize(0.2, 'hsl(0, 0%, 100%)'),\n *   background: transparentize('0.5', 'rgba(255, 0, 0, 0.8)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${transparentize(0.1, '#fff')};\n *   background: ${transparentize(0.2, 'hsl(0, 0%, 100%)')},\n *   background: ${transparentize('0.5', 'rgba(255, 0, 0, 0.8)')},\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,255,255,0.9)\";\n *   background: \"rgba(255,255,255,0.8)\";\n *   background: \"rgba(255,0,0,0.3)\";\n * }\n */ function transparentize(amount, color) {\n    if (color === \"transparent\") return color;\n    var parsedColor = parseToRgb(color);\n    var alpha = typeof parsedColor.alpha === \"number\" ? parsedColor.alpha : 1;\n    var colorWithAlpha = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor, {\n        alpha: guard(0, 1, (alpha * 100 - parseFloat(amount) * 100) / 100)\n    });\n    return rgba(colorWithAlpha);\n} // prettier-ignore\nvar curriedTransparentize = /*#__PURE__*/ curry(transparentize);\n/**\n * Shorthand for easily setting the animation property. Allows either multiple arrays with animations\n * or a single animation spread over the arguments.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out, colorchange 2s'\n * }\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation('rotate', '1s', 'ease-in-out')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation('rotate', '1s', 'ease-in-out')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out'\n * }\n */ function animation() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    // Allow single or multiple animations passed\n    var multiMode = Array.isArray(args[0]);\n    if (!multiMode && args.length > 8) {\n        throw new PolishedError(64);\n    }\n    var code = args.map(function(arg) {\n        if (multiMode && !Array.isArray(arg) || !multiMode && Array.isArray(arg)) {\n            throw new PolishedError(65);\n        }\n        if (Array.isArray(arg) && arg.length > 8) {\n            throw new PolishedError(66);\n        }\n        return Array.isArray(arg) ? arg.join(\" \") : arg;\n    }).join(\", \");\n    return {\n        animation: code\n    };\n}\n/**\n * Shorthand that accepts any number of backgroundImage values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'backgroundImage': 'url(\"/image/background.jpg\"), linear-gradient(red, green)'\n * }\n */ function backgroundImages() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    return {\n        backgroundImage: properties.join(\", \")\n    };\n}\n/**\n * Shorthand that accepts any number of background values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'background': 'url(\"/image/background.jpg\"), linear-gradient(red, green), center no-repeat'\n * }\n */ function backgrounds() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    return {\n        background: properties.join(\", \")\n    };\n}\nvar sideMap = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\n/**\n * Shorthand for the border property that splits out individual properties for use with tools like Fela and Styletron. A side keyword can optionally be passed to target only one side's border properties.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...border('1px', 'solid', 'red')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${border('1px', 'solid', 'red')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderColor': 'red',\n *   'borderStyle': 'solid',\n *   'borderWidth': `1px`,\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...border('top', '1px', 'solid', 'red')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${border('top', '1px', 'solid', 'red')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderTopStyle': 'solid',\n *   'borderTopWidth': `1px`,\n * }\n */ function border(sideKeyword) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    if (typeof sideKeyword === \"string\" && sideMap.indexOf(sideKeyword) >= 0) {\n        var _ref;\n        return _ref = {}, _ref[\"border\" + capitalizeString(sideKeyword) + \"Width\"] = values[0], _ref[\"border\" + capitalizeString(sideKeyword) + \"Style\"] = values[1], _ref[\"border\" + capitalizeString(sideKeyword) + \"Color\"] = values[2], _ref;\n    } else {\n        values.unshift(sideKeyword);\n        return {\n            borderWidth: values[0],\n            borderStyle: values[1],\n            borderColor: values[2]\n        };\n    }\n}\n/**\n * Shorthand that accepts a value for side and a value for radius and applies the radius value to both corners of the side.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderRadius('top', '5px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderRadius('top', '5px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopRightRadius': '5px',\n *   'borderTopLeftRadius': '5px',\n * }\n */ function borderRadius(side, radius) {\n    var uppercaseSide = capitalizeString(side);\n    if (!radius && radius !== 0) {\n        throw new PolishedError(62);\n    }\n    if (uppercaseSide === \"Top\" || uppercaseSide === \"Bottom\") {\n        var _ref;\n        return _ref = {}, _ref[\"border\" + uppercaseSide + \"RightRadius\"] = radius, _ref[\"border\" + uppercaseSide + \"LeftRadius\"] = radius, _ref;\n    }\n    if (uppercaseSide === \"Left\" || uppercaseSide === \"Right\") {\n        var _ref2;\n        return _ref2 = {}, _ref2[\"borderTop\" + uppercaseSide + \"Radius\"] = radius, _ref2[\"borderBottom\" + uppercaseSide + \"Radius\"] = radius, _ref2;\n    }\n    throw new PolishedError(63);\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderStyle('solid', 'dashed', 'dotted', 'double')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderStyle('solid', 'dashed', 'dotted', 'double')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopStyle': 'solid',\n *   'borderRightStyle': 'dashed',\n *   'borderBottomStyle': 'dotted',\n *   'borderLeftStyle': 'double'\n * }\n */ function borderStyle() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderStyle\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderWidth('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderWidth('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopWidth': '12px',\n *   'borderRightWidth': '24px',\n *   'borderBottomWidth': '36px',\n *   'borderLeftWidth': '48px'\n * }\n */ function borderWidth() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderWidth\"\n    ].concat(values));\n}\nfunction generateSelectors(template, state) {\n    var stateSuffix = state ? \":\" + state : \"\";\n    return template(stateSuffix);\n}\n/**\n * Function helper that adds an array of states to a template of selectors. Used in textInputs and buttons.\n * @private\n */ function statefulSelectors(states, template, stateMap) {\n    if (!template) throw new PolishedError(67);\n    if (states.length === 0) return generateSelectors(template, null);\n    var selectors = [];\n    for(var i = 0; i < states.length; i += 1){\n        if (stateMap && stateMap.indexOf(states[i]) < 0) {\n            throw new PolishedError(68);\n        }\n        selectors.push(generateSelectors(template, states[i]));\n    }\n    selectors = selectors.join(\",\");\n    return selectors;\n}\nvar stateMap = [\n    undefined,\n    null,\n    \"active\",\n    \"focus\",\n    \"hover\"\n];\nfunction template(state) {\n    return \"button\" + state + ',\\n  input[type=\"button\"]' + state + ',\\n  input[type=\"reset\"]' + state + ',\\n  input[type=\"submit\"]' + state;\n}\n/**\n * Populates selectors that target all buttons. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [buttons('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${buttons('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'button:active,\n *  'input[type=\"button\"]:active,\n *  'input[type=\\\"reset\\\"]:active,\n *  'input[type=\\\"submit\\\"]:active: {\n *   'border': 'none'\n * }\n */ function buttons() {\n    for(var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++){\n        states[_key] = arguments[_key];\n    }\n    return statefulSelectors(states, template, stateMap);\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...margin('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${margin('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'marginTop': '12px',\n *   'marginRight': '24px',\n *   'marginBottom': '36px',\n *   'marginLeft': '48px'\n * }\n */ function margin() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"margin\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...padding('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${padding('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */ function padding() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"padding\"\n    ].concat(values));\n}\nvar positionMap$1 = [\n    \"absolute\",\n    \"fixed\",\n    \"relative\",\n    \"static\",\n    \"sticky\"\n];\n/**\n * Shorthand accepts up to five values, including null to skip a value, and maps them to their respective directions. The first value can optionally be a position keyword.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...position('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...position('absolute', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('absolute', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'position': 'absolute',\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n */ function position(positionKeyword) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    if (positionMap$1.indexOf(positionKeyword) >= 0) {\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            position: positionKeyword\n        }, directionalProperty.apply(void 0, [\n            \"\"\n        ].concat(values)));\n    } else {\n        var firstValue = positionKeyword; // in this case position is actually the first value\n        return directionalProperty.apply(void 0, [\n            \"\",\n            firstValue\n        ].concat(values));\n    }\n}\n/**\n * Shorthand to set the height and width properties in a single statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...size('300px', '250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${size('300px', '250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'height': '300px',\n *   'width': '250px',\n * }\n */ function size(height, width) {\n    if (width === void 0) {\n        width = height;\n    }\n    return {\n        height: height,\n        width: width\n    };\n}\nvar stateMap$1 = [\n    undefined,\n    null,\n    \"active\",\n    \"focus\",\n    \"hover\"\n];\nfunction template$1(state) {\n    return 'input[type=\"color\"]' + state + ',\\n    input[type=\"date\"]' + state + ',\\n    input[type=\"datetime\"]' + state + ',\\n    input[type=\"datetime-local\"]' + state + ',\\n    input[type=\"email\"]' + state + ',\\n    input[type=\"month\"]' + state + ',\\n    input[type=\"number\"]' + state + ',\\n    input[type=\"password\"]' + state + ',\\n    input[type=\"search\"]' + state + ',\\n    input[type=\"tel\"]' + state + ',\\n    input[type=\"text\"]' + state + ',\\n    input[type=\"time\"]' + state + ',\\n    input[type=\"url\"]' + state + ',\\n    input[type=\"week\"]' + state + \",\\n    input:not([type])\" + state + \",\\n    textarea\" + state;\n}\n/**\n * Populates selectors that target all text inputs. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [textInputs('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${textInputs('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'input[type=\"color\"]:active,\n *  input[type=\"date\"]:active,\n *  input[type=\"datetime\"]:active,\n *  input[type=\"datetime-local\"]:active,\n *  input[type=\"email\"]:active,\n *  input[type=\"month\"]:active,\n *  input[type=\"number\"]:active,\n *  input[type=\"password\"]:active,\n *  input[type=\"search\"]:active,\n *  input[type=\"tel\"]:active,\n *  input[type=\"text\"]:active,\n *  input[type=\"time\"]:active,\n *  input[type=\"url\"]:active,\n *  input[type=\"week\"]:active,\n *  input:not([type]):active,\n *  textarea:active': {\n *   'border': 'none'\n * }\n */ function textInputs() {\n    for(var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++){\n        states[_key] = arguments[_key];\n    }\n    return statefulSelectors(states, template$1, stateMap$1);\n}\n/**\n * Accepts any number of transition values as parameters for creating a single transition statement. You may also pass an array of properties as the first parameter that you would like to apply the same tranisition values to (second parameter).\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s'),\n *   ...transitions(['color', 'background-color'], '2.0s ease-in 2s')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s')};\n *   ${transitions(['color', 'background-color'], '2.0s ease-in 2s'),};\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'transition': 'opacity 1.0s ease-in 0s, width 2.0s ease-in 2s'\n *   'transition': 'color 2.0s ease-in 2s, background-color 2.0s ease-in 2s',\n * }\n */ function transitions() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    if (Array.isArray(properties[0]) && properties.length === 2) {\n        var value = properties[1];\n        if (typeof value !== \"string\") {\n            throw new PolishedError(61);\n        }\n        var transitionsString = properties[0].map(function(property) {\n            return property + \" \" + value;\n        }).join(\", \");\n        return {\n            transition: transitionsString\n        };\n    } else {\n        return {\n            transition: properties.join(\", \")\n        };\n    }\n}\n// Math\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9saXNoZWQvZGlzdC9wb2xpc2hlZC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzRCO0FBQ2hCO0FBQ0k7QUFDc0I7QUFFaEcsU0FBU0s7SUFDUCxJQUFJQztJQUVKLE9BQU9BLE9BQU9DLFVBQVVDLE1BQU0sR0FBRyxHQUFHRixPQUFPLEtBQUtDLFVBQVVDLE1BQU0sSUFBSUYsT0FBT0csWUFBWUYsU0FBUyxDQUFDRCxLQUFLO0FBQ3hHO0FBRUEsU0FBU0ksU0FBU0MsQ0FBQztJQUNqQixPQUFPLENBQUNBO0FBQ1Y7QUFFQSxTQUFTQyxTQUFTRCxDQUFDLEVBQUVFLENBQUM7SUFDcEIsT0FBT0YsSUFBSUU7QUFDYjtBQUVBLFNBQVNDLFlBQVlILENBQUMsRUFBRUUsQ0FBQztJQUN2QixPQUFPRixJQUFJRTtBQUNiO0FBRUEsU0FBU0UsZUFBZUosQ0FBQyxFQUFFRSxDQUFDO0lBQzFCLE9BQU9GLElBQUlFO0FBQ2I7QUFFQSxTQUFTRyxTQUFTTCxDQUFDLEVBQUVFLENBQUM7SUFDcEIsT0FBT0YsSUFBSUU7QUFDYjtBQUVBLFNBQVNJLFVBQVVOLENBQUM7SUFDbEIsSUFBSUEsSUFBSSxLQUFLLENBQUUsRUFBQ0EsS0FBSyxJQUFJLE9BQU9PO0lBQ2hDLElBQUlQLElBQUksS0FBSyxPQUFPUTtTQUFjLElBQUlSLE1BQU0sR0FBRyxPQUFPO1NBQU87UUFDM0QsT0FBT0EsSUFBSU0sVUFBVU4sSUFBSTtJQUMzQjtBQUNGO0FBRUEsU0FBU1MsTUFBTVQsQ0FBQyxFQUFFRSxDQUFDO0lBQ2pCLE9BQU9RLEtBQUtDLEdBQUcsQ0FBQ1gsR0FBR0U7QUFDckI7QUFFQSxTQUFTVSxLQUFLWixDQUFDO0lBQ2IsT0FBT1UsS0FBS0UsSUFBSSxDQUFDWjtBQUNuQjtBQUVBLFNBQVNhO0lBQ1AsT0FBT0gs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R0EsT0FBT0YsTUFBTUUsT0FBUTtRQUN6RnVuQixNQUFNLENBQUN2bkIsS0FBSyxHQUFHeEMsU0FBUyxDQUFDd0MsS0FBSztJQUNoQztJQUVBLE9BQU9zbkIsa0JBQWtCQyxRQUFRUSxZQUFZRDtBQUMvQztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FFRCxTQUFTRztJQUNQLElBQUssSUFBSW5vQixPQUFPdEMsVUFBVUMsTUFBTSxFQUFFZ3BCLGFBQWEsSUFBSTVuQixNQUFNaUIsT0FBT0UsT0FBTyxHQUFHQSxPQUFPRixNQUFNRSxPQUFRO1FBQzdGeW1CLFVBQVUsQ0FBQ3ptQixLQUFLLEdBQUd4QyxTQUFTLENBQUN3QyxLQUFLO0lBQ3BDO0lBRUEsSUFBSW5CLE1BQU0rTCxPQUFPLENBQUM2YixVQUFVLENBQUMsRUFBRSxLQUFLQSxXQUFXaHBCLE1BQU0sS0FBSyxHQUFHO1FBQzNELElBQUlrSSxRQUFROGdCLFVBQVUsQ0FBQyxFQUFFO1FBRXpCLElBQUksT0FBTzlnQixVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJckYsY0FBYztRQUMxQjtRQUVBLElBQUk0bkIsb0JBQW9CekIsVUFBVSxDQUFDLEVBQUUsQ0FBQ3hrQixHQUFHLENBQUMsU0FBVWtDLFFBQVE7WUFDMUQsT0FBT0EsV0FBVyxNQUFNd0I7UUFDMUIsR0FBR3RELElBQUksQ0FBQztRQUNSLE9BQU87WUFDTDhsQixZQUFZRDtRQUNkO0lBQ0YsT0FBTztRQUNMLE9BQU87WUFDTEMsWUFBWTFCLFdBQVdwa0IsSUFBSSxDQUFDO1FBQzlCO0lBQ0Y7QUFDRjtBQUVBLE9BQU87QUFFdThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UvLi9ub2RlX21vZHVsZXMvcG9saXNoZWQvZGlzdC9wb2xpc2hlZC5lcy5qcz83MzM5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZCc7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgX3dyYXBOYXRpdmVTdXBlciBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS93cmFwTmF0aXZlU3VwZXInO1xuaW1wb3J0IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZSc7XG5cbmZ1bmN0aW9uIGxhc3QoKSB7XG4gIHZhciBfcmVmO1xuXG4gIHJldHVybiBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCAtIDEsIF9yZWYgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gX3JlZiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tfcmVmXTtcbn1cblxuZnVuY3Rpb24gbmVnYXRpb24oYSkge1xuICByZXR1cm4gLWE7XG59XG5cbmZ1bmN0aW9uIGFkZGl0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgKyBiO1xufVxuXG5mdW5jdGlvbiBzdWJ0cmFjdGlvbihhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGljYXRpb24oYSwgYikge1xuICByZXR1cm4gYSAqIGI7XG59XG5cbmZ1bmN0aW9uIGRpdmlzaW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgLyBiO1xufVxuXG5mdW5jdGlvbiBmYWN0b3JpYWwoYSkge1xuICBpZiAoYSAlIDEgfHwgISgrYSA+PSAwKSkgcmV0dXJuIE5hTjtcbiAgaWYgKGEgPiAxNzApIHJldHVybiBJbmZpbml0eTtlbHNlIGlmIChhID09PSAwKSByZXR1cm4gMTtlbHNlIHtcbiAgICByZXR1cm4gYSAqIGZhY3RvcmlhbChhIC0gMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG93ZXIoYSwgYikge1xuICByZXR1cm4gTWF0aC5wb3coYSwgYik7XG59XG5cbmZ1bmN0aW9uIHNxcnQoYSkge1xuICByZXR1cm4gTWF0aC5zcXJ0KGEpO1xufVxuXG5mdW5jdGlvbiBtYXgoKSB7XG4gIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBtaW4oKSB7XG4gIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBjb21tYSgpIHtcbiAgcmV0dXJuIEFycmF5Lm9mLmFwcGx5KEFycmF5LCBhcmd1bWVudHMpO1xufVxuXG52YXIgZGVmYXVsdE1hdGhTeW1ib2xzID0ge1xuICBzeW1ib2xzOiB7XG4gICAgJyEnOiB7XG4gICAgICBwb3N0Zml4OiB7XG4gICAgICAgIHN5bWJvbDogJyEnLFxuICAgICAgICBmOiBmYWN0b3JpYWwsXG4gICAgICAgIG5vdGF0aW9uOiAncG9zdGZpeCcsXG4gICAgICAgIHByZWNlZGVuY2U6IDYsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJyEnLFxuICAgICAgcmVnU3ltYm9sOiAnISdcbiAgICB9LFxuICAgICdeJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnXicsXG4gICAgICAgIGY6IHBvd2VyLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogNSxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDEsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnXicsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcXidcbiAgICB9LFxuICAgICcqJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKicsXG4gICAgICAgIGY6IG11bHRpcGxpY2F0aW9uLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogNCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKicsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKidcbiAgICB9LFxuICAgICcvJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnLycsXG4gICAgICAgIGY6IGRpdmlzaW9uLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogNCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnLycsXG4gICAgICByZWdTeW1ib2w6ICcvJ1xuICAgIH0sXG4gICAgJysnOiB7XG4gICAgICBpbmZpeDoge1xuICAgICAgICBzeW1ib2w6ICcrJyxcbiAgICAgICAgZjogYWRkaXRpb24sXG4gICAgICAgIG5vdGF0aW9uOiAnaW5maXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiAyLFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDJcbiAgICAgIH0sXG4gICAgICBwcmVmaXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKycsXG4gICAgICAgIGY6IGxhc3QsXG4gICAgICAgIG5vdGF0aW9uOiAncHJlZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMyxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAxXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKycsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKydcbiAgICB9LFxuICAgICctJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnLScsXG4gICAgICAgIGY6IHN1YnRyYWN0aW9uLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMixcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgcHJlZml4OiB7XG4gICAgICAgIHN5bWJvbDogJy0nLFxuICAgICAgICBmOiBuZWdhdGlvbixcbiAgICAgICAgbm90YXRpb246ICdwcmVmaXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiAzLFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDFcbiAgICAgIH0sXG4gICAgICBzeW1ib2w6ICctJyxcbiAgICAgIHJlZ1N5bWJvbDogJy0nXG4gICAgfSxcbiAgICAnLCc6IHtcbiAgICAgIGluZml4OiB7XG4gICAgICAgIHN5bWJvbDogJywnLFxuICAgICAgICBmOiBjb21tYSxcbiAgICAgICAgbm90YXRpb246ICdpbmZpeCcsXG4gICAgICAgIHByZWNlZGVuY2U6IDEsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMlxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJywnLFxuICAgICAgcmVnU3ltYm9sOiAnLCdcbiAgICB9LFxuICAgICcoJzoge1xuICAgICAgcHJlZml4OiB7XG4gICAgICAgIHN5bWJvbDogJygnLFxuICAgICAgICBmOiBsYXN0LFxuICAgICAgICBub3RhdGlvbjogJ3ByZWZpeCcsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJygnLFxuICAgICAgcmVnU3ltYm9sOiAnXFxcXCgnXG4gICAgfSxcbiAgICAnKSc6IHtcbiAgICAgIHBvc3RmaXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKScsXG4gICAgICAgIGY6IHVuZGVmaW5lZCxcbiAgICAgICAgbm90YXRpb246ICdwb3N0Zml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAxXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKScsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKSdcbiAgICB9LFxuICAgIG1pbjoge1xuICAgICAgZnVuYzoge1xuICAgICAgICBzeW1ib2w6ICdtaW4nLFxuICAgICAgICBmOiBtaW4sXG4gICAgICAgIG5vdGF0aW9uOiAnZnVuYycsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJ21pbicsXG4gICAgICByZWdTeW1ib2w6ICdtaW5cXFxcYidcbiAgICB9LFxuICAgIG1heDoge1xuICAgICAgZnVuYzoge1xuICAgICAgICBzeW1ib2w6ICdtYXgnLFxuICAgICAgICBmOiBtYXgsXG4gICAgICAgIG5vdGF0aW9uOiAnZnVuYycsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJ21heCcsXG4gICAgICByZWdTeW1ib2w6ICdtYXhcXFxcYidcbiAgICB9LFxuICAgIHNxcnQ6IHtcbiAgICAgIGZ1bmM6IHtcbiAgICAgICAgc3ltYm9sOiAnc3FydCcsXG4gICAgICAgIGY6IHNxcnQsXG4gICAgICAgIG5vdGF0aW9uOiAnZnVuYycsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJ3NxcnQnLFxuICAgICAgcmVnU3ltYm9sOiAnc3FydFxcXFxiJ1xuICAgIH1cbiAgfVxufTtcblxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3N0eWxlZC1jb21wb25lbnRzL3N0eWxlZC1jb21wb25lbnRzL2Jsb2IvZmNmNmYzODA0YzU3YTE0ZGQ3OTg0ZGZhYjdiYzA2ZWUyZWRjYTA0NC9zcmMvdXRpbHMvZXJyb3IuanNcblxuLyoqXG4gKiBQYXJzZSBlcnJvcnMubWQgYW5kIHR1cm4gaXQgaW50byBhIHNpbXBsZSBoYXNoIG9mIGNvZGU6IG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBFUlJPUlMgPSB7XG4gIFwiMVwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50cyB0byBoc2wsIHBsZWFzZSBwYXNzIG11bHRpcGxlIG51bWJlcnMgZS5nLiBoc2woMzYwLCAwLjc1LCAwLjQpIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IGh1ZTogMjU1LCBzYXR1cmF0aW9uOiAwLjQsIGxpZ2h0bmVzczogMC43NSB9KS5cXG5cXG5cIixcbiAgXCIyXCI6IFwiUGFzc2VkIGludmFsaWQgYXJndW1lbnRzIHRvIGhzbGEsIHBsZWFzZSBwYXNzIG11bHRpcGxlIG51bWJlcnMgZS5nLiBoc2xhKDM2MCwgMC43NSwgMC40LCAwLjcpIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IGh1ZTogMjU1LCBzYXR1cmF0aW9uOiAwLjQsIGxpZ2h0bmVzczogMC43NSwgYWxwaGE6IDAuNyB9KS5cXG5cXG5cIixcbiAgXCIzXCI6IFwiUGFzc2VkIGFuIGluY29ycmVjdCBhcmd1bWVudCB0byBhIGNvbG9yIGZ1bmN0aW9uLCBwbGVhc2UgcGFzcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxcblxcblwiLFxuICBcIjRcIjogXCJDb3VsZG4ndCBnZW5lcmF0ZSB2YWxpZCByZ2Igc3RyaW5nIGZyb20gJXMsIGl0IHJldHVybmVkICVzLlxcblxcblwiLFxuICBcIjVcIjogXCJDb3VsZG4ndCBwYXJzZSB0aGUgY29sb3Igc3RyaW5nLiBQbGVhc2UgcHJvdmlkZSB0aGUgY29sb3IgYXMgYSBzdHJpbmcgaW4gaGV4LCByZ2IsIHJnYmEsIGhzbCBvciBoc2xhIG5vdGF0aW9uLlxcblxcblwiLFxuICBcIjZcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudHMgdG8gcmdiLCBwbGVhc2UgcGFzcyBtdWx0aXBsZSBudW1iZXJzIGUuZy4gcmdiKDI1NSwgMjA1LCAxMDApIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAgfSkuXFxuXFxuXCIsXG4gIFwiN1wiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50cyB0byByZ2JhLCBwbGVhc2UgcGFzcyBtdWx0aXBsZSBudW1iZXJzIGUuZy4gcmdiKDI1NSwgMjA1LCAxMDAsIDAuNzUpIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjc1IH0pLlxcblxcblwiLFxuICBcIjhcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudCB0byB0b0NvbG9yU3RyaW5nLCBwbGVhc2UgcGFzcyBhIFJnYkNvbG9yLCBSZ2JhQ29sb3IsIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QuXFxuXFxuXCIsXG4gIFwiOVwiOiBcIlBsZWFzZSBwcm92aWRlIGEgbnVtYmVyIG9mIHN0ZXBzIHRvIHRoZSBtb2R1bGFyU2NhbGUgaGVscGVyLlxcblxcblwiLFxuICBcIjEwXCI6IFwiUGxlYXNlIHBhc3MgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBwcmVkZWZpbmVkIHNjYWxlcyB0byB0aGUgbW9kdWxhclNjYWxlIGhlbHBlciBhcyB0aGUgcmF0aW8uXFxuXFxuXCIsXG4gIFwiMTFcIjogXCJJbnZhbGlkIHZhbHVlIHBhc3NlZCBhcyBiYXNlIHRvIG1vZHVsYXJTY2FsZSwgZXhwZWN0ZWQgbnVtYmVyIG9yIGVtIHN0cmluZyBidXQgZ290IFxcXCIlc1xcXCJcXG5cXG5cIixcbiAgXCIxMlwiOiBcIkV4cGVjdGVkIGEgc3RyaW5nIGVuZGluZyBpbiBcXFwicHhcXFwiIG9yIGEgbnVtYmVyIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gJXMoKSwgZ290IFxcXCIlc1xcXCIgaW5zdGVhZC5cXG5cXG5cIixcbiAgXCIxM1wiOiBcIkV4cGVjdGVkIGEgc3RyaW5nIGVuZGluZyBpbiBcXFwicHhcXFwiIG9yIGEgbnVtYmVyIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvICVzKCksIGdvdCBcXFwiJXNcXFwiIGluc3RlYWQuXFxuXFxuXCIsXG4gIFwiMTRcIjogXCJQYXNzZWQgaW52YWxpZCBwaXhlbCB2YWx1ZSAoXFxcIiVzXFxcIikgdG8gJXMoKSwgcGxlYXNlIHBhc3MgYSB2YWx1ZSBsaWtlIFxcXCIxMnB4XFxcIiBvciAxMi5cXG5cXG5cIixcbiAgXCIxNVwiOiBcIlBhc3NlZCBpbnZhbGlkIGJhc2UgdmFsdWUgKFxcXCIlc1xcXCIpIHRvICVzKCksIHBsZWFzZSBwYXNzIGEgdmFsdWUgbGlrZSBcXFwiMTJweFxcXCIgb3IgMTIuXFxuXFxuXCIsXG4gIFwiMTZcIjogXCJZb3UgbXVzdCBwcm92aWRlIGEgdGVtcGxhdGUgdG8gdGhpcyBtZXRob2QuXFxuXFxuXCIsXG4gIFwiMTdcIjogXCJZb3UgcGFzc2VkIGFuIHVuc3VwcG9ydGVkIHNlbGVjdG9yIHN0YXRlIHRvIHRoaXMgbWV0aG9kLlxcblxcblwiLFxuICBcIjE4XCI6IFwibWluU2NyZWVuIGFuZCBtYXhTY3JlZW4gbXVzdCBiZSBwcm92aWRlZCBhcyBzdHJpbmdpZmllZCBudW1iZXJzIHdpdGggdGhlIHNhbWUgdW5pdHMuXFxuXFxuXCIsXG4gIFwiMTlcIjogXCJmcm9tU2l6ZSBhbmQgdG9TaXplIG11c3QgYmUgcHJvdmlkZWQgYXMgc3RyaW5naWZpZWQgbnVtYmVycyB3aXRoIHRoZSBzYW1lIHVuaXRzLlxcblxcblwiLFxuICBcIjIwXCI6IFwiZXhwZWN0cyBlaXRoZXIgYW4gYXJyYXkgb2Ygb2JqZWN0cyBvciBhIHNpbmdsZSBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBwcm9wLCBmcm9tU2l6ZSwgYW5kIHRvU2l6ZS5cXG5cXG5cIixcbiAgXCIyMVwiOiBcImV4cGVjdHMgdGhlIG9iamVjdHMgaW4gdGhlIGZpcnN0IGFyZ3VtZW50IGFycmF5IHRvIGhhdmUgdGhlIHByb3BlcnRpZXMgYHByb3BgLCBgZnJvbVNpemVgLCBhbmQgYHRvU2l6ZWAuXFxuXFxuXCIsXG4gIFwiMjJcIjogXCJleHBlY3RzIHRoZSBmaXJzdCBhcmd1bWVudCBvYmplY3QgdG8gaGF2ZSB0aGUgcHJvcGVydGllcyBgcHJvcGAsIGBmcm9tU2l6ZWAsIGFuZCBgdG9TaXplYC5cXG5cXG5cIixcbiAgXCIyM1wiOiBcImZvbnRGYWNlIGV4cGVjdHMgYSBuYW1lIG9mIGEgZm9udC1mYW1pbHkuXFxuXFxuXCIsXG4gIFwiMjRcIjogXCJmb250RmFjZSBleHBlY3RzIGVpdGhlciB0aGUgcGF0aCB0byB0aGUgZm9udCBmaWxlKHMpIG9yIGEgbmFtZSBvZiBhIGxvY2FsIGNvcHkuXFxuXFxuXCIsXG4gIFwiMjVcIjogXCJmb250RmFjZSBleHBlY3RzIGxvY2FsRm9udHMgdG8gYmUgYW4gYXJyYXkuXFxuXFxuXCIsXG4gIFwiMjZcIjogXCJmb250RmFjZSBleHBlY3RzIGZpbGVGb3JtYXRzIHRvIGJlIGFuIGFycmF5LlxcblxcblwiLFxuICBcIjI3XCI6IFwicmFkaWFsR3JhZGllbnQgcmVxdXJpZXMgYXQgbGVhc3QgMiBjb2xvci1zdG9wcyB0byBwcm9wZXJseSByZW5kZXIuXFxuXFxuXCIsXG4gIFwiMjhcIjogXCJQbGVhc2Ugc3VwcGx5IGEgZmlsZW5hbWUgdG8gcmV0aW5hSW1hZ2UoKSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiMjlcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudCB0byB0cmlhbmdsZSwgcGxlYXNlIHBhc3MgY29ycmVjdCBwb2ludGluZ0RpcmVjdGlvbiBlLmcuICdyaWdodCcuXFxuXFxuXCIsXG4gIFwiMzBcIjogXCJQYXNzZWQgYW4gaW52YWxpZCB2YWx1ZSB0byBgaGVpZ2h0YCBvciBgd2lkdGhgLiBQbGVhc2UgcHJvdmlkZSBhIHBpeGVsIGJhc2VkIHVuaXQuXFxuXFxuXCIsXG4gIFwiMzFcIjogXCJUaGUgYW5pbWF0aW9uIHNob3J0aGFuZCBvbmx5IHRha2VzIDggYXJndW1lbnRzLiBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9tZG4uaW8vYW5pbWF0aW9uXFxuXFxuXCIsXG4gIFwiMzJcIjogXCJUbyBwYXNzIG11bHRpcGxlIGFuaW1hdGlvbnMgcGxlYXNlIHN1cHBseSB0aGVtIGluIGFycmF5cywgZS5nLiBhbmltYXRpb24oWydyb3RhdGUnLCAnMnMnXSwgWydtb3ZlJywgJzFzJ10pXFxuVG8gcGFzcyBhIHNpbmdsZSBhbmltYXRpb24gcGxlYXNlIHN1cHBseSB0aGVtIGluIHNpbXBsZSB2YWx1ZXMsIGUuZy4gYW5pbWF0aW9uKCdyb3RhdGUnLCAnMnMnKVxcblxcblwiLFxuICBcIjMzXCI6IFwiVGhlIGFuaW1hdGlvbiBzaG9ydGhhbmQgYXJyYXlzIGNhbiBvbmx5IGhhdmUgOCBlbGVtZW50cy4gU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwOi8vbWRuLmlvL2FuaW1hdGlvblxcblxcblwiLFxuICBcIjM0XCI6IFwiYm9yZGVyUmFkaXVzIGV4cGVjdHMgYSByYWRpdXMgdmFsdWUgYXMgYSBzdHJpbmcgb3IgbnVtYmVyIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiMzVcIjogXCJib3JkZXJSYWRpdXMgZXhwZWN0cyBvbmUgb2YgXFxcInRvcFxcXCIsIFxcXCJib3R0b21cXFwiLCBcXFwibGVmdFxcXCIgb3IgXFxcInJpZ2h0XFxcIiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiMzZcIjogXCJQcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nIHZhbHVlLlxcblxcblwiLFxuICBcIjM3XCI6IFwiU3ludGF4IEVycm9yIGF0ICVzLlxcblxcblwiLFxuICBcIjM4XCI6IFwiRm9ybXVsYSBjb250YWlucyBhIGZ1bmN0aW9uIHRoYXQgbmVlZHMgcGFyZW50aGVzZXMgYXQgJXMuXFxuXFxuXCIsXG4gIFwiMzlcIjogXCJGb3JtdWxhIGlzIG1pc3NpbmcgY2xvc2luZyBwYXJlbnRoZXNpcyBhdCAlcy5cXG5cXG5cIixcbiAgXCI0MFwiOiBcIkZvcm11bGEgaGFzIHRvbyBtYW55IGNsb3NpbmcgcGFyZW50aGVzZXMgYXQgJXMuXFxuXFxuXCIsXG4gIFwiNDFcIjogXCJBbGwgdmFsdWVzIGluIGEgZm9ybXVsYSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdCBvciBiZSB1bml0bGVzcy5cXG5cXG5cIixcbiAgXCI0MlwiOiBcIlBsZWFzZSBwcm92aWRlIGEgbnVtYmVyIG9mIHN0ZXBzIHRvIHRoZSBtb2R1bGFyU2NhbGUgaGVscGVyLlxcblxcblwiLFxuICBcIjQzXCI6IFwiUGxlYXNlIHBhc3MgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBwcmVkZWZpbmVkIHNjYWxlcyB0byB0aGUgbW9kdWxhclNjYWxlIGhlbHBlciBhcyB0aGUgcmF0aW8uXFxuXFxuXCIsXG4gIFwiNDRcIjogXCJJbnZhbGlkIHZhbHVlIHBhc3NlZCBhcyBiYXNlIHRvIG1vZHVsYXJTY2FsZSwgZXhwZWN0ZWQgbnVtYmVyIG9yIGVtL3JlbSBzdHJpbmcgYnV0IGdvdCAlcy5cXG5cXG5cIixcbiAgXCI0NVwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIGhzbFRvQ29sb3JTdHJpbmcsIHBsZWFzZSBwYXNzIGEgSHNsQ29sb3Igb3IgSHNsYUNvbG9yIG9iamVjdC5cXG5cXG5cIixcbiAgXCI0NlwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIHJnYlRvQ29sb3JTdHJpbmcsIHBsZWFzZSBwYXNzIGEgUmdiQ29sb3Igb3IgUmdiYUNvbG9yIG9iamVjdC5cXG5cXG5cIixcbiAgXCI0N1wiOiBcIm1pblNjcmVlbiBhbmQgbWF4U2NyZWVuIG11c3QgYmUgcHJvdmlkZWQgYXMgc3RyaW5naWZpZWQgbnVtYmVycyB3aXRoIHRoZSBzYW1lIHVuaXRzLlxcblxcblwiLFxuICBcIjQ4XCI6IFwiZnJvbVNpemUgYW5kIHRvU2l6ZSBtdXN0IGJlIHByb3ZpZGVkIGFzIHN0cmluZ2lmaWVkIG51bWJlcnMgd2l0aCB0aGUgc2FtZSB1bml0cy5cXG5cXG5cIixcbiAgXCI0OVwiOiBcIkV4cGVjdHMgZWl0aGVyIGFuIGFycmF5IG9mIG9iamVjdHMgb3IgYSBzaW5nbGUgb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgcHJvcCwgZnJvbVNpemUsIGFuZCB0b1NpemUuXFxuXFxuXCIsXG4gIFwiNTBcIjogXCJFeHBlY3RzIHRoZSBvYmplY3RzIGluIHRoZSBmaXJzdCBhcmd1bWVudCBhcnJheSB0byBoYXZlIHRoZSBwcm9wZXJ0aWVzIHByb3AsIGZyb21TaXplLCBhbmQgdG9TaXplLlxcblxcblwiLFxuICBcIjUxXCI6IFwiRXhwZWN0cyB0aGUgZmlyc3QgYXJndW1lbnQgb2JqZWN0IHRvIGhhdmUgdGhlIHByb3BlcnRpZXMgcHJvcCwgZnJvbVNpemUsIGFuZCB0b1NpemUuXFxuXFxuXCIsXG4gIFwiNTJcIjogXCJmb250RmFjZSBleHBlY3RzIGVpdGhlciB0aGUgcGF0aCB0byB0aGUgZm9udCBmaWxlKHMpIG9yIGEgbmFtZSBvZiBhIGxvY2FsIGNvcHkuXFxuXFxuXCIsXG4gIFwiNTNcIjogXCJmb250RmFjZSBleHBlY3RzIGxvY2FsRm9udHMgdG8gYmUgYW4gYXJyYXkuXFxuXFxuXCIsXG4gIFwiNTRcIjogXCJmb250RmFjZSBleHBlY3RzIGZpbGVGb3JtYXRzIHRvIGJlIGFuIGFycmF5LlxcblxcblwiLFxuICBcIjU1XCI6IFwiZm9udEZhY2UgZXhwZWN0cyBhIG5hbWUgb2YgYSBmb250LWZhbWlseS5cXG5cXG5cIixcbiAgXCI1NlwiOiBcImxpbmVhckdyYWRpZW50IHJlcXVyaWVzIGF0IGxlYXN0IDIgY29sb3Itc3RvcHMgdG8gcHJvcGVybHkgcmVuZGVyLlxcblxcblwiLFxuICBcIjU3XCI6IFwicmFkaWFsR3JhZGllbnQgcmVxdXJpZXMgYXQgbGVhc3QgMiBjb2xvci1zdG9wcyB0byBwcm9wZXJseSByZW5kZXIuXFxuXFxuXCIsXG4gIFwiNThcIjogXCJQbGVhc2Ugc3VwcGx5IGEgZmlsZW5hbWUgdG8gcmV0aW5hSW1hZ2UoKSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiNTlcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudCB0byB0cmlhbmdsZSwgcGxlYXNlIHBhc3MgY29ycmVjdCBwb2ludGluZ0RpcmVjdGlvbiBlLmcuICdyaWdodCcuXFxuXFxuXCIsXG4gIFwiNjBcIjogXCJQYXNzZWQgYW4gaW52YWxpZCB2YWx1ZSB0byBgaGVpZ2h0YCBvciBgd2lkdGhgLiBQbGVhc2UgcHJvdmlkZSBhIHBpeGVsIGJhc2VkIHVuaXQuXFxuXFxuXCIsXG4gIFwiNjFcIjogXCJQcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nIHZhbHVlLlxcblxcblwiLFxuICBcIjYyXCI6IFwiYm9yZGVyUmFkaXVzIGV4cGVjdHMgYSByYWRpdXMgdmFsdWUgYXMgYSBzdHJpbmcgb3IgbnVtYmVyIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiNjNcIjogXCJib3JkZXJSYWRpdXMgZXhwZWN0cyBvbmUgb2YgXFxcInRvcFxcXCIsIFxcXCJib3R0b21cXFwiLCBcXFwibGVmdFxcXCIgb3IgXFxcInJpZ2h0XFxcIiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiNjRcIjogXCJUaGUgYW5pbWF0aW9uIHNob3J0aGFuZCBvbmx5IHRha2VzIDggYXJndW1lbnRzLiBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9tZG4uaW8vYW5pbWF0aW9uLlxcblxcblwiLFxuICBcIjY1XCI6IFwiVG8gcGFzcyBtdWx0aXBsZSBhbmltYXRpb25zIHBsZWFzZSBzdXBwbHkgdGhlbSBpbiBhcnJheXMsIGUuZy4gYW5pbWF0aW9uKFsncm90YXRlJywgJzJzJ10sIFsnbW92ZScsICcxcyddKVxcXFxuVG8gcGFzcyBhIHNpbmdsZSBhbmltYXRpb24gcGxlYXNlIHN1cHBseSB0aGVtIGluIHNpbXBsZSB2YWx1ZXMsIGUuZy4gYW5pbWF0aW9uKCdyb3RhdGUnLCAnMnMnKS5cXG5cXG5cIixcbiAgXCI2NlwiOiBcIlRoZSBhbmltYXRpb24gc2hvcnRoYW5kIGFycmF5cyBjYW4gb25seSBoYXZlIDggZWxlbWVudHMuIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cDovL21kbi5pby9hbmltYXRpb24uXFxuXFxuXCIsXG4gIFwiNjdcIjogXCJZb3UgbXVzdCBwcm92aWRlIGEgdGVtcGxhdGUgdG8gdGhpcyBtZXRob2QuXFxuXFxuXCIsXG4gIFwiNjhcIjogXCJZb3UgcGFzc2VkIGFuIHVuc3VwcG9ydGVkIHNlbGVjdG9yIHN0YXRlIHRvIHRoaXMgbWV0aG9kLlxcblxcblwiLFxuICBcIjY5XCI6IFwiRXhwZWN0ZWQgYSBzdHJpbmcgZW5kaW5nIGluIFxcXCJweFxcXCIgb3IgYSBudW1iZXIgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byAlcygpLCBnb3QgJXMgaW5zdGVhZC5cXG5cXG5cIixcbiAgXCI3MFwiOiBcIkV4cGVjdGVkIGEgc3RyaW5nIGVuZGluZyBpbiBcXFwicHhcXFwiIG9yIGEgbnVtYmVyIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvICVzKCksIGdvdCAlcyBpbnN0ZWFkLlxcblxcblwiLFxuICBcIjcxXCI6IFwiUGFzc2VkIGludmFsaWQgcGl4ZWwgdmFsdWUgJXMgdG8gJXMoKSwgcGxlYXNlIHBhc3MgYSB2YWx1ZSBsaWtlIFxcXCIxMnB4XFxcIiBvciAxMi5cXG5cXG5cIixcbiAgXCI3MlwiOiBcIlBhc3NlZCBpbnZhbGlkIGJhc2UgdmFsdWUgJXMgdG8gJXMoKSwgcGxlYXNlIHBhc3MgYSB2YWx1ZSBsaWtlIFxcXCIxMnB4XFxcIiBvciAxMi5cXG5cIlxufTtcbi8qKlxuICogc3VwZXIgYmFzaWMgdmVyc2lvbiBvZiBzcHJpbnRmXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdCgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBhID0gYXJnc1swXTtcbiAgdmFyIGIgPSBbXTtcbiAgdmFyIGM7XG5cbiAgZm9yIChjID0gMTsgYyA8IGFyZ3MubGVuZ3RoOyBjICs9IDEpIHtcbiAgICBiLnB1c2goYXJnc1tjXSk7XG4gIH1cblxuICBiLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBhID0gYS5yZXBsYWNlKC8lW2Etel0vLCBkKTtcbiAgfSk7XG4gIHJldHVybiBhO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gZXJyb3IgZmlsZSBvdXQgb2YgZXJyb3JzLm1kIGZvciBkZXZlbG9wbWVudCBhbmQgYSBzaW1wbGUgd2ViIGxpbmsgdG8gdGhlIGZ1bGwgZXJyb3JzXG4gKiBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIFBvbGlzaGVkRXJyb3IgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShQb2xpc2hlZEVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFBvbGlzaGVkRXJyb3IoY29kZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBfdGhpcyA9IF9FcnJvci5jYWxsKHRoaXMsIFwiQW4gZXJyb3Igb2NjdXJyZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3R5bGVkLWNvbXBvbmVudHMvcG9saXNoZWQvYmxvYi9tYXN0ZXIvc3JjL2Vycm9yL2Vycm9ycy5tZCNcIiArIGNvZGUgKyBcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIikgfHwgdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMgPSBfRXJyb3IuY2FsbCh0aGlzLCBmb3JtYXQuYXBwbHkodm9pZCAwLCBbRVJST1JTW2NvZGVdXS5jb25jYXQoYXJncykpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgfVxuXG4gIHJldHVybiBQb2xpc2hlZEVycm9yO1xufShcbi8qI19fUFVSRV9fKi9cbl93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxudmFyIHVuaXRSZWdFeHAgPSAvKCg/IVxcdylhfG5hfGhjfG1jfGRnfG1lW3JdP3x4ZXxuaSg/IVthLXpBLVpdKXxtbXxjcHx0cHx4cHxxKD8hcyl8aHZ8eGFtdnxuaW12fHd2fHNtfHMoPyFcXER8JCl8Z2VkfGRhcmc/fG5ydXQpL2c7IC8vIE1lcmdlcyBhZGRpdGlvbmFsIG1hdGggZnVuY3Rpb25hbGl0eSBpbnRvIHRoZSBkZWZhdWx0cy5cblxuZnVuY3Rpb24gbWVyZ2VTeW1ib2xNYXBzKGFkZGl0aW9uYWxTeW1ib2xzKSB7XG4gIHZhciBzeW1ib2xNYXAgPSB7fTtcbiAgc3ltYm9sTWFwLnN5bWJvbHMgPSBhZGRpdGlvbmFsU3ltYm9scyA/IF9leHRlbmRzKHt9LCBkZWZhdWx0TWF0aFN5bWJvbHMuc3ltYm9scywgYWRkaXRpb25hbFN5bWJvbHMuc3ltYm9scykgOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdE1hdGhTeW1ib2xzLnN5bWJvbHMpO1xuICByZXR1cm4gc3ltYm9sTWFwO1xufVxuXG5mdW5jdGlvbiBleGVjKG9wZXJhdG9ycywgdmFsdWVzKSB7XG4gIHZhciBfcmVmO1xuXG4gIHZhciBvcCA9IG9wZXJhdG9ycy5wb3AoKTtcbiAgdmFsdWVzLnB1c2gob3AuZi5hcHBseShvcCwgKF9yZWYgPSBbXSkuY29uY2F0LmFwcGx5KF9yZWYsIHZhbHVlcy5zcGxpY2UoLW9wLmFyZ0NvdW50KSkpKTtcbiAgcmV0dXJuIG9wLnByZWNlZGVuY2U7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZShleHByZXNzaW9uLCBhZGRpdGlvbmFsU3ltYm9scykge1xuICB2YXIgc3ltYm9sTWFwID0gbWVyZ2VTeW1ib2xNYXBzKGFkZGl0aW9uYWxTeW1ib2xzKTtcbiAgdmFyIG1hdGNoO1xuICB2YXIgb3BlcmF0b3JzID0gW3N5bWJvbE1hcC5zeW1ib2xzWycoJ10ucHJlZml4XTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgcGF0dGVybiA9IG5ldyBSZWdFeHAoIC8vIFBhdHRlcm4gZm9yIG51bWJlcnNcbiAgXCJcXFxcZCsoPzpcXFxcLlxcXFxkKyk/fFwiICsgLy8gLi4uYW5kIHBhdHRlcm5zIGZvciBpbmRpdmlkdWFsIG9wZXJhdG9ycy9mdW5jdGlvbiBuYW1lc1xuICBPYmplY3Qua2V5cyhzeW1ib2xNYXAuc3ltYm9scykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gc3ltYm9sTWFwLnN5bWJvbHNba2V5XTtcbiAgfSkgLy8gbG9uZ2VyIHN5bWJvbHMgc2hvdWxkIGJlIGxpc3RlZCBmaXJzdFxuICAvLyAkRmxvd0ZpeE1lXG4gIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuc3ltYm9sLmxlbmd0aCAtIGEuc3ltYm9sLmxlbmd0aDtcbiAgfSkgLy8gJEZsb3dGaXhNZVxuICAubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsLnJlZ1N5bWJvbDtcbiAgfSkuam9pbignfCcpICsgXCJ8KFxcXFxTKVwiLCAnZycpO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7IC8vIFJlc2V0IHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3RcblxuICB2YXIgYWZ0ZXJWYWx1ZSA9IGZhbHNlO1xuXG4gIGRvIHtcbiAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhleHByZXNzaW9uKTtcblxuICAgIHZhciBfcmVmMiA9IG1hdGNoIHx8IFsnKScsIHVuZGVmaW5lZF0sXG4gICAgICAgIHRva2VuID0gX3JlZjJbMF0sXG4gICAgICAgIGJhZCA9IF9yZWYyWzFdO1xuXG4gICAgdmFyIG5vdE51bWJlciA9IHN5bWJvbE1hcC5zeW1ib2xzW3Rva2VuXTtcbiAgICB2YXIgbm90TmV3VmFsdWUgPSBub3ROdW1iZXIgJiYgIW5vdE51bWJlci5wcmVmaXggJiYgIW5vdE51bWJlci5mdW5jO1xuICAgIHZhciBub3RBZnRlclZhbHVlID0gIW5vdE51bWJlciB8fCAhbm90TnVtYmVyLnBvc3RmaXggJiYgIW5vdE51bWJlci5pbmZpeDsgLy8gQ2hlY2sgZm9yIHN5bnRheCBlcnJvcnM6XG5cbiAgICBpZiAoYmFkIHx8IChhZnRlclZhbHVlID8gbm90QWZ0ZXJWYWx1ZSA6IG5vdE5ld1ZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoMzcsIG1hdGNoID8gbWF0Y2guaW5kZXggOiBleHByZXNzaW9uLmxlbmd0aCwgZXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgaWYgKGFmdGVyVmFsdWUpIHtcbiAgICAgIC8vIFdlIGVpdGhlciBoYXZlIGFuIGluZml4IG9yIHBvc3RmaXggb3BlcmF0b3IgKHRoZXkgc2hvdWxkIGJlIG11dHVhbGx5IGV4Y2x1c2l2ZSlcbiAgICAgIHZhciBjdXJyID0gbm90TnVtYmVyLnBvc3RmaXggfHwgbm90TnVtYmVyLmluZml4O1xuXG4gICAgICBkbyB7XG4gICAgICAgIHZhciBwcmV2ID0gb3BlcmF0b3JzW29wZXJhdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKChjdXJyLnByZWNlZGVuY2UgLSBwcmV2LnByZWNlZGVuY2UgfHwgcHJldi5yaWdodFRvTGVmdCkgPiAwKSBicmVhazsgLy8gQXBwbHkgcHJldmlvdXMgb3BlcmF0b3IsIHNpbmNlIGl0IGhhcyBwcmVjZWRlbmNlIG92ZXIgY3VycmVudCBvbmVcbiAgICAgIH0gd2hpbGUgKGV4ZWMob3BlcmF0b3JzLCB2YWx1ZXMpKTsgLy8gRXhpdCBsb29wIGFmdGVyIGV4ZWN1dGluZyBhbiBvcGVuaW5nIHBhcmVudGhlc2lzIG9yIGZ1bmN0aW9uXG5cblxuICAgICAgYWZ0ZXJWYWx1ZSA9IGN1cnIubm90YXRpb24gPT09ICdwb3N0Zml4JztcblxuICAgICAgaWYgKGN1cnIuc3ltYm9sICE9PSAnKScpIHtcbiAgICAgICAgb3BlcmF0b3JzLnB1c2goY3Vycik7IC8vIFBvc3RmaXggYWx3YXlzIGhhcyBwcmVjZWRlbmNlIG92ZXIgYW55IG9wZXJhdG9yIHRoYXQgZm9sbG93cyBhZnRlciBpdFxuXG4gICAgICAgIGlmIChhZnRlclZhbHVlKSBleGVjKG9wZXJhdG9ycywgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vdE51bWJlcikge1xuICAgICAgLy8gcHJlZml4IG9wZXJhdG9yIG9yIGZ1bmN0aW9uXG4gICAgICBvcGVyYXRvcnMucHVzaChub3ROdW1iZXIucHJlZml4IHx8IG5vdE51bWJlci5mdW5jKTtcblxuICAgICAgaWYgKG5vdE51bWJlci5mdW5jKSB7XG4gICAgICAgIC8vIFJlcXVpcmUgYW4gb3BlbmluZyBwYXJlbnRoZXNpc1xuICAgICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhleHByZXNzaW9uKTtcblxuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoWzBdICE9PSAnKCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcigzOCwgbWF0Y2ggPyBtYXRjaC5pbmRleCA6IGV4cHJlc3Npb24ubGVuZ3RoLCBleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBudW1iZXJcbiAgICAgIHZhbHVlcy5wdXNoKCt0b2tlbik7XG4gICAgICBhZnRlclZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0gd2hpbGUgKG1hdGNoICYmIG9wZXJhdG9ycy5sZW5ndGgpO1xuXG4gIGlmIChvcGVyYXRvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoMzksIG1hdGNoID8gbWF0Y2guaW5kZXggOiBleHByZXNzaW9uLmxlbmd0aCwgZXhwcmVzc2lvbik7XG4gIH0gZWxzZSBpZiAobWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0MCwgbWF0Y2ggPyBtYXRjaC5pbmRleCA6IGV4cHJlc3Npb24ubGVuZ3RoLCBleHByZXNzaW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWVzLnBvcCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbn1cbi8qKlxuICogSGVscGVyIGZvciBkb2luZyBtYXRoIHdpdGggQ1NTIFVuaXRzLiBBY2NlcHRzIGEgZm9ybXVsYSBhcyBhIHN0cmluZy4gQWxsIHZhbHVlcyBpbiB0aGUgZm9ybXVsYSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdCAob3IgYmUgdW5pdGxlc3MpLiBTdXBwb3J0cyBjb21wbGV4IGZvcm11bGFzIHV0bGl6aWluZyBhZGRpdGlvbiwgc3VidHJhY3Rpb24sIG11bHRpcGxpY2F0aW9uLCBkaXZpc2lvbiwgc3F1YXJlIHJvb3QsIHBvd2VycywgZmFjdG9yaWFsLCBtaW4sIG1heCwgYXMgd2VsbCBhcyBwYXJlbnRoZXNlcyBmb3Igb3JkZXIgb2Ygb3BlcmF0aW9uLlxuICpcbiAqSW4gY2FzZXMgd2hlcmUgeW91IG5lZWQgdG8gZG8gY2FsY3VsYXRpb25zIHdpdGggbWl4ZWQgdW5pdHMgd2hlcmUgb25lIHVuaXQgaXMgYSBbcmVsYXRpdmUgbGVuZ3RoIHVuaXRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9sZW5ndGgjUmVsYXRpdmVfbGVuZ3RoX3VuaXRzKSwgeW91IHdpbGwgd2FudCB0byB1c2UgW0NTUyBDYWxjXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY2FsYykuXG4gKlxuICogKndhcm5pbmcqIFdoaWxlIHdlJ3ZlIGRvbmUgZXZlcnl0aGluZyBwb3NzaWJsZSB0byBlbnN1cmUgbWF0aCBzYWZlbHkgZXZhbHV0ZXMgZm9ybXVsYXMgZXhwcmVzc2VkIGFzIHN0cmluZ3MsIHlvdSBzaG91bGQgYWx3YXlzIHVzZSBleHRyZW1lIGNhdXRpb24gd2hlbiBwYXNzaW5nIGBtYXRoYCB1c2VyIHByb3ZpZGVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGZvbnRTaXplOiBtYXRoKCcxMnJlbSArIDhyZW0nKSxcbiAqICAgZm9udFNpemU6IG1hdGgoJygxMnB4ICsgMnB4KSAqIDMnKSxcbiAqICAgZm9udFNpemU6IG1hdGgoJzNweF4yICsgc3FydCg0KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBmb250U2l6ZTogJHttYXRoKCcxMnJlbSArIDhyZW0nKX07XG4gKiAgIGZvbnRTaXplOiAke21hdGgoJygxMnB4ICsgMnB4KSAqIDMnKX07XG4gKiAgIGZvbnRTaXplOiAke21hdGgoJzNweF4yICsgc3FydCg0KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgIGZvbnRTaXplOiAnMjByZW0nLFxuICogICBmb250U2l6ZTogJzQycHgnLFxuICogICBmb250U2l6ZTogJzExcHgnLFxuICogfVxuICovXG5cblxuZnVuY3Rpb24gbWF0aChmb3JtdWxhLCBhZGRpdGlvbmFsU3ltYm9scykge1xuICB2YXIgcmV2ZXJzZWRGb3JtdWxhID0gcmV2ZXJzZVN0cmluZyhmb3JtdWxhKTtcbiAgdmFyIGZvcm11bGFNYXRjaCA9IHJldmVyc2VkRm9ybXVsYS5tYXRjaCh1bml0UmVnRXhwKTsgLy8gQ2hlY2sgdGhhdCBhbGwgdW5pdHMgYXJlIHRoZSBzYW1lXG5cbiAgaWYgKGZvcm11bGFNYXRjaCAmJiAhZm9ybXVsYU1hdGNoLmV2ZXJ5KGZ1bmN0aW9uICh1bml0KSB7XG4gICAgcmV0dXJuIHVuaXQgPT09IGZvcm11bGFNYXRjaFswXTtcbiAgfSkpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0MSk7XG4gIH1cblxuICB2YXIgY2xlYW5Gb3JtdWxhID0gcmV2ZXJzZVN0cmluZyhyZXZlcnNlZEZvcm11bGEucmVwbGFjZSh1bml0UmVnRXhwLCAnJykpO1xuICByZXR1cm4gXCJcIiArIGNhbGN1bGF0ZShjbGVhbkZvcm11bGEsIGFkZGl0aW9uYWxTeW1ib2xzKSArIChmb3JtdWxhTWF0Y2ggPyByZXZlcnNlU3RyaW5nKGZvcm11bGFNYXRjaFswXSkgOiAnJyk7XG59XG5cbi8vIEBwcml2YXRlXG5mdW5jdGlvbiBjYXBpdGFsaXplU3RyaW5nKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG52YXIgcG9zaXRpb25NYXAgPSBbJ1RvcCcsICdSaWdodCcsICdCb3R0b20nLCAnTGVmdCddO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVByb3BlcnR5KHByb3BlcnR5LCBwb3NpdGlvbikge1xuICBpZiAoIXByb3BlcnR5KSByZXR1cm4gcG9zaXRpb24udG9Mb3dlckNhc2UoKTtcbiAgdmFyIHNwbGl0UHJvcGVydHkgPSBwcm9wZXJ0eS5zcGxpdCgnLScpO1xuXG4gIGlmIChzcGxpdFByb3BlcnR5Lmxlbmd0aCA+IDEpIHtcbiAgICBzcGxpdFByb3BlcnR5LnNwbGljZSgxLCAwLCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIHNwbGl0UHJvcGVydHkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBhY2MgKyBjYXBpdGFsaXplU3RyaW5nKHZhbCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgam9pbmVkUHJvcGVydHkgPSBwcm9wZXJ0eS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxXCIgKyBwb3NpdGlvbiArIFwiJDJcIik7XG4gIHJldHVybiBwcm9wZXJ0eSA9PT0gam9pbmVkUHJvcGVydHkgPyBcIlwiICsgcHJvcGVydHkgKyBwb3NpdGlvbiA6IGpvaW5lZFByb3BlcnR5O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVN0eWxlcyhwcm9wZXJ0eSwgdmFsdWVzV2l0aERlZmF1bHRzKSB7XG4gIHZhciBzdHlsZXMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlc1dpdGhEZWZhdWx0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmICh2YWx1ZXNXaXRoRGVmYXVsdHNbaV0gfHwgdmFsdWVzV2l0aERlZmF1bHRzW2ldID09PSAwKSB7XG4gICAgICBzdHlsZXNbZ2VuZXJhdGVQcm9wZXJ0eShwcm9wZXJ0eSwgcG9zaXRpb25NYXBbaV0pXSA9IHZhbHVlc1dpdGhEZWZhdWx0c1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGVzO1xufVxuLyoqXG4gKiBFbmFibGVzIHNob3J0aGFuZCBmb3IgZGlyZWN0aW9uLWJhc2VkIHByb3BlcnRpZXMuIEl0IGFjY2VwdHMgYSBwcm9wZXJ0eSAoaHlwaGVuYXRlZCBvciBjYW1lbENhc2VkKSBhbmQgdXAgdG8gZm91ciB2YWx1ZXMgdGhhdCBtYXAgdG8gdG9wLCByaWdodCwgYm90dG9tLCBhbmQgbGVmdCwgcmVzcGVjdGl2ZWx5LiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhbiBlbXB0eSBzdHJpbmcgdG8gZ2V0IG9ubHkgdGhlIGRpcmVjdGlvbmFsIHZhbHVlcyBhcyBwcm9wZXJ0aWVzLiBZb3UgY2FuIGFsc28gb3B0aW9uYWxseSBwYXNzIGEgbnVsbCBhcmd1bWVudCBmb3IgYSBkaXJlY3Rpb25hbCB2YWx1ZSB0byBpZ25vcmUgaXQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5kaXJlY3Rpb25hbFByb3BlcnR5KCdwYWRkaW5nJywgJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2RpcmVjdGlvbmFsUHJvcGVydHkoJ3BhZGRpbmcnLCAnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAncGFkZGluZ1RvcCc6ICcxMnB4JyxcbiAqICAgJ3BhZGRpbmdSaWdodCc6ICcyNHB4JyxcbiAqICAgJ3BhZGRpbmdCb3R0b20nOiAnMzZweCcsXG4gKiAgICdwYWRkaW5nTGVmdCc6ICc0OHB4J1xuICogfVxuICovXG5cblxuZnVuY3Rpb24gZGlyZWN0aW9uYWxQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgLy8gIHByZXR0aWVyLWlnbm9yZVxuICB2YXIgZmlyc3RWYWx1ZSA9IHZhbHVlc1swXSxcbiAgICAgIF92YWx1ZXMkID0gdmFsdWVzWzFdLFxuICAgICAgc2Vjb25kVmFsdWUgPSBfdmFsdWVzJCA9PT0gdm9pZCAwID8gZmlyc3RWYWx1ZSA6IF92YWx1ZXMkLFxuICAgICAgX3ZhbHVlcyQyID0gdmFsdWVzWzJdLFxuICAgICAgdGhpcmRWYWx1ZSA9IF92YWx1ZXMkMiA9PT0gdm9pZCAwID8gZmlyc3RWYWx1ZSA6IF92YWx1ZXMkMixcbiAgICAgIF92YWx1ZXMkMyA9IHZhbHVlc1szXSxcbiAgICAgIGZvdXJ0aFZhbHVlID0gX3ZhbHVlcyQzID09PSB2b2lkIDAgPyBzZWNvbmRWYWx1ZSA6IF92YWx1ZXMkMztcbiAgdmFyIHZhbHVlc1dpdGhEZWZhdWx0cyA9IFtmaXJzdFZhbHVlLCBzZWNvbmRWYWx1ZSwgdGhpcmRWYWx1ZSwgZm91cnRoVmFsdWVdO1xuICByZXR1cm4gZ2VuZXJhdGVTdHlsZXMocHJvcGVydHksIHZhbHVlc1dpdGhEZWZhdWx0cyk7XG59XG5cbmZ1bmN0aW9uIGVuZHNXaXRoIChzdHJpbmcsIHN1ZmZpeCkge1xuICByZXR1cm4gc3RyaW5nLnN1YnN0cigtc3VmZml4Lmxlbmd0aCkgPT09IHN1ZmZpeDtcbn1cblxudmFyIGNzc1JlZ2V4ID0gL14oWystXT8oPzpcXGQrfFxcZCpcXC5cXGQrKSkoW2Etel0qfCUpJC87XG4vKipcbiAqIFJldHVybnMgYSBnaXZlbiBDU1MgdmFsdWUgbWludXMgaXRzIHVuaXQgKG9yIHRoZSBvcmlnaW5hbCB2YWx1ZSBpZiBhbiBpbnZhbGlkIHN0cmluZyBpcyBwYXNzZWQpLiBPcHRpb25hbGx5IHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgc3RyaXBwZWQgdmFsdWUgYW5kIHRoZSBvcmlnaW5hbCB1bml0IG9mIG1lYXN1cmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJy0tZGltZW5zaW9uJzogc3RyaXBVbml0KCcxMDBweCcpLFxuICogICAnLS11bml0Jzogc3RyaXBVbml0KCcxMDBweCcpWzFdLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAtLWRpbWVuc2lvbjogJHtzdHJpcFVuaXQoJzEwMHB4Jyl9O1xuICogICAtLXVuaXQ6ICR7c3RyaXBVbml0KCcxMDBweCcpWzFdfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICctLWRpbWVuc2lvbic6IDEwMCxcbiAqICAgJy0tdW5pdCc6ICdweCcsXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gc3RyaXBVbml0KHZhbHVlLCB1bml0UmV0dXJuKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm4gdW5pdFJldHVybiA/IFt2YWx1ZSwgdW5kZWZpbmVkXSA6IHZhbHVlO1xuICB2YXIgbWF0Y2hlZFZhbHVlID0gdmFsdWUubWF0Y2goY3NzUmVnZXgpO1xuXG4gIGlmICh1bml0UmV0dXJuKSB7XG4gICAgaWYgKG1hdGNoZWRWYWx1ZSkgcmV0dXJuIFtwYXJzZUZsb2F0KHZhbHVlKSwgbWF0Y2hlZFZhbHVlWzJdXTtcbiAgICByZXR1cm4gW3ZhbHVlLCB1bmRlZmluZWRdO1xuICB9XG5cbiAgaWYgKG1hdGNoZWRWYWx1ZSkgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgcGl4ZWwtdG8teCBjb252ZXJ0ZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBweHRvRmFjdG9yeSA9IGZ1bmN0aW9uIHB4dG9GYWN0b3J5KHRvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocHh2YWwsIGJhc2UpIHtcbiAgICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgICBiYXNlID0gJzE2cHgnO1xuICAgIH1cblxuICAgIHZhciBuZXdQeHZhbCA9IHB4dmFsO1xuICAgIHZhciBuZXdCYXNlID0gYmFzZTtcblxuICAgIGlmICh0eXBlb2YgcHh2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoIWVuZHNXaXRoKHB4dmFsLCAncHgnKSkge1xuICAgICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2OSwgdG8sIHB4dmFsKTtcbiAgICAgIH1cblxuICAgICAgbmV3UHh2YWwgPSBzdHJpcFVuaXQocHh2YWwpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghZW5kc1dpdGgoYmFzZSwgJ3B4JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzAsIHRvLCBiYXNlKTtcbiAgICAgIH1cblxuICAgICAgbmV3QmFzZSA9IHN0cmlwVW5pdChiYXNlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld1B4dmFsID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzEsIHB4dmFsLCB0byk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdCYXNlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzIsIGJhc2UsIHRvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIiArIG5ld1B4dmFsIC8gbmV3QmFzZSArIHRvO1xuICB9O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHBpeGVsIHZhbHVlIHRvIGVtcy4gVGhlIGRlZmF1bHQgYmFzZSB2YWx1ZSBpcyAxNnB4LCBidXQgY2FuIGJlIGNoYW5nZWQgYnkgcGFzc2luZyBhXG4gKiBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHB4dmFsXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtiYXNlPScxNnB4J11cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICdoZWlnaHQnOiBlbSgnMTZweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGhlaWdodDogJHtlbSgnMTZweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgJ2hlaWdodCc6ICcxZW0nXG4gKiB9XG4gKi9cblxudmFyIGVtID1cbi8qI19fUFVSRV9fKi9cbnB4dG9GYWN0b3J5KCdlbScpO1xuXG52YXIgY3NzUmVnZXgkMSA9IC9eKFsrLV0/KD86XFxkK3xcXGQqXFwuXFxkKykpKFthLXpdKnwlKSQvO1xuLyoqXG4gKiBSZXR1cm5zIGEgZ2l2ZW4gQ1NTIHZhbHVlIGFuZCBpdHMgdW5pdCBhcyBlbGVtZW50cyBvZiBhbiBhcnJheS5cbiAqXG4gKiBAZGVwcmVjYXRlZCAtIGdldFZhbHVlQW5kVW5pdCBoYXMgYmVlbiBtYXJrZWQgZm9yIGRlcHJlY2F0aW9uIGluIHBvbGlzaGVkIDMuMCBhbmQgd2lsbCBiZSBmdWxseSBkZXByZWNhdGVkIGluIDQuMC4gSXQncyBmdW5jdGlvbmFsaXR5IGhhcyBiZWVuIGJlZW4gbW92ZWQgdG8gc3RyaXBVbml0IGFzIGFuIG9wdGlvbmFsIHJldHVybi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAnLS1kaW1lbnNpb24nOiBnZXRWYWx1ZUFuZFVuaXQoJzEwMHB4JylbMF0sXG4gKiAgICctLXVuaXQnOiBnZXRWYWx1ZUFuZFVuaXQoJzEwMHB4JylbMV0sXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIC0tZGltZW5zaW9uOiAke2dldFZhbHVlQW5kVW5pdCgnMTAwcHgnKVswXX07XG4gKiAgIC0tdW5pdDogJHtnZXRWYWx1ZUFuZFVuaXQoJzEwMHB4JylbMV19O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgJy0tZGltZW5zaW9uJzogMTAwLFxuICogICAnLS11bml0JzogJ3B4JyxcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRWYWx1ZUFuZFVuaXQodmFsdWUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS53YXJuKFwiZ2V0VmFsdWVBbmRVbml0IGhhcyBiZWVuIG1hcmtlZCBmb3IgZGVwcmVjYXRpb24gaW4gcG9saXNoZWQgMy4wIGFuZCB3aWxsIGJlIGZ1bGx5IGRlcHJlY2F0ZWQgaW4gNC4wLiBJdCdzIGZ1bmN0aW9uYWxpdHkgaGFzIGJlZW4gYmVlbiBtb3ZlZCB0byBzdHJpcFVuaXQgYXMgYW4gb3B0aW9uYWwgcmV0dXJuLlwiKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHJldHVybiBbdmFsdWUsICcnXTtcbiAgdmFyIG1hdGNoZWRWYWx1ZSA9IHZhbHVlLm1hdGNoKGNzc1JlZ2V4JDEpO1xuICBpZiAobWF0Y2hlZFZhbHVlKSByZXR1cm4gW3BhcnNlRmxvYXQodmFsdWUpLCBtYXRjaGVkVmFsdWVbMl1dO1xuICByZXR1cm4gW3ZhbHVlLCB1bmRlZmluZWRdO1xufVxuXG52YXIgcmF0aW9OYW1lcyA9IHtcbiAgbWlub3JTZWNvbmQ6IDEuMDY3LFxuICBtYWpvclNlY29uZDogMS4xMjUsXG4gIG1pbm9yVGhpcmQ6IDEuMixcbiAgbWFqb3JUaGlyZDogMS4yNSxcbiAgcGVyZmVjdEZvdXJ0aDogMS4zMzMsXG4gIGF1Z0ZvdXJ0aDogMS40MTQsXG4gIHBlcmZlY3RGaWZ0aDogMS41LFxuICBtaW5vclNpeHRoOiAxLjYsXG4gIGdvbGRlblNlY3Rpb246IDEuNjE4LFxuICBtYWpvclNpeHRoOiAxLjY2NyxcbiAgbWlub3JTZXZlbnRoOiAxLjc3OCxcbiAgbWFqb3JTZXZlbnRoOiAxLjg3NSxcbiAgb2N0YXZlOiAyLFxuICBtYWpvclRlbnRoOiAyLjUsXG4gIG1ham9yRWxldmVudGg6IDIuNjY3LFxuICBtYWpvclR3ZWxmdGg6IDMsXG4gIGRvdWJsZU9jdGF2ZTogNFxufTtcblxuZnVuY3Rpb24gZ2V0UmF0aW8ocmF0aW9OYW1lKSB7XG4gIHJldHVybiByYXRpb05hbWVzW3JhdGlvTmFtZV07XG59XG4vKipcbiAqIEVzdGFibGlzaCBjb25zaXN0ZW50IG1lYXN1cmVtZW50cyBhbmQgc3BhY2lhbCByZWxhdGlvbnNoaXBzIHRocm91Z2hvdXQgeW91ciBwcm9qZWN0cyBieSBpbmNyZW1lbnRpbmcgYW4gZW0gb3IgcmVtIHZhbHVlIHVwIG9yIGRvd24gYSBkZWZpbmVkIHNjYWxlLiBXZSBwcm92aWRlIGEgbGlzdCBvZiBjb21tb25seSB1c2VkIHNjYWxlcyBhcyBwcmUtZGVmaW5lZCB2YXJpYWJsZXMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAgLy8gSW5jcmVtZW50IHR3byBzdGVwcyB1cCB0aGUgZGVmYXVsdCBzY2FsZVxuICogICAnZm9udFNpemUnOiBtb2R1bGFyU2NhbGUoMilcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgIC8vIEluY3JlbWVudCB0d28gc3RlcHMgdXAgdGhlIGRlZmF1bHQgc2NhbGVcbiAqICAgZm9udFNpemU6ICR7bW9kdWxhclNjYWxlKDIpfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgJ2ZvbnRTaXplJzogJzEuNzc2ODllbSdcbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1vZHVsYXJTY2FsZShzdGVwcywgYmFzZSwgcmF0aW8pIHtcbiAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xuICAgIGJhc2UgPSAnMWVtJztcbiAgfVxuXG4gIGlmIChyYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgcmF0aW8gPSAncGVyZmVjdEZvdXJ0aCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHN0ZXBzICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQyKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmF0aW8gPT09ICdzdHJpbmcnICYmICFyYXRpb05hbWVzW3JhdGlvXSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQzKTtcbiAgfVxuXG4gIHZhciBfcmVmID0gdHlwZW9mIGJhc2UgPT09ICdzdHJpbmcnID8gc3RyaXBVbml0KGJhc2UsIHRydWUpIDogW2Jhc2UsICcnXSxcbiAgICAgIHJlYWxCYXNlID0gX3JlZlswXSxcbiAgICAgIHVuaXQgPSBfcmVmWzFdO1xuXG4gIHZhciByZWFsUmF0aW8gPSB0eXBlb2YgcmF0aW8gPT09ICdzdHJpbmcnID8gZ2V0UmF0aW8ocmF0aW8pIDogcmF0aW87XG5cbiAgaWYgKHR5cGVvZiByZWFsQmFzZSA9PT0gJ3N0cmluZycgfHwgdW5pdCAhPT0gJ2VtJyAmJiB1bml0ICE9PSAncmVtJykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ0LCBiYXNlKTtcbiAgfVxuXG4gIHJldHVybiBcIlwiICsgcmVhbEJhc2UgKiBNYXRoLnBvdyhyZWFsUmF0aW8sIHN0ZXBzKSArIHVuaXQ7XG59XG5cbi8qKlxuICogQ29udmVydCBwaXhlbCB2YWx1ZSB0byByZW1zLiBUaGUgZGVmYXVsdCBiYXNlIHZhbHVlIGlzIDE2cHgsIGJ1dCBjYW4gYmUgY2hhbmdlZCBieSBwYXNzaW5nIGFcbiAqIHNlY29uZCBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gcHh2YWxcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2Jhc2U9JzE2cHgnXVxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJ2hlaWdodCc6IHJlbSgnMTZweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGhlaWdodDogJHtyZW0oJzE2cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICdoZWlnaHQnOiAnMXJlbSdcbiAqIH1cbiAqL1xuXG52YXIgcmVtID1cbi8qI19fUFVSRV9fKi9cbnB4dG9GYWN0b3J5KCdyZW0nKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgQ1NTIGNhbGMgZm9ybXVsYSBmb3IgbGluZWFyIGludGVycG9sYXRpb24gb2YgYSBwcm9wZXJ0eSBiZXR3ZWVuIHR3byB2YWx1ZXMuIEFjY2VwdHMgb3B0aW9uYWwgbWluU2NyZWVuIChkZWZhdWx0cyB0byAnMzIwcHgnKSBhbmQgbWF4U2NyZWVuIChkZWZhdWx0cyB0byAnMTIwMHB4JykuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgZm9udFNpemU6IGJldHdlZW4oJzIwcHgnLCAnMTAwcHgnLCAnNDAwcHgnLCAnMTAwMHB4JyksXG4gKiAgIGZvbnRTaXplOiBiZXR3ZWVuKCcyMHB4JywgJzEwMHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgZm9udFNpemU6ICR7YmV0d2VlbignMjBweCcsICcxMDBweCcsICc0MDBweCcsICcxMDAwcHgnKX07XG4gKiAgIGZvbnRTaXplOiAke2JldHdlZW4oJzIwcHgnLCAnMTAwcHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogaDE6IHtcbiAqICAgJ2ZvbnRTaXplJzogJ2NhbGMoLTMzLjMzMzMzMzMzMzMzMzM0cHggKyAxMy4zMzMzMzMzMzMzMzMzMzR2dyknLFxuICogICAnZm9udFNpemUnOiAnY2FsYygtOS4wOTA5MDkwOTA5MDkwOTNweCArIDkuMDkwOTA5MDkwOTA5MDkydncpJ1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGJldHdlZW4oZnJvbVNpemUsIHRvU2l6ZSwgbWluU2NyZWVuLCBtYXhTY3JlZW4pIHtcbiAgaWYgKG1pblNjcmVlbiA9PT0gdm9pZCAwKSB7XG4gICAgbWluU2NyZWVuID0gJzMyMHB4JztcbiAgfVxuXG4gIGlmIChtYXhTY3JlZW4gPT09IHZvaWQgMCkge1xuICAgIG1heFNjcmVlbiA9ICcxMjAwcHgnO1xuICB9XG5cbiAgdmFyIF9zdHJpcFVuaXQgPSBzdHJpcFVuaXQoZnJvbVNpemUsIHRydWUpLFxuICAgICAgdW5pdGxlc3NGcm9tU2l6ZSA9IF9zdHJpcFVuaXRbMF0sXG4gICAgICBmcm9tU2l6ZVVuaXQgPSBfc3RyaXBVbml0WzFdO1xuXG4gIHZhciBfc3RyaXBVbml0MiA9IHN0cmlwVW5pdCh0b1NpemUsIHRydWUpLFxuICAgICAgdW5pdGxlc3NUb1NpemUgPSBfc3RyaXBVbml0MlswXSxcbiAgICAgIHRvU2l6ZVVuaXQgPSBfc3RyaXBVbml0MlsxXTtcblxuICB2YXIgX3N0cmlwVW5pdDMgPSBzdHJpcFVuaXQobWluU2NyZWVuLCB0cnVlKSxcbiAgICAgIHVuaXRsZXNzTWluU2NyZWVuID0gX3N0cmlwVW5pdDNbMF0sXG4gICAgICBtaW5TY3JlZW5Vbml0ID0gX3N0cmlwVW5pdDNbMV07XG5cbiAgdmFyIF9zdHJpcFVuaXQ0ID0gc3RyaXBVbml0KG1heFNjcmVlbiwgdHJ1ZSksXG4gICAgICB1bml0bGVzc01heFNjcmVlbiA9IF9zdHJpcFVuaXQ0WzBdLFxuICAgICAgbWF4U2NyZWVuVW5pdCA9IF9zdHJpcFVuaXQ0WzFdO1xuXG4gIGlmICh0eXBlb2YgdW5pdGxlc3NNaW5TY3JlZW4gIT09ICdudW1iZXInIHx8IHR5cGVvZiB1bml0bGVzc01heFNjcmVlbiAhPT0gJ251bWJlcicgfHwgIW1pblNjcmVlblVuaXQgfHwgIW1heFNjcmVlblVuaXQgfHwgbWluU2NyZWVuVW5pdCAhPT0gbWF4U2NyZWVuVW5pdCkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ3KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdW5pdGxlc3NGcm9tU2l6ZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHVuaXRsZXNzVG9TaXplICE9PSAnbnVtYmVyJyB8fCAhZnJvbVNpemVVbml0IHx8ICF0b1NpemVVbml0IHx8IGZyb21TaXplVW5pdCAhPT0gdG9TaXplVW5pdCkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ4KTtcbiAgfVxuXG4gIHZhciBzbG9wZSA9ICh1bml0bGVzc0Zyb21TaXplIC0gdW5pdGxlc3NUb1NpemUpIC8gKHVuaXRsZXNzTWluU2NyZWVuIC0gdW5pdGxlc3NNYXhTY3JlZW4pO1xuICB2YXIgYmFzZSA9IHVuaXRsZXNzVG9TaXplIC0gc2xvcGUgKiB1bml0bGVzc01heFNjcmVlbjtcbiAgcmV0dXJuIFwiY2FsYyhcIiArIGJhc2UudG9GaXhlZCgyKSArIGZyb21TaXplVW5pdCArIFwiICsgXCIgKyAoMTAwICogc2xvcGUpLnRvRml4ZWQoMikgKyBcInZ3KVwiO1xufVxuXG4vKipcbiAqIENTUyB0byBjb250YWluIGEgZmxvYXQgKGNyZWRpdCB0byBDU1NNb2pvKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAgLi4uY2xlYXJGaXgoKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtjbGVhckZpeCgpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnJjo6YWZ0ZXInOiB7XG4gKiAgICdjbGVhcic6ICdib3RoJyxcbiAqICAgJ2NvbnRlbnQnOiAnXCJcIicsXG4gKiAgICdkaXNwbGF5JzogJ3RhYmxlJ1xuICogfVxuICovXG5mdW5jdGlvbiBjbGVhckZpeChwYXJlbnQpIHtcbiAgdmFyIF9yZWY7XG5cbiAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50ID0gJyYnO1xuICB9XG5cbiAgdmFyIHBzZXVkb1NlbGVjdG9yID0gcGFyZW50ICsgXCI6OmFmdGVyXCI7XG4gIHJldHVybiBfcmVmID0ge30sIF9yZWZbcHNldWRvU2VsZWN0b3JdID0ge1xuICAgIGNsZWFyOiAnYm90aCcsXG4gICAgY29udGVudDogJ1wiXCInLFxuICAgIGRpc3BsYXk6ICd0YWJsZSdcbiAgfSwgX3JlZjtcbn1cblxuLyoqXG4gKiBDU1MgdG8gZnVsbHkgY292ZXIgYW4gYXJlYS4gQ2FuIG9wdGlvbmFsbHkgYmUgcGFzc2VkIGFuIG9mZnNldCB0byBhY3QgYXMgYSBcInBhZGRpbmdcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5jb3ZlcigpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Y292ZXIoKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gKiAgICd0b3AnOiAnMCcsXG4gKiAgICdyaWdodDogJzAnLFxuICogICAnYm90dG9tJzogJzAnLFxuICogICAnbGVmdDogJzAnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNvdmVyKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHtcbiAgICBvZmZzZXQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IG9mZnNldCxcbiAgICByaWdodDogb2Zmc2V0LFxuICAgIGJvdHRvbTogb2Zmc2V0LFxuICAgIGxlZnQ6IG9mZnNldFxuICB9O1xufVxuXG4vKipcbiAqIENTUyB0byByZXByZXNlbnQgdHJ1bmNhdGVkIHRleHQgd2l0aCBhbiBlbGxpcHNpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5lbGxpcHNpcygnMjUwcHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2VsbGlwc2lzKCcyNTBweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXY6IHtcbiAqICAgJ2Rpc3BsYXknOiAnaW5saW5lLWJsb2NrJyxcbiAqICAgJ21heFdpZHRoJzogJzI1MHB4JyxcbiAqICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gKiAgICd0ZXh0T3ZlcmZsb3cnOiAnZWxsaXBzaXMnLFxuICogICAnd2hpdGVTcGFjZSc6ICdub3dyYXAnLFxuICogICAnd29yZFdyYXAnOiAnbm9ybWFsJ1xuICogfVxuICovXG5mdW5jdGlvbiBlbGxpcHNpcyh3aWR0aCkge1xuICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xuICAgIHdpZHRoID0gJzEwMCUnO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICBtYXhXaWR0aDogd2lkdGgsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICB3b3JkV3JhcDogJ25vcm1hbCdcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2V0IG9mIG1lZGlhIHF1ZXJpZXMgdGhhdCByZXNpemVzIGEgcHJvcGVydHkgKG9yIHNldCBvZiBwcm9wZXJ0aWVzKSBiZXR3ZWVuIGEgcHJvdmlkZWQgZnJvbVNpemUgYW5kIHRvU2l6ZS4gQWNjZXB0cyBvcHRpb25hbCBtaW5TY3JlZW4gKGRlZmF1bHRzIHRvICczMjBweCcpIGFuZCBtYXhTY3JlZW4gKGRlZmF1bHRzIHRvICcxMjAwcHgnKSB0byBjb25zdHJhaW4gdGhlIGludGVycG9sYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uZmx1aWRSYW5nZShcbiAqICAgIHtcbiAqICAgICAgICBwcm9wOiAncGFkZGluZycsXG4gKiAgICAgICAgZnJvbVNpemU6ICcyMHB4JyxcbiAqICAgICAgICB0b1NpemU6ICcxMDBweCcsXG4gKiAgICAgIH0sXG4gKiAgICAgICc0MDBweCcsXG4gKiAgICAgICcxMDAwcHgnLFxuICogICAgKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2ZsdWlkUmFuZ2UoXG4gKiAgICAgIHtcbiAqICAgICAgICBwcm9wOiAncGFkZGluZycsXG4gKiAgICAgICAgZnJvbVNpemU6ICcyMHB4JyxcbiAqICAgICAgICB0b1NpemU6ICcxMDBweCcsXG4gKiAgICAgIH0sXG4gKiAgICAgICc0MDBweCcsXG4gKiAgICAgICcxMDAwcHgnLFxuICogICAgKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgIFwiQG1lZGlhIChtaW4td2lkdGg6IDEwMDBweClcIjogT2JqZWN0IHtcbiAqICAgICBcInBhZGRpbmdcIjogXCIxMDBweFwiLFxuICogICB9LFxuICogICBcIkBtZWRpYSAobWluLXdpZHRoOiA0MDBweClcIjogT2JqZWN0IHtcbiAqICAgICBcInBhZGRpbmdcIjogXCJjYWxjKC0zMy4zMzMzMzMzMzMzMzMzNHB4ICsgMTMuMzMzMzMzMzMzMzMzMzM0dncpXCIsXG4gKiAgIH0sXG4gKiAgIFwicGFkZGluZ1wiOiBcIjIwcHhcIixcbiAqIH1cbiAqL1xuZnVuY3Rpb24gZmx1aWRSYW5nZShjc3NQcm9wLCBtaW5TY3JlZW4sIG1heFNjcmVlbikge1xuICBpZiAobWluU2NyZWVuID09PSB2b2lkIDApIHtcbiAgICBtaW5TY3JlZW4gPSAnMzIwcHgnO1xuICB9XG5cbiAgaWYgKG1heFNjcmVlbiA9PT0gdm9pZCAwKSB7XG4gICAgbWF4U2NyZWVuID0gJzEyMDBweCc7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoY3NzUHJvcCkgJiYgdHlwZW9mIGNzc1Byb3AgIT09ICdvYmplY3QnIHx8IGNzc1Byb3AgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0OSk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShjc3NQcm9wKSkge1xuICAgIHZhciBtZWRpYVF1ZXJpZXMgPSB7fTtcbiAgICB2YXIgZmFsbGJhY2tzID0ge307XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBjc3NQcm9wLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgdmFyIF9leHRlbmRzMiwgX2V4dGVuZHMzO1xuXG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmogPSBfcmVmO1xuXG4gICAgICBpZiAoIW9iai5wcm9wIHx8ICFvYmouZnJvbVNpemUgfHwgIW9iai50b1NpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTApO1xuICAgICAgfVxuXG4gICAgICBmYWxsYmFja3Nbb2JqLnByb3BdID0gb2JqLmZyb21TaXplO1xuICAgICAgbWVkaWFRdWVyaWVzW1wiQG1lZGlhIChtaW4td2lkdGg6IFwiICsgbWluU2NyZWVuICsgXCIpXCJdID0gX2V4dGVuZHMoe30sIG1lZGlhUXVlcmllc1tcIkBtZWRpYSAobWluLXdpZHRoOiBcIiArIG1pblNjcmVlbiArIFwiKVwiXSwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbb2JqLnByb3BdID0gYmV0d2VlbihvYmouZnJvbVNpemUsIG9iai50b1NpemUsIG1pblNjcmVlbiwgbWF4U2NyZWVuKSwgX2V4dGVuZHMyKSk7XG4gICAgICBtZWRpYVF1ZXJpZXNbXCJAbWVkaWEgKG1pbi13aWR0aDogXCIgKyBtYXhTY3JlZW4gKyBcIilcIl0gPSBfZXh0ZW5kcyh7fSwgbWVkaWFRdWVyaWVzW1wiQG1lZGlhIChtaW4td2lkdGg6IFwiICsgbWF4U2NyZWVuICsgXCIpXCJdLCAoX2V4dGVuZHMzID0ge30sIF9leHRlbmRzM1tvYmoucHJvcF0gPSBvYmoudG9TaXplLCBfZXh0ZW5kczMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGZhbGxiYWNrcywgbWVkaWFRdWVyaWVzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3JlZjIsIF9yZWYzLCBfcmVmNDtcblxuICAgIGlmICghY3NzUHJvcC5wcm9wIHx8ICFjc3NQcm9wLmZyb21TaXplIHx8ICFjc3NQcm9wLnRvU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTEpO1xuICAgIH1cblxuICAgIHJldHVybiBfcmVmNCA9IHt9LCBfcmVmNFtjc3NQcm9wLnByb3BdID0gY3NzUHJvcC5mcm9tU2l6ZSwgX3JlZjRbXCJAbWVkaWEgKG1pbi13aWR0aDogXCIgKyBtaW5TY3JlZW4gKyBcIilcIl0gPSAoX3JlZjIgPSB7fSwgX3JlZjJbY3NzUHJvcC5wcm9wXSA9IGJldHdlZW4oY3NzUHJvcC5mcm9tU2l6ZSwgY3NzUHJvcC50b1NpemUsIG1pblNjcmVlbiwgbWF4U2NyZWVuKSwgX3JlZjIpLCBfcmVmNFtcIkBtZWRpYSAobWluLXdpZHRoOiBcIiArIG1heFNjcmVlbiArIFwiKVwiXSA9IChfcmVmMyA9IHt9LCBfcmVmM1tjc3NQcm9wLnByb3BdID0gY3NzUHJvcC50b1NpemUsIF9yZWYzKSwgX3JlZjQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVGaWxlUmVmZXJlbmNlcyhmb250RmlsZVBhdGgsIGZpbGVGb3JtYXRzKSB7XG4gIHZhciBmaWxlRm9udFJlZmVyZW5jZXMgPSBmaWxlRm9ybWF0cy5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiBcInVybChcXFwiXCIgKyBmb250RmlsZVBhdGggKyBcIi5cIiArIGZvcm1hdCArIFwiXFxcIilcIjtcbiAgfSk7XG4gIHJldHVybiBmaWxlRm9udFJlZmVyZW5jZXMuam9pbignLCAnKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVMb2NhbFJlZmVyZW5jZXMobG9jYWxGb250cykge1xuICB2YXIgbG9jYWxGb250UmVmZXJlbmNlcyA9IGxvY2FsRm9udHMubWFwKGZ1bmN0aW9uIChmb250KSB7XG4gICAgcmV0dXJuIFwibG9jYWwoXFxcIlwiICsgZm9udCArIFwiXFxcIilcIjtcbiAgfSk7XG4gIHJldHVybiBsb2NhbEZvbnRSZWZlcmVuY2VzLmpvaW4oJywgJyk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU291cmNlcyhmb250RmlsZVBhdGgsIGxvY2FsRm9udHMsIGZpbGVGb3JtYXRzKSB7XG4gIHZhciBmb250UmVmZXJlbmNlcyA9IFtdO1xuICBpZiAobG9jYWxGb250cykgZm9udFJlZmVyZW5jZXMucHVzaChnZW5lcmF0ZUxvY2FsUmVmZXJlbmNlcyhsb2NhbEZvbnRzKSk7XG5cbiAgaWYgKGZvbnRGaWxlUGF0aCkge1xuICAgIGZvbnRSZWZlcmVuY2VzLnB1c2goZ2VuZXJhdGVGaWxlUmVmZXJlbmNlcyhmb250RmlsZVBhdGgsIGZpbGVGb3JtYXRzKSk7XG4gIH1cblxuICByZXR1cm4gZm9udFJlZmVyZW5jZXMuam9pbignLCAnKTtcbn1cbi8qKlxuICogQ1NTIGZvciBhIEBmb250LWZhY2UgZGVjbGFyYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgYmFzaWMgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgIC4uLmZvbnRGYWNlKHtcbiAqICAgICAgJ2ZvbnRGYW1pbHknOiAnU2Fucy1Qcm8nLFxuICogICAgICAnZm9udEZpbGVQYXRoJzogJ3BhdGgvdG8vZmlsZSdcbiAqICAgIH0pXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgYmFzaWMgdXNhZ2VcbiAqIGNvbnN0IEdsb2JhbFN0eWxlID0gY3JlYXRlR2xvYmFsU3R5bGVgJHtcbiAqICAgZm9udEZhY2Uoe1xuICogICAgICdmb250RmFtaWx5JzogJ1NhbnMtUHJvJyxcbiAqICAgICAnZm9udEZpbGVQYXRoJzogJ3BhdGgvdG8vZmlsZSdcbiAqICAgfVxuICogKX1gXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICdAZm9udC1mYWNlJzoge1xuICogICAnZm9udEZhbWlseSc6ICdTYW5zLVBybycsXG4gKiAgICdzcmMnOiAndXJsKFwicGF0aC90by9maWxlLmVvdFwiKSwgdXJsKFwicGF0aC90by9maWxlLndvZmYyXCIpLCB1cmwoXCJwYXRoL3RvL2ZpbGUud29mZlwiKSwgdXJsKFwicGF0aC90by9maWxlLnR0ZlwiKSwgdXJsKFwicGF0aC90by9maWxlLnN2Z1wiKScsXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiBmb250RmFjZShfcmVmKSB7XG4gIHZhciBmb250RmFtaWx5ID0gX3JlZi5mb250RmFtaWx5LFxuICAgICAgZm9udEZpbGVQYXRoID0gX3JlZi5mb250RmlsZVBhdGgsXG4gICAgICBmb250U3RyZXRjaCA9IF9yZWYuZm9udFN0cmV0Y2gsXG4gICAgICBmb250U3R5bGUgPSBfcmVmLmZvbnRTdHlsZSxcbiAgICAgIGZvbnRWYXJpYW50ID0gX3JlZi5mb250VmFyaWFudCxcbiAgICAgIGZvbnRXZWlnaHQgPSBfcmVmLmZvbnRXZWlnaHQsXG4gICAgICBfcmVmJGZpbGVGb3JtYXRzID0gX3JlZi5maWxlRm9ybWF0cyxcbiAgICAgIGZpbGVGb3JtYXRzID0gX3JlZiRmaWxlRm9ybWF0cyA9PT0gdm9pZCAwID8gWydlb3QnLCAnd29mZjInLCAnd29mZicsICd0dGYnLCAnc3ZnJ10gOiBfcmVmJGZpbGVGb3JtYXRzLFxuICAgICAgbG9jYWxGb250cyA9IF9yZWYubG9jYWxGb250cyxcbiAgICAgIHVuaWNvZGVSYW5nZSA9IF9yZWYudW5pY29kZVJhbmdlLFxuICAgICAgZm9udERpc3BsYXkgPSBfcmVmLmZvbnREaXNwbGF5LFxuICAgICAgZm9udFZhcmlhdGlvblNldHRpbmdzID0gX3JlZi5mb250VmFyaWF0aW9uU2V0dGluZ3MsXG4gICAgICBmb250RmVhdHVyZVNldHRpbmdzID0gX3JlZi5mb250RmVhdHVyZVNldHRpbmdzO1xuICAvLyBFcnJvciBIYW5kbGluZ1xuICBpZiAoIWZvbnRGYW1pbHkpIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU1KTtcblxuICBpZiAoIWZvbnRGaWxlUGF0aCAmJiAhbG9jYWxGb250cykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDUyKTtcbiAgfVxuXG4gIGlmIChsb2NhbEZvbnRzICYmICFBcnJheS5pc0FycmF5KGxvY2FsRm9udHMpKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTMpO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGZpbGVGb3JtYXRzKSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU0KTtcbiAgfVxuXG4gIHZhciBmb250RmFjZURlY2xhcmF0aW9uID0ge1xuICAgICdAZm9udC1mYWNlJzoge1xuICAgICAgZm9udEZhbWlseTogZm9udEZhbWlseSxcbiAgICAgIHNyYzogZ2VuZXJhdGVTb3VyY2VzKGZvbnRGaWxlUGF0aCwgbG9jYWxGb250cywgZmlsZUZvcm1hdHMpLFxuICAgICAgdW5pY29kZVJhbmdlOiB1bmljb2RlUmFuZ2UsXG4gICAgICBmb250U3RyZXRjaDogZm9udFN0cmV0Y2gsXG4gICAgICBmb250U3R5bGU6IGZvbnRTdHlsZSxcbiAgICAgIGZvbnRWYXJpYW50OiBmb250VmFyaWFudCxcbiAgICAgIGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQsXG4gICAgICBmb250RGlzcGxheTogZm9udERpc3BsYXksXG4gICAgICBmb250VmFyaWF0aW9uU2V0dGluZ3M6IGZvbnRWYXJpYXRpb25TZXR0aW5ncyxcbiAgICAgIGZvbnRGZWF0dXJlU2V0dGluZ3M6IGZvbnRGZWF0dXJlU2V0dGluZ3NcbiAgICB9IC8vIFJlbW92ZXMgdW5kZWZpbmVkIGZpZWxkcyBmb3IgY2xlYW5lciBjc3Mgb2JqZWN0LlxuXG4gIH07XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGZvbnRGYWNlRGVjbGFyYXRpb24pKTtcbn1cblxuLyoqXG4gKiBDU1MgdG8gaGlkZSB0ZXh0IHRvIHNob3cgYSBiYWNrZ3JvdW5kIGltYWdlIGluIGEgU0VPLWZyaWVuZGx5IHdheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAnYmFja2dyb3VuZEltYWdlJzogJ3VybChsb2dvLnBuZyknLFxuICogICAuLi5oaWRlVGV4dCgpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kSW1hZ2U6IHVybChsb2dvLnBuZyk7XG4gKiAgICR7aGlkZVRleHQoKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICdkaXYnOiB7XG4gKiAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAndXJsKGxvZ28ucG5nKScsXG4gKiAgICd0ZXh0SW5kZW50JzogJzEwMSUnLFxuICogICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcbiAqICAgJ3doaXRlU3BhY2UnOiAnbm93cmFwJyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gaGlkZVRleHQoKSB7XG4gIHJldHVybiB7XG4gICAgdGV4dEluZGVudDogJzEwMSUnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJ1xuICB9O1xufVxuXG4vKipcbiAqIENTUyB0byBoaWRlIGNvbnRlbnQgdmlzdWFsbHkgYnV0IHJlbWFpbiBhY2Nlc3NpYmxlIHRvIHNjcmVlbiByZWFkZXJzLlxuICogZnJvbSBbSFRNTDUgQm9pbGVycGxhdGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9oNWJwL2h0bWw1LWJvaWxlcnBsYXRlL2Jsb2IvOWExNzZmNTdhZjFjZmU4ZWM3MDMwMGRhNDYyMWZiOWIwN2U1ZmEzMS9zcmMvY3NzL21haW4uY3NzI0wxMjEpXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uaGlkZVZpc3VhbGx5KCksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7aGlkZVZpc3VhbGx5KCl9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnZGl2Jzoge1xuICogICAnYm9yZGVyJzogJzAnLFxuICogICAnY2xpcCc6ICdyZWN0KDAgMCAwIDApJyxcbiAqICAgJ2NsaXBQYXRoJzogJ2luc2V0KDUwJSknLFxuICogICAnaGVpZ2h0JzogJzFweCcsXG4gKiAgICdtYXJnaW4nOiAnLTFweCcsXG4gKiAgICdvdmVyZmxvdyc6ICdoaWRkZW4nLFxuICogICAncGFkZGluZyc6ICcwJyxcbiAqICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcbiAqICAgJ3doaXRlU3BhY2UnOiAnbm93cmFwJyxcbiAqICAgJ3dpZHRoJzogJzFweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhpZGVWaXN1YWxseSgpIHtcbiAgcmV0dXJuIHtcbiAgICBib3JkZXI6ICcwJyxcbiAgICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gICAgY2xpcFBhdGg6ICdpbnNldCg1MCUpJyxcbiAgICBoZWlnaHQ6ICcxcHgnLFxuICAgIG1hcmdpbjogJy0xcHgnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBwYWRkaW5nOiAnMCcsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgd2lkdGg6ICcxcHgnXG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWVkaWEgcXVlcnkgdG8gdGFyZ2V0IEhpRFBJIGRldmljZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICBbaGlEUEkoMS41KV06IHtcbiAqICAgIHdpZHRoOiAyMDBweDtcbiAqICB9XG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7aGlEUEkoMS41KX0ge1xuICogICAgIHdpZHRoOiAyMDBweDtcbiAqICAgfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjUpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjUpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMS41LzEpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE0NGRwaSksXG4gKiAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMS41ZHBweCknOiB7XG4gKiAgICd3aWR0aCc6ICcyMDBweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhpRFBJKHJhdGlvKSB7XG4gIGlmIChyYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgcmF0aW8gPSAxLjM7XG4gIH1cblxuICByZXR1cm4gXCJcXG4gICAgQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiBcIiArIHJhdGlvICsgXCIpLFxcbiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogXCIgKyByYXRpbyArIFwiKSxcXG4gICAgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiBcIiArIHJhdGlvICsgXCIvMSksXFxuICAgIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IFwiICsgTWF0aC5yb3VuZChyYXRpbyAqIDk2KSArIFwiZHBpKSxcXG4gICAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogXCIgKyByYXRpbyArIFwiZHBweClcXG4gIFwiO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RHcmFkaWVudFZhbHVlKGxpdGVyYWxzKSB7XG4gIHZhciB0ZW1wbGF0ZSA9ICcnO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdWJzdGl0dXRpb25zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdWJzdGl0dXRpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGl0ZXJhbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0ZW1wbGF0ZSArPSBsaXRlcmFsc1tpXTtcblxuICAgIGlmIChpID09PSBzdWJzdGl0dXRpb25zLmxlbmd0aCAtIDEgJiYgc3Vic3RpdHV0aW9uc1tpXSkge1xuICAgICAgdmFyIGRlZmluZWRWYWx1ZXMgPSBzdWJzdGl0dXRpb25zLmZpbHRlcihmdW5jdGlvbiAoc3Vic3RpdHV0ZSkge1xuICAgICAgICByZXR1cm4gISFzdWJzdGl0dXRlO1xuICAgICAgfSk7IC8vIEFkZHMgbGVhZGluZyBjb21hIGlmIHByb3BlcnRpZXMgcHJlY2VlZCBjb2xvci1zdG9wc1xuXG4gICAgICBpZiAoZGVmaW5lZFZhbHVlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuc2xpY2UoMCwgLTEpO1xuICAgICAgICB0ZW1wbGF0ZSArPSBcIiwgXCIgKyBzdWJzdGl0dXRpb25zW2ldOyAvLyBObyB0cmFpbGluZyBzcGFjZSBpZiBjb2xvci1zdG9wcyBpcyB0aGUgb25seSBwYXJhbSBwcm92aWRlZFxuICAgICAgfSBlbHNlIGlmIChkZWZpbmVkVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBcIlwiICsgc3Vic3RpdHV0aW9uc1tpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN1YnN0aXR1dGlvbnNbaV0pIHtcbiAgICAgIHRlbXBsYXRlICs9IHN1YnN0aXR1dGlvbnNbaV0gKyBcIiBcIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGVtcGxhdGUudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QoKSB7XG4gIHZhciBkYXRhID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFtcImxpbmVhci1ncmFkaWVudChcIiwgXCJcIiwgXCIpXCJdKTtcblxuICBfdGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ1NTIGZvciBkZWNsYXJpbmcgYSBsaW5lYXIgZ3JhZGllbnQsIGluY2x1ZGluZyBhIGZhbGxiYWNrIGJhY2tncm91bmQtY29sb3IuIFRoZSBmYWxsYmFjayBpcyBlaXRoZXIgdGhlIGZpcnN0IGNvbG9yLXN0b3Agb3IgYW4gZXhwbGljaXRseSBwYXNzZWQgZmFsbGJhY2sgY29sb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ubGluZWFyR3JhZGllbnQoe1xuICAgICAgICBjb2xvclN0b3BzOiBbJyMwMEZGRkYgMCUnLCAncmdiYSgwLCAwLCAyNTUsIDApIDUwJScsICcjMDAwMEZGIDk1JSddLFxuICAgICAgICB0b0RpcmVjdGlvbjogJ3RvIHRvcCByaWdodCcsXG4gICAgICAgIGZhbGxiYWNrOiAnI0ZGRicsXG4gICAgICB9KVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2xpbmVhckdyYWRpZW50KHtcbiAgICAgICAgY29sb3JTdG9wczogWycjMDBGRkZGIDAlJywgJ3JnYmEoMCwgMCwgMjU1LCAwKSA1MCUnLCAnIzAwMDBGRiA5NSUnXSxcbiAgICAgICAgdG9EaXJlY3Rpb246ICd0byB0b3AgcmlnaHQnLFxuICAgICAgICBmYWxsYmFjazogJyNGRkYnLFxuICAgICAgfSl9XG4gKmBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgICdiYWNrZ3JvdW5kQ29sb3InOiAnI0ZGRicsXG4gKiAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAnbGluZWFyLWdyYWRpZW50KHRvIHRvcCByaWdodCwgIzAwRkZGRiAwJSwgcmdiYSgwLCAwLCAyNTUsIDApIDUwJSwgIzAwMDBGRiA5NSUpJyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gbGluZWFyR3JhZGllbnQoX3JlZikge1xuICB2YXIgY29sb3JTdG9wcyA9IF9yZWYuY29sb3JTdG9wcyxcbiAgICAgIGZhbGxiYWNrID0gX3JlZi5mYWxsYmFjayxcbiAgICAgIF9yZWYkdG9EaXJlY3Rpb24gPSBfcmVmLnRvRGlyZWN0aW9uLFxuICAgICAgdG9EaXJlY3Rpb24gPSBfcmVmJHRvRGlyZWN0aW9uID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkdG9EaXJlY3Rpb247XG5cbiAgaWYgKCFjb2xvclN0b3BzIHx8IGNvbG9yU3RvcHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU2KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBmYWxsYmFjayB8fCBjb2xvclN0b3BzWzBdLnNwbGl0KCcgJylbMF0sXG4gICAgYmFja2dyb3VuZEltYWdlOiBjb25zdHJ1Y3RHcmFkaWVudFZhbHVlKF90ZW1wbGF0ZU9iamVjdCgpLCB0b0RpcmVjdGlvbiwgY29sb3JTdG9wcy5qb2luKCcsICcpKVxuICB9O1xufVxuXG4vKipcbiAqIENTUyB0byBub3JtYWxpemUgYWJub3JtYWxpdGllcyBhY3Jvc3MgYnJvd3NlcnMgKG5vcm1hbGl6ZS5jc3MgdjguMC4wIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcylcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAgLi4ubm9ybWFsaXplKCksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IEdsb2JhbFN0eWxlID0gY3JlYXRlR2xvYmFsU3R5bGVgJHtub3JtYWxpemUoKX1gXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGh0bWwge1xuICogICBsaW5lSGVpZ2h0OiAxLjE1LFxuICogICB0ZXh0U2l6ZUFkanVzdDogMTAwJSxcbiAqIH0gLi4uXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgdmFyIF9yZWY7XG5cbiAgcmV0dXJuIFsoX3JlZiA9IHtcbiAgICBodG1sOiB7XG4gICAgICBsaW5lSGVpZ2h0OiAnMS4xNScsXG4gICAgICB0ZXh0U2l6ZUFkanVzdDogJzEwMCUnXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgaDE6IHtcbiAgICAgIGZvbnRTaXplOiAnMmVtJyxcbiAgICAgIG1hcmdpbjogJzAuNjdlbSAwJ1xuICAgIH0sXG4gICAgaHI6IHtcbiAgICAgIGJveFNpemluZzogJ2NvbnRlbnQtYm94JyxcbiAgICAgIGhlaWdodDogJzAnLFxuICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJ1xuICAgIH0sXG4gICAgcHJlOiB7XG4gICAgICBmb250RmFtaWx5OiAnbW9ub3NwYWNlLCBtb25vc3BhY2UnLFxuICAgICAgZm9udFNpemU6ICcxZW0nXG4gICAgfSxcbiAgICBhOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICB9LFxuICAgICdhYmJyW3RpdGxlXSc6IHtcbiAgICAgIGJvcmRlckJvdHRvbTogJ25vbmUnLFxuICAgICAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnXG4gICAgfVxuICB9LCBfcmVmW1wiYixcXG4gICAgc3Ryb25nXCJdID0ge1xuICAgIGZvbnRXZWlnaHQ6ICdib2xkZXInXG4gIH0sIF9yZWZbXCJjb2RlLFxcbiAgICBrYmQsXFxuICAgIHNhbXBcIl0gPSB7XG4gICAgZm9udEZhbWlseTogJ21vbm9zcGFjZSwgbW9ub3NwYWNlJyxcbiAgICBmb250U2l6ZTogJzFlbSdcbiAgfSwgX3JlZi5zbWFsbCA9IHtcbiAgICBmb250U2l6ZTogJzgwJSdcbiAgfSwgX3JlZltcInN1YixcXG4gICAgc3VwXCJdID0ge1xuICAgIGZvbnRTaXplOiAnNzUlJyxcbiAgICBsaW5lSGVpZ2h0OiAnMCcsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgdmVydGljYWxBbGlnbjogJ2Jhc2VsaW5lJ1xuICB9LCBfcmVmLnN1YiA9IHtcbiAgICBib3R0b206ICctMC4yNWVtJ1xuICB9LCBfcmVmLnN1cCA9IHtcbiAgICB0b3A6ICctMC41ZW0nXG4gIH0sIF9yZWYuaW1nID0ge1xuICAgIGJvcmRlclN0eWxlOiAnbm9uZSdcbiAgfSwgX3JlZltcImJ1dHRvbixcXG4gICAgaW5wdXQsXFxuICAgIG9wdGdyb3VwLFxcbiAgICBzZWxlY3QsXFxuICAgIHRleHRhcmVhXCJdID0ge1xuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogJzEwMCUnLFxuICAgIGxpbmVIZWlnaHQ6ICcxLjE1JyxcbiAgICBtYXJnaW46ICcwJ1xuICB9LCBfcmVmW1wiYnV0dG9uLFxcbiAgICBpbnB1dFwiXSA9IHtcbiAgICBvdmVyZmxvdzogJ3Zpc2libGUnXG4gIH0sIF9yZWZbXCJidXR0b24sXFxuICAgIHNlbGVjdFwiXSA9IHtcbiAgICB0ZXh0VHJhbnNmb3JtOiAnbm9uZSdcbiAgfSwgX3JlZltcImJ1dHRvbixcXG4gICAgaHRtbCBbdHlwZT1cXFwiYnV0dG9uXFxcIl0sXFxuICAgIFt0eXBlPVxcXCJyZXNldFxcXCJdLFxcbiAgICBbdHlwZT1cXFwic3VibWl0XFxcIl1cIl0gPSB7XG4gICAgV2Via2l0QXBwZWFyYW5jZTogJ2J1dHRvbidcbiAgfSwgX3JlZltcImJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgW3R5cGU9XFxcImJ1dHRvblxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcbiAgICBbdHlwZT1cXFwicmVzZXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgW3R5cGU9XFxcInN1Ym1pdFxcXCJdOjotbW96LWZvY3VzLWlubmVyXCJdID0ge1xuICAgIGJvcmRlclN0eWxlOiAnbm9uZScsXG4gICAgcGFkZGluZzogJzAnXG4gIH0sIF9yZWZbXCJidXR0b246LW1vei1mb2N1c3JpbmcsXFxuICAgIFt0eXBlPVxcXCJidXR0b25cXFwiXTotbW96LWZvY3VzcmluZyxcXG4gICAgW3R5cGU9XFxcInJlc2V0XFxcIl06LW1vei1mb2N1c3JpbmcsXFxuICAgIFt0eXBlPVxcXCJzdWJtaXRcXFwiXTotbW96LWZvY3VzcmluZ1wiXSA9IHtcbiAgICBvdXRsaW5lOiAnMXB4IGRvdHRlZCBCdXR0b25UZXh0J1xuICB9LCBfcmVmLmZpZWxkc2V0ID0ge1xuICAgIHBhZGRpbmc6ICcwLjM1ZW0gMC42MjVlbSAwLjc1ZW0nXG4gIH0sIF9yZWYubGVnZW5kID0ge1xuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIGNvbG9yOiAnaW5oZXJpdCcsXG4gICAgZGlzcGxheTogJ3RhYmxlJyxcbiAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgIHBhZGRpbmc6ICcwJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm9ybWFsJ1xuICB9LCBfcmVmLnByb2dyZXNzID0ge1xuICAgIHZlcnRpY2FsQWxpZ246ICdiYXNlbGluZSdcbiAgfSwgX3JlZi50ZXh0YXJlYSA9IHtcbiAgICBvdmVyZmxvdzogJ2F1dG8nXG4gIH0sIF9yZWZbXCJbdHlwZT1cXFwiY2hlY2tib3hcXFwiXSxcXG4gICAgW3R5cGU9XFxcInJhZGlvXFxcIl1cIl0gPSB7XG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgcGFkZGluZzogJzAnXG4gIH0sIF9yZWZbXCJbdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuICAgIFt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvblwiXSA9IHtcbiAgICBoZWlnaHQ6ICdhdXRvJ1xuICB9LCBfcmVmWydbdHlwZT1cInNlYXJjaFwiXSddID0ge1xuICAgIFdlYmtpdEFwcGVhcmFuY2U6ICd0ZXh0ZmllbGQnLFxuICAgIG91dGxpbmVPZmZzZXQ6ICctMnB4J1xuICB9LCBfcmVmWydbdHlwZT1cInNlYXJjaFwiXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiddID0ge1xuICAgIFdlYmtpdEFwcGVhcmFuY2U6ICdub25lJ1xuICB9LCBfcmVmWyc6Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uJ10gPSB7XG4gICAgV2Via2l0QXBwZWFyYW5jZTogJ2J1dHRvbicsXG4gICAgZm9udDogJ2luaGVyaXQnXG4gIH0sIF9yZWYuZGV0YWlscyA9IHtcbiAgICBkaXNwbGF5OiAnYmxvY2snXG4gIH0sIF9yZWYuc3VtbWFyeSA9IHtcbiAgICBkaXNwbGF5OiAnbGlzdC1pdGVtJ1xuICB9LCBfcmVmLnRlbXBsYXRlID0ge1xuICAgIGRpc3BsYXk6ICdub25lJ1xuICB9LCBfcmVmWydbaGlkZGVuXSddID0ge1xuICAgIGRpc3BsYXk6ICdub25lJ1xuICB9LCBfcmVmKSwge1xuICAgICdhYmJyW3RpdGxlXSc6IHtcbiAgICAgIHRleHREZWNvcmF0aW9uOiAndW5kZXJsaW5lIGRvdHRlZCdcbiAgICB9XG4gIH1dO1xufVxuXG5mdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QkMSgpIHtcbiAgdmFyIGRhdGEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoW1wicmFkaWFsLWdyYWRpZW50KFwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIilcIl0pO1xuXG4gIF90ZW1wbGF0ZU9iamVjdCQxID0gZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0KCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENTUyBmb3IgZGVjbGFyaW5nIGEgcmFkaWFsIGdyYWRpZW50LCBpbmNsdWRpbmcgYSBmYWxsYmFjayBiYWNrZ3JvdW5kLWNvbG9yLiBUaGUgZmFsbGJhY2sgaXMgZWl0aGVyIHRoZSBmaXJzdCBjb2xvci1zdG9wIG9yIGFuIGV4cGxpY2l0bHkgcGFzc2VkIGZhbGxiYWNrIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnJhZGlhbEdyYWRpZW50KHtcbiAqICAgICBjb2xvclN0b3BzOiBbJyMwMEZGRkYgMCUnLCAncmdiYSgwLCAwLCAyNTUsIDApIDUwJScsICcjMDAwMEZGIDk1JSddLFxuICogICAgIGV4dGVudDogJ2ZhcnRoZXN0LWNvcm5lciBhdCA0NXB4IDQ1cHgnLFxuICogICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAqICAgICBzaGFwZTogJ2VsbGlwc2UnLFxuICogICB9KVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3JhZGlhbEdyYWRpZW50KHtcbiAqICAgICBjb2xvclN0b3BzOiBbJyMwMEZGRkYgMCUnLCAncmdiYSgwLCAwLCAyNTUsIDApIDUwJScsICcjMDAwMEZGIDk1JSddLFxuICogICAgIGV4dGVudDogJ2ZhcnRoZXN0LWNvcm5lciBhdCA0NXB4IDQ1cHgnLFxuICogICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAqICAgICBzaGFwZTogJ2VsbGlwc2UnLFxuICogICB9KX1cbiAqYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXY6IHtcbiAqICAgJ2JhY2tncm91bmRDb2xvcic6ICcjMDBGRkZGJyxcbiAqICAgJ2JhY2tncm91bmRJbWFnZSc6ICdyYWRpYWwtZ3JhZGllbnQoY2VudGVyIGVsbGlwc2UgZmFydGhlc3QtY29ybmVyIGF0IDQ1cHggNDVweCwgIzAwRkZGRiAwJSwgcmdiYSgwLCAwLCAyNTUsIDApIDUwJSwgIzAwMDBGRiA5NSUpJyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmFkaWFsR3JhZGllbnQoX3JlZikge1xuICB2YXIgY29sb3JTdG9wcyA9IF9yZWYuY29sb3JTdG9wcyxcbiAgICAgIF9yZWYkZXh0ZW50ID0gX3JlZi5leHRlbnQsXG4gICAgICBleHRlbnQgPSBfcmVmJGV4dGVudCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJGV4dGVudCxcbiAgICAgIGZhbGxiYWNrID0gX3JlZi5mYWxsYmFjayxcbiAgICAgIF9yZWYkcG9zaXRpb24gPSBfcmVmLnBvc2l0aW9uLFxuICAgICAgcG9zaXRpb24gPSBfcmVmJHBvc2l0aW9uID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkcG9zaXRpb24sXG4gICAgICBfcmVmJHNoYXBlID0gX3JlZi5zaGFwZSxcbiAgICAgIHNoYXBlID0gX3JlZiRzaGFwZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHNoYXBlO1xuXG4gIGlmICghY29sb3JTdG9wcyB8fCBjb2xvclN0b3BzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1Nyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogZmFsbGJhY2sgfHwgY29sb3JTdG9wc1swXS5zcGxpdCgnICcpWzBdLFxuICAgIGJhY2tncm91bmRJbWFnZTogY29uc3RydWN0R3JhZGllbnRWYWx1ZShfdGVtcGxhdGVPYmplY3QkMSgpLCBwb3NpdGlvbiwgc2hhcGUsIGV4dGVudCwgY29sb3JTdG9wcy5qb2luKCcsICcpKVxuICB9O1xufVxuXG4vKipcbiAqIEEgaGVscGVyIHRvIGdlbmVyYXRlIGEgcmV0aW5hIGJhY2tncm91bmQgaW1hZ2UgYW5kIG5vbi1yZXRpbmFcbiAqIGJhY2tncm91bmQgaW1hZ2UuIFRoZSByZXRpbmEgYmFja2dyb3VuZCBpbWFnZSB3aWxsIG91dHB1dCB0byBhIEhpRFBJIG1lZGlhIHF1ZXJ5LiBUaGUgbWl4aW4gdXNlc1xuICogYSBfMngucG5nIGZpbGVuYW1lIHN1ZmZpeCBieSBkZWZhdWx0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgLi4ucmV0aW5hSW1hZ2UoJ215LWltZycpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7cmV0aW5hSW1hZ2UoJ215LWltZycpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqIGRpdiB7XG4gKiAgIGJhY2tncm91bmRJbWFnZTogJ3VybChteS1pbWcucG5nKScsXG4gKiAgICdAbWVkaWEgb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDEuMyksXG4gKiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMS4zKSxcbiAqICAgIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMS4zLzEpLFxuICogICAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTQ0ZHBpKSxcbiAqICAgIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDEuNWRwcHgpJzoge1xuICogICAgIGJhY2tncm91bmRJbWFnZTogJ3VybChteS1pbWdfMngucG5nKScsXG4gKiAgIH1cbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmV0aW5hSW1hZ2UoZmlsZW5hbWUsIGJhY2tncm91bmRTaXplLCBleHRlbnNpb24sIHJldGluYUZpbGVuYW1lLCByZXRpbmFTdWZmaXgpIHtcbiAgdmFyIF9yZWY7XG5cbiAgaWYgKGV4dGVuc2lvbiA9PT0gdm9pZCAwKSB7XG4gICAgZXh0ZW5zaW9uID0gJ3BuZyc7XG4gIH1cblxuICBpZiAocmV0aW5hU3VmZml4ID09PSB2b2lkIDApIHtcbiAgICByZXRpbmFTdWZmaXggPSAnXzJ4JztcbiAgfVxuXG4gIGlmICghZmlsZW5hbWUpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1OCk7XG4gIH0gLy8gUmVwbGFjZSB0aGUgZG90IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhc3NlZCBleHRlbnNpb24gaWYgb25lIGV4aXN0c1xuXG5cbiAgdmFyIGV4dCA9IGV4dGVuc2lvbi5yZXBsYWNlKC9eXFwuLywgJycpO1xuICB2YXIgckZpbGVuYW1lID0gcmV0aW5hRmlsZW5hbWUgPyByZXRpbmFGaWxlbmFtZSArIFwiLlwiICsgZXh0IDogXCJcIiArIGZpbGVuYW1lICsgcmV0aW5hU3VmZml4ICsgXCIuXCIgKyBleHQ7XG4gIHJldHVybiBfcmVmID0ge1xuICAgIGJhY2tncm91bmRJbWFnZTogXCJ1cmwoXCIgKyBmaWxlbmFtZSArIFwiLlwiICsgZXh0ICsgXCIpXCJcbiAgfSwgX3JlZltoaURQSSgpXSA9IF9leHRlbmRzKHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwidXJsKFwiICsgckZpbGVuYW1lICsgXCIpXCJcbiAgfSwgYmFja2dyb3VuZFNpemUgPyB7XG4gICAgYmFja2dyb3VuZFNpemU6IGJhY2tncm91bmRTaXplXG4gIH0gOiB7fSksIF9yZWY7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG52YXIgZnVuY3Rpb25zTWFwID0ge1xuICBlYXNlSW5CYWNrOiAnY3ViaWMtYmV6aWVyKDAuNjAwLCAtMC4yODAsIDAuNzM1LCAwLjA0NSknLFxuICBlYXNlSW5DaXJjOiAnY3ViaWMtYmV6aWVyKDAuNjAwLCAgMC4wNDAsIDAuOTgwLCAwLjMzNSknLFxuICBlYXNlSW5DdWJpYzogJ2N1YmljLWJlemllcigwLjU1MCwgIDAuMDU1LCAwLjY3NSwgMC4xOTApJyxcbiAgZWFzZUluRXhwbzogJ2N1YmljLWJlemllcigwLjk1MCwgIDAuMDUwLCAwLjc5NSwgMC4wMzUpJyxcbiAgZWFzZUluUXVhZDogJ2N1YmljLWJlemllcigwLjU1MCwgIDAuMDg1LCAwLjY4MCwgMC41MzApJyxcbiAgZWFzZUluUXVhcnQ6ICdjdWJpYy1iZXppZXIoMC44OTUsICAwLjAzMCwgMC42ODUsIDAuMjIwKScsXG4gIGVhc2VJblF1aW50OiAnY3ViaWMtYmV6aWVyKDAuNzU1LCAgMC4wNTAsIDAuODU1LCAwLjA2MCknLFxuICBlYXNlSW5TaW5lOiAnY3ViaWMtYmV6aWVyKDAuNDcwLCAgMC4wMDAsIDAuNzQ1LCAwLjcxNSknLFxuICBlYXNlT3V0QmFjazogJ2N1YmljLWJlemllcigwLjE3NSwgIDAuODg1LCAwLjMyMCwgMS4yNzUpJyxcbiAgZWFzZU91dEN1YmljOiAnY3ViaWMtYmV6aWVyKDAuMjE1LCAgMC42MTAsIDAuMzU1LCAxLjAwMCknLFxuICBlYXNlT3V0Q2lyYzogJ2N1YmljLWJlemllcigwLjA3NSwgIDAuODIwLCAwLjE2NSwgMS4wMDApJyxcbiAgZWFzZU91dEV4cG86ICdjdWJpYy1iZXppZXIoMC4xOTAsICAxLjAwMCwgMC4yMjAsIDEuMDAwKScsXG4gIGVhc2VPdXRRdWFkOiAnY3ViaWMtYmV6aWVyKDAuMjUwLCAgMC40NjAsIDAuNDUwLCAwLjk0MCknLFxuICBlYXNlT3V0UXVhcnQ6ICdjdWJpYy1iZXppZXIoMC4xNjUsICAwLjg0MCwgMC40NDAsIDEuMDAwKScsXG4gIGVhc2VPdXRRdWludDogJ2N1YmljLWJlemllcigwLjIzMCwgIDEuMDAwLCAwLjMyMCwgMS4wMDApJyxcbiAgZWFzZU91dFNpbmU6ICdjdWJpYy1iZXppZXIoMC4zOTAsICAwLjU3NSwgMC41NjUsIDEuMDAwKScsXG4gIGVhc2VJbk91dEJhY2s6ICdjdWJpYy1iZXppZXIoMC42ODAsIC0wLjU1MCwgMC4yNjUsIDEuNTUwKScsXG4gIGVhc2VJbk91dENpcmM6ICdjdWJpYy1iZXppZXIoMC43ODUsICAwLjEzNSwgMC4xNTAsIDAuODYwKScsXG4gIGVhc2VJbk91dEN1YmljOiAnY3ViaWMtYmV6aWVyKDAuNjQ1LCAgMC4wNDUsIDAuMzU1LCAxLjAwMCknLFxuICBlYXNlSW5PdXRFeHBvOiAnY3ViaWMtYmV6aWVyKDEuMDAwLCAgMC4wMDAsIDAuMDAwLCAxLjAwMCknLFxuICBlYXNlSW5PdXRRdWFkOiAnY3ViaWMtYmV6aWVyKDAuNDU1LCAgMC4wMzAsIDAuNTE1LCAwLjk1NSknLFxuICBlYXNlSW5PdXRRdWFydDogJ2N1YmljLWJlemllcigwLjc3MCwgIDAuMDAwLCAwLjE3NSwgMS4wMDApJyxcbiAgZWFzZUluT3V0UXVpbnQ6ICdjdWJpYy1iZXppZXIoMC44NjAsICAwLjAwMCwgMC4wNzAsIDEuMDAwKScsXG4gIGVhc2VJbk91dFNpbmU6ICdjdWJpYy1iZXppZXIoMC40NDUsICAwLjA1MCwgMC41NTAsIDAuOTUwKSdcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuXG59O1xuXG5mdW5jdGlvbiBnZXRUaW1pbmdGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uc01hcFtmdW5jdGlvbk5hbWVdO1xufVxuLyoqXG4gKiBTdHJpbmcgdG8gcmVwcmVzZW50IGNvbW1vbiBlYXNpbmcgZnVuY3Rpb25zIGFzIGRlbW9uc3RyYXRlZCBoZXJlOiAoZ2l0aHViLmNvbS9qYXVraWEvZWFzaWUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiB0aW1pbmdGdW5jdGlvbnMoJ2Vhc2VJblF1YWQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiAgY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAke3RpbWluZ0Z1bmN0aW9ucygnZWFzZUluUXVhZCcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbic6ICdjdWJpYy1iZXppZXIoMC41NTAsICAwLjA4NSwgMC42ODAsIDAuNTMwKScsXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiB0aW1pbmdGdW5jdGlvbnModGltaW5nRnVuY3Rpb24pIHtcbiAgcmV0dXJuIGdldFRpbWluZ0Z1bmN0aW9uKHRpbWluZ0Z1bmN0aW9uKTtcbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYm9yZGVyQ29sb3IoJ3JlZCcsICdncmVlbicsICdibHVlJywgJ3llbGxvdycpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Ym9yZGVyQ29sb3IoJ3JlZCcsICdncmVlbicsICdibHVlJywgJ3llbGxvdycpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wQ29sb3InOiAncmVkJyxcbiAqICAgJ2JvcmRlclJpZ2h0Q29sb3InOiAnZ3JlZW4nLFxuICogICAnYm9yZGVyQm90dG9tQ29sb3InOiAnYmx1ZScsXG4gKiAgICdib3JkZXJMZWZ0Q29sb3InOiAneWVsbG93J1xuICogfVxuICovXG5mdW5jdGlvbiBib3JkZXJDb2xvcigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnYm9yZGVyQ29sb3InXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbnZhciBnZXRCb3JkZXJXaWR0aCA9IGZ1bmN0aW9uIGdldEJvcmRlcldpZHRoKHBvaW50aW5nRGlyZWN0aW9uLCBoZWlnaHQsIHdpZHRoKSB7XG4gIHN3aXRjaCAocG9pbnRpbmdEaXJlY3Rpb24pIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgcmV0dXJuIFwiMCBcIiArIHdpZHRoWzBdIC8gMiArIHdpZHRoWzFdICsgXCIgXCIgKyBoZWlnaHRbMF0gKyBoZWlnaHRbMV0gKyBcIiBcIiArIHdpZHRoWzBdIC8gMiArIHdpZHRoWzFdO1xuXG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4gXCJcIiArIGhlaWdodFswXSAvIDIgKyBoZWlnaHRbMV0gKyBcIiBcIiArIHdpZHRoWzBdICsgd2lkdGhbMV0gKyBcIiBcIiArIGhlaWdodFswXSAvIDIgKyBoZWlnaHRbMV0gKyBcIiAwXCI7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgcmV0dXJuIFwiXCIgKyBoZWlnaHRbMF0gKyBoZWlnaHRbMV0gKyBcIiBcIiArIHdpZHRoWzBdIC8gMiArIHdpZHRoWzFdICsgXCIgMCBcIiArIHdpZHRoWzBdIC8gMiArIHdpZHRoWzFdO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgcmV0dXJuIFwiXCIgKyBoZWlnaHRbMF0gLyAyICsgaGVpZ2h0WzFdICsgXCIgMCBcIiArIGhlaWdodFswXSAvIDIgKyBoZWlnaHRbMV0gKyBcIiBcIiArIHdpZHRoWzBdICsgd2lkdGhbMV07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTkpO1xuICB9XG59OyAvLyBuZWVkZWQgZm9yIGJvcmRlci1jb2xvclxuXG5cbnZhciByZXZlcnNlRGlyZWN0aW9uID0gWydib3R0b20nLCAnbGVmdCcsICd0b3AnLCAncmlnaHQnXTtcbnZhciBOVU1CRVJfQU5EX0ZMT0FUID0gLyhcXGQqXFwuP1xcZCopLztcbi8qKlxuICogQ1NTIHRvIHJlcHJlc2VudCB0cmlhbmdsZSB3aXRoIGFueSBwb2ludGluZyBkaXJlY3Rpb24gd2l0aCBhbiBvcHRpb25hbCBiYWNrZ3JvdW5kIGNvbG9yLiBBY2NlcHRzIG51bWJlciBvciBweCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGguXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnRyaWFuZ2xlKHsgcG9pbnRpbmdEaXJlY3Rpb246ICdyaWdodCcsIHdpZHRoOiAnMTAwcHgnLCBoZWlnaHQ6ICcxMDBweCcsIGZvcmVncm91bmRDb2xvcjogJ3JlZCcgfSlcbiAqIH1cbiAqXG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7dHJpYW5nbGUoeyBwb2ludGluZ0RpcmVjdGlvbjogJ3JpZ2h0Jywgd2lkdGg6ICcxMDBweCcsIGhlaWdodDogJzEwMHB4JywgZm9yZWdyb3VuZENvbG9yOiAncmVkJyB9KX1cbiAqXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdjoge1xuICogICdib3JkZXJDb2xvcic6ICd0cmFuc3BhcmVudCcsXG4gKiAgJ2JvcmRlckxlZnRDb2xvcic6ICdyZWQgIWltcG9ydGFudCcsXG4gKiAgJ2JvcmRlclN0eWxlJzogJ3NvbGlkJyxcbiAqICAnYm9yZGVyV2lkdGgnOiAnNTBweCAwIDUwcHggMTAwcHgnLFxuICogICdoZWlnaHQnOiAnMCcsXG4gKiAgJ3dpZHRoJzogJzAnLFxuICogfVxuICovXG5cbmZ1bmN0aW9uIHRyaWFuZ2xlKF9yZWYpIHtcbiAgdmFyIHBvaW50aW5nRGlyZWN0aW9uID0gX3JlZi5wb2ludGluZ0RpcmVjdGlvbixcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgZm9yZWdyb3VuZENvbG9yID0gX3JlZi5mb3JlZ3JvdW5kQ29sb3IsXG4gICAgICBfcmVmJGJhY2tncm91bmRDb2xvciA9IF9yZWYuYmFja2dyb3VuZENvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yID0gX3JlZiRiYWNrZ3JvdW5kQ29sb3IgPT09IHZvaWQgMCA/ICd0cmFuc3BhcmVudCcgOiBfcmVmJGJhY2tncm91bmRDb2xvcjtcbiAgdmFyIHdpZHRoQW5kVW5pdCA9IFtwYXJzZUZsb2F0KHdpZHRoKSwgU3RyaW5nKHdpZHRoKS5yZXBsYWNlKE5VTUJFUl9BTkRfRkxPQVQsICcnKSB8fCAncHgnXTtcbiAgdmFyIGhlaWdodEFuZFVuaXQgPSBbcGFyc2VGbG9hdChoZWlnaHQpLCBTdHJpbmcoaGVpZ2h0KS5yZXBsYWNlKE5VTUJFUl9BTkRfRkxPQVQsICcnKSB8fCAncHgnXTtcblxuICBpZiAoaXNOYU4oaGVpZ2h0QW5kVW5pdFswXSkgfHwgaXNOYU4od2lkdGhBbmRVbml0WzBdKSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDYwKTtcbiAgfVxuXG4gIHZhciByZXZlcnNlRGlyZWN0aW9uSW5kZXggPSByZXZlcnNlRGlyZWN0aW9uLmluZGV4T2YocG9pbnRpbmdEaXJlY3Rpb24pO1xuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIHdpZHRoOiAnMCcsXG4gICAgaGVpZ2h0OiAnMCcsXG4gICAgYm9yZGVyV2lkdGg6IGdldEJvcmRlcldpZHRoKHBvaW50aW5nRGlyZWN0aW9uLCBoZWlnaHRBbmRVbml0LCB3aWR0aEFuZFVuaXQpLFxuICAgIGJvcmRlclN0eWxlOiAnc29saWQnXG4gIH0sIGJvcmRlckNvbG9yLmFwcGx5KHZvaWQgMCwgQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiA0XG4gIH0pLm1hcChmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPT09IHJldmVyc2VEaXJlY3Rpb25JbmRleCA/IGZvcmVncm91bmRDb2xvciA6IGJhY2tncm91bmRDb2xvcjtcbiAgfSkpKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhbiBlYXN5IHdheSB0byBjaGFuZ2UgdGhlIGB3b3JkV3JhcGAgcHJvcGVydHkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ud29yZFdyYXAoJ2JyZWFrLXdvcmQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3dvcmRXcmFwKCdicmVhay13b3JkJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgb3ZlcmZsb3dXcmFwOiAnYnJlYWstd29yZCcsXG4gKiAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCcsXG4gKiAgIHdvcmRCcmVhazogJ2JyZWFrLWFsbCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHdvcmRXcmFwKHdyYXApIHtcbiAgaWYgKHdyYXAgPT09IHZvaWQgMCkge1xuICAgIHdyYXAgPSAnYnJlYWstd29yZCc7XG4gIH1cblxuICB2YXIgd29yZEJyZWFrID0gd3JhcCA9PT0gJ2JyZWFrLXdvcmQnID8gJ2JyZWFrLWFsbCcgOiB3cmFwO1xuICByZXR1cm4ge1xuICAgIG92ZXJmbG93V3JhcDogd3JhcCxcbiAgICB3b3JkV3JhcDogd3JhcCxcbiAgICB3b3JkQnJlYWs6IHdvcmRCcmVha1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb2xvclRvSW50KGNvbG9yKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGNvbG9yICogMjU1KTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRvSW50KHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmV0dXJuIGNvbG9yVG9JbnQocmVkKSArIFwiLFwiICsgY29sb3JUb0ludChncmVlbikgKyBcIixcIiArIGNvbG9yVG9JbnQoYmx1ZSk7XG59XG5cbmZ1bmN0aW9uIGhzbFRvUmdiKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBjb252ZXJ0KSB7XG4gIGlmIChjb252ZXJ0ID09PSB2b2lkIDApIHtcbiAgICBjb252ZXJ0ID0gY29udmVydFRvSW50O1xuICB9XG5cbiAgaWYgKHNhdHVyYXRpb24gPT09IDApIHtcbiAgICAvLyBhY2hyb21hdGljXG4gICAgcmV0dXJuIGNvbnZlcnQobGlnaHRuZXNzLCBsaWdodG5lc3MsIGxpZ2h0bmVzcyk7XG4gIH0gLy8gZm9ybXVsYXIgZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfYW5kX0hTVlxuXG5cbiAgdmFyIGh1ZVByaW1lID0gaHVlICUgMzYwIC8gNjA7XG4gIHZhciBjaHJvbWEgPSAoMSAtIE1hdGguYWJzKDIgKiBsaWdodG5lc3MgLSAxKSkgKiBzYXR1cmF0aW9uO1xuICB2YXIgc2Vjb25kQ29tcG9uZW50ID0gY2hyb21hICogKDEgLSBNYXRoLmFicyhodWVQcmltZSAlIDIgLSAxKSk7XG4gIHZhciByZWQgPSAwO1xuICB2YXIgZ3JlZW4gPSAwO1xuICB2YXIgYmx1ZSA9IDA7XG5cbiAgaWYgKGh1ZVByaW1lID49IDAgJiYgaHVlUHJpbWUgPCAxKSB7XG4gICAgcmVkID0gY2hyb21hO1xuICAgIGdyZWVuID0gc2Vjb25kQ29tcG9uZW50O1xuICB9IGVsc2UgaWYgKGh1ZVByaW1lID49IDEgJiYgaHVlUHJpbWUgPCAyKSB7XG4gICAgcmVkID0gc2Vjb25kQ29tcG9uZW50O1xuICAgIGdyZWVuID0gY2hyb21hO1xuICB9IGVsc2UgaWYgKGh1ZVByaW1lID49IDIgJiYgaHVlUHJpbWUgPCAzKSB7XG4gICAgZ3JlZW4gPSBjaHJvbWE7XG4gICAgYmx1ZSA9IHNlY29uZENvbXBvbmVudDtcbiAgfSBlbHNlIGlmIChodWVQcmltZSA+PSAzICYmIGh1ZVByaW1lIDwgNCkge1xuICAgIGdyZWVuID0gc2Vjb25kQ29tcG9uZW50O1xuICAgIGJsdWUgPSBjaHJvbWE7XG4gIH0gZWxzZSBpZiAoaHVlUHJpbWUgPj0gNCAmJiBodWVQcmltZSA8IDUpIHtcbiAgICByZWQgPSBzZWNvbmRDb21wb25lbnQ7XG4gICAgYmx1ZSA9IGNocm9tYTtcbiAgfSBlbHNlIGlmIChodWVQcmltZSA+PSA1ICYmIGh1ZVByaW1lIDwgNikge1xuICAgIHJlZCA9IGNocm9tYTtcbiAgICBibHVlID0gc2Vjb25kQ29tcG9uZW50O1xuICB9XG5cbiAgdmFyIGxpZ2h0bmVzc01vZGlmaWNhdGlvbiA9IGxpZ2h0bmVzcyAtIGNocm9tYSAvIDI7XG4gIHZhciBmaW5hbFJlZCA9IHJlZCArIGxpZ2h0bmVzc01vZGlmaWNhdGlvbjtcbiAgdmFyIGZpbmFsR3JlZW4gPSBncmVlbiArIGxpZ2h0bmVzc01vZGlmaWNhdGlvbjtcbiAgdmFyIGZpbmFsQmx1ZSA9IGJsdWUgKyBsaWdodG5lc3NNb2RpZmljYXRpb247XG4gIHJldHVybiBjb252ZXJ0KGZpbmFsUmVkLCBmaW5hbEdyZWVuLCBmaW5hbEJsdWUpO1xufVxuXG52YXIgbmFtZWRDb2xvck1hcCA9IHtcbiAgYWxpY2VibHVlOiAnZjBmOGZmJyxcbiAgYW50aXF1ZXdoaXRlOiAnZmFlYmQ3JyxcbiAgYXF1YTogJzAwZmZmZicsXG4gIGFxdWFtYXJpbmU6ICc3ZmZmZDQnLFxuICBhenVyZTogJ2YwZmZmZicsXG4gIGJlaWdlOiAnZjVmNWRjJyxcbiAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgYmxhY2s6ICcwMDAnLFxuICBibGFuY2hlZGFsbW9uZDogJ2ZmZWJjZCcsXG4gIGJsdWU6ICcwMDAwZmYnLFxuICBibHVldmlvbGV0OiAnOGEyYmUyJyxcbiAgYnJvd246ICdhNTJhMmEnLFxuICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICBjYWRldGJsdWU6ICc1ZjllYTAnLFxuICBjaGFydHJldXNlOiAnN2ZmZjAwJyxcbiAgY2hvY29sYXRlOiAnZDI2OTFlJyxcbiAgY29yYWw6ICdmZjdmNTAnLFxuICBjb3JuZmxvd2VyYmx1ZTogJzY0OTVlZCcsXG4gIGNvcm5zaWxrOiAnZmZmOGRjJyxcbiAgY3JpbXNvbjogJ2RjMTQzYycsXG4gIGN5YW46ICcwMGZmZmYnLFxuICBkYXJrYmx1ZTogJzAwMDA4YicsXG4gIGRhcmtjeWFuOiAnMDA4YjhiJyxcbiAgZGFya2dvbGRlbnJvZDogJ2I4ODYwYicsXG4gIGRhcmtncmF5OiAnYTlhOWE5JyxcbiAgZGFya2dyZWVuOiAnMDA2NDAwJyxcbiAgZGFya2dyZXk6ICdhOWE5YTknLFxuICBkYXJra2hha2k6ICdiZGI3NmInLFxuICBkYXJrbWFnZW50YTogJzhiMDA4YicsXG4gIGRhcmtvbGl2ZWdyZWVuOiAnNTU2YjJmJyxcbiAgZGFya29yYW5nZTogJ2ZmOGMwMCcsXG4gIGRhcmtvcmNoaWQ6ICc5OTMyY2MnLFxuICBkYXJrcmVkOiAnOGIwMDAwJyxcbiAgZGFya3NhbG1vbjogJ2U5OTY3YScsXG4gIGRhcmtzZWFncmVlbjogJzhmYmM4ZicsXG4gIGRhcmtzbGF0ZWJsdWU6ICc0ODNkOGInLFxuICBkYXJrc2xhdGVncmF5OiAnMmY0ZjRmJyxcbiAgZGFya3NsYXRlZ3JleTogJzJmNGY0ZicsXG4gIGRhcmt0dXJxdW9pc2U6ICcwMGNlZDEnLFxuICBkYXJrdmlvbGV0OiAnOTQwMGQzJyxcbiAgZGVlcHBpbms6ICdmZjE0OTMnLFxuICBkZWVwc2t5Ymx1ZTogJzAwYmZmZicsXG4gIGRpbWdyYXk6ICc2OTY5NjknLFxuICBkaW1ncmV5OiAnNjk2OTY5JyxcbiAgZG9kZ2VyYmx1ZTogJzFlOTBmZicsXG4gIGZpcmVicmljazogJ2IyMjIyMicsXG4gIGZsb3JhbHdoaXRlOiAnZmZmYWYwJyxcbiAgZm9yZXN0Z3JlZW46ICcyMjhiMjInLFxuICBmdWNoc2lhOiAnZmYwMGZmJyxcbiAgZ2FpbnNib3JvOiAnZGNkY2RjJyxcbiAgZ2hvc3R3aGl0ZTogJ2Y4ZjhmZicsXG4gIGdvbGQ6ICdmZmQ3MDAnLFxuICBnb2xkZW5yb2Q6ICdkYWE1MjAnLFxuICBncmF5OiAnODA4MDgwJyxcbiAgZ3JlZW46ICcwMDgwMDAnLFxuICBncmVlbnllbGxvdzogJ2FkZmYyZicsXG4gIGdyZXk6ICc4MDgwODAnLFxuICBob25leWRldzogJ2YwZmZmMCcsXG4gIGhvdHBpbms6ICdmZjY5YjQnLFxuICBpbmRpYW5yZWQ6ICdjZDVjNWMnLFxuICBpbmRpZ286ICc0YjAwODInLFxuICBpdm9yeTogJ2ZmZmZmMCcsXG4gIGtoYWtpOiAnZjBlNjhjJyxcbiAgbGF2ZW5kZXI6ICdlNmU2ZmEnLFxuICBsYXZlbmRlcmJsdXNoOiAnZmZmMGY1JyxcbiAgbGF3bmdyZWVuOiAnN2NmYzAwJyxcbiAgbGVtb25jaGlmZm9uOiAnZmZmYWNkJyxcbiAgbGlnaHRibHVlOiAnYWRkOGU2JyxcbiAgbGlnaHRjb3JhbDogJ2YwODA4MCcsXG4gIGxpZ2h0Y3lhbjogJ2UwZmZmZicsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnZmFmYWQyJyxcbiAgbGlnaHRncmF5OiAnZDNkM2QzJyxcbiAgbGlnaHRncmVlbjogJzkwZWU5MCcsXG4gIGxpZ2h0Z3JleTogJ2QzZDNkMycsXG4gIGxpZ2h0cGluazogJ2ZmYjZjMScsXG4gIGxpZ2h0c2FsbW9uOiAnZmZhMDdhJyxcbiAgbGlnaHRzZWFncmVlbjogJzIwYjJhYScsXG4gIGxpZ2h0c2t5Ymx1ZTogJzg3Y2VmYScsXG4gIGxpZ2h0c2xhdGVncmF5OiAnNzg5JyxcbiAgbGlnaHRzbGF0ZWdyZXk6ICc3ODknLFxuICBsaWdodHN0ZWVsYmx1ZTogJ2IwYzRkZScsXG4gIGxpZ2h0eWVsbG93OiAnZmZmZmUwJyxcbiAgbGltZTogJzBmMCcsXG4gIGxpbWVncmVlbjogJzMyY2QzMicsXG4gIGxpbmVuOiAnZmFmMGU2JyxcbiAgbWFnZW50YTogJ2YwZicsXG4gIG1hcm9vbjogJzgwMDAwMCcsXG4gIG1lZGl1bWFxdWFtYXJpbmU6ICc2NmNkYWEnLFxuICBtZWRpdW1ibHVlOiAnMDAwMGNkJyxcbiAgbWVkaXVtb3JjaGlkOiAnYmE1NWQzJyxcbiAgbWVkaXVtcHVycGxlOiAnOTM3MGRiJyxcbiAgbWVkaXVtc2VhZ3JlZW46ICczY2IzNzEnLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICc3YjY4ZWUnLFxuICBtZWRpdW1zcHJpbmdncmVlbjogJzAwZmE5YScsXG4gIG1lZGl1bXR1cnF1b2lzZTogJzQ4ZDFjYycsXG4gIG1lZGl1bXZpb2xldHJlZDogJ2M3MTU4NScsXG4gIG1pZG5pZ2h0Ymx1ZTogJzE5MTk3MCcsXG4gIG1pbnRjcmVhbTogJ2Y1ZmZmYScsXG4gIG1pc3R5cm9zZTogJ2ZmZTRlMScsXG4gIG1vY2Nhc2luOiAnZmZlNGI1JyxcbiAgbmF2YWpvd2hpdGU6ICdmZmRlYWQnLFxuICBuYXZ5OiAnMDAwMDgwJyxcbiAgb2xkbGFjZTogJ2ZkZjVlNicsXG4gIG9saXZlOiAnODA4MDAwJyxcbiAgb2xpdmVkcmFiOiAnNmI4ZTIzJyxcbiAgb3JhbmdlOiAnZmZhNTAwJyxcbiAgb3JhbmdlcmVkOiAnZmY0NTAwJyxcbiAgb3JjaGlkOiAnZGE3MGQ2JyxcbiAgcGFsZWdvbGRlbnJvZDogJ2VlZThhYScsXG4gIHBhbGVncmVlbjogJzk4ZmI5OCcsXG4gIHBhbGV0dXJxdW9pc2U6ICdhZmVlZWUnLFxuICBwYWxldmlvbGV0cmVkOiAnZGI3MDkzJyxcbiAgcGFwYXlhd2hpcDogJ2ZmZWZkNScsXG4gIHBlYWNocHVmZjogJ2ZmZGFiOScsXG4gIHBlcnU6ICdjZDg1M2YnLFxuICBwaW5rOiAnZmZjMGNiJyxcbiAgcGx1bTogJ2RkYTBkZCcsXG4gIHBvd2RlcmJsdWU6ICdiMGUwZTYnLFxuICBwdXJwbGU6ICc4MDAwODAnLFxuICByZWJlY2NhcHVycGxlOiAnNjM5JyxcbiAgcmVkOiAnZjAwJyxcbiAgcm9zeWJyb3duOiAnYmM4ZjhmJyxcbiAgcm95YWxibHVlOiAnNDE2OWUxJyxcbiAgc2FkZGxlYnJvd246ICc4YjQ1MTMnLFxuICBzYWxtb246ICdmYTgwNzInLFxuICBzYW5keWJyb3duOiAnZjRhNDYwJyxcbiAgc2VhZ3JlZW46ICcyZThiNTcnLFxuICBzZWFzaGVsbDogJ2ZmZjVlZScsXG4gIHNpZW5uYTogJ2EwNTIyZCcsXG4gIHNpbHZlcjogJ2MwYzBjMCcsXG4gIHNreWJsdWU6ICc4N2NlZWInLFxuICBzbGF0ZWJsdWU6ICc2YTVhY2QnLFxuICBzbGF0ZWdyYXk6ICc3MDgwOTAnLFxuICBzbGF0ZWdyZXk6ICc3MDgwOTAnLFxuICBzbm93OiAnZmZmYWZhJyxcbiAgc3ByaW5nZ3JlZW46ICcwMGZmN2YnLFxuICBzdGVlbGJsdWU6ICc0NjgyYjQnLFxuICB0YW46ICdkMmI0OGMnLFxuICB0ZWFsOiAnMDA4MDgwJyxcbiAgdGhpc3RsZTogJ2Q4YmZkOCcsXG4gIHRvbWF0bzogJ2ZmNjM0NycsXG4gIHR1cnF1b2lzZTogJzQwZTBkMCcsXG4gIHZpb2xldDogJ2VlODJlZScsXG4gIHdoZWF0OiAnZjVkZWIzJyxcbiAgd2hpdGU6ICdmZmYnLFxuICB3aGl0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgeWVsbG93OiAnZmYwJyxcbiAgeWVsbG93Z3JlZW46ICc5YWNkMzInXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgYSBDU1MgbmFtZWQgY29sb3IgYW5kIHJldHVybnMgaXRzIGVxdWl2YWxlbnQgaGV4IHZhbHVlLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgb3JpZ2luYWwgY29sb3IuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG59O1xuXG5mdW5jdGlvbiBuYW1lVG9IZXgoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycpIHJldHVybiBjb2xvcjtcbiAgdmFyIG5vcm1hbGl6ZWRDb2xvck5hbWUgPSBjb2xvci50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbmFtZWRDb2xvck1hcFtub3JtYWxpemVkQ29sb3JOYW1lXSA/IFwiI1wiICsgbmFtZWRDb2xvck1hcFtub3JtYWxpemVkQ29sb3JOYW1lXSA6IGNvbG9yO1xufVxuXG52YXIgaGV4UmVnZXggPSAvXiNbYS1mQS1GMC05XXs2fSQvO1xudmFyIGhleFJnYmFSZWdleCA9IC9eI1thLWZBLUYwLTldezh9JC87XG52YXIgcmVkdWNlZEhleFJlZ2V4ID0gL14jW2EtZkEtRjAtOV17M30kLztcbnZhciByZWR1Y2VkUmdiYUhleFJlZ2V4ID0gL14jW2EtZkEtRjAtOV17NH0kLztcbnZhciByZ2JSZWdleCA9IC9ecmdiXFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccypcXCkkLztcbnZhciByZ2JhUmVnZXggPSAvXnJnYmFcXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFstK10/WzAtOV0qWy5dP1swLTldKylcXHMqXFwpJC87XG52YXIgaHNsUmVnZXggPSAvXmhzbFxcKFxccyooXFxkezAsM31bLl0/WzAtOV0rKVxccyosXFxzKihcXGR7MSwzfSklXFxzKixcXHMqKFxcZHsxLDN9KSVcXHMqXFwpJC87XG52YXIgaHNsYVJlZ2V4ID0gL15oc2xhXFwoXFxzKihcXGR7MCwzfVsuXT9bMC05XSspXFxzKixcXHMqKFxcZHsxLDN9KSVcXHMqLFxccyooXFxkezEsM30pJVxccyosXFxzKihbLStdP1swLTldKlsuXT9bMC05XSspXFxzKlxcKSQvO1xuLyoqXG4gKiBSZXR1cm5zIGFuIFJnYkNvbG9yIG9yIFJnYmFDb2xvciBvYmplY3QuIFRoaXMgdXRpbGl0eSBmdW5jdGlvbiBpcyBvbmx5IHVzZWZ1bFxuICogaWYgd2FudCB0byBleHRyYWN0IGEgY29sb3IgY29tcG9uZW50LiBXaXRoIHRoZSBjb2xvciB1dGlsIGB0b0NvbG9yU3RyaW5nYCB5b3VcbiAqIGNhbiBjb252ZXJ0IGEgUmdiQ29sb3Igb3IgUmdiYUNvbG9yIG9iamVjdCBiYWNrIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBc3NpZ25zIGB7IHJlZDogMjU1LCBncmVlbjogMCwgYmx1ZTogMCB9YCB0byBjb2xvcjFcbiAqIGNvbnN0IGNvbG9yMSA9IHBhcnNlVG9SZ2IoJ3JnYigyNTUsIDAsIDApJyk7XG4gKiAvLyBBc3NpZ25zIGB7IHJlZDogOTIsIGdyZWVuOiAxMDIsIGJsdWU6IDExMiwgYWxwaGE6IDAuNzUgfWAgdG8gY29sb3IyXG4gKiBjb25zdCBjb2xvcjIgPSBwYXJzZVRvUmdiKCdoc2xhKDIxMCwgMTAlLCA0MCUsIDAuNzUpJyk7XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUb1JnYihjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDMpO1xuICB9XG5cbiAgdmFyIG5vcm1hbGl6ZWRDb2xvciA9IG5hbWVUb0hleChjb2xvcik7XG5cbiAgaWYgKG5vcm1hbGl6ZWRDb2xvci5tYXRjaChoZXhSZWdleCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzFdICsgbm9ybWFsaXplZENvbG9yWzJdLCAxNiksXG4gICAgICBncmVlbjogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclszXSArIG5vcm1hbGl6ZWRDb2xvcls0XSwgMTYpLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvcls1XSArIG5vcm1hbGl6ZWRDb2xvcls2XSwgMTYpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChub3JtYWxpemVkQ29sb3IubWF0Y2goaGV4UmdiYVJlZ2V4KSkge1xuICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQoKHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbN10gKyBub3JtYWxpemVkQ29sb3JbOF0sIDE2KSAvIDI1NSkudG9GaXhlZCgyKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclsxXSArIG5vcm1hbGl6ZWRDb2xvclsyXSwgMTYpLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbM10gKyBub3JtYWxpemVkQ29sb3JbNF0sIDE2KSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbNV0gKyBub3JtYWxpemVkQ29sb3JbNl0sIDE2KSxcbiAgICAgIGFscGhhOiBhbHBoYVxuICAgIH07XG4gIH1cblxuICBpZiAobm9ybWFsaXplZENvbG9yLm1hdGNoKHJlZHVjZWRIZXhSZWdleCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzFdICsgbm9ybWFsaXplZENvbG9yWzFdLCAxNiksXG4gICAgICBncmVlbjogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclsyXSArIG5vcm1hbGl6ZWRDb2xvclsyXSwgMTYpLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclszXSArIG5vcm1hbGl6ZWRDb2xvclszXSwgMTYpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChub3JtYWxpemVkQ29sb3IubWF0Y2gocmVkdWNlZFJnYmFIZXhSZWdleCkpIHtcbiAgICB2YXIgX2FscGhhID0gcGFyc2VGbG9hdCgocGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvcls0XSArIG5vcm1hbGl6ZWRDb2xvcls0XSwgMTYpIC8gMjU1KS50b0ZpeGVkKDIpKTtcblxuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbMV0gKyBub3JtYWxpemVkQ29sb3JbMV0sIDE2KSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzJdICsgbm9ybWFsaXplZENvbG9yWzJdLCAxNiksXG4gICAgICBibHVlOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzNdICsgbm9ybWFsaXplZENvbG9yWzNdLCAxNiksXG4gICAgICBhbHBoYTogX2FscGhhXG4gICAgfTtcbiAgfVxuXG4gIHZhciByZ2JNYXRjaGVkID0gcmdiUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3IpO1xuXG4gIGlmIChyZ2JNYXRjaGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIHJnYk1hdGNoZWRbMV0sIDEwKSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgcmdiTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIHJnYk1hdGNoZWRbM10sIDEwKVxuICAgIH07XG4gIH1cblxuICB2YXIgcmdiYU1hdGNoZWQgPSByZ2JhUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3IpO1xuXG4gIGlmIChyZ2JhTWF0Y2hlZCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KFwiXCIgKyByZ2JhTWF0Y2hlZFsxXSwgMTApLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyByZ2JhTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIHJnYmFNYXRjaGVkWzNdLCAxMCksXG4gICAgICBhbHBoYTogcGFyc2VGbG9hdChcIlwiICsgcmdiYU1hdGNoZWRbNF0pXG4gICAgfTtcbiAgfVxuXG4gIHZhciBoc2xNYXRjaGVkID0gaHNsUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3IpO1xuXG4gIGlmIChoc2xNYXRjaGVkKSB7XG4gICAgdmFyIGh1ZSA9IHBhcnNlSW50KFwiXCIgKyBoc2xNYXRjaGVkWzFdLCAxMCk7XG4gICAgdmFyIHNhdHVyYXRpb24gPSBwYXJzZUludChcIlwiICsgaHNsTWF0Y2hlZFsyXSwgMTApIC8gMTAwO1xuICAgIHZhciBsaWdodG5lc3MgPSBwYXJzZUludChcIlwiICsgaHNsTWF0Y2hlZFszXSwgMTApIC8gMTAwO1xuICAgIHZhciByZ2JDb2xvclN0cmluZyA9IFwicmdiKFwiICsgaHNsVG9SZ2IoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpICsgXCIpXCI7XG4gICAgdmFyIGhzbFJnYk1hdGNoZWQgPSByZ2JSZWdleC5leGVjKHJnYkNvbG9yU3RyaW5nKTtcblxuICAgIGlmICghaHNsUmdiTWF0Y2hlZCkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNCwgbm9ybWFsaXplZENvbG9yLCByZ2JDb2xvclN0cmluZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIGhzbFJnYk1hdGNoZWRbMV0sIDEwKSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgaHNsUmdiTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIGhzbFJnYk1hdGNoZWRbM10sIDEwKVxuICAgIH07XG4gIH1cblxuICB2YXIgaHNsYU1hdGNoZWQgPSBoc2xhUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3IpO1xuXG4gIGlmIChoc2xhTWF0Y2hlZCkge1xuICAgIHZhciBfaHVlID0gcGFyc2VJbnQoXCJcIiArIGhzbGFNYXRjaGVkWzFdLCAxMCk7XG5cbiAgICB2YXIgX3NhdHVyYXRpb24gPSBwYXJzZUludChcIlwiICsgaHNsYU1hdGNoZWRbMl0sIDEwKSAvIDEwMDtcblxuICAgIHZhciBfbGlnaHRuZXNzID0gcGFyc2VJbnQoXCJcIiArIGhzbGFNYXRjaGVkWzNdLCAxMCkgLyAxMDA7XG5cbiAgICB2YXIgX3JnYkNvbG9yU3RyaW5nID0gXCJyZ2IoXCIgKyBoc2xUb1JnYihfaHVlLCBfc2F0dXJhdGlvbiwgX2xpZ2h0bmVzcykgKyBcIilcIjtcblxuICAgIHZhciBfaHNsUmdiTWF0Y2hlZCA9IHJnYlJlZ2V4LmV4ZWMoX3JnYkNvbG9yU3RyaW5nKTtcblxuICAgIGlmICghX2hzbFJnYk1hdGNoZWQpIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQsIG5vcm1hbGl6ZWRDb2xvciwgX3JnYkNvbG9yU3RyaW5nKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgX2hzbFJnYk1hdGNoZWRbMV0sIDEwKSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgX2hzbFJnYk1hdGNoZWRbMl0sIDEwKSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KFwiXCIgKyBfaHNsUmdiTWF0Y2hlZFszXSwgMTApLFxuICAgICAgYWxwaGE6IHBhcnNlRmxvYXQoXCJcIiArIGhzbGFNYXRjaGVkWzRdKVxuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1KTtcbn1cblxuZnVuY3Rpb24gcmdiVG9Ic2woY29sb3IpIHtcbiAgLy8gbWFrZSBzdXJlIHJnYiBhcmUgY29udGFpbmVkIGluIGEgc2V0IG9mIFswLCAyNTVdXG4gIHZhciByZWQgPSBjb2xvci5yZWQgLyAyNTU7XG4gIHZhciBncmVlbiA9IGNvbG9yLmdyZWVuIC8gMjU1O1xuICB2YXIgYmx1ZSA9IGNvbG9yLmJsdWUgLyAyNTU7XG4gIHZhciBtYXggPSBNYXRoLm1heChyZWQsIGdyZWVuLCBibHVlKTtcbiAgdmFyIG1pbiA9IE1hdGgubWluKHJlZCwgZ3JlZW4sIGJsdWUpO1xuICB2YXIgbGlnaHRuZXNzID0gKG1heCArIG1pbikgLyAyO1xuXG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIC8vIGFjaHJvbWF0aWNcbiAgICBpZiAoY29sb3IuYWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHVlOiAwLFxuICAgICAgICBzYXR1cmF0aW9uOiAwLFxuICAgICAgICBsaWdodG5lc3M6IGxpZ2h0bmVzcyxcbiAgICAgICAgYWxwaGE6IGNvbG9yLmFscGhhXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBodWU6IDAsXG4gICAgICAgIHNhdHVyYXRpb246IDAsXG4gICAgICAgIGxpZ2h0bmVzczogbGlnaHRuZXNzXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBodWU7XG4gIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcbiAgdmFyIHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPiAwLjUgPyBkZWx0YSAvICgyIC0gbWF4IC0gbWluKSA6IGRlbHRhIC8gKG1heCArIG1pbik7XG5cbiAgc3dpdGNoIChtYXgpIHtcbiAgICBjYXNlIHJlZDpcbiAgICAgIGh1ZSA9IChncmVlbiAtIGJsdWUpIC8gZGVsdGEgKyAoZ3JlZW4gPCBibHVlID8gNiA6IDApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGdyZWVuOlxuICAgICAgaHVlID0gKGJsdWUgLSByZWQpIC8gZGVsdGEgKyAyO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gYmx1ZSBjYXNlXG4gICAgICBodWUgPSAocmVkIC0gZ3JlZW4pIC8gZGVsdGEgKyA0O1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBodWUgKj0gNjA7XG5cbiAgaWYgKGNvbG9yLmFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHVlOiBodWUsXG4gICAgICBzYXR1cmF0aW9uOiBzYXR1cmF0aW9uLFxuICAgICAgbGlnaHRuZXNzOiBsaWdodG5lc3MsXG4gICAgICBhbHBoYTogY29sb3IuYWxwaGFcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBodWU6IGh1ZSxcbiAgICBzYXR1cmF0aW9uOiBzYXR1cmF0aW9uLFxuICAgIGxpZ2h0bmVzczogbGlnaHRuZXNzXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBIc2xDb2xvciBvciBIc2xhQ29sb3Igb2JqZWN0LiBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgb25seSB1c2VmdWxcbiAqIGlmIHdhbnQgdG8gZXh0cmFjdCBhIGNvbG9yIGNvbXBvbmVudC4gV2l0aCB0aGUgY29sb3IgdXRpbCBgdG9Db2xvclN0cmluZ2AgeW91XG4gKiBjYW4gY29udmVydCBhIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QgYmFjayB0byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXNzaWducyBgeyBodWU6IDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH1gIHRvIGNvbG9yMVxuICogY29uc3QgY29sb3IxID0gcGFyc2VUb0hzbCgncmdiKDI1NSwgMCwgMCknKTtcbiAqIC8vIEFzc2lnbnMgYHsgaHVlOiAxMjgsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41LCBhbHBoYTogMC43NSB9YCB0byBjb2xvcjJcbiAqIGNvbnN0IGNvbG9yMiA9IHBhcnNlVG9Ic2woJ2hzbGEoMTI4LCAxMDAlLCA1MCUsIDAuNzUpJyk7XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVG9Ic2woY29sb3IpIHtcbiAgLy8gTm90ZTogQXQgYSBsYXRlciBzdGFnZSB3ZSBjYW4gb3B0aW1pemUgdGhpcyBmdW5jdGlvbiBhcyByaWdodCBub3cgYSBoc2xcbiAgLy8gY29sb3Igd291bGQgYmUgcGFyc2VkIGNvbnZlcnRlZCB0byByZ2IgdmFsdWVzIGFuZCBjb252ZXJ0ZWQgYmFjayB0byBoc2wuXG4gIHJldHVybiByZ2JUb0hzbChwYXJzZVRvUmdiKGNvbG9yKSk7XG59XG5cbi8qKlxuICogUmVkdWNlcyBoZXggdmFsdWVzIGlmIHBvc3NpYmxlIGUuZy4gI2ZmODg2NiB0byAjZjg2XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgcmVkdWNlSGV4VmFsdWUgPSBmdW5jdGlvbiByZWR1Y2VIZXhWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSA3ICYmIHZhbHVlWzFdID09PSB2YWx1ZVsyXSAmJiB2YWx1ZVszXSA9PT0gdmFsdWVbNF0gJiYgdmFsdWVbNV0gPT09IHZhbHVlWzZdKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgdmFsdWVbMV0gKyB2YWx1ZVszXSArIHZhbHVlWzVdO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZnVuY3Rpb24gbnVtYmVyVG9IZXgodmFsdWUpIHtcbiAgdmFyIGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyBcIjBcIiArIGhleCA6IGhleDtcbn1cblxuZnVuY3Rpb24gY29sb3JUb0hleChjb2xvcikge1xuICByZXR1cm4gbnVtYmVyVG9IZXgoTWF0aC5yb3VuZChjb2xvciAqIDI1NSkpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9IZXgocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZXR1cm4gcmVkdWNlSGV4VmFsdWUoXCIjXCIgKyBjb2xvclRvSGV4KHJlZCkgKyBjb2xvclRvSGV4KGdyZWVuKSArIGNvbG9yVG9IZXgoYmx1ZSkpO1xufVxuXG5mdW5jdGlvbiBoc2xUb0hleChodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykge1xuICByZXR1cm4gaHNsVG9SZ2IoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGNvbnZlcnRUb0hleCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB2YWx1ZSBmb3IgdGhlIGNvbG9yLiBUaGUgcmV0dXJuZWQgcmVzdWx0IGlzIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBoZXggbm90YXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogaHNsKDM1OSwgMC43NSwgMC40KSxcbiAqICAgYmFja2dyb3VuZDogaHNsKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40IH0pLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2hzbCgzNTksIDAuNzUsIDAuNCl9O1xuICogICBiYWNrZ3JvdW5kOiAke2hzbCh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNiMzE5MWNcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjYjMxOTFjXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhzbCh2YWx1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBzYXR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGlnaHRuZXNzID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBoc2xUb0hleCh2YWx1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHNhdHVyYXRpb24gPT09IHVuZGVmaW5lZCAmJiBsaWdodG5lc3MgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoc2xUb0hleCh2YWx1ZS5odWUsIHZhbHVlLnNhdHVyYXRpb24sIHZhbHVlLmxpZ2h0bmVzcyk7XG4gIH1cblxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcigxKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgY29sb3IuIFRoZSByZXR1cm5lZCByZXN1bHQgaXMgdGhlIHNtYWxsZXN0IHBvc3NpYmxlIHJnYmEgb3IgaGV4IG5vdGF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGhzbGEoMzU5LCAwLjc1LCAwLjQsIDAuNyksXG4gKiAgIGJhY2tncm91bmQ6IGhzbGEoeyBodWU6IDM2MCwgc2F0dXJhdGlvbjogMC43NSwgbGlnaHRuZXNzOiAwLjQsIGFscGhhOiAwLDcgfSksXG4gKiAgIGJhY2tncm91bmQ6IGhzbGEoMzU5LCAwLjc1LCAwLjQsIDEpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2hzbGEoMzU5LCAwLjc1LCAwLjQsIDAuNyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2hzbGEoeyBodWU6IDM2MCwgc2F0dXJhdGlvbjogMC43NSwgbGlnaHRuZXNzOiAwLjQsIGFscGhhOiAwLDcgfSl9O1xuICogICBiYWNrZ3JvdW5kOiAke2hzbGEoMzU5LCAwLjc1LCAwLjQsIDEpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNzksMjUsMjgsMC43KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTc5LDI1LDI4LDAuNylcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjYjMxOTFjXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhzbGEodmFsdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgYWxwaGEpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHNhdHVyYXRpb24gPT09ICdudW1iZXInICYmIHR5cGVvZiBsaWdodG5lc3MgPT09ICdudW1iZXInICYmIHR5cGVvZiBhbHBoYSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gYWxwaGEgPj0gMSA/IGhzbFRvSGV4KHZhbHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpIDogXCJyZ2JhKFwiICsgaHNsVG9SZ2IodmFsdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykgKyBcIixcIiArIGFscGhhICsgXCIpXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBzYXR1cmF0aW9uID09PSB1bmRlZmluZWQgJiYgbGlnaHRuZXNzID09PSB1bmRlZmluZWQgJiYgYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZS5hbHBoYSA+PSAxID8gaHNsVG9IZXgodmFsdWUuaHVlLCB2YWx1ZS5zYXR1cmF0aW9uLCB2YWx1ZS5saWdodG5lc3MpIDogXCJyZ2JhKFwiICsgaHNsVG9SZ2IodmFsdWUuaHVlLCB2YWx1ZS5zYXR1cmF0aW9uLCB2YWx1ZS5saWdodG5lc3MpICsgXCIsXCIgKyB2YWx1ZS5hbHBoYSArIFwiKVwiO1xuICB9XG5cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoMik7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB2YWx1ZSBmb3IgdGhlIGNvbG9yLiBUaGUgcmV0dXJuZWQgcmVzdWx0IGlzIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBoZXggbm90YXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogcmdiKDI1NSwgMjA1LCAxMDApLFxuICogICBiYWNrZ3JvdW5kOiByZ2IoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3JnYigyNTUsIDIwNSwgMTAwKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmNkNjRcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjZmZjZDY0XCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHJnYih2YWx1ZSwgZ3JlZW4sIGJsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGdyZWVuID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYmx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gcmVkdWNlSGV4VmFsdWUoXCIjXCIgKyBudW1iZXJUb0hleCh2YWx1ZSkgKyBudW1iZXJUb0hleChncmVlbikgKyBudW1iZXJUb0hleChibHVlKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBncmVlbiA9PT0gdW5kZWZpbmVkICYmIGJsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZWR1Y2VIZXhWYWx1ZShcIiNcIiArIG51bWJlclRvSGV4KHZhbHVlLnJlZCkgKyBudW1iZXJUb0hleCh2YWx1ZS5ncmVlbikgKyBudW1iZXJUb0hleCh2YWx1ZS5ibHVlKSk7XG4gIH1cblxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgY29sb3IuIFRoZSByZXR1cm5lZCByZXN1bHQgaXMgdGhlIHNtYWxsZXN0IHBvc3NpYmxlIHJnYmEgb3IgaGV4IG5vdGF0aW9uLlxuICpcbiAqIENhbiBhbHNvIGJlIHVzZWQgdG8gZmFkZSBhIGNvbG9yIGJ5IHBhc3NpbmcgYSBoZXggdmFsdWUgb3IgbmFtZWQgQ1NTIGNvbG9yIGFsb25nIHdpdGggYW4gYWxwaGEgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDIwNSwgMTAwLCAwLjcpLFxuICogICBiYWNrZ3JvdW5kOiByZ2JhKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCwgYWxwaGE6IDAuNyB9KSxcbiAqICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDIwNSwgMTAwLCAxKSxcbiAqICAgYmFja2dyb3VuZDogcmdiYSgnI2ZmZmZmZicsIDAuNCksXG4gKiAgIGJhY2tncm91bmQ6IHJnYmEoJ2JsYWNrJywgMC43KSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JhKDI1NSwgMjA1LCAxMDAsIDAuNyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3JnYmEoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwLCBhbHBoYTogMC43IH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JhKDI1NSwgMjA1LCAxMDAsIDEpfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JhKCcjZmZmZmZmJywgMC40KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiYSgnYmxhY2snLCAwLjcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjA1LDEwMCwwLjcpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjA1LDEwMCwwLjcpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDI1NSwyNTUsMC40KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMCwwLDAsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiByZ2JhKGZpcnN0VmFsdWUsIHNlY29uZFZhbHVlLCB0aGlyZFZhbHVlLCBmb3VydGhWYWx1ZSkge1xuICBpZiAodHlwZW9mIGZpcnN0VmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzZWNvbmRWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgcmdiVmFsdWUgPSBwYXJzZVRvUmdiKGZpcnN0VmFsdWUpO1xuICAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JWYWx1ZS5yZWQgKyBcIixcIiArIHJnYlZhbHVlLmdyZWVuICsgXCIsXCIgKyByZ2JWYWx1ZS5ibHVlICsgXCIsXCIgKyBzZWNvbmRWYWx1ZSArIFwiKVwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmaXJzdFZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2Vjb25kVmFsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiB0aGlyZFZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZm91cnRoVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZvdXJ0aFZhbHVlID49IDEgPyByZ2IoZmlyc3RWYWx1ZSwgc2Vjb25kVmFsdWUsIHRoaXJkVmFsdWUpIDogXCJyZ2JhKFwiICsgZmlyc3RWYWx1ZSArIFwiLFwiICsgc2Vjb25kVmFsdWUgKyBcIixcIiArIHRoaXJkVmFsdWUgKyBcIixcIiArIGZvdXJ0aFZhbHVlICsgXCIpXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0VmFsdWUgPT09ICdvYmplY3QnICYmIHNlY29uZFZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcmRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIGZvdXJ0aFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmlyc3RWYWx1ZS5hbHBoYSA+PSAxID8gcmdiKGZpcnN0VmFsdWUucmVkLCBmaXJzdFZhbHVlLmdyZWVuLCBmaXJzdFZhbHVlLmJsdWUpIDogXCJyZ2JhKFwiICsgZmlyc3RWYWx1ZS5yZWQgKyBcIixcIiArIGZpcnN0VmFsdWUuZ3JlZW4gKyBcIixcIiArIGZpcnN0VmFsdWUuYmx1ZSArIFwiLFwiICsgZmlyc3RWYWx1ZS5hbHBoYSArIFwiKVwiO1xuICB9XG5cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNyk7XG59XG5cbnZhciBpc1JnYiA9IGZ1bmN0aW9uIGlzUmdiKGNvbG9yKSB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IucmVkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuZ3JlZW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ibHVlID09PSAnbnVtYmVyJyAmJiAodHlwZW9mIGNvbG9yLmFscGhhICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICd1bmRlZmluZWQnKTtcbn07XG5cbnZhciBpc1JnYmEgPSBmdW5jdGlvbiBpc1JnYmEoY29sb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb2xvci5yZWQgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ncmVlbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmJsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ251bWJlcic7XG59O1xuXG52YXIgaXNIc2wgPSBmdW5jdGlvbiBpc0hzbChjb2xvcikge1xuICByZXR1cm4gdHlwZW9mIGNvbG9yLmh1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLnNhdHVyYXRpb24gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5saWdodG5lc3MgPT09ICdudW1iZXInICYmICh0eXBlb2YgY29sb3IuYWxwaGEgIT09ICdudW1iZXInIHx8IHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ3VuZGVmaW5lZCcpO1xufTtcblxudmFyIGlzSHNsYSA9IGZ1bmN0aW9uIGlzSHNsYShjb2xvcikge1xuICByZXR1cm4gdHlwZW9mIGNvbG9yLmh1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLnNhdHVyYXRpb24gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5saWdodG5lc3MgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ251bWJlcic7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIFJnYkNvbG9yLCBSZ2JhQ29sb3IsIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QgdG8gYSBjb2xvciBzdHJpbmcuXG4gKiBUaGlzIHV0aWwgaXMgdXNlZnVsIGluIGNhc2UgeW91IG9ubHkga25vdyBvbiBydW50aW1lIHdoaWNoIGNvbG9yIG9iamVjdCBpc1xuICogdXNlZC4gT3RoZXJ3aXNlIHdlIHJlY29tbWVuZCB0byByZWx5IG9uIGByZ2JgLCBgcmdiYWAsIGBoc2xgIG9yIGBoc2xhYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KSxcbiAqICAgYmFja2dyb3VuZDogdG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcyIH0pLFxuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgaHVlOiAyNDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH0pLFxuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40LCBhbHBoYTogMC43MiB9KSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7dG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcyIH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgaHVlOiAyNDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40LCBhbHBoYTogMC43MiB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDIwNSwxMDAsMC43MilcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjMDBmXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNzksMjUsMjUsMC43MilcIjtcbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQ29sb3JTdHJpbmcoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDgpO1xuICBpZiAoaXNSZ2JhKGNvbG9yKSkgcmV0dXJuIHJnYmEoY29sb3IpO1xuICBpZiAoaXNSZ2IoY29sb3IpKSByZXR1cm4gcmdiKGNvbG9yKTtcbiAgaWYgKGlzSHNsYShjb2xvcikpIHJldHVybiBoc2xhKGNvbG9yKTtcbiAgaWYgKGlzSHNsKGNvbG9yKSkgcmV0dXJuIGhzbChjb2xvcik7XG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDgpO1xufVxuXG4vLyBUeXBlIGRlZmluaXRpb25zIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2djYW50aS9mbG93LXN0YXRpYy1sYW5kL2Jsb2IvbWFzdGVyL3NyYy9GdW4uanNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5mdW5jdGlvbiBjdXJyaWVkKGYsIGxlbmd0aCwgYWNjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmbigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgdmFyIGNvbWJpbmVkID0gYWNjLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gY29tYmluZWQubGVuZ3RoID49IGxlbmd0aCA/IGYuYXBwbHkodGhpcywgY29tYmluZWQpIDogY3VycmllZChmLCBsZW5ndGgsIGNvbWJpbmVkKTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5cbmZ1bmN0aW9uIGN1cnJ5KGYpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZWRlY2xhcmVcbiAgcmV0dXJuIGN1cnJpZWQoZiwgZi5sZW5ndGgsIFtdKTtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBodWUgb2YgdGhlIGNvbG9yLiBIdWUgaXMgYSBudW1iZXIgYmV0d2VlbiAwIHRvIDM2MC4gVGhlIGZpcnN0XG4gKiBhcmd1bWVudCBmb3IgYWRqdXN0SHVlIGlzIHRoZSBhbW91bnQgb2YgZGVncmVlcyB0aGUgY29sb3IgaXMgcm90YXRlZCBhbG9uZ1xuICogdGhlIGNvbG9yIHdoZWVsLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGFkanVzdEh1ZSgxODAsICcjNDQ4JyksXG4gKiAgIGJhY2tncm91bmQ6IGFkanVzdEh1ZSgnMTgwJywgJ3JnYmEoMTAxLDEwMCwyMDUsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2FkanVzdEh1ZSgxODAsICcjNDQ4Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2FkanVzdEh1ZSgnMTgwJywgJ3JnYmEoMTAxLDEwMCwyMDUsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjODg4ODQ0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxMzYsMTM2LDY4LDAuNylcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBhZGp1c3RIdWUoZGVncmVlLCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIGh1ZTogKGhzbENvbG9yLmh1ZSArIHBhcnNlRmxvYXQoZGVncmVlKSkgJSAzNjBcbiAgfSkpO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG52YXIgY3VycmllZEFkanVzdEh1ZSA9XG4vKiNfX1BVUkVfXyovXG5jdXJyeVxuLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi9cbihhZGp1c3RIdWUpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbXBsZW1lbnQgb2YgdGhlIHByb3ZpZGVkIGNvbG9yLiBUaGlzIGlzIGlkZW50aWNhbCB0byBhZGp1c3RIdWUoMTgwLCA8Y29sb3I+KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBjb21wbGVtZW50KCcjNDQ4JyksXG4gKiAgIGJhY2tncm91bmQ6IGNvbXBsZW1lbnQoJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2NvbXBsZW1lbnQoJyM0NDgnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7Y29tcGxlbWVudCgncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiM4ODRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE1MywxNTMsMTUzLDAuNylcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBjb21wbGVtZW50KGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgaHVlOiAoaHNsQ29sb3IuaHVlICsgMTgwKSAlIDM2MFxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIGd1YXJkKGxvd2VyQm91bmRhcnksIHVwcGVyQm91bmRhcnksIHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heChsb3dlckJvdW5kYXJ5LCBNYXRoLm1pbih1cHBlckJvdW5kYXJ5LCB2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBkYXJrZW5lZCBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBkYXJrZW4oMC4yLCAnI0ZGQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBkYXJrZW4oJzAuMicsICdyZ2JhKDI1NSwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtkYXJrZW4oMC4yLCAnI0ZGQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtkYXJrZW4oJzAuMicsICdyZ2JhKDI1NSwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmJkMzFcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwxODksNDksMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGRhcmtlbihhbW91bnQsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgbGlnaHRuZXNzOiBndWFyZCgwLCAxLCBoc2xDb2xvci5saWdodG5lc3MgLSBwYXJzZUZsb2F0KGFtb3VudCkpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWREYXJrZW4gPVxuLyojX19QVVJFX18qL1xuY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4oZGFya2VuKTtcblxuLyoqXG4gKiBEZWNyZWFzZXMgdGhlIGludGVuc2l0eSBvZiBhIGNvbG9yLiBJdHMgcmFuZ2UgaXMgYmV0d2VlbiAwIHRvIDEuIFRoZSBmaXJzdFxuICogYXJndW1lbnQgb2YgdGhlIGRlc2F0dXJhdGUgZnVuY3Rpb24gaXMgdGhlIGFtb3VudCBieSBob3cgbXVjaCB0aGUgY29sb3JcbiAqIGludGVuc2l0eSBzaG91bGQgYmUgZGVjcmVhc2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGRlc2F0dXJhdGUoMC4yLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBkZXNhdHVyYXRlKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7ZGVzYXR1cmF0ZSgwLjIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2Rlc2F0dXJhdGUoJzAuMicsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2I4Yjk3OVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTg0LDE4NSwxMjEsMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGRlc2F0dXJhdGUoYW1vdW50LCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIHNhdHVyYXRpb246IGd1YXJkKDAsIDEsIGhzbENvbG9yLnNhdHVyYXRpb24gLSBwYXJzZUZsb2F0KGFtb3VudCkpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWREZXNhdHVyYXRlID1cbi8qI19fUFVSRV9fKi9cbmN1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKGRlc2F0dXJhdGUpO1xuXG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgKGZsb2F0KSByZXByZXNlbnRpbmcgdGhlIGx1bWluYW5jZSBvZiBhIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGdldEx1bWluYW5jZSgnI0NDQ0Q2NCcpID49IGdldEx1bWluYW5jZSgnIzAwMDBmZicpID8gJyNDQ0NENjQnIDogJyMwMDAwZmYnLFxuICogICBiYWNrZ3JvdW5kOiBnZXRMdW1pbmFuY2UoJ3JnYmEoNTgsIDEzMywgMjU1LCAxKScpID49IGdldEx1bWluYW5jZSgncmdiYSgyNTUsIDU3LCAxNDksIDEpJykgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZ2JhKDU4LCAxMzMsIDI1NSwgMSknIDpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmdiYSgyNTUsIDU3LCAxNDksIDEpJyxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtnZXRMdW1pbmFuY2UoJyNDQ0NENjQnKSA+PSBnZXRMdW1pbmFuY2UoJyMwMDAwZmYnKSA/ICcjQ0NDRDY0JyA6ICcjMDAwMGZmJ307XG4gKiAgIGJhY2tncm91bmQ6ICR7Z2V0THVtaW5hbmNlKCdyZ2JhKDU4LCAxMzMsIDI1NSwgMSknKSA+PSBnZXRMdW1pbmFuY2UoJ3JnYmEoMjU1LCA1NywgMTQ5LCAxKScpID9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmdiYSg1OCwgMTMzLCAyNTUsIDEpJyA6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JnYmEoMjU1LCA1NywgMTQ5LCAxKSd9O1xuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICBiYWNrZ3JvdW5kOiBcIiNDQ0NENjRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDU4LCAxMzMsIDI1NSwgMSlcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRMdW1pbmFuY2UoY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gMDtcbiAgdmFyIHJnYkNvbG9yID0gcGFyc2VUb1JnYihjb2xvcik7XG5cbiAgdmFyIF9PYmplY3Qka2V5cyRtYXAgPSBPYmplY3Qua2V5cyhyZ2JDb2xvcikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY2hhbm5lbCA9IHJnYkNvbG9yW2tleV0gLyAyNTU7XG4gICAgcmV0dXJuIGNoYW5uZWwgPD0gMC4wMzkyOCA/IGNoYW5uZWwgLyAxMi45MiA6IE1hdGgucG93KChjaGFubmVsICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gIH0pLFxuICAgICAgciA9IF9PYmplY3Qka2V5cyRtYXBbMF0sXG4gICAgICBnID0gX09iamVjdCRrZXlzJG1hcFsxXSxcbiAgICAgIGIgPSBfT2JqZWN0JGtleXMkbWFwWzJdO1xuXG4gIHJldHVybiBwYXJzZUZsb2F0KCgwLjIxMjYgKiByICsgMC43MTUyICogZyArIDAuMDcyMiAqIGIpLnRvRml4ZWQoMykpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjb2xvciB0byBhIGdyYXlzY2FsZSwgYnkgcmVkdWNpbmcgaXRzIHNhdHVyYXRpb24gdG8gMC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBncmF5c2NhbGUoJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogZ3JheXNjYWxlKCdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtncmF5c2NhbGUoJyNDQ0NENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7Z3JheXNjYWxlKCdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzk5OVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTUzLDE1MywxNTMsMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGdyYXlzY2FsZShjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIHBhcnNlVG9Ic2woY29sb3IpLCB7XG4gICAgc2F0dXJhdGlvbjogMFxuICB9KSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBIc2xDb2xvciBvciBIc2xhQ29sb3Igb2JqZWN0IHRvIGEgY29sb3Igc3RyaW5nLlxuICogVGhpcyB1dGlsIGlzIHVzZWZ1bCBpbiBjYXNlIHlvdSBvbmx5IGtub3cgb24gcnVudGltZSB3aGljaCBjb2xvciBvYmplY3QgaXNcbiAqIHVzZWQuIE90aGVyd2lzZSB3ZSByZWNvbW1lbmQgdG8gcmVseSBvbiBgaHNsYCBvciBgaHNsYWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogaHNsVG9Db2xvclN0cmluZyh7IGh1ZTogMjQwLCBzYXR1cmF0aW9uOiAxLCBsaWdodG5lc3M6IDAuNSB9KSxcbiAqICAgYmFja2dyb3VuZDogaHNsVG9Db2xvclN0cmluZyh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAuNzIgfSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsVG9Db2xvclN0cmluZyh7IGh1ZTogMjQwLCBzYXR1cmF0aW9uOiAxLCBsaWdodG5lc3M6IDAuNSB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsVG9Db2xvclN0cmluZyh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAuNzIgfSl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiMwMGZcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE3OSwyNSwyNSwwLjcyKVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBoc2xUb0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gIGlmICh0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb2xvci5odWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5zYXR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IubGlnaHRuZXNzID09PSAnbnVtYmVyJykge1xuICAgIGlmIChjb2xvci5hbHBoYSAmJiB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gaHNsYSh7XG4gICAgICAgIGh1ZTogY29sb3IuaHVlLFxuICAgICAgICBzYXR1cmF0aW9uOiBjb2xvci5zYXR1cmF0aW9uLFxuICAgICAgICBsaWdodG5lc3M6IGNvbG9yLmxpZ2h0bmVzcyxcbiAgICAgICAgYWxwaGE6IGNvbG9yLmFscGhhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHNsKHtcbiAgICAgIGh1ZTogY29sb3IuaHVlLFxuICAgICAgc2F0dXJhdGlvbjogY29sb3Iuc2F0dXJhdGlvbixcbiAgICAgIGxpZ2h0bmVzczogY29sb3IubGlnaHRuZXNzXG4gICAgfSk7XG4gIH1cblxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0NSk7XG59XG5cbi8qKlxuICogSW52ZXJ0cyB0aGUgcmVkLCBncmVlbiBhbmQgYmx1ZSB2YWx1ZXMgb2YgYSBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBpbnZlcnQoJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogaW52ZXJ0KCdyZ2JhKDEwMSwxMDAsMjA1LDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtpbnZlcnQoJyNDQ0NENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aW52ZXJ0KCdyZ2JhKDEwMSwxMDAsMjA1LDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiMzMzMyOWJcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE1NCwxNTUsNTAsMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGludmVydChjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjsgLy8gcGFyc2UgY29sb3Igc3RyaW5nIHRvIHJnYlxuXG4gIHZhciB2YWx1ZSA9IHBhcnNlVG9SZ2IoY29sb3IpO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgdmFsdWUsIHtcbiAgICByZWQ6IDI1NSAtIHZhbHVlLnJlZCxcbiAgICBncmVlbjogMjU1IC0gdmFsdWUuZ3JlZW4sXG4gICAgYmx1ZTogMjU1IC0gdmFsdWUuYmx1ZVxuICB9KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB2YWx1ZSBmb3IgdGhlIGxpZ2h0ZW5lZCBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBsaWdodGVuKDAuMiwgJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogbGlnaHRlbignMC4yJywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2xpZ2h0ZW4oMC4yLCAnI0ZGQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtsaWdodGVuKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjZTVlNmIxXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyMjksMjMwLDE3NywwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gbGlnaHRlbihhbW91bnQsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgbGlnaHRuZXNzOiBndWFyZCgwLCAxLCBoc2xDb2xvci5saWdodG5lc3MgKyBwYXJzZUZsb2F0KGFtb3VudCkpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRMaWdodGVuID1cbi8qI19fUFVSRV9fKi9cbmN1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKGxpZ2h0ZW4pO1xuXG4vKipcbiAqIE1peGVzIHRoZSB0d28gcHJvdmlkZWQgY29sb3JzIHRvZ2V0aGVyIGJ5IGNhbGN1bGF0aW5nIHRoZSBhdmVyYWdlIG9mIGVhY2ggb2YgdGhlIFJHQiBjb21wb25lbnRzIHdlaWdodGVkIHRvIHRoZSBmaXJzdCBjb2xvciBieSB0aGUgcHJvdmlkZWQgd2VpZ2h0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IG1peCgwLjUsICcjZjAwJywgJyMwMGYnKVxuICogICBiYWNrZ3JvdW5kOiBtaXgoMC4yNSwgJyNmMDAnLCAnIzAwZicpXG4gKiAgIGJhY2tncm91bmQ6IG1peCgnMC41JywgJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJywgJyMwMGYnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke21peCgwLjUsICcjZjAwJywgJyMwMGYnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7bWl4KDAuMjUsICcjZjAwJywgJyMwMGYnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7bWl4KCcwLjUnLCAncmdiYSgyNTUsIDAsIDAsIDAuNSknLCAnIzAwZicpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzdmMDA3ZlwiO1xuICogICBiYWNrZ3JvdW5kOiBcIiMzZjAwYmZcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDYzLCAwLCAxOTEsIDAuNzUpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gbWl4KHdlaWdodCwgY29sb3IsIG90aGVyQ29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gb3RoZXJDb2xvcjtcbiAgaWYgKG90aGVyQ29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIHBhcnNlZENvbG9yMSA9IHBhcnNlVG9SZ2IoY29sb3IpO1xuXG4gIHZhciBjb2xvcjEgPSBfZXh0ZW5kcyh7fSwgcGFyc2VkQ29sb3IxLCB7XG4gICAgYWxwaGE6IHR5cGVvZiBwYXJzZWRDb2xvcjEuYWxwaGEgPT09ICdudW1iZXInID8gcGFyc2VkQ29sb3IxLmFscGhhIDogMVxuICB9KTtcblxuICB2YXIgcGFyc2VkQ29sb3IyID0gcGFyc2VUb1JnYihvdGhlckNvbG9yKTtcblxuICB2YXIgY29sb3IyID0gX2V4dGVuZHMoe30sIHBhcnNlZENvbG9yMiwge1xuICAgIGFscGhhOiB0eXBlb2YgcGFyc2VkQ29sb3IyLmFscGhhID09PSAnbnVtYmVyJyA/IHBhcnNlZENvbG9yMi5hbHBoYSA6IDEgLy8gVGhlIGZvcm11bGFyIGlzIGNvcGllZCBmcm9tIHRoZSBvcmlnaW5hbCBTYXNzIGltcGxlbWVudGF0aW9uOlxuICAgIC8vIGh0dHA6Ly9zYXNzLWxhbmcuY29tL2RvY3VtZW50YXRpb24vU2Fzcy9TY3JpcHQvRnVuY3Rpb25zLmh0bWwjbWl4LWluc3RhbmNlX21ldGhvZFxuXG4gIH0pO1xuXG4gIHZhciBhbHBoYURlbHRhID0gY29sb3IxLmFscGhhIC0gY29sb3IyLmFscGhhO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQod2VpZ2h0KSAqIDIgLSAxO1xuICB2YXIgeSA9IHggKiBhbHBoYURlbHRhID09PSAtMSA/IHggOiB4ICsgYWxwaGFEZWx0YTtcbiAgdmFyIHogPSAxICsgeCAqIGFscGhhRGVsdGE7XG4gIHZhciB3ZWlnaHQxID0gKHkgLyB6ICsgMSkgLyAyLjA7XG4gIHZhciB3ZWlnaHQyID0gMSAtIHdlaWdodDE7XG4gIHZhciBtaXhlZENvbG9yID0ge1xuICAgIHJlZDogTWF0aC5mbG9vcihjb2xvcjEucmVkICogd2VpZ2h0MSArIGNvbG9yMi5yZWQgKiB3ZWlnaHQyKSxcbiAgICBncmVlbjogTWF0aC5mbG9vcihjb2xvcjEuZ3JlZW4gKiB3ZWlnaHQxICsgY29sb3IyLmdyZWVuICogd2VpZ2h0MiksXG4gICAgYmx1ZTogTWF0aC5mbG9vcihjb2xvcjEuYmx1ZSAqIHdlaWdodDEgKyBjb2xvcjIuYmx1ZSAqIHdlaWdodDIpLFxuICAgIGFscGhhOiBjb2xvcjEuYWxwaGEgKyAoY29sb3IyLmFscGhhIC0gY29sb3IxLmFscGhhKSAqIChwYXJzZUZsb2F0KHdlaWdodCkgLyAxLjApXG4gIH07XG4gIHJldHVybiByZ2JhKG1peGVkQ29sb3IpO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG52YXIgY3VycmllZE1peCA9XG4vKiNfX1BVUkVfXyovXG5jdXJyeVxuLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKG1peCk7XG5cbi8qKlxuICogSW5jcmVhc2VzIHRoZSBvcGFjaXR5IG9mIGEgY29sb3IuIEl0cyByYW5nZSBmb3IgdGhlIGFtb3VudCBpcyBiZXR3ZWVuIDAgdG8gMS5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogb3BhY2lmeSgwLjEsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSknKTtcbiAqICAgYmFja2dyb3VuZDogb3BhY2lmeSgwLjIsICdoc2xhKDAsIDAlLCAxMDAlLCAwLjUpJyksXG4gKiAgIGJhY2tncm91bmQ6IG9wYWNpZnkoJzAuNScsICdyZ2JhKDI1NSwgMCwgMCwgMC4yKScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke29wYWNpZnkoMC4xLCAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpJyl9O1xuICogICBiYWNrZ3JvdW5kOiAke29wYWNpZnkoMC4yLCAnaHNsYSgwLCAwJSwgMTAwJSwgMC41KScpfSxcbiAqICAgYmFja2dyb3VuZDogJHtvcGFjaWZ5KCcwLjUnLCAncmdiYSgyNTUsIDAsIDAsIDAuMiknKX0sXG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmZcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyNTUsMjU1LDAuNylcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwwLDAsMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIG9wYWNpZnkoYW1vdW50LCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIHBhcnNlZENvbG9yID0gcGFyc2VUb1JnYihjb2xvcik7XG4gIHZhciBhbHBoYSA9IHR5cGVvZiBwYXJzZWRDb2xvci5hbHBoYSA9PT0gJ251bWJlcicgPyBwYXJzZWRDb2xvci5hbHBoYSA6IDE7XG5cbiAgdmFyIGNvbG9yV2l0aEFscGhhID0gX2V4dGVuZHMoe30sIHBhcnNlZENvbG9yLCB7XG4gICAgYWxwaGE6IGd1YXJkKDAsIDEsIChhbHBoYSAqIDEwMCArIHBhcnNlRmxvYXQoYW1vdW50KSAqIDEwMCkgLyAxMDApXG4gIH0pO1xuXG4gIHJldHVybiByZ2JhKGNvbG9yV2l0aEFscGhhKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRPcGFjaWZ5ID1cbi8qI19fUFVSRV9fKi9cbmN1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKG9wYWNpZnkpO1xuXG4vKipcbiAqIFJldHVybnMgYmxhY2sgb3Igd2hpdGUgKG9yIG9wdGlvbmFsIGxpZ2h0IGFuZCBkYXJrIHJldHVybiBjb2xvcnMpIGZvciBiZXN0IGNvbnRyYXN0IGRlcGVuZGluZyBvbiB0aGUgbHVtaW5vc2l0eSBvZiB0aGUgZ2l2ZW4gY29sb3IuXG4gKiBGb2xsb3dzIFtXM0Mgc3BlY3MgZm9yIHJlYWRhYmlsaXR5XShodHRwczovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0cxOC5odG1sKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBjb2xvcjogcmVhZGFibGVDb2xvcignIzAwMCcpLFxuICogICBjb2xvcjogcmVhZGFibGVDb2xvcignYmxhY2snLCAnIzAwMScsICcjZmY4JyksXG4gKiAgIGNvbG9yOiByZWFkYWJsZUNvbG9yKCd3aGl0ZScsICcjMDAxJywgJyNmZjgnKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgY29sb3I6ICR7cmVhZGFibGVDb2xvcignIzAwMCcpfTtcbiAqICAgY29sb3I6ICR7cmVhZGFibGVDb2xvcignYmxhY2snLCAnIzAwMScsICcjZmY4Jyl9O1xuICogICBjb2xvcjogJHtyZWFkYWJsZUNvbG9yKCd3aGl0ZScsICcjMDAxJywgJyNmZjgnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBjb2xvcjogXCIjZmZmXCI7XG4gKiAgIGNvbG9yOiBcIiNmZjhcIjtcbiAqICAgY29sb3I6IFwiIzAwMVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHJlYWRhYmxlQ29sb3IoY29sb3IsIGxpZ2h0UmV0dXJuQ29sb3IsIGRhcmtSZXR1cm5Db2xvcikge1xuICBpZiAobGlnaHRSZXR1cm5Db2xvciA9PT0gdm9pZCAwKSB7XG4gICAgbGlnaHRSZXR1cm5Db2xvciA9ICcjMDAwJztcbiAgfVxuXG4gIGlmIChkYXJrUmV0dXJuQ29sb3IgPT09IHZvaWQgMCkge1xuICAgIGRhcmtSZXR1cm5Db2xvciA9ICcjZmZmJztcbiAgfVxuXG4gIHJldHVybiBnZXRMdW1pbmFuY2UoY29sb3IpID4gMC4xNzkgPyBsaWdodFJldHVybkNvbG9yIDogZGFya1JldHVybkNvbG9yO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgUmdiQ29sb3Igb3IgUmdiYUNvbG9yIG9iamVjdCB0byBhIGNvbG9yIHN0cmluZy5cbiAqIFRoaXMgdXRpbCBpcyB1c2VmdWwgaW4gY2FzZSB5b3Ugb25seSBrbm93IG9uIHJ1bnRpbWUgd2hpY2ggY29sb3Igb2JqZWN0IGlzXG4gKiB1c2VkLiBPdGhlcndpc2Ugd2UgcmVjb21tZW5kIHRvIHJlbHkgb24gYHJnYmAgb3IgYHJnYmFgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHJnYlRvQ29sb3JTdHJpbmcoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pLFxuICogICBiYWNrZ3JvdW5kOiByZ2JUb0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCwgYWxwaGE6IDAuNzIgfSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiVG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAgfSl9O1xuICogICBiYWNrZ3JvdW5kOiAke3JnYlRvQ29sb3JTdHJpbmcoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwLCBhbHBoYTogMC43MiB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDIwNSwxMDAsMC43MilcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmdiVG9Db2xvclN0cmluZyhjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29sb3IucmVkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuZ3JlZW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ibHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmIChjb2xvci5hbHBoYSAmJiB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcmdiYSh7XG4gICAgICAgIHJlZDogY29sb3IucmVkLFxuICAgICAgICBncmVlbjogY29sb3IuZ3JlZW4sXG4gICAgICAgIGJsdWU6IGNvbG9yLmJsdWUsXG4gICAgICAgIGFscGhhOiBjb2xvci5hbHBoYVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJnYih7XG4gICAgICByZWQ6IGNvbG9yLnJlZCxcbiAgICAgIGdyZWVuOiBjb2xvci5ncmVlbixcbiAgICAgIGJsdWU6IGNvbG9yLmJsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ2KTtcbn1cblxuLyoqXG4gKiBJbmNyZWFzZXMgdGhlIGludGVuc2l0eSBvZiBhIGNvbG9yLiBJdHMgcmFuZ2UgaXMgYmV0d2VlbiAwIHRvIDEuIFRoZSBmaXJzdFxuICogYXJndW1lbnQgb2YgdGhlIHNhdHVyYXRlIGZ1bmN0aW9uIGlzIHRoZSBhbW91bnQgYnkgaG93IG11Y2ggdGhlIGNvbG9yXG4gKiBpbnRlbnNpdHkgc2hvdWxkIGJlIGluY3JlYXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBzYXR1cmF0ZSgwLjIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IHNhdHVyYXRlKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7c2F0dXJhdGUoMC4yLCAnI0ZGQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtzYXR1cmF0ZSgnMC4yJywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2UwZTI1MFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjI0LDIyNiw4MCwwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gc2F0dXJhdGUoYW1vdW50LCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIHNhdHVyYXRpb246IGd1YXJkKDAsIDEsIGhzbENvbG9yLnNhdHVyYXRpb24gKyBwYXJzZUZsb2F0KGFtb3VudCkpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRTYXR1cmF0ZSA9XG4vKiNfX1BVUkVfXyovXG5jdXJyeVxuLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi9cbihzYXR1cmF0ZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgaHVlIG9mIGEgY29sb3IgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLiBUaGUgaHVlIHJhbmdlIGNhbiBiZVxuICogZnJvbSAwIGFuZCAzNTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogc2V0SHVlKDQyLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBzZXRIdWUoJzI0NCcsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtzZXRIdWUoNDIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3NldEh1ZSgnMjQ0JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjY2RhZTY0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxMDcsMTAwLDIwNSwwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gc2V0SHVlKGh1ZSwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBwYXJzZVRvSHNsKGNvbG9yKSwge1xuICAgIGh1ZTogcGFyc2VGbG9hdChodWUpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRTZXRIdWUgPVxuLyojX19QVVJFX18qL1xuY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4oc2V0SHVlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaWdodG5lc3Mgb2YgYSBjb2xvciB0byB0aGUgcHJvdmlkZWQgdmFsdWUuIFRoZSBsaWdodG5lc3MgcmFuZ2UgY2FuIGJlXG4gKiBmcm9tIDAgYW5kIDEuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogc2V0TGlnaHRuZXNzKDAuMiwgJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogc2V0TGlnaHRuZXNzKCcwLjc1JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3NldExpZ2h0bmVzcygwLjIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3NldExpZ2h0bmVzcygnMC43NScsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzRkNGQxOVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjIzLDIyNCwxNTksMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHNldExpZ2h0bmVzcyhsaWdodG5lc3MsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgcGFyc2VUb0hzbChjb2xvciksIHtcbiAgICBsaWdodG5lc3M6IHBhcnNlRmxvYXQobGlnaHRuZXNzKVxuICB9KSk7XG59IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbnZhciBjdXJyaWVkU2V0TGlnaHRuZXNzID1cbi8qI19fUFVSRV9fKi9cbmN1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKHNldExpZ2h0bmVzcyk7XG5cbi8qKlxuICogU2V0cyB0aGUgc2F0dXJhdGlvbiBvZiBhIGNvbG9yIHRvIHRoZSBwcm92aWRlZCB2YWx1ZS4gVGhlIHNhdHVyYXRpb24gcmFuZ2UgY2FuIGJlXG4gKiBmcm9tIDAgYW5kIDEuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogc2V0U2F0dXJhdGlvbigwLjIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IHNldFNhdHVyYXRpb24oJzAuNzUnLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7c2V0U2F0dXJhdGlvbigwLjIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3NldFNhdHVyYXRpb24oJzAuNzUnLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNhZGFkODRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDIyOCwyMjksNzYsMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHNldFNhdHVyYXRpb24oc2F0dXJhdGlvbiwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBwYXJzZVRvSHNsKGNvbG9yKSwge1xuICAgIHNhdHVyYXRpb246IHBhcnNlRmxvYXQoc2F0dXJhdGlvbilcbiAgfSkpO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG52YXIgY3VycmllZFNldFNhdHVyYXRpb24gPVxuLyojX19QVVJFX18qL1xuY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4oc2V0U2F0dXJhdGlvbik7XG5cbi8qKlxuICogU2hhZGVzIGEgY29sb3IgYnkgbWl4aW5nIGl0IHdpdGggYmxhY2suIGBzaGFkZWAgY2FuIHByb2R1Y2VcbiAqIGh1ZSBzaGlmdHMsIHdoZXJlIGFzIGBkYXJrZW5gIG1hbmlwdWxhdGVzIHRoZSBsdW1pbmFuY2UgY2hhbm5lbCBhbmQgdGhlcmVmb3JlXG4gKiBkb2Vzbid0IHByb2R1Y2UgaHVlIHNoaWZ0cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBzaGFkZSgwLjI1LCAnIzAwZicpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7c2hhZGUoMC4yNSwgJyMwMGYnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiMwMDAwM2ZcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBzaGFkZShwZXJjZW50YWdlLCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgcmV0dXJuIGN1cnJpZWRNaXgocGFyc2VGbG9hdChwZXJjZW50YWdlKSwgJ3JnYigwLCAwLCAwKScsIGNvbG9yKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRTaGFkZSA9XG4vKiNfX1BVUkVfXyovXG5jdXJyeVxuLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi9cbihzaGFkZSk7XG5cbi8qKlxuICogVGludHMgYSBjb2xvciBieSBtaXhpbmcgaXQgd2l0aCB3aGl0ZS4gYHRpbnRgIGNhbiBwcm9kdWNlXG4gKiBodWUgc2hpZnRzLCB3aGVyZSBhcyBgbGlnaHRlbmAgbWFuaXB1bGF0ZXMgdGhlIGx1bWluYW5jZSBjaGFubmVsIGFuZCB0aGVyZWZvcmVcbiAqIGRvZXNuJ3QgcHJvZHVjZSBodWUgc2hpZnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHRpbnQoMC4yNSwgJyMwMGYnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3RpbnQoMC4yNSwgJyMwMGYnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNiZmJmZmZcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiB0aW50KHBlcmNlbnRhZ2UsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gY3VycmllZE1peChwYXJzZUZsb2F0KHBlcmNlbnRhZ2UpLCAncmdiKDI1NSwgMjU1LCAyNTUpJywgY29sb3IpO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG52YXIgY3VycmllZFRpbnQgPVxuLyojX19QVVJFX18qL1xuY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4odGludCk7XG5cbi8qKlxuICogRGVjcmVhc2VzIHRoZSBvcGFjaXR5IG9mIGEgY29sb3IuIEl0cyByYW5nZSBmb3IgdGhlIGFtb3VudCBpcyBiZXR3ZWVuIDAgdG8gMS5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnRpemUoMC4xLCAnI2ZmZicpO1xuICogICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudGl6ZSgwLjIsICdoc2woMCwgMCUsIDEwMCUpJyksXG4gKiAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50aXplKCcwLjUnLCAncmdiYSgyNTUsIDAsIDAsIDAuOCknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHt0cmFuc3BhcmVudGl6ZSgwLjEsICcjZmZmJyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3RyYW5zcGFyZW50aXplKDAuMiwgJ2hzbCgwLCAwJSwgMTAwJSknKX0sXG4gKiAgIGJhY2tncm91bmQ6ICR7dHJhbnNwYXJlbnRpemUoJzAuNScsICdyZ2JhKDI1NSwgMCwgMCwgMC44KScpfSxcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjkpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjgpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMCwwLDAuMylcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc3BhcmVudGl6ZShhbW91bnQsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgcGFyc2VkQ29sb3IgPSBwYXJzZVRvUmdiKGNvbG9yKTtcbiAgdmFyIGFscGhhID0gdHlwZW9mIHBhcnNlZENvbG9yLmFscGhhID09PSAnbnVtYmVyJyA/IHBhcnNlZENvbG9yLmFscGhhIDogMTtcblxuICB2YXIgY29sb3JXaXRoQWxwaGEgPSBfZXh0ZW5kcyh7fSwgcGFyc2VkQ29sb3IsIHtcbiAgICBhbHBoYTogZ3VhcmQoMCwgMSwgKGFscGhhICogMTAwIC0gcGFyc2VGbG9hdChhbW91bnQpICogMTAwKSAvIDEwMClcbiAgfSk7XG5cbiAgcmV0dXJuIHJnYmEoY29sb3JXaXRoQWxwaGEpO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG52YXIgY3VycmllZFRyYW5zcGFyZW50aXplID1cbi8qI19fUFVSRV9fKi9cbmN1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKHRyYW5zcGFyZW50aXplKTtcblxuLyoqXG4gKiBTaG9ydGhhbmQgZm9yIGVhc2lseSBzZXR0aW5nIHRoZSBhbmltYXRpb24gcHJvcGVydHkuIEFsbG93cyBlaXRoZXIgbXVsdGlwbGUgYXJyYXlzIHdpdGggYW5pbWF0aW9uc1xuICogb3IgYSBzaW5nbGUgYW5pbWF0aW9uIHNwcmVhZCBvdmVyIHRoZSBhcmd1bWVudHMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5hbmltYXRpb24oWydyb3RhdGUnLCAnMXMnLCAnZWFzZS1pbi1vdXQnXSwgWydjb2xvcmNoYW5nZScsICcycyddKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2FuaW1hdGlvbihbJ3JvdGF0ZScsICcxcycsICdlYXNlLWluLW91dCddLCBbJ2NvbG9yY2hhbmdlJywgJzJzJ10pfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYW5pbWF0aW9uJzogJ3JvdGF0ZSAxcyBlYXNlLWluLW91dCwgY29sb3JjaGFuZ2UgMnMnXG4gKiB9XG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5hbmltYXRpb24oJ3JvdGF0ZScsICcxcycsICdlYXNlLWluLW91dCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7YW5pbWF0aW9uKCdyb3RhdGUnLCAnMXMnLCAnZWFzZS1pbi1vdXQnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2FuaW1hdGlvbic6ICdyb3RhdGUgMXMgZWFzZS1pbi1vdXQnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGlvbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIC8vIEFsbG93IHNpbmdsZSBvciBtdWx0aXBsZSBhbmltYXRpb25zIHBhc3NlZFxuICB2YXIgbXVsdGlNb2RlID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKTtcblxuICBpZiAoIW11bHRpTW9kZSAmJiBhcmdzLmxlbmd0aCA+IDgpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2NCk7XG4gIH1cblxuICB2YXIgY29kZSA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAobXVsdGlNb2RlICYmICFBcnJheS5pc0FycmF5KGFyZykgfHwgIW11bHRpTW9kZSAmJiBBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDY1KTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGggPiA4KSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2Nik7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZy5qb2luKCcgJykgOiBhcmc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIHJldHVybiB7XG4gICAgYW5pbWF0aW9uOiBjb2RlXG4gIH07XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyBhbnkgbnVtYmVyIG9mIGJhY2tncm91bmRJbWFnZSB2YWx1ZXMgYXMgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBzaW5nbGUgYmFja2dyb3VuZCBzdGF0ZW1lbnQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5iYWNrZ3JvdW5kSW1hZ2VzKCd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiknLCAnbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtiYWNrZ3JvdW5kSW1hZ2VzKCd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiknLCAnbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAndXJsKFwiL2ltYWdlL2JhY2tncm91bmQuanBnXCIpLCBsaW5lYXItZ3JhZGllbnQocmVkLCBncmVlbiknXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGJhY2tncm91bmRJbWFnZXMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wZXJ0aWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHByb3BlcnRpZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRJbWFnZTogcHJvcGVydGllcy5qb2luKCcsICcpXG4gIH07XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyBhbnkgbnVtYmVyIG9mIGJhY2tncm91bmQgdmFsdWVzIGFzIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIGEgc2luZ2xlIGJhY2tncm91bmQgc3RhdGVtZW50LlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYmFja2dyb3VuZHMoJ3VybChcIi9pbWFnZS9iYWNrZ3JvdW5kLmpwZ1wiKScsICdsaW5lYXItZ3JhZGllbnQocmVkLCBncmVlbiknLCAnY2VudGVyIG5vLXJlcGVhdCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7YmFja2dyb3VuZHMoJ3VybChcIi9pbWFnZS9iYWNrZ3JvdW5kLmpwZ1wiKScsICdsaW5lYXItZ3JhZGllbnQocmVkLCBncmVlbiknLCAnY2VudGVyIG5vLXJlcGVhdCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYmFja2dyb3VuZCc6ICd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiksIGxpbmVhci1ncmFkaWVudChyZWQsIGdyZWVuKSwgY2VudGVyIG5vLXJlcGVhdCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYmFja2dyb3VuZHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wZXJ0aWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHByb3BlcnRpZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmQ6IHByb3BlcnRpZXMuam9pbignLCAnKVxuICB9O1xufVxuXG52YXIgc2lkZU1hcCA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG4vKipcbiAqIFNob3J0aGFuZCBmb3IgdGhlIGJvcmRlciBwcm9wZXJ0eSB0aGF0IHNwbGl0cyBvdXQgaW5kaXZpZHVhbCBwcm9wZXJ0aWVzIGZvciB1c2Ugd2l0aCB0b29scyBsaWtlIEZlbGEgYW5kIFN0eWxldHJvbi4gQSBzaWRlIGtleXdvcmQgY2FuIG9wdGlvbmFsbHkgYmUgcGFzc2VkIHRvIHRhcmdldCBvbmx5IG9uZSBzaWRlJ3MgYm9yZGVyIHByb3BlcnRpZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYm9yZGVyKCcxcHgnLCAnc29saWQnLCAncmVkJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXIoJzFweCcsICdzb2xpZCcsICdyZWQnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JvcmRlckNvbG9yJzogJ3JlZCcsXG4gKiAgICdib3JkZXJTdHlsZSc6ICdzb2xpZCcsXG4gKiAgICdib3JkZXJXaWR0aCc6IGAxcHhgLFxuICogfVxuICpcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYm9yZGVyKCd0b3AnLCAnMXB4JywgJ3NvbGlkJywgJ3JlZCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Ym9yZGVyKCd0b3AnLCAnMXB4JywgJ3NvbGlkJywgJ3JlZCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wQ29sb3InOiAncmVkJyxcbiAqICAgJ2JvcmRlclRvcFN0eWxlJzogJ3NvbGlkJyxcbiAqICAgJ2JvcmRlclRvcFdpZHRoJzogYDFweGAsXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gYm9yZGVyKHNpZGVLZXl3b3JkKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAodHlwZW9mIHNpZGVLZXl3b3JkID09PSAnc3RyaW5nJyAmJiBzaWRlTWFwLmluZGV4T2Yoc2lkZUtleXdvcmQpID49IDApIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbXCJib3JkZXJcIiArIGNhcGl0YWxpemVTdHJpbmcoc2lkZUtleXdvcmQpICsgXCJXaWR0aFwiXSA9IHZhbHVlc1swXSwgX3JlZltcImJvcmRlclwiICsgY2FwaXRhbGl6ZVN0cmluZyhzaWRlS2V5d29yZCkgKyBcIlN0eWxlXCJdID0gdmFsdWVzWzFdLCBfcmVmW1wiYm9yZGVyXCIgKyBjYXBpdGFsaXplU3RyaW5nKHNpZGVLZXl3b3JkKSArIFwiQ29sb3JcIl0gPSB2YWx1ZXNbMl0sIF9yZWY7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVzLnVuc2hpZnQoc2lkZUtleXdvcmQpO1xuICAgIHJldHVybiB7XG4gICAgICBib3JkZXJXaWR0aDogdmFsdWVzWzBdLFxuICAgICAgYm9yZGVyU3R5bGU6IHZhbHVlc1sxXSxcbiAgICAgIGJvcmRlckNvbG9yOiB2YWx1ZXNbMl1cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyBhIHZhbHVlIGZvciBzaWRlIGFuZCBhIHZhbHVlIGZvciByYWRpdXMgYW5kIGFwcGxpZXMgdGhlIHJhZGl1cyB2YWx1ZSB0byBib3RoIGNvcm5lcnMgb2YgdGhlIHNpZGUuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXJSYWRpdXMoJ3RvcCcsICc1cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JvcmRlclJhZGl1cygndG9wJywgJzVweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wUmlnaHRSYWRpdXMnOiAnNXB4JyxcbiAqICAgJ2JvcmRlclRvcExlZnRSYWRpdXMnOiAnNXB4JyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYm9yZGVyUmFkaXVzKHNpZGUsIHJhZGl1cykge1xuICB2YXIgdXBwZXJjYXNlU2lkZSA9IGNhcGl0YWxpemVTdHJpbmcoc2lkZSk7XG5cbiAgaWYgKCFyYWRpdXMgJiYgcmFkaXVzICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjIpO1xuICB9XG5cbiAgaWYgKHVwcGVyY2FzZVNpZGUgPT09ICdUb3AnIHx8IHVwcGVyY2FzZVNpZGUgPT09ICdCb3R0b20nKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW1wiYm9yZGVyXCIgKyB1cHBlcmNhc2VTaWRlICsgXCJSaWdodFJhZGl1c1wiXSA9IHJhZGl1cywgX3JlZltcImJvcmRlclwiICsgdXBwZXJjYXNlU2lkZSArIFwiTGVmdFJhZGl1c1wiXSA9IHJhZGl1cywgX3JlZjtcbiAgfVxuXG4gIGlmICh1cHBlcmNhc2VTaWRlID09PSAnTGVmdCcgfHwgdXBwZXJjYXNlU2lkZSA9PT0gJ1JpZ2h0Jykge1xuICAgIHZhciBfcmVmMjtcblxuICAgIHJldHVybiBfcmVmMiA9IHt9LCBfcmVmMltcImJvcmRlclRvcFwiICsgdXBwZXJjYXNlU2lkZSArIFwiUmFkaXVzXCJdID0gcmFkaXVzLCBfcmVmMltcImJvcmRlckJvdHRvbVwiICsgdXBwZXJjYXNlU2lkZSArIFwiUmFkaXVzXCJdID0gcmFkaXVzLCBfcmVmMjtcbiAgfVxuXG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDYzKTtcbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYm9yZGVyU3R5bGUoJ3NvbGlkJywgJ2Rhc2hlZCcsICdkb3R0ZWQnLCAnZG91YmxlJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXJTdHlsZSgnc29saWQnLCAnZGFzaGVkJywgJ2RvdHRlZCcsICdkb3VibGUnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JvcmRlclRvcFN0eWxlJzogJ3NvbGlkJyxcbiAqICAgJ2JvcmRlclJpZ2h0U3R5bGUnOiAnZGFzaGVkJyxcbiAqICAgJ2JvcmRlckJvdHRvbVN0eWxlJzogJ2RvdHRlZCcsXG4gKiAgICdib3JkZXJMZWZ0U3R5bGUnOiAnZG91YmxlJ1xuICogfVxuICovXG5mdW5jdGlvbiBib3JkZXJTdHlsZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnYm9yZGVyU3R5bGUnXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIHZhbHVlcywgaW5jbHVkaW5nIG51bGwgdG8gc2tpcCBhIHZhbHVlLCBhbmQgbWFwcyB0aGVtIHRvIHRoZWlyIHJlc3BlY3RpdmUgZGlyZWN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmJvcmRlcldpZHRoKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXJXaWR0aCgnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wV2lkdGgnOiAnMTJweCcsXG4gKiAgICdib3JkZXJSaWdodFdpZHRoJzogJzI0cHgnLFxuICogICAnYm9yZGVyQm90dG9tV2lkdGgnOiAnMzZweCcsXG4gKiAgICdib3JkZXJMZWZ0V2lkdGgnOiAnNDhweCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYm9yZGVyV2lkdGgoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodm9pZCAwLCBbJ2JvcmRlcldpZHRoJ10uY29uY2F0KHZhbHVlcykpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNlbGVjdG9ycyh0ZW1wbGF0ZSwgc3RhdGUpIHtcbiAgdmFyIHN0YXRlU3VmZml4ID0gc3RhdGUgPyBcIjpcIiArIHN0YXRlIDogJyc7XG4gIHJldHVybiB0ZW1wbGF0ZShzdGF0ZVN1ZmZpeCk7XG59XG4vKipcbiAqIEZ1bmN0aW9uIGhlbHBlciB0aGF0IGFkZHMgYW4gYXJyYXkgb2Ygc3RhdGVzIHRvIGEgdGVtcGxhdGUgb2Ygc2VsZWN0b3JzLiBVc2VkIGluIHRleHRJbnB1dHMgYW5kIGJ1dHRvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc3RhdGVmdWxTZWxlY3RvcnMoc3RhdGVzLCB0ZW1wbGF0ZSwgc3RhdGVNYXApIHtcbiAgaWYgKCF0ZW1wbGF0ZSkgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjcpO1xuICBpZiAoc3RhdGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGdlbmVyYXRlU2VsZWN0b3JzKHRlbXBsYXRlLCBudWxsKTtcbiAgdmFyIHNlbGVjdG9ycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHN0YXRlTWFwICYmIHN0YXRlTWFwLmluZGV4T2Yoc3RhdGVzW2ldKSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDY4KTtcbiAgICB9XG5cbiAgICBzZWxlY3RvcnMucHVzaChnZW5lcmF0ZVNlbGVjdG9ycyh0ZW1wbGF0ZSwgc3RhdGVzW2ldKSk7XG4gIH1cblxuICBzZWxlY3RvcnMgPSBzZWxlY3RvcnMuam9pbignLCcpO1xuICByZXR1cm4gc2VsZWN0b3JzO1xufVxuXG52YXIgc3RhdGVNYXAgPSBbdW5kZWZpbmVkLCBudWxsLCAnYWN0aXZlJywgJ2ZvY3VzJywgJ2hvdmVyJ107XG5cbmZ1bmN0aW9uIHRlbXBsYXRlKHN0YXRlKSB7XG4gIHJldHVybiBcImJ1dHRvblwiICsgc3RhdGUgKyBcIixcXG4gIGlucHV0W3R5cGU9XFxcImJ1dHRvblxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgaW5wdXRbdHlwZT1cXFwicmVzZXRcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gIGlucHV0W3R5cGU9XFxcInN1Ym1pdFxcXCJdXCIgKyBzdGF0ZTtcbn1cbi8qKlxuICogUG9wdWxhdGVzIHNlbGVjdG9ycyB0aGF0IHRhcmdldCBhbGwgYnV0dG9ucy4gWW91IGNhbiBwYXNzIG9wdGlvbmFsIHN0YXRlcyB0byBhcHBlbmQgdG8gdGhlIHNlbGVjdG9ycy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIFtidXR0b25zKCdhY3RpdmUnKV06IHtcbiAqICAgICAnYm9yZGVyJzogJ25vbmUnXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgPiAke2J1dHRvbnMoJ2FjdGl2ZScpfSB7XG4gKiAgICAgYm9yZGVyOiBub25lO1xuICogICB9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqICAnYnV0dG9uOmFjdGl2ZSxcbiAqICAnaW5wdXRbdHlwZT1cImJ1dHRvblwiXTphY3RpdmUsXG4gKiAgJ2lucHV0W3R5cGU9XFxcInJlc2V0XFxcIl06YWN0aXZlLFxuICogICdpbnB1dFt0eXBlPVxcXCJzdWJtaXRcXFwiXTphY3RpdmU6IHtcbiAqICAgJ2JvcmRlcic6ICdub25lJ1xuICogfVxuICovXG5cblxuZnVuY3Rpb24gYnV0dG9ucygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0YXRlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdGF0ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gc3RhdGVmdWxTZWxlY3RvcnMoc3RhdGVzLCB0ZW1wbGF0ZSwgc3RhdGVNYXApO1xufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgdXAgdG8gZm91ciB2YWx1ZXMsIGluY2x1ZGluZyBudWxsIHRvIHNraXAgYSB2YWx1ZSwgYW5kIG1hcHMgdGhlbSB0byB0aGVpciByZXNwZWN0aXZlIGRpcmVjdGlvbnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5tYXJnaW4oJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke21hcmdpbignMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnbWFyZ2luVG9wJzogJzEycHgnLFxuICogICAnbWFyZ2luUmlnaHQnOiAnMjRweCcsXG4gKiAgICdtYXJnaW5Cb3R0b20nOiAnMzZweCcsXG4gKiAgICdtYXJnaW5MZWZ0JzogJzQ4cHgnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIG1hcmdpbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnbWFyZ2luJ10uY29uY2F0KHZhbHVlcykpO1xufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgdXAgdG8gZm91ciB2YWx1ZXMsIGluY2x1ZGluZyBudWxsIHRvIHNraXAgYSB2YWx1ZSwgYW5kIG1hcHMgdGhlbSB0byB0aGVpciByZXNwZWN0aXZlIGRpcmVjdGlvbnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5wYWRkaW5nKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtwYWRkaW5nKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdwYWRkaW5nVG9wJzogJzEycHgnLFxuICogICAncGFkZGluZ1JpZ2h0JzogJzI0cHgnLFxuICogICAncGFkZGluZ0JvdHRvbSc6ICczNnB4JyxcbiAqICAgJ3BhZGRpbmdMZWZ0JzogJzQ4cHgnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHBhZGRpbmcoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodm9pZCAwLCBbJ3BhZGRpbmcnXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbnZhciBwb3NpdGlvbk1hcCQxID0gWydhYnNvbHV0ZScsICdmaXhlZCcsICdyZWxhdGl2ZScsICdzdGF0aWMnLCAnc3RpY2t5J107XG4vKipcbiAqIFNob3J0aGFuZCBhY2NlcHRzIHVwIHRvIGZpdmUgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLiBUaGUgZmlyc3QgdmFsdWUgY2FuIG9wdGlvbmFsbHkgYmUgYSBwb3NpdGlvbiBrZXl3b3JkLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ucG9zaXRpb24oJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3Bvc2l0aW9uKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICd0b3AnOiAnMTJweCcsXG4gKiAgICdyaWdodCc6ICcyNHB4JyxcbiAqICAgJ2JvdHRvbSc6ICczNnB4JyxcbiAqICAgJ2xlZnQnOiAnNDhweCdcbiAqIH1cbiAqXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnBvc2l0aW9uKCdhYnNvbHV0ZScsICcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtwb3NpdGlvbignYWJzb2x1dGUnLCAnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxuICogICAndG9wJzogJzEycHgnLFxuICogICAncmlnaHQnOiAnMjRweCcsXG4gKiAgICdib3R0b20nOiAnMzZweCcsXG4gKiAgICdsZWZ0JzogJzQ4cHgnXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gcG9zaXRpb24ocG9zaXRpb25LZXl3b3JkKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAocG9zaXRpb25NYXAkMS5pbmRleE9mKHBvc2l0aW9uS2V5d29yZCkgPj0gMCkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBwb3NpdGlvbjogcG9zaXRpb25LZXl3b3JkXG4gICAgfSwgZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnJ10uY29uY2F0KHZhbHVlcykpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmlyc3RWYWx1ZSA9IHBvc2l0aW9uS2V5d29yZDsgLy8gaW4gdGhpcyBjYXNlIHBvc2l0aW9uIGlzIGFjdHVhbGx5IHRoZSBmaXJzdCB2YWx1ZVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodm9pZCAwLCBbJycsIGZpcnN0VmFsdWVdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0byBzZXQgdGhlIGhlaWdodCBhbmQgd2lkdGggcHJvcGVydGllcyBpbiBhIHNpbmdsZSBzdGF0ZW1lbnQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5zaXplKCczMDBweCcsICcyNTBweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7c2l6ZSgnMzAwcHgnLCAnMjUwcHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2hlaWdodCc6ICczMDBweCcsXG4gKiAgICd3aWR0aCc6ICcyNTBweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHNpemUoaGVpZ2h0LCB3aWR0aCkge1xuICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xuICAgIHdpZHRoID0gaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB3aWR0aDogd2lkdGhcbiAgfTtcbn1cblxudmFyIHN0YXRlTWFwJDEgPSBbdW5kZWZpbmVkLCBudWxsLCAnYWN0aXZlJywgJ2ZvY3VzJywgJ2hvdmVyJ107XG5cbmZ1bmN0aW9uIHRlbXBsYXRlJDEoc3RhdGUpIHtcbiAgcmV0dXJuIFwiaW5wdXRbdHlwZT1cXFwiY29sb3JcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwiZGF0ZVxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJkYXRldGltZVxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJkYXRldGltZS1sb2NhbFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJlbWFpbFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJtb250aFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJudW1iZXJcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwicGFzc3dvcmRcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwic2VhcmNoXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcInRlbFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcInRpbWVcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwidXJsXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcIndlZWtcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXQ6bm90KFt0eXBlXSlcIiArIHN0YXRlICsgXCIsXFxuICAgIHRleHRhcmVhXCIgKyBzdGF0ZTtcbn1cbi8qKlxuICogUG9wdWxhdGVzIHNlbGVjdG9ycyB0aGF0IHRhcmdldCBhbGwgdGV4dCBpbnB1dHMuIFlvdSBjYW4gcGFzcyBvcHRpb25hbCBzdGF0ZXMgdG8gYXBwZW5kIHRvIHRoZSBzZWxlY3RvcnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBbdGV4dElucHV0cygnYWN0aXZlJyldOiB7XG4gKiAgICAgJ2JvcmRlcic6ICdub25lJ1xuICogICB9XG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgID4gJHt0ZXh0SW5wdXRzKCdhY3RpdmUnKX0ge1xuICogICAgIGJvcmRlcjogbm9uZTtcbiAqICAgfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiAgJ2lucHV0W3R5cGU9XCJjb2xvclwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cImRhdGVcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJkYXRldGltZVwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cImRhdGV0aW1lLWxvY2FsXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwiZW1haWxcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJtb250aFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cIm51bWJlclwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cInBhc3N3b3JkXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwic2VhcmNoXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwidGVsXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwidGV4dFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cInRpbWVcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJ1cmxcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJ3ZWVrXCJdOmFjdGl2ZSxcbiAqICBpbnB1dDpub3QoW3R5cGVdKTphY3RpdmUsXG4gKiAgdGV4dGFyZWE6YWN0aXZlJzoge1xuICogICAnYm9yZGVyJzogJ25vbmUnXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiB0ZXh0SW5wdXRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RhdGVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0YXRlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZWZ1bFNlbGVjdG9ycyhzdGF0ZXMsIHRlbXBsYXRlJDEsIHN0YXRlTWFwJDEpO1xufVxuXG4vKipcbiAqIEFjY2VwdHMgYW55IG51bWJlciBvZiB0cmFuc2l0aW9uIHZhbHVlcyBhcyBwYXJhbWV0ZXJzIGZvciBjcmVhdGluZyBhIHNpbmdsZSB0cmFuc2l0aW9uIHN0YXRlbWVudC4gWW91IG1heSBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgcHJvcGVydGllcyBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHRoYXQgeW91IHdvdWxkIGxpa2UgdG8gYXBwbHkgdGhlIHNhbWUgdHJhbmlzaXRpb24gdmFsdWVzIHRvIChzZWNvbmQgcGFyYW1ldGVyKS5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnRyYW5zaXRpb25zKCdvcGFjaXR5IDEuMHMgZWFzZS1pbiAwcycsICd3aWR0aCAyLjBzIGVhc2UtaW4gMnMnKSxcbiAqICAgLi4udHJhbnNpdGlvbnMoWydjb2xvcicsICdiYWNrZ3JvdW5kLWNvbG9yJ10sICcyLjBzIGVhc2UtaW4gMnMnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3RyYW5zaXRpb25zKCdvcGFjaXR5IDEuMHMgZWFzZS1pbiAwcycsICd3aWR0aCAyLjBzIGVhc2UtaW4gMnMnKX07XG4gKiAgICR7dHJhbnNpdGlvbnMoWydjb2xvcicsICdiYWNrZ3JvdW5kLWNvbG9yJ10sICcyLjBzIGVhc2UtaW4gMnMnKSx9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAndHJhbnNpdGlvbic6ICdvcGFjaXR5IDEuMHMgZWFzZS1pbiAwcywgd2lkdGggMi4wcyBlYXNlLWluIDJzJ1xuICogICAndHJhbnNpdGlvbic6ICdjb2xvciAyLjBzIGVhc2UtaW4gMnMsIGJhY2tncm91bmQtY29sb3IgMi4wcyBlYXNlLWluIDJzJyxcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2l0aW9ucygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHByb3BlcnRpZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcHJvcGVydGllc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnRpZXNbMF0pICYmIHByb3BlcnRpZXMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvcGVydGllc1sxXTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2MSk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb25zU3RyaW5nID0gcHJvcGVydGllc1swXS5tYXAoZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gcHJvcGVydHkgKyBcIiBcIiArIHZhbHVlO1xuICAgIH0pLmpvaW4oJywgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25zU3RyaW5nXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNpdGlvbjogcHJvcGVydGllcy5qb2luKCcsICcpXG4gICAgfTtcbiAgfVxufVxuXG4vLyBNYXRoXG5cbmV4cG9ydCB7IGN1cnJpZWRBZGp1c3RIdWUgYXMgYWRqdXN0SHVlLCBhbmltYXRpb24sIGJhY2tncm91bmRJbWFnZXMsIGJhY2tncm91bmRzLCBiZXR3ZWVuLCBib3JkZXIsIGJvcmRlckNvbG9yLCBib3JkZXJSYWRpdXMsIGJvcmRlclN0eWxlLCBib3JkZXJXaWR0aCwgYnV0dG9ucywgY2xlYXJGaXgsIGNvbXBsZW1lbnQsIGNvdmVyLCBjdXJyaWVkRGFya2VuIGFzIGRhcmtlbiwgY3VycmllZERlc2F0dXJhdGUgYXMgZGVzYXR1cmF0ZSwgZGlyZWN0aW9uYWxQcm9wZXJ0eSwgZWxsaXBzaXMsIGVtLCBmbHVpZFJhbmdlLCBmb250RmFjZSwgZ2V0THVtaW5hbmNlLCBnZXRWYWx1ZUFuZFVuaXQsIGdyYXlzY2FsZSwgaW52ZXJ0LCBoaWRlVGV4dCwgaGlkZVZpc3VhbGx5LCBoaURQSSwgaHNsLCBoc2xhLCBoc2xUb0NvbG9yU3RyaW5nLCBjdXJyaWVkTGlnaHRlbiBhcyBsaWdodGVuLCBsaW5lYXJHcmFkaWVudCwgbWFyZ2luLCBtYXRoLCBjdXJyaWVkTWl4IGFzIG1peCwgbW9kdWxhclNjYWxlLCBub3JtYWxpemUsIGN1cnJpZWRPcGFjaWZ5IGFzIG9wYWNpZnksIHBhZGRpbmcsIHBhcnNlVG9Ic2wsIHBhcnNlVG9SZ2IsIHBvc2l0aW9uLCByYWRpYWxHcmFkaWVudCwgcmVhZGFibGVDb2xvciwgcmVtLCByZXRpbmFJbWFnZSwgcmdiLCByZ2JhLCByZ2JUb0NvbG9yU3RyaW5nLCBjdXJyaWVkU2F0dXJhdGUgYXMgc2F0dXJhdGUsIGN1cnJpZWRTZXRIdWUgYXMgc2V0SHVlLCBjdXJyaWVkU2V0TGlnaHRuZXNzIGFzIHNldExpZ2h0bmVzcywgY3VycmllZFNldFNhdHVyYXRpb24gYXMgc2V0U2F0dXJhdGlvbiwgY3VycmllZFNoYWRlIGFzIHNoYWRlLCBzaXplLCBzdHJpcFVuaXQsIHRleHRJbnB1dHMsIHRpbWluZ0Z1bmN0aW9ucywgY3VycmllZFRpbnQgYXMgdGludCwgdG9Db2xvclN0cmluZywgdHJhbnNpdGlvbnMsIGN1cnJpZWRUcmFuc3BhcmVudGl6ZSBhcyB0cmFuc3BhcmVudGl6ZSwgdHJpYW5nbGUsIHdvcmRXcmFwIH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiX2luaGVyaXRzTG9vc2UiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlIiwibGFzdCIsIl9yZWYiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJuZWdhdGlvbiIsImEiLCJhZGRpdGlvbiIsImIiLCJzdWJ0cmFjdGlvbiIsIm11bHRpcGxpY2F0aW9uIiwiZGl2aXNpb24iLCJmYWN0b3JpYWwiLCJOYU4iLCJJbmZpbml0eSIsInBvd2VyIiwiTWF0aCIsInBvdyIsInNxcnQiLCJtYXgiLCJhcHBseSIsIm1pbiIsImNvbW1hIiwiQXJyYXkiLCJvZiIsImRlZmF1bHRNYXRoU3ltYm9scyIsInN5bWJvbHMiLCJwb3N0Zml4Iiwic3ltYm9sIiwiZiIsIm5vdGF0aW9uIiwicHJlY2VkZW5jZSIsInJpZ2h0VG9MZWZ0IiwiYXJnQ291bnQiLCJyZWdTeW1ib2wiLCJpbmZpeCIsInByZWZpeCIsImZ1bmMiLCJFUlJPUlMiLCJmb3JtYXQiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJjIiwicHVzaCIsImZvckVhY2giLCJkIiwicmVwbGFjZSIsIlBvbGlzaGVkRXJyb3IiLCJfRXJyb3IiLCJjb2RlIiwiX3RoaXMiLCJwcm9jZXNzIiwiY2FsbCIsIl9sZW4yIiwiX2tleTIiLCJjb25jYXQiLCJFcnJvciIsInVuaXRSZWdFeHAiLCJtZXJnZVN5bWJvbE1hcHMiLCJhZGRpdGlvbmFsU3ltYm9scyIsInN5bWJvbE1hcCIsImV4ZWMiLCJvcGVyYXRvcnMiLCJ2YWx1ZXMiLCJvcCIsInBvcCIsInNwbGljZSIsImNhbGN1bGF0ZSIsImV4cHJlc3Npb24iLCJtYXRjaCIsInBhdHRlcm4iLCJSZWdFeHAiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwia2V5Iiwic29ydCIsInZhbCIsImpvaW4iLCJsYXN0SW5kZXgiLCJhZnRlclZhbHVlIiwiX3JlZjIiLCJ0b2tlbiIsImJhZCIsIm5vdE51bWJlciIsIm5vdE5ld1ZhbHVlIiwibm90QWZ0ZXJWYWx1ZSIsImluZGV4IiwiY3VyciIsInByZXYiLCJyZXZlcnNlU3RyaW5nIiwic3RyIiwic3BsaXQiLCJyZXZlcnNlIiwibWF0aCIsImZvcm11bGEiLCJyZXZlcnNlZEZvcm11bGEiLCJmb3JtdWxhTWF0Y2giLCJldmVyeSIsInVuaXQiLCJjbGVhbkZvcm11bGEiLCJjYXBpdGFsaXplU3RyaW5nIiwic3RyaW5nIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsInBvc2l0aW9uTWFwIiwiZ2VuZXJhdGVQcm9wZXJ0eSIsInByb3BlcnR5IiwicG9zaXRpb24iLCJ0b0xvd2VyQ2FzZSIsInNwbGl0UHJvcGVydHkiLCJyZWR1Y2UiLCJhY2MiLCJqb2luZWRQcm9wZXJ0eSIsImdlbmVyYXRlU3R5bGVzIiwidmFsdWVzV2l0aERlZmF1bHRzIiwic3R5bGVzIiwiaSIsImRpcmVjdGlvbmFsUHJvcGVydHkiLCJmaXJzdFZhbHVlIiwiX3ZhbHVlcyQiLCJzZWNvbmRWYWx1ZSIsIl92YWx1ZXMkMiIsInRoaXJkVmFsdWUiLCJfdmFsdWVzJDMiLCJmb3VydGhWYWx1ZSIsImVuZHNXaXRoIiwic3VmZml4Iiwic3Vic3RyIiwiY3NzUmVnZXgiLCJzdHJpcFVuaXQiLCJ2YWx1ZSIsInVuaXRSZXR1cm4iLCJtYXRjaGVkVmFsdWUiLCJwYXJzZUZsb2F0IiwicHh0b0ZhY3RvcnkiLCJ0byIsInB4dmFsIiwiYmFzZSIsIm5ld1B4dmFsIiwibmV3QmFzZSIsImVtIiwiY3NzUmVnZXgkMSIsImdldFZhbHVlQW5kVW5pdCIsImNvbnNvbGUiLCJ3YXJuIiwicmF0aW9OYW1lcyIsIm1pbm9yU2Vjb25kIiwibWFqb3JTZWNvbmQiLCJtaW5vclRoaXJkIiwibWFqb3JUaGlyZCIsInBlcmZlY3RGb3VydGgiLCJhdWdGb3VydGgiLCJwZXJmZWN0RmlmdGgiLCJtaW5vclNpeHRoIiwiZ29sZGVuU2VjdGlvbiIsIm1ham9yU2l4dGgiLCJtaW5vclNldmVudGgiLCJtYWpvclNldmVudGgiLCJvY3RhdmUiLCJtYWpvclRlbnRoIiwibWFqb3JFbGV2ZW50aCIsIm1ham9yVHdlbGZ0aCIsImRvdWJsZU9jdGF2ZSIsImdldFJhdGlvIiwicmF0aW9OYW1lIiwibW9kdWxhclNjYWxlIiwic3RlcHMiLCJyYXRpbyIsInJlYWxCYXNlIiwicmVhbFJhdGlvIiwicmVtIiwiYmV0d2VlbiIsImZyb21TaXplIiwidG9TaXplIiwibWluU2NyZWVuIiwibWF4U2NyZWVuIiwiX3N0cmlwVW5pdCIsInVuaXRsZXNzRnJvbVNpemUiLCJmcm9tU2l6ZVVuaXQiLCJfc3RyaXBVbml0MiIsInVuaXRsZXNzVG9TaXplIiwidG9TaXplVW5pdCIsIl9zdHJpcFVuaXQzIiwidW5pdGxlc3NNaW5TY3JlZW4iLCJtaW5TY3JlZW5Vbml0IiwiX3N0cmlwVW5pdDQiLCJ1bml0bGVzc01heFNjcmVlbiIsIm1heFNjcmVlblVuaXQiLCJzbG9wZSIsInRvRml4ZWQiLCJjbGVhckZpeCIsInBhcmVudCIsInBzZXVkb1NlbGVjdG9yIiwiY2xlYXIiLCJjb250ZW50IiwiZGlzcGxheSIsImNvdmVyIiwib2Zmc2V0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiZWxsaXBzaXMiLCJ3aWR0aCIsIm1heFdpZHRoIiwib3ZlcmZsb3ciLCJ0ZXh0T3ZlcmZsb3ciLCJ3aGl0ZVNwYWNlIiwid29yZFdyYXAiLCJmbHVpZFJhbmdlIiwiY3NzUHJvcCIsImlzQXJyYXkiLCJtZWRpYVF1ZXJpZXMiLCJmYWxsYmFja3MiLCJfaXRlcmF0b3IiLCJfaXNBcnJheSIsIl9pIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfZXh0ZW5kczIiLCJfZXh0ZW5kczMiLCJuZXh0IiwiZG9uZSIsIm9iaiIsInByb3AiLCJfcmVmMyIsIl9yZWY0IiwiZ2VuZXJhdGVGaWxlUmVmZXJlbmNlcyIsImZvbnRGaWxlUGF0aCIsImZpbGVGb3JtYXRzIiwiZmlsZUZvbnRSZWZlcmVuY2VzIiwiZ2VuZXJhdGVMb2NhbFJlZmVyZW5jZXMiLCJsb2NhbEZvbnRzIiwibG9jYWxGb250UmVmZXJlbmNlcyIsImZvbnQiLCJnZW5lcmF0ZVNvdXJjZXMiLCJmb250UmVmZXJlbmNlcyIsImZvbnRGYWNlIiwiZm9udEZhbWlseSIsImZvbnRTdHJldGNoIiwiZm9udFN0eWxlIiwiZm9udFZhcmlhbnQiLCJmb250V2VpZ2h0IiwiX3JlZiRmaWxlRm9ybWF0cyIsInVuaWNvZGVSYW5nZSIsImZvbnREaXNwbGF5IiwiZm9udFZhcmlhdGlvblNldHRpbmdzIiwiZm9udEZlYXR1cmVTZXR0aW5ncyIsImZvbnRGYWNlRGVjbGFyYXRpb24iLCJzcmMiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJoaWRlVGV4dCIsInRleHRJbmRlbnQiLCJoaWRlVmlzdWFsbHkiLCJib3JkZXIiLCJjbGlwIiwiY2xpcFBhdGgiLCJoZWlnaHQiLCJtYXJnaW4iLCJwYWRkaW5nIiwiaGlEUEkiLCJyb3VuZCIsImNvbnN0cnVjdEdyYWRpZW50VmFsdWUiLCJsaXRlcmFscyIsInRlbXBsYXRlIiwic3Vic3RpdHV0aW9ucyIsImRlZmluZWRWYWx1ZXMiLCJmaWx0ZXIiLCJzdWJzdGl0dXRlIiwidHJpbSIsIl90ZW1wbGF0ZU9iamVjdCIsImRhdGEiLCJsaW5lYXJHcmFkaWVudCIsImNvbG9yU3RvcHMiLCJmYWxsYmFjayIsIl9yZWYkdG9EaXJlY3Rpb24iLCJ0b0RpcmVjdGlvbiIsImJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRJbWFnZSIsIm5vcm1hbGl6ZSIsImh0bWwiLCJsaW5lSGVpZ2h0IiwidGV4dFNpemVBZGp1c3QiLCJib2R5IiwiaDEiLCJmb250U2l6ZSIsImhyIiwiYm94U2l6aW5nIiwicHJlIiwiYm9yZGVyQm90dG9tIiwidGV4dERlY29yYXRpb24iLCJzbWFsbCIsInZlcnRpY2FsQWxpZ24iLCJzdWIiLCJzdXAiLCJpbWciLCJib3JkZXJTdHlsZSIsInRleHRUcmFuc2Zvcm0iLCJXZWJraXRBcHBlYXJhbmNlIiwib3V0bGluZSIsImZpZWxkc2V0IiwibGVnZW5kIiwiY29sb3IiLCJwcm9ncmVzcyIsInRleHRhcmVhIiwib3V0bGluZU9mZnNldCIsImRldGFpbHMiLCJzdW1tYXJ5IiwiX3RlbXBsYXRlT2JqZWN0JDEiLCJyYWRpYWxHcmFkaWVudCIsIl9yZWYkZXh0ZW50IiwiZXh0ZW50IiwiX3JlZiRwb3NpdGlvbiIsIl9yZWYkc2hhcGUiLCJzaGFwZSIsInJldGluYUltYWdlIiwiZmlsZW5hbWUiLCJiYWNrZ3JvdW5kU2l6ZSIsImV4dGVuc2lvbiIsInJldGluYUZpbGVuYW1lIiwicmV0aW5hU3VmZml4IiwiZXh0IiwickZpbGVuYW1lIiwiZnVuY3Rpb25zTWFwIiwiZWFzZUluQmFjayIsImVhc2VJbkNpcmMiLCJlYXNlSW5DdWJpYyIsImVhc2VJbkV4cG8iLCJlYXNlSW5RdWFkIiwiZWFzZUluUXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VJblNpbmUiLCJlYXNlT3V0QmFjayIsImVhc2VPdXRDdWJpYyIsImVhc2VPdXRDaXJjIiwiZWFzZU91dEV4cG8iLCJlYXNlT3V0UXVhZCIsImVhc2VPdXRRdWFydCIsImVhc2VPdXRRdWludCIsImVhc2VPdXRTaW5lIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJbk91dEV4cG8iLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJbk91dFNpbmUiLCJnZXRUaW1pbmdGdW5jdGlvbiIsImZ1bmN0aW9uTmFtZSIsInRpbWluZ0Z1bmN0aW9ucyIsInRpbWluZ0Z1bmN0aW9uIiwiYm9yZGVyQ29sb3IiLCJnZXRCb3JkZXJXaWR0aCIsInBvaW50aW5nRGlyZWN0aW9uIiwicmV2ZXJzZURpcmVjdGlvbiIsIk5VTUJFUl9BTkRfRkxPQVQiLCJ0cmlhbmdsZSIsImZvcmVncm91bmRDb2xvciIsIl9yZWYkYmFja2dyb3VuZENvbG9yIiwid2lkdGhBbmRVbml0IiwiU3RyaW5nIiwiaGVpZ2h0QW5kVW5pdCIsImlzTmFOIiwicmV2ZXJzZURpcmVjdGlvbkluZGV4IiwiaW5kZXhPZiIsImJvcmRlcldpZHRoIiwiZnJvbSIsIl8iLCJ3cmFwIiwid29yZEJyZWFrIiwib3ZlcmZsb3dXcmFwIiwiY29sb3JUb0ludCIsImNvbnZlcnRUb0ludCIsInJlZCIsImdyZWVuIiwiYmx1ZSIsImhzbFRvUmdiIiwiaHVlIiwic2F0dXJhdGlvbiIsImxpZ2h0bmVzcyIsImNvbnZlcnQiLCJodWVQcmltZSIsImNocm9tYSIsImFicyIsInNlY29uZENvbXBvbmVudCIsImxpZ2h0bmVzc01vZGlmaWNhdGlvbiIsImZpbmFsUmVkIiwiZmluYWxHcmVlbiIsImZpbmFsQmx1ZSIsIm5hbWVkQ29sb3JNYXAiLCJhbGljZWJsdWUiLCJhbnRpcXVld2hpdGUiLCJhcXVhIiwiYXF1YW1hcmluZSIsImF6dXJlIiwiYmVpZ2UiLCJiaXNxdWUiLCJibGFjayIsImJsYW5jaGVkYWxtb25kIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiY2FkZXRibHVlIiwiY2hhcnRyZXVzZSIsImNob2NvbGF0ZSIsImNvcmFsIiwiY29ybmZsb3dlcmJsdWUiLCJjb3Juc2lsayIsImNyaW1zb24iLCJjeWFuIiwiZGFya2JsdWUiLCJkYXJrY3lhbiIsImRhcmtnb2xkZW5yb2QiLCJkYXJrZ3JheSIsImRhcmtncmVlbiIsImRhcmtncmV5IiwiZGFya2toYWtpIiwiZGFya21hZ2VudGEiLCJkYXJrb2xpdmVncmVlbiIsImRhcmtvcmFuZ2UiLCJkYXJrb3JjaGlkIiwiZGFya3JlZCIsImRhcmtzYWxtb24iLCJkYXJrc2VhZ3JlZW4iLCJkYXJrc2xhdGVibHVlIiwiZGFya3NsYXRlZ3JheSIsImRhcmtzbGF0ZWdyZXkiLCJkYXJrdHVycXVvaXNlIiwiZGFya3Zpb2xldCIsImRlZXBwaW5rIiwiZGVlcHNreWJsdWUiLCJkaW1ncmF5IiwiZGltZ3JleSIsImRvZGdlcmJsdWUiLCJmaXJlYnJpY2siLCJmbG9yYWx3aGl0ZSIsImZvcmVzdGdyZWVuIiwiZnVjaHNpYSIsImdhaW5zYm9ybyIsImdob3N0d2hpdGUiLCJnb2xkIiwiZ29sZGVucm9kIiwiZ3JheSIsImdyZWVueWVsbG93IiwiZ3JleSIsImhvbmV5ZGV3IiwiaG90cGluayIsImluZGlhbnJlZCIsImluZGlnbyIsIml2b3J5Iiwia2hha2kiLCJsYXZlbmRlciIsImxhdmVuZGVyYmx1c2giLCJsYXduZ3JlZW4iLCJsZW1vbmNoaWZmb24iLCJsaWdodGJsdWUiLCJsaWdodGNvcmFsIiwibGlnaHRjeWFuIiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaWdodGdyYXkiLCJsaWdodGdyZWVuIiwibGlnaHRncmV5IiwibGlnaHRwaW5rIiwibGlnaHRzYWxtb24iLCJsaWdodHNlYWdyZWVuIiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlZ3JleSIsImxpZ2h0c3RlZWxibHVlIiwibGlnaHR5ZWxsb3ciLCJsaW1lIiwibGltZWdyZWVuIiwibGluZW4iLCJtYWdlbnRhIiwibWFyb29uIiwibWVkaXVtYXF1YW1hcmluZSIsIm1lZGl1bWJsdWUiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW1wdXJwbGUiLCJtZWRpdW1zZWFncmVlbiIsIm1lZGl1bXNsYXRlYmx1ZSIsIm1lZGl1bXNwcmluZ2dyZWVuIiwibWVkaXVtdHVycXVvaXNlIiwibWVkaXVtdmlvbGV0cmVkIiwibWlkbmlnaHRibHVlIiwibWludGNyZWFtIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJuYXZham93aGl0ZSIsIm5hdnkiLCJvbGRsYWNlIiwib2xpdmUiLCJvbGl2ZWRyYWIiLCJvcmFuZ2UiLCJvcmFuZ2VyZWQiLCJvcmNoaWQiLCJwYWxlZ29sZGVucm9kIiwicGFsZWdyZWVuIiwicGFsZXR1cnF1b2lzZSIsInBhbGV2aW9sZXRyZWQiLCJwYXBheWF3aGlwIiwicGVhY2hwdWZmIiwicGVydSIsInBpbmsiLCJwbHVtIiwicG93ZGVyYmx1ZSIsInB1cnBsZSIsInJlYmVjY2FwdXJwbGUiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRhbiIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsIm5hbWVUb0hleCIsIm5vcm1hbGl6ZWRDb2xvck5hbWUiLCJoZXhSZWdleCIsImhleFJnYmFSZWdleCIsInJlZHVjZWRIZXhSZWdleCIsInJlZHVjZWRSZ2JhSGV4UmVnZXgiLCJyZ2JSZWdleCIsInJnYmFSZWdleCIsImhzbFJlZ2V4IiwiaHNsYVJlZ2V4IiwicGFyc2VUb1JnYiIsIm5vcm1hbGl6ZWRDb2xvciIsInBhcnNlSW50IiwiYWxwaGEiLCJfYWxwaGEiLCJyZ2JNYXRjaGVkIiwicmdiYU1hdGNoZWQiLCJoc2xNYXRjaGVkIiwicmdiQ29sb3JTdHJpbmciLCJoc2xSZ2JNYXRjaGVkIiwiaHNsYU1hdGNoZWQiLCJfaHVlIiwiX3NhdHVyYXRpb24iLCJfbGlnaHRuZXNzIiwiX3JnYkNvbG9yU3RyaW5nIiwiX2hzbFJnYk1hdGNoZWQiLCJyZ2JUb0hzbCIsImRlbHRhIiwicGFyc2VUb0hzbCIsInJlZHVjZUhleFZhbHVlIiwibnVtYmVyVG9IZXgiLCJoZXgiLCJ0b1N0cmluZyIsImNvbG9yVG9IZXgiLCJjb252ZXJ0VG9IZXgiLCJoc2xUb0hleCIsImhzbCIsImhzbGEiLCJyZ2IiLCJyZ2JhIiwicmdiVmFsdWUiLCJpc1JnYiIsImlzUmdiYSIsImlzSHNsIiwiaXNIc2xhIiwidG9Db2xvclN0cmluZyIsImN1cnJpZWQiLCJmbiIsImNvbWJpbmVkIiwicHJvdG90eXBlIiwiY3VycnkiLCJhZGp1c3RIdWUiLCJkZWdyZWUiLCJoc2xDb2xvciIsImN1cnJpZWRBZGp1c3RIdWUiLCJjb21wbGVtZW50IiwiZ3VhcmQiLCJsb3dlckJvdW5kYXJ5IiwidXBwZXJCb3VuZGFyeSIsImRhcmtlbiIsImFtb3VudCIsImN1cnJpZWREYXJrZW4iLCJkZXNhdHVyYXRlIiwiY3VycmllZERlc2F0dXJhdGUiLCJnZXRMdW1pbmFuY2UiLCJyZ2JDb2xvciIsIl9PYmplY3Qka2V5cyRtYXAiLCJjaGFubmVsIiwiciIsImciLCJncmF5c2NhbGUiLCJoc2xUb0NvbG9yU3RyaW5nIiwiaW52ZXJ0IiwibGlnaHRlbiIsImN1cnJpZWRMaWdodGVuIiwibWl4Iiwid2VpZ2h0Iiwib3RoZXJDb2xvciIsInBhcnNlZENvbG9yMSIsImNvbG9yMSIsInBhcnNlZENvbG9yMiIsImNvbG9yMiIsImFscGhhRGVsdGEiLCJ4IiwieSIsInoiLCJ3ZWlnaHQxIiwid2VpZ2h0MiIsIm1peGVkQ29sb3IiLCJmbG9vciIsImN1cnJpZWRNaXgiLCJvcGFjaWZ5IiwicGFyc2VkQ29sb3IiLCJjb2xvcldpdGhBbHBoYSIsImN1cnJpZWRPcGFjaWZ5IiwicmVhZGFibGVDb2xvciIsImxpZ2h0UmV0dXJuQ29sb3IiLCJkYXJrUmV0dXJuQ29sb3IiLCJyZ2JUb0NvbG9yU3RyaW5nIiwic2F0dXJhdGUiLCJjdXJyaWVkU2F0dXJhdGUiLCJzZXRIdWUiLCJjdXJyaWVkU2V0SHVlIiwic2V0TGlnaHRuZXNzIiwiY3VycmllZFNldExpZ2h0bmVzcyIsInNldFNhdHVyYXRpb24iLCJjdXJyaWVkU2V0U2F0dXJhdGlvbiIsInNoYWRlIiwicGVyY2VudGFnZSIsImN1cnJpZWRTaGFkZSIsInRpbnQiLCJjdXJyaWVkVGludCIsInRyYW5zcGFyZW50aXplIiwiY3VycmllZFRyYW5zcGFyZW50aXplIiwiYW5pbWF0aW9uIiwibXVsdGlNb2RlIiwiYXJnIiwiYmFja2dyb3VuZEltYWdlcyIsInByb3BlcnRpZXMiLCJiYWNrZ3JvdW5kcyIsImJhY2tncm91bmQiLCJzaWRlTWFwIiwic2lkZUtleXdvcmQiLCJ1bnNoaWZ0IiwiYm9yZGVyUmFkaXVzIiwic2lkZSIsInJhZGl1cyIsInVwcGVyY2FzZVNpZGUiLCJnZW5lcmF0ZVNlbGVjdG9ycyIsInN0YXRlIiwic3RhdGVTdWZmaXgiLCJzdGF0ZWZ1bFNlbGVjdG9ycyIsInN0YXRlcyIsInN0YXRlTWFwIiwic2VsZWN0b3JzIiwiYnV0dG9ucyIsInBvc2l0aW9uTWFwJDEiLCJwb3NpdGlvbktleXdvcmQiLCJzaXplIiwic3RhdGVNYXAkMSIsInRlbXBsYXRlJDEiLCJ0ZXh0SW5wdXRzIiwidHJhbnNpdGlvbnMiLCJ0cmFuc2l0aW9uc1N0cmluZyIsInRyYW5zaXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/polished/dist/polished.es.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/polished/dist/polished.es.js":
/*!***************************************************!*\
  !*** ./node_modules/polished/dist/polished.es.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adjustHue: () => (/* binding */ curriedAdjustHue),\n/* harmony export */   animation: () => (/* binding */ animation),\n/* harmony export */   backgroundImages: () => (/* binding */ backgroundImages),\n/* harmony export */   backgrounds: () => (/* binding */ backgrounds),\n/* harmony export */   between: () => (/* binding */ between),\n/* harmony export */   border: () => (/* binding */ border),\n/* harmony export */   borderColor: () => (/* binding */ borderColor),\n/* harmony export */   borderRadius: () => (/* binding */ borderRadius),\n/* harmony export */   borderStyle: () => (/* binding */ borderStyle),\n/* harmony export */   borderWidth: () => (/* binding */ borderWidth),\n/* harmony export */   buttons: () => (/* binding */ buttons),\n/* harmony export */   clearFix: () => (/* binding */ clearFix),\n/* harmony export */   complement: () => (/* binding */ complement),\n/* harmony export */   cover: () => (/* binding */ cover),\n/* harmony export */   darken: () => (/* binding */ curriedDarken),\n/* harmony export */   desaturate: () => (/* binding */ curriedDesaturate),\n/* harmony export */   directionalProperty: () => (/* binding */ directionalProperty),\n/* harmony export */   ellipsis: () => (/* binding */ ellipsis),\n/* harmony export */   em: () => (/* binding */ em),\n/* harmony export */   fluidRange: () => (/* binding */ fluidRange),\n/* harmony export */   fontFace: () => (/* binding */ fontFace),\n/* harmony export */   getLuminance: () => (/* binding */ getLuminance),\n/* harmony export */   getValueAndUnit: () => (/* binding */ getValueAndUnit),\n/* harmony export */   grayscale: () => (/* binding */ grayscale),\n/* harmony export */   hiDPI: () => (/* binding */ hiDPI),\n/* harmony export */   hideText: () => (/* binding */ hideText),\n/* harmony export */   hideVisually: () => (/* binding */ hideVisually),\n/* harmony export */   hsl: () => (/* binding */ hsl),\n/* harmony export */   hslToColorString: () => (/* binding */ hslToColorString),\n/* harmony export */   hsla: () => (/* binding */ hsla),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   lighten: () => (/* binding */ curriedLighten),\n/* harmony export */   linearGradient: () => (/* binding */ linearGradient),\n/* harmony export */   margin: () => (/* binding */ margin),\n/* harmony export */   math: () => (/* binding */ math),\n/* harmony export */   mix: () => (/* binding */ curriedMix),\n/* harmony export */   modularScale: () => (/* binding */ modularScale),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   opacify: () => (/* binding */ curriedOpacify),\n/* harmony export */   padding: () => (/* binding */ padding),\n/* harmony export */   parseToHsl: () => (/* binding */ parseToHsl),\n/* harmony export */   parseToRgb: () => (/* binding */ parseToRgb),\n/* harmony export */   position: () => (/* binding */ position),\n/* harmony export */   radialGradient: () => (/* binding */ radialGradient),\n/* harmony export */   readableColor: () => (/* binding */ readableColor),\n/* harmony export */   rem: () => (/* binding */ rem),\n/* harmony export */   retinaImage: () => (/* binding */ retinaImage),\n/* harmony export */   rgb: () => (/* binding */ rgb),\n/* harmony export */   rgbToColorString: () => (/* binding */ rgbToColorString),\n/* harmony export */   rgba: () => (/* binding */ rgba),\n/* harmony export */   saturate: () => (/* binding */ curriedSaturate),\n/* harmony export */   setHue: () => (/* binding */ curriedSetHue),\n/* harmony export */   setLightness: () => (/* binding */ curriedSetLightness),\n/* harmony export */   setSaturation: () => (/* binding */ curriedSetSaturation),\n/* harmony export */   shade: () => (/* binding */ curriedShade),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   stripUnit: () => (/* binding */ stripUnit),\n/* harmony export */   textInputs: () => (/* binding */ textInputs),\n/* harmony export */   timingFunctions: () => (/* binding */ timingFunctions),\n/* harmony export */   tint: () => (/* binding */ curriedTint),\n/* harmony export */   toColorString: () => (/* binding */ toColorString),\n/* harmony export */   transitions: () => (/* binding */ transitions),\n/* harmony export */   transparentize: () => (/* binding */ curriedTransparentize),\n/* harmony export */   triangle: () => (/* binding */ triangle),\n/* harmony export */   wordWrap: () => (/* binding */ wordWrap)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(rsc)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ \"(rsc)/./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"(rsc)/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/wrapNativeSuper */ \"(rsc)/./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/taggedTemplateLiteralLoose */ \"(rsc)/./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js\");\n\n\n\n\n\nfunction last() {\n    var _ref;\n    return _ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref];\n}\nfunction negation(a) {\n    return -a;\n}\nfunction addition(a, b) {\n    return a + b;\n}\nfunction subtraction(a, b) {\n    return a - b;\n}\nfunction multiplication(a, b) {\n    return a * b;\n}\nfunction division(a, b) {\n    return a / b;\n}\nfunction factorial(a) {\n    if (a % 1 || !(+a >= 0)) return NaN;\n    if (a > 170) return Infinity;\n    else if (a === 0) return 1;\n    else {\n        return a * factorial(a - 1);\n    }\n}\nfunction power(a, b) {\n    return Math.pow(a, b);\n}\nfunction sqrt(a) {\n    return Math.sqrt(a);\n}\nfunction max() {\n    return Math.max.apply(Math, arguments);\n}\nfunction min() {\n    return Math.min.apply(Math, arguments);\n}\nfunction comma() {\n    return Array.of.apply(Array, arguments);\n}\nvar defaultMathSymbols = {\n    symbols: {\n        \"!\": {\n            postfix: {\n                symbol: \"!\",\n                f: factorial,\n                notation: \"postfix\",\n                precedence: 6,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"!\",\n            regSymbol: \"!\"\n        },\n        \"^\": {\n            infix: {\n                symbol: \"^\",\n                f: power,\n                notation: \"infix\",\n                precedence: 5,\n                rightToLeft: 1,\n                argCount: 2\n            },\n            symbol: \"^\",\n            regSymbol: \"\\\\^\"\n        },\n        \"*\": {\n            infix: {\n                symbol: \"*\",\n                f: multiplication,\n                notation: \"infix\",\n                precedence: 4,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \"*\",\n            regSymbol: \"\\\\*\"\n        },\n        \"/\": {\n            infix: {\n                symbol: \"/\",\n                f: division,\n                notation: \"infix\",\n                precedence: 4,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \"/\",\n            regSymbol: \"/\"\n        },\n        \"+\": {\n            infix: {\n                symbol: \"+\",\n                f: addition,\n                notation: \"infix\",\n                precedence: 2,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            prefix: {\n                symbol: \"+\",\n                f: last,\n                notation: \"prefix\",\n                precedence: 3,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"+\",\n            regSymbol: \"\\\\+\"\n        },\n        \"-\": {\n            infix: {\n                symbol: \"-\",\n                f: subtraction,\n                notation: \"infix\",\n                precedence: 2,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            prefix: {\n                symbol: \"-\",\n                f: negation,\n                notation: \"prefix\",\n                precedence: 3,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"-\",\n            regSymbol: \"-\"\n        },\n        \",\": {\n            infix: {\n                symbol: \",\",\n                f: comma,\n                notation: \"infix\",\n                precedence: 1,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \",\",\n            regSymbol: \",\"\n        },\n        \"(\": {\n            prefix: {\n                symbol: \"(\",\n                f: last,\n                notation: \"prefix\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"(\",\n            regSymbol: \"\\\\(\"\n        },\n        \")\": {\n            postfix: {\n                symbol: \")\",\n                f: undefined,\n                notation: \"postfix\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \")\",\n            regSymbol: \"\\\\)\"\n        },\n        min: {\n            func: {\n                symbol: \"min\",\n                f: min,\n                notation: \"func\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"min\",\n            regSymbol: \"min\\\\b\"\n        },\n        max: {\n            func: {\n                symbol: \"max\",\n                f: max,\n                notation: \"func\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"max\",\n            regSymbol: \"max\\\\b\"\n        },\n        sqrt: {\n            func: {\n                symbol: \"sqrt\",\n                f: sqrt,\n                notation: \"func\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"sqrt\",\n            regSymbol: \"sqrt\\\\b\"\n        }\n    }\n};\n// based on https://github.com/styled-components/styled-components/blob/fcf6f3804c57a14dd7984dfab7bc06ee2edca044/src/utils/error.js\n/**\n * Parse errors.md and turn it into a simple hash of code: message\n * @private\n */ var ERRORS = {\n    \"1\": \"Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\\n\\n\",\n    \"2\": \"Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\\n\\n\",\n    \"3\": \"Passed an incorrect argument to a color function, please pass a string representation of a color.\\n\\n\",\n    \"4\": \"Couldn't generate valid rgb string from %s, it returned %s.\\n\\n\",\n    \"5\": \"Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\\n\\n\",\n    \"6\": \"Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\\n\\n\",\n    \"7\": \"Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\\n\\n\",\n    \"8\": \"Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\\n\\n\",\n    \"9\": \"Please provide a number of steps to the modularScale helper.\\n\\n\",\n    \"10\": \"Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\\n\\n\",\n    \"11\": 'Invalid value passed as base to modularScale, expected number or em string but got \"%s\"\\n\\n',\n    \"12\": 'Expected a string ending in \"px\" or a number passed as the first argument to %s(), got \"%s\" instead.\\n\\n',\n    \"13\": 'Expected a string ending in \"px\" or a number passed as the second argument to %s(), got \"%s\" instead.\\n\\n',\n    \"14\": 'Passed invalid pixel value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"15\": 'Passed invalid base value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"16\": \"You must provide a template to this method.\\n\\n\",\n    \"17\": \"You passed an unsupported selector state to this method.\\n\\n\",\n    \"18\": \"minScreen and maxScreen must be provided as stringified numbers with the same units.\\n\\n\",\n    \"19\": \"fromSize and toSize must be provided as stringified numbers with the same units.\\n\\n\",\n    \"20\": \"expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\\n\\n\",\n    \"21\": \"expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n    \"22\": \"expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n    \"23\": \"fontFace expects a name of a font-family.\\n\\n\",\n    \"24\": \"fontFace expects either the path to the font file(s) or a name of a local copy.\\n\\n\",\n    \"25\": \"fontFace expects localFonts to be an array.\\n\\n\",\n    \"26\": \"fontFace expects fileFormats to be an array.\\n\\n\",\n    \"27\": \"radialGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"28\": \"Please supply a filename to retinaImage() as the first argument.\\n\\n\",\n    \"29\": \"Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\\n\\n\",\n    \"30\": \"Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\\n\\n\",\n    \"31\": \"The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\\n\\n\",\n    \"32\": \"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\\n\\n\",\n    \"33\": \"The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\\n\\n\",\n    \"34\": \"borderRadius expects a radius value as a string or number as the second argument.\\n\\n\",\n    \"35\": 'borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\\n\\n',\n    \"36\": \"Property must be a string value.\\n\\n\",\n    \"37\": \"Syntax Error at %s.\\n\\n\",\n    \"38\": \"Formula contains a function that needs parentheses at %s.\\n\\n\",\n    \"39\": \"Formula is missing closing parenthesis at %s.\\n\\n\",\n    \"40\": \"Formula has too many closing parentheses at %s.\\n\\n\",\n    \"41\": \"All values in a formula must have the same unit or be unitless.\\n\\n\",\n    \"42\": \"Please provide a number of steps to the modularScale helper.\\n\\n\",\n    \"43\": \"Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\\n\\n\",\n    \"44\": \"Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\\n\\n\",\n    \"45\": \"Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\\n\\n\",\n    \"46\": \"Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\\n\\n\",\n    \"47\": \"minScreen and maxScreen must be provided as stringified numbers with the same units.\\n\\n\",\n    \"48\": \"fromSize and toSize must be provided as stringified numbers with the same units.\\n\\n\",\n    \"49\": \"Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\\n\\n\",\n    \"50\": \"Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\\n\\n\",\n    \"51\": \"Expects the first argument object to have the properties prop, fromSize, and toSize.\\n\\n\",\n    \"52\": \"fontFace expects either the path to the font file(s) or a name of a local copy.\\n\\n\",\n    \"53\": \"fontFace expects localFonts to be an array.\\n\\n\",\n    \"54\": \"fontFace expects fileFormats to be an array.\\n\\n\",\n    \"55\": \"fontFace expects a name of a font-family.\\n\\n\",\n    \"56\": \"linearGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"57\": \"radialGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"58\": \"Please supply a filename to retinaImage() as the first argument.\\n\\n\",\n    \"59\": \"Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\\n\\n\",\n    \"60\": \"Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\\n\\n\",\n    \"61\": \"Property must be a string value.\\n\\n\",\n    \"62\": \"borderRadius expects a radius value as a string or number as the second argument.\\n\\n\",\n    \"63\": 'borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\\n\\n',\n    \"64\": \"The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\\n\\n\",\n    \"65\": \"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\\n\\n\",\n    \"66\": \"The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\\n\\n\",\n    \"67\": \"You must provide a template to this method.\\n\\n\",\n    \"68\": \"You passed an unsupported selector state to this method.\\n\\n\",\n    \"69\": 'Expected a string ending in \"px\" or a number passed as the first argument to %s(), got %s instead.\\n\\n',\n    \"70\": 'Expected a string ending in \"px\" or a number passed as the second argument to %s(), got %s instead.\\n\\n',\n    \"71\": 'Passed invalid pixel value %s to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"72\": 'Passed invalid base value %s to %s(), please pass a value like \"12px\" or 12.\\n'\n};\n/**\n * super basic version of sprintf\n * @private\n */ function format() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    var a = args[0];\n    var b = [];\n    var c;\n    for(c = 1; c < args.length; c += 1){\n        b.push(args[c]);\n    }\n    b.forEach(function(d) {\n        a = a.replace(/%[a-z]/, d);\n    });\n    return a;\n}\n/**\n * Create an error file out of errors.md for development and a simple web link to the full errors\n * in production mode.\n * @private\n */ var PolishedError = /*#__PURE__*/ function(_Error) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(PolishedError, _Error);\n    function PolishedError(code) {\n        var _this;\n        if (false) {} else {\n            for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                args[_key2 - 1] = arguments[_key2];\n            }\n            _this = _Error.call(this, format.apply(void 0, [\n                ERRORS[code]\n            ].concat(args))) || this;\n        }\n        return (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this);\n    }\n    return PolishedError;\n}(/*#__PURE__*/ (0,_babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(Error));\nvar unitRegExp = /((?!\\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\\D|$)|ged|darg?|nrut)/g; // Merges additional math functionality into the defaults.\nfunction mergeSymbolMaps(additionalSymbols) {\n    var symbolMap = {};\n    symbolMap.symbols = additionalSymbols ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, defaultMathSymbols.symbols, additionalSymbols.symbols) : (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, defaultMathSymbols.symbols);\n    return symbolMap;\n}\nfunction exec(operators, values) {\n    var _ref;\n    var op = operators.pop();\n    values.push(op.f.apply(op, (_ref = []).concat.apply(_ref, values.splice(-op.argCount))));\n    return op.precedence;\n}\nfunction calculate(expression, additionalSymbols) {\n    var symbolMap = mergeSymbolMaps(additionalSymbols);\n    var match;\n    var operators = [\n        symbolMap.symbols[\"(\"].prefix\n    ];\n    var values = [];\n    var pattern = new RegExp(\"\\\\d+(?:\\\\.\\\\d+)?|\" + // ...and patterns for individual operators/function names\n    Object.keys(symbolMap.symbols).map(function(key) {\n        return symbolMap.symbols[key];\n    }) // longer symbols should be listed first\n    // $FlowFixMe\n    .sort(function(a, b) {\n        return b.symbol.length - a.symbol.length;\n    }) // $FlowFixMe\n    .map(function(val) {\n        return val.regSymbol;\n    }).join(\"|\") + \"|(\\\\S)\", \"g\");\n    pattern.lastIndex = 0; // Reset regular expression object\n    var afterValue = false;\n    do {\n        match = pattern.exec(expression);\n        var _ref2 = match || [\n            \")\",\n            undefined\n        ], token = _ref2[0], bad = _ref2[1];\n        var notNumber = symbolMap.symbols[token];\n        var notNewValue = notNumber && !notNumber.prefix && !notNumber.func;\n        var notAfterValue = !notNumber || !notNumber.postfix && !notNumber.infix; // Check for syntax errors:\n        if (bad || (afterValue ? notAfterValue : notNewValue)) {\n            throw new PolishedError(37, match ? match.index : expression.length, expression);\n        }\n        if (afterValue) {\n            // We either have an infix or postfix operator (they should be mutually exclusive)\n            var curr = notNumber.postfix || notNumber.infix;\n            do {\n                var prev = operators[operators.length - 1];\n                if ((curr.precedence - prev.precedence || prev.rightToLeft) > 0) break; // Apply previous operator, since it has precedence over current one\n            }while (exec(operators, values)); // Exit loop after executing an opening parenthesis or function\n            afterValue = curr.notation === \"postfix\";\n            if (curr.symbol !== \")\") {\n                operators.push(curr); // Postfix always has precedence over any operator that follows after it\n                if (afterValue) exec(operators, values);\n            }\n        } else if (notNumber) {\n            // prefix operator or function\n            operators.push(notNumber.prefix || notNumber.func);\n            if (notNumber.func) {\n                // Require an opening parenthesis\n                match = pattern.exec(expression);\n                if (!match || match[0] !== \"(\") {\n                    throw new PolishedError(38, match ? match.index : expression.length, expression);\n                }\n            }\n        } else {\n            // number\n            values.push(+token);\n            afterValue = true;\n        }\n    }while (match && operators.length);\n    if (operators.length) {\n        throw new PolishedError(39, match ? match.index : expression.length, expression);\n    } else if (match) {\n        throw new PolishedError(40, match ? match.index : expression.length, expression);\n    } else {\n        return values.pop();\n    }\n}\nfunction reverseString(str) {\n    return str.split(\"\").reverse().join(\"\");\n}\n/**\n * Helper for doing math with CSS Units. Accepts a formula as a string. All values in the formula must have the same unit (or be unitless). Supports complex formulas utliziing addition, subtraction, multiplication, division, square root, powers, factorial, min, max, as well as parentheses for order of operation.\n *\n *In cases where you need to do calculations with mixed units where one unit is a [relative length unit](https://developer.mozilla.org/en-US/docs/Web/CSS/length#Relative_length_units), you will want to use [CSS Calc](https://developer.mozilla.org/en-US/docs/Web/CSS/calc).\n *\n * *warning* While we've done everything possible to ensure math safely evalutes formulas expressed as strings, you should always use extreme caution when passing `math` user provided values.\n * @example\n * // Styles as object usage\n * const styles = {\n *   fontSize: math('12rem + 8rem'),\n *   fontSize: math('(12px + 2px) * 3'),\n *   fontSize: math('3px^2 + sqrt(4)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   fontSize: ${math('12rem + 8rem')};\n *   fontSize: ${math('(12px + 2px) * 3')};\n *   fontSize: ${math('3px^2 + sqrt(4)')};\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   fontSize: '20rem',\n *   fontSize: '42px',\n *   fontSize: '11px',\n * }\n */ function math(formula, additionalSymbols) {\n    var reversedFormula = reverseString(formula);\n    var formulaMatch = reversedFormula.match(unitRegExp); // Check that all units are the same\n    if (formulaMatch && !formulaMatch.every(function(unit) {\n        return unit === formulaMatch[0];\n    })) {\n        throw new PolishedError(41);\n    }\n    var cleanFormula = reverseString(reversedFormula.replace(unitRegExp, \"\"));\n    return \"\" + calculate(cleanFormula, additionalSymbols) + (formulaMatch ? reverseString(formulaMatch[0]) : \"\");\n}\n// @private\nfunction capitalizeString(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nvar positionMap = [\n    \"Top\",\n    \"Right\",\n    \"Bottom\",\n    \"Left\"\n];\nfunction generateProperty(property, position) {\n    if (!property) return position.toLowerCase();\n    var splitProperty = property.split(\"-\");\n    if (splitProperty.length > 1) {\n        splitProperty.splice(1, 0, position);\n        return splitProperty.reduce(function(acc, val) {\n            return \"\" + acc + capitalizeString(val);\n        });\n    }\n    var joinedProperty = property.replace(/([a-z])([A-Z])/g, \"$1\" + position + \"$2\");\n    return property === joinedProperty ? \"\" + property + position : joinedProperty;\n}\nfunction generateStyles(property, valuesWithDefaults) {\n    var styles = {};\n    for(var i = 0; i < valuesWithDefaults.length; i += 1){\n        if (valuesWithDefaults[i] || valuesWithDefaults[i] === 0) {\n            styles[generateProperty(property, positionMap[i])] = valuesWithDefaults[i];\n        }\n    }\n    return styles;\n}\n/**\n * Enables shorthand for direction-based properties. It accepts a property (hyphenated or camelCased) and up to four values that map to top, right, bottom, and left, respectively. You can optionally pass an empty string to get only the directional values as properties. You can also optionally pass a null argument for a directional value to ignore it.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...directionalProperty('padding', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${directionalProperty('padding', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */ function directionalProperty(property) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    //  prettier-ignore\n    var firstValue = values[0], _values$ = values[1], secondValue = _values$ === void 0 ? firstValue : _values$, _values$2 = values[2], thirdValue = _values$2 === void 0 ? firstValue : _values$2, _values$3 = values[3], fourthValue = _values$3 === void 0 ? secondValue : _values$3;\n    var valuesWithDefaults = [\n        firstValue,\n        secondValue,\n        thirdValue,\n        fourthValue\n    ];\n    return generateStyles(property, valuesWithDefaults);\n}\nfunction endsWith(string, suffix) {\n    return string.substr(-suffix.length) === suffix;\n}\nvar cssRegex = /^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\n/**\n * Returns a given CSS value minus its unit (or the original value if an invalid string is passed). Optionally returns an array containing the stripped value and the original unit of measure.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': stripUnit('100px'),\n *   '--unit': stripUnit('100px')[1],\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${stripUnit('100px')};\n *   --unit: ${stripUnit('100px')[1]};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100,\n *   '--unit': 'px',\n * }\n */ function stripUnit(value, unitReturn) {\n    if (typeof value !== \"string\") return unitReturn ? [\n        value,\n        undefined\n    ] : value;\n    var matchedValue = value.match(cssRegex);\n    if (unitReturn) {\n        if (matchedValue) return [\n            parseFloat(value),\n            matchedValue[2]\n        ];\n        return [\n            value,\n            undefined\n        ];\n    }\n    if (matchedValue) return parseFloat(value);\n    return value;\n}\n/**\n * Factory function that creates pixel-to-x converters\n * @private\n */ var pxtoFactory = function pxtoFactory(to) {\n    return function(pxval, base) {\n        if (base === void 0) {\n            base = \"16px\";\n        }\n        var newPxval = pxval;\n        var newBase = base;\n        if (typeof pxval === \"string\") {\n            if (!endsWith(pxval, \"px\")) {\n                throw new PolishedError(69, to, pxval);\n            }\n            newPxval = stripUnit(pxval);\n        }\n        if (typeof base === \"string\") {\n            if (!endsWith(base, \"px\")) {\n                throw new PolishedError(70, to, base);\n            }\n            newBase = stripUnit(base);\n        }\n        if (typeof newPxval === \"string\") {\n            throw new PolishedError(71, pxval, to);\n        }\n        if (typeof newBase === \"string\") {\n            throw new PolishedError(72, base, to);\n        }\n        return \"\" + newPxval / newBase + to;\n    };\n};\n/**\n * Convert pixel value to ems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': em('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${em('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1em'\n * }\n */ var em = /*#__PURE__*/ pxtoFactory(\"em\");\nvar cssRegex$1 = /^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\n/**\n * Returns a given CSS value and its unit as elements of an array.\n *\n * @deprecated - getValueAndUnit has been marked for deprecation in polished 3.0 and will be fully deprecated in 4.0. It's functionality has been been moved to stripUnit as an optional return.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': getValueAndUnit('100px')[0],\n *   '--unit': getValueAndUnit('100px')[1],\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${getValueAndUnit('100px')[0]};\n *   --unit: ${getValueAndUnit('100px')[1]};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100,\n *   '--unit': 'px',\n * }\n */ function getValueAndUnit(value) {\n    // eslint-disable-next-line no-console\n    console.warn(\"getValueAndUnit has been marked for deprecation in polished 3.0 and will be fully deprecated in 4.0. It's functionality has been been moved to stripUnit as an optional return.\");\n    if (typeof value !== \"string\") return [\n        value,\n        \"\"\n    ];\n    var matchedValue = value.match(cssRegex$1);\n    if (matchedValue) return [\n        parseFloat(value),\n        matchedValue[2]\n    ];\n    return [\n        value,\n        undefined\n    ];\n}\nvar ratioNames = {\n    minorSecond: 1.067,\n    majorSecond: 1.125,\n    minorThird: 1.2,\n    majorThird: 1.25,\n    perfectFourth: 1.333,\n    augFourth: 1.414,\n    perfectFifth: 1.5,\n    minorSixth: 1.6,\n    goldenSection: 1.618,\n    majorSixth: 1.667,\n    minorSeventh: 1.778,\n    majorSeventh: 1.875,\n    octave: 2,\n    majorTenth: 2.5,\n    majorEleventh: 2.667,\n    majorTwelfth: 3,\n    doubleOctave: 4\n};\nfunction getRatio(ratioName) {\n    return ratioNames[ratioName];\n}\n/**\n * Establish consistent measurements and spacial relationships throughout your projects by incrementing an em or rem value up or down a defined scale. We provide a list of commonly used scales as pre-defined variables.\n * @example\n * // Styles as object usage\n * const styles = {\n *    // Increment two steps up the default scale\n *   'fontSize': modularScale(2)\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *    // Increment two steps up the default scale\n *   fontSize: ${modularScale(2)}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'fontSize': '1.77689em'\n * }\n */ function modularScale(steps, base, ratio) {\n    if (base === void 0) {\n        base = \"1em\";\n    }\n    if (ratio === void 0) {\n        ratio = \"perfectFourth\";\n    }\n    if (typeof steps !== \"number\") {\n        throw new PolishedError(42);\n    }\n    if (typeof ratio === \"string\" && !ratioNames[ratio]) {\n        throw new PolishedError(43);\n    }\n    var _ref = typeof base === \"string\" ? stripUnit(base, true) : [\n        base,\n        \"\"\n    ], realBase = _ref[0], unit = _ref[1];\n    var realRatio = typeof ratio === \"string\" ? getRatio(ratio) : ratio;\n    if (typeof realBase === \"string\" || unit !== \"em\" && unit !== \"rem\") {\n        throw new PolishedError(44, base);\n    }\n    return \"\" + realBase * Math.pow(realRatio, steps) + unit;\n}\n/**\n * Convert pixel value to rems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': rem('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${rem('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1rem'\n * }\n */ var rem = /*#__PURE__*/ pxtoFactory(\"rem\");\n/**\n * Returns a CSS calc formula for linear interpolation of a property between two values. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px').\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   fontSize: between('20px', '100px', '400px', '1000px'),\n *   fontSize: between('20px', '100px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   fontSize: ${between('20px', '100px', '400px', '1000px')};\n *   fontSize: ${between('20px', '100px')}\n * `\n *\n * // CSS as JS Output\n *\n * h1: {\n *   'fontSize': 'calc(-33.33333333333334px + 13.333333333333334vw)',\n *   'fontSize': 'calc(-9.090909090909093px + 9.090909090909092vw)'\n * }\n */ function between(fromSize, toSize, minScreen, maxScreen) {\n    if (minScreen === void 0) {\n        minScreen = \"320px\";\n    }\n    if (maxScreen === void 0) {\n        maxScreen = \"1200px\";\n    }\n    var _stripUnit = stripUnit(fromSize, true), unitlessFromSize = _stripUnit[0], fromSizeUnit = _stripUnit[1];\n    var _stripUnit2 = stripUnit(toSize, true), unitlessToSize = _stripUnit2[0], toSizeUnit = _stripUnit2[1];\n    var _stripUnit3 = stripUnit(minScreen, true), unitlessMinScreen = _stripUnit3[0], minScreenUnit = _stripUnit3[1];\n    var _stripUnit4 = stripUnit(maxScreen, true), unitlessMaxScreen = _stripUnit4[0], maxScreenUnit = _stripUnit4[1];\n    if (typeof unitlessMinScreen !== \"number\" || typeof unitlessMaxScreen !== \"number\" || !minScreenUnit || !maxScreenUnit || minScreenUnit !== maxScreenUnit) {\n        throw new PolishedError(47);\n    }\n    if (typeof unitlessFromSize !== \"number\" || typeof unitlessToSize !== \"number\" || !fromSizeUnit || !toSizeUnit || fromSizeUnit !== toSizeUnit) {\n        throw new PolishedError(48);\n    }\n    var slope = (unitlessFromSize - unitlessToSize) / (unitlessMinScreen - unitlessMaxScreen);\n    var base = unitlessToSize - slope * unitlessMaxScreen;\n    return \"calc(\" + base.toFixed(2) + fromSizeUnit + \" + \" + (100 * slope).toFixed(2) + \"vw)\";\n}\n/**\n * CSS to contain a float (credit to CSSMojo).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...clearFix(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${clearFix()}\n * `\n *\n * // CSS as JS Output\n *\n * '&::after': {\n *   'clear': 'both',\n *   'content': '\"\"',\n *   'display': 'table'\n * }\n */ function clearFix(parent) {\n    var _ref;\n    if (parent === void 0) {\n        parent = \"&\";\n    }\n    var pseudoSelector = parent + \"::after\";\n    return _ref = {}, _ref[pseudoSelector] = {\n        clear: \"both\",\n        content: '\"\"',\n        display: \"table\"\n    }, _ref;\n}\n/**\n * CSS to fully cover an area. Can optionally be passed an offset to act as a \"padding\".\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...cover()\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${cover()}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'position': 'absolute',\n *   'top': '0',\n *   'right: '0',\n *   'bottom': '0',\n *   'left: '0'\n * }\n */ function cover(offset) {\n    if (offset === void 0) {\n        offset = 0;\n    }\n    return {\n        position: \"absolute\",\n        top: offset,\n        right: offset,\n        bottom: offset,\n        left: offset\n    };\n}\n/**\n * CSS to represent truncated text with an ellipsis.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...ellipsis('250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${ellipsis('250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'display': 'inline-block',\n *   'maxWidth': '250px',\n *   'overflow': 'hidden',\n *   'textOverflow': 'ellipsis',\n *   'whiteSpace': 'nowrap',\n *   'wordWrap': 'normal'\n * }\n */ function ellipsis(width) {\n    if (width === void 0) {\n        width = \"100%\";\n    }\n    return {\n        display: \"inline-block\",\n        maxWidth: width,\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        whiteSpace: \"nowrap\",\n        wordWrap: \"normal\"\n    };\n}\n/**\n * Returns a set of media queries that resizes a property (or set of properties) between a provided fromSize and toSize. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px') to constrain the interpolation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...fluidRange(\n *    {\n *        prop: 'padding',\n *        fromSize: '20px',\n *        toSize: '100px',\n *      },\n *      '400px',\n *      '1000px',\n *    )\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${fluidRange(\n *      {\n *        prop: 'padding',\n *        fromSize: '20px',\n *        toSize: '100px',\n *      },\n *      '400px',\n *      '1000px',\n *    )}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   \"@media (min-width: 1000px)\": Object {\n *     \"padding\": \"100px\",\n *   },\n *   \"@media (min-width: 400px)\": Object {\n *     \"padding\": \"calc(-33.33333333333334px + 13.333333333333334vw)\",\n *   },\n *   \"padding\": \"20px\",\n * }\n */ function fluidRange(cssProp, minScreen, maxScreen) {\n    if (minScreen === void 0) {\n        minScreen = \"320px\";\n    }\n    if (maxScreen === void 0) {\n        maxScreen = \"1200px\";\n    }\n    if (!Array.isArray(cssProp) && typeof cssProp !== \"object\" || cssProp === null) {\n        throw new PolishedError(49);\n    }\n    if (Array.isArray(cssProp)) {\n        var mediaQueries = {};\n        var fallbacks = {};\n        for(var _iterator = cssProp, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;){\n            var _extends2, _extends3;\n            var _ref;\n            if (_isArray) {\n                if (_i >= _iterator.length) break;\n                _ref = _iterator[_i++];\n            } else {\n                _i = _iterator.next();\n                if (_i.done) break;\n                _ref = _i.value;\n            }\n            var obj = _ref;\n            if (!obj.prop || !obj.fromSize || !obj.toSize) {\n                throw new PolishedError(50);\n            }\n            fallbacks[obj.prop] = obj.fromSize;\n            mediaQueries[\"@media (min-width: \" + minScreen + \")\"] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, mediaQueries[\"@media (min-width: \" + minScreen + \")\"], (_extends2 = {}, _extends2[obj.prop] = between(obj.fromSize, obj.toSize, minScreen, maxScreen), _extends2));\n            mediaQueries[\"@media (min-width: \" + maxScreen + \")\"] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, mediaQueries[\"@media (min-width: \" + maxScreen + \")\"], (_extends3 = {}, _extends3[obj.prop] = obj.toSize, _extends3));\n        }\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, fallbacks, mediaQueries);\n    } else {\n        var _ref2, _ref3, _ref4;\n        if (!cssProp.prop || !cssProp.fromSize || !cssProp.toSize) {\n            throw new PolishedError(51);\n        }\n        return _ref4 = {}, _ref4[cssProp.prop] = cssProp.fromSize, _ref4[\"@media (min-width: \" + minScreen + \")\"] = (_ref2 = {}, _ref2[cssProp.prop] = between(cssProp.fromSize, cssProp.toSize, minScreen, maxScreen), _ref2), _ref4[\"@media (min-width: \" + maxScreen + \")\"] = (_ref3 = {}, _ref3[cssProp.prop] = cssProp.toSize, _ref3), _ref4;\n    }\n}\nfunction generateFileReferences(fontFilePath, fileFormats) {\n    var fileFontReferences = fileFormats.map(function(format) {\n        return 'url(\"' + fontFilePath + \".\" + format + '\")';\n    });\n    return fileFontReferences.join(\", \");\n}\nfunction generateLocalReferences(localFonts) {\n    var localFontReferences = localFonts.map(function(font) {\n        return 'local(\"' + font + '\")';\n    });\n    return localFontReferences.join(\", \");\n}\nfunction generateSources(fontFilePath, localFonts, fileFormats) {\n    var fontReferences = [];\n    if (localFonts) fontReferences.push(generateLocalReferences(localFonts));\n    if (fontFilePath) {\n        fontReferences.push(generateFileReferences(fontFilePath, fileFormats));\n    }\n    return fontReferences.join(\", \");\n}\n/**\n * CSS for a @font-face declaration.\n *\n * @example\n * // Styles as object basic usage\n * const styles = {\n *    ...fontFace({\n *      'fontFamily': 'Sans-Pro',\n *      'fontFilePath': 'path/to/file'\n *    })\n * }\n *\n * // styled-components basic usage\n * const GlobalStyle = createGlobalStyle`${\n *   fontFace({\n *     'fontFamily': 'Sans-Pro',\n *     'fontFilePath': 'path/to/file'\n *   }\n * )}`\n *\n * // CSS as JS Output\n *\n * '@font-face': {\n *   'fontFamily': 'Sans-Pro',\n *   'src': 'url(\"path/to/file.eot\"), url(\"path/to/file.woff2\"), url(\"path/to/file.woff\"), url(\"path/to/file.ttf\"), url(\"path/to/file.svg\")',\n * }\n */ function fontFace(_ref) {\n    var fontFamily = _ref.fontFamily, fontFilePath = _ref.fontFilePath, fontStretch = _ref.fontStretch, fontStyle = _ref.fontStyle, fontVariant = _ref.fontVariant, fontWeight = _ref.fontWeight, _ref$fileFormats = _ref.fileFormats, fileFormats = _ref$fileFormats === void 0 ? [\n        \"eot\",\n        \"woff2\",\n        \"woff\",\n        \"ttf\",\n        \"svg\"\n    ] : _ref$fileFormats, localFonts = _ref.localFonts, unicodeRange = _ref.unicodeRange, fontDisplay = _ref.fontDisplay, fontVariationSettings = _ref.fontVariationSettings, fontFeatureSettings = _ref.fontFeatureSettings;\n    // Error Handling\n    if (!fontFamily) throw new PolishedError(55);\n    if (!fontFilePath && !localFonts) {\n        throw new PolishedError(52);\n    }\n    if (localFonts && !Array.isArray(localFonts)) {\n        throw new PolishedError(53);\n    }\n    if (!Array.isArray(fileFormats)) {\n        throw new PolishedError(54);\n    }\n    var fontFaceDeclaration = {\n        \"@font-face\": {\n            fontFamily: fontFamily,\n            src: generateSources(fontFilePath, localFonts, fileFormats),\n            unicodeRange: unicodeRange,\n            fontStretch: fontStretch,\n            fontStyle: fontStyle,\n            fontVariant: fontVariant,\n            fontWeight: fontWeight,\n            fontDisplay: fontDisplay,\n            fontVariationSettings: fontVariationSettings,\n            fontFeatureSettings: fontFeatureSettings\n        } // Removes undefined fields for cleaner css object.\n    };\n    return JSON.parse(JSON.stringify(fontFaceDeclaration));\n}\n/**\n * CSS to hide text to show a background image in a SEO-friendly way.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'backgroundImage': 'url(logo.png)',\n *   ...hideText(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   backgroundImage: url(logo.png);\n *   ${hideText()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'backgroundImage': 'url(logo.png)',\n *   'textIndent': '101%',\n *   'overflow': 'hidden',\n *   'whiteSpace': 'nowrap',\n * }\n */ function hideText() {\n    return {\n        textIndent: \"101%\",\n        overflow: \"hidden\",\n        whiteSpace: \"nowrap\"\n    };\n}\n/**\n * CSS to hide content visually but remain accessible to screen readers.\n * from [HTML5 Boilerplate](https://github.com/h5bp/html5-boilerplate/blob/9a176f57af1cfe8ec70300da4621fb9b07e5fa31/src/css/main.css#L121)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...hideVisually(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hideVisually()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'border': '0',\n *   'clip': 'rect(0 0 0 0)',\n *   'clipPath': 'inset(50%)',\n *   'height': '1px',\n *   'margin': '-1px',\n *   'overflow': 'hidden',\n *   'padding': '0',\n *   'position': 'absolute',\n *   'whiteSpace': 'nowrap',\n *   'width': '1px',\n * }\n */ function hideVisually() {\n    return {\n        border: \"0\",\n        clip: \"rect(0 0 0 0)\",\n        clipPath: \"inset(50%)\",\n        height: \"1px\",\n        margin: \"-1px\",\n        overflow: \"hidden\",\n        padding: \"0\",\n        position: \"absolute\",\n        whiteSpace: \"nowrap\",\n        width: \"1px\"\n    };\n}\n/**\n * Generates a media query to target HiDPI devices.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  [hiDPI(1.5)]: {\n *    width: 200px;\n *  }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hiDPI(1.5)} {\n *     width: 200px;\n *   }\n * `\n *\n * // CSS as JS Output\n *\n * '@media only screen and (-webkit-min-device-pixel-ratio: 1.5),\n *  only screen and (min--moz-device-pixel-ratio: 1.5),\n *  only screen and (-o-min-device-pixel-ratio: 1.5/1),\n *  only screen and (min-resolution: 144dpi),\n *  only screen and (min-resolution: 1.5dppx)': {\n *   'width': '200px',\n * }\n */ function hiDPI(ratio) {\n    if (ratio === void 0) {\n        ratio = 1.3;\n    }\n    return \"\\n    @media only screen and (-webkit-min-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (min--moz-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (-o-min-device-pixel-ratio: \" + ratio + \"/1),\\n    only screen and (min-resolution: \" + Math.round(ratio * 96) + \"dpi),\\n    only screen and (min-resolution: \" + ratio + \"dppx)\\n  \";\n}\nfunction constructGradientValue(literals) {\n    var template = \"\";\n    for(var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        substitutions[_key - 1] = arguments[_key];\n    }\n    for(var i = 0; i < literals.length; i += 1){\n        template += literals[i];\n        if (i === substitutions.length - 1 && substitutions[i]) {\n            var definedValues = substitutions.filter(function(substitute) {\n                return !!substitute;\n            }); // Adds leading coma if properties preceed color-stops\n            if (definedValues.length > 1) {\n                template = template.slice(0, -1);\n                template += \", \" + substitutions[i]; // No trailing space if color-stops is the only param provided\n            } else if (definedValues.length === 1) {\n                template += \"\" + substitutions[i];\n            }\n        } else if (substitutions[i]) {\n            template += substitutions[i] + \" \";\n        }\n    }\n    return template.trim();\n}\nfunction _templateObject() {\n    var data = (0,_babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        \"linear-gradient(\",\n        \"\",\n        \")\"\n    ]);\n    _templateObject = function _templateObject() {\n        return data;\n    };\n    return data;\n}\n/**\n * CSS for declaring a linear gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...linearGradient({\n        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n        toDirection: 'to top right',\n        fallback: '#FFF',\n      })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${linearGradient({\n        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n        toDirection: 'to top right',\n        fallback: '#FFF',\n      })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#FFF',\n *   'backgroundImage': 'linear-gradient(to top right, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */ function linearGradient(_ref) {\n    var colorStops = _ref.colorStops, fallback = _ref.fallback, _ref$toDirection = _ref.toDirection, toDirection = _ref$toDirection === void 0 ? \"\" : _ref$toDirection;\n    if (!colorStops || colorStops.length < 2) {\n        throw new PolishedError(56);\n    }\n    return {\n        backgroundColor: fallback || colorStops[0].split(\" \")[0],\n        backgroundImage: constructGradientValue(_templateObject(), toDirection, colorStops.join(\", \"))\n    };\n}\n/**\n * CSS to normalize abnormalities across browsers (normalize.css v8.0.0 | MIT License | github.com/necolas/normalize.css)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...normalize(),\n * }\n *\n * // styled-components usage\n * const GlobalStyle = createGlobalStyle`${normalize()}`\n *\n * // CSS as JS Output\n *\n * html {\n *   lineHeight: 1.15,\n *   textSizeAdjust: 100%,\n * } ...\n */ function normalize() {\n    var _ref;\n    return [\n        (_ref = {\n            html: {\n                lineHeight: \"1.15\",\n                textSizeAdjust: \"100%\"\n            },\n            body: {\n                margin: \"0\"\n            },\n            h1: {\n                fontSize: \"2em\",\n                margin: \"0.67em 0\"\n            },\n            hr: {\n                boxSizing: \"content-box\",\n                height: \"0\",\n                overflow: \"visible\"\n            },\n            pre: {\n                fontFamily: \"monospace, monospace\",\n                fontSize: \"1em\"\n            },\n            a: {\n                backgroundColor: \"transparent\"\n            },\n            \"abbr[title]\": {\n                borderBottom: \"none\",\n                textDecoration: \"underline\"\n            }\n        }, _ref[\"b,\\n    strong\"] = {\n            fontWeight: \"bolder\"\n        }, _ref[\"code,\\n    kbd,\\n    samp\"] = {\n            fontFamily: \"monospace, monospace\",\n            fontSize: \"1em\"\n        }, _ref.small = {\n            fontSize: \"80%\"\n        }, _ref[\"sub,\\n    sup\"] = {\n            fontSize: \"75%\",\n            lineHeight: \"0\",\n            position: \"relative\",\n            verticalAlign: \"baseline\"\n        }, _ref.sub = {\n            bottom: \"-0.25em\"\n        }, _ref.sup = {\n            top: \"-0.5em\"\n        }, _ref.img = {\n            borderStyle: \"none\"\n        }, _ref[\"button,\\n    input,\\n    optgroup,\\n    select,\\n    textarea\"] = {\n            fontFamily: \"inherit\",\n            fontSize: \"100%\",\n            lineHeight: \"1.15\",\n            margin: \"0\"\n        }, _ref[\"button,\\n    input\"] = {\n            overflow: \"visible\"\n        }, _ref[\"button,\\n    select\"] = {\n            textTransform: \"none\"\n        }, _ref['button,\\n    html [type=\"button\"],\\n    [type=\"reset\"],\\n    [type=\"submit\"]'] = {\n            WebkitAppearance: \"button\"\n        }, _ref['button::-moz-focus-inner,\\n    [type=\"button\"]::-moz-focus-inner,\\n    [type=\"reset\"]::-moz-focus-inner,\\n    [type=\"submit\"]::-moz-focus-inner'] = {\n            borderStyle: \"none\",\n            padding: \"0\"\n        }, _ref['button:-moz-focusring,\\n    [type=\"button\"]:-moz-focusring,\\n    [type=\"reset\"]:-moz-focusring,\\n    [type=\"submit\"]:-moz-focusring'] = {\n            outline: \"1px dotted ButtonText\"\n        }, _ref.fieldset = {\n            padding: \"0.35em 0.625em 0.75em\"\n        }, _ref.legend = {\n            boxSizing: \"border-box\",\n            color: \"inherit\",\n            display: \"table\",\n            maxWidth: \"100%\",\n            padding: \"0\",\n            whiteSpace: \"normal\"\n        }, _ref.progress = {\n            verticalAlign: \"baseline\"\n        }, _ref.textarea = {\n            overflow: \"auto\"\n        }, _ref['[type=\"checkbox\"],\\n    [type=\"radio\"]'] = {\n            boxSizing: \"border-box\",\n            padding: \"0\"\n        }, _ref['[type=\"number\"]::-webkit-inner-spin-button,\\n    [type=\"number\"]::-webkit-outer-spin-button'] = {\n            height: \"auto\"\n        }, _ref['[type=\"search\"]'] = {\n            WebkitAppearance: \"textfield\",\n            outlineOffset: \"-2px\"\n        }, _ref['[type=\"search\"]::-webkit-search-decoration'] = {\n            WebkitAppearance: \"none\"\n        }, _ref[\"::-webkit-file-upload-button\"] = {\n            WebkitAppearance: \"button\",\n            font: \"inherit\"\n        }, _ref.details = {\n            display: \"block\"\n        }, _ref.summary = {\n            display: \"list-item\"\n        }, _ref.template = {\n            display: \"none\"\n        }, _ref[\"[hidden]\"] = {\n            display: \"none\"\n        }, _ref),\n        {\n            \"abbr[title]\": {\n                textDecoration: \"underline dotted\"\n            }\n        }\n    ];\n}\nfunction _templateObject$1() {\n    var data = (0,_babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        \"radial-gradient(\",\n        \"\",\n        \"\",\n        \"\",\n        \")\"\n    ]);\n    _templateObject$1 = function _templateObject() {\n        return data;\n    };\n    return data;\n}\n/**\n * CSS for declaring a radial gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#00FFFF',\n *   'backgroundImage': 'radial-gradient(center ellipse farthest-corner at 45px 45px, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */ function radialGradient(_ref) {\n    var colorStops = _ref.colorStops, _ref$extent = _ref.extent, extent = _ref$extent === void 0 ? \"\" : _ref$extent, fallback = _ref.fallback, _ref$position = _ref.position, position = _ref$position === void 0 ? \"\" : _ref$position, _ref$shape = _ref.shape, shape = _ref$shape === void 0 ? \"\" : _ref$shape;\n    if (!colorStops || colorStops.length < 2) {\n        throw new PolishedError(57);\n    }\n    return {\n        backgroundColor: fallback || colorStops[0].split(\" \")[0],\n        backgroundImage: constructGradientValue(_templateObject$1(), position, shape, extent, colorStops.join(\", \"))\n    };\n}\n/**\n * A helper to generate a retina background image and non-retina\n * background image. The retina background image will output to a HiDPI media query. The mixin uses\n * a _2x.png filename suffix by default.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  ...retinaImage('my-img')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${retinaImage('my-img')}\n * `\n *\n * // CSS as JS Output\n * div {\n *   backgroundImage: 'url(my-img.png)',\n *   '@media only screen and (-webkit-min-device-pixel-ratio: 1.3),\n *    only screen and (min--moz-device-pixel-ratio: 1.3),\n *    only screen and (-o-min-device-pixel-ratio: 1.3/1),\n *    only screen and (min-resolution: 144dpi),\n *    only screen and (min-resolution: 1.5dppx)': {\n *     backgroundImage: 'url(my-img_2x.png)',\n *   }\n * }\n */ function retinaImage(filename, backgroundSize, extension, retinaFilename, retinaSuffix) {\n    var _ref;\n    if (extension === void 0) {\n        extension = \"png\";\n    }\n    if (retinaSuffix === void 0) {\n        retinaSuffix = \"_2x\";\n    }\n    if (!filename) {\n        throw new PolishedError(58);\n    } // Replace the dot at the beginning of the passed extension if one exists\n    var ext = extension.replace(/^\\./, \"\");\n    var rFilename = retinaFilename ? retinaFilename + \".\" + ext : \"\" + filename + retinaSuffix + \".\" + ext;\n    return _ref = {\n        backgroundImage: \"url(\" + filename + \".\" + ext + \")\"\n    }, _ref[hiDPI()] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        backgroundImage: \"url(\" + rFilename + \")\"\n    }, backgroundSize ? {\n        backgroundSize: backgroundSize\n    } : {}), _ref;\n}\n/* eslint-disable key-spacing */ var functionsMap = {\n    easeInBack: \"cubic-bezier(0.600, -0.280, 0.735, 0.045)\",\n    easeInCirc: \"cubic-bezier(0.600,  0.040, 0.980, 0.335)\",\n    easeInCubic: \"cubic-bezier(0.550,  0.055, 0.675, 0.190)\",\n    easeInExpo: \"cubic-bezier(0.950,  0.050, 0.795, 0.035)\",\n    easeInQuad: \"cubic-bezier(0.550,  0.085, 0.680, 0.530)\",\n    easeInQuart: \"cubic-bezier(0.895,  0.030, 0.685, 0.220)\",\n    easeInQuint: \"cubic-bezier(0.755,  0.050, 0.855, 0.060)\",\n    easeInSine: \"cubic-bezier(0.470,  0.000, 0.745, 0.715)\",\n    easeOutBack: \"cubic-bezier(0.175,  0.885, 0.320, 1.275)\",\n    easeOutCubic: \"cubic-bezier(0.215,  0.610, 0.355, 1.000)\",\n    easeOutCirc: \"cubic-bezier(0.075,  0.820, 0.165, 1.000)\",\n    easeOutExpo: \"cubic-bezier(0.190,  1.000, 0.220, 1.000)\",\n    easeOutQuad: \"cubic-bezier(0.250,  0.460, 0.450, 0.940)\",\n    easeOutQuart: \"cubic-bezier(0.165,  0.840, 0.440, 1.000)\",\n    easeOutQuint: \"cubic-bezier(0.230,  1.000, 0.320, 1.000)\",\n    easeOutSine: \"cubic-bezier(0.390,  0.575, 0.565, 1.000)\",\n    easeInOutBack: \"cubic-bezier(0.680, -0.550, 0.265, 1.550)\",\n    easeInOutCirc: \"cubic-bezier(0.785,  0.135, 0.150, 0.860)\",\n    easeInOutCubic: \"cubic-bezier(0.645,  0.045, 0.355, 1.000)\",\n    easeInOutExpo: \"cubic-bezier(1.000,  0.000, 0.000, 1.000)\",\n    easeInOutQuad: \"cubic-bezier(0.455,  0.030, 0.515, 0.955)\",\n    easeInOutQuart: \"cubic-bezier(0.770,  0.000, 0.175, 1.000)\",\n    easeInOutQuint: \"cubic-bezier(0.860,  0.000, 0.070, 1.000)\",\n    easeInOutSine: \"cubic-bezier(0.445,  0.050, 0.550, 0.950)\"\n};\nfunction getTimingFunction(functionName) {\n    return functionsMap[functionName];\n}\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': timingFunctions('easeInQuad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${timingFunctions('easeInQuad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n * }\n */ function timingFunctions(timingFunction) {\n    return getTimingFunction(timingFunction);\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderColor('red', 'green', 'blue', 'yellow')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderColor('red', 'green', 'blue', 'yellow')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderRightColor': 'green',\n *   'borderBottomColor': 'blue',\n *   'borderLeftColor': 'yellow'\n * }\n */ function borderColor() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderColor\"\n    ].concat(values));\n}\nvar getBorderWidth = function getBorderWidth(pointingDirection, height, width) {\n    switch(pointingDirection){\n        case \"top\":\n            return \"0 \" + width[0] / 2 + width[1] + \" \" + height[0] + height[1] + \" \" + width[0] / 2 + width[1];\n        case \"left\":\n            return \"\" + height[0] / 2 + height[1] + \" \" + width[0] + width[1] + \" \" + height[0] / 2 + height[1] + \" 0\";\n        case \"bottom\":\n            return \"\" + height[0] + height[1] + \" \" + width[0] / 2 + width[1] + \" 0 \" + width[0] / 2 + width[1];\n        case \"right\":\n            return \"\" + height[0] / 2 + height[1] + \" 0 \" + height[0] / 2 + height[1] + \" \" + width[0] + width[1];\n        default:\n            throw new PolishedError(59);\n    }\n}; // needed for border-color\nvar reverseDirection = [\n    \"bottom\",\n    \"left\",\n    \"top\",\n    \"right\"\n];\nvar NUMBER_AND_FLOAT = /(\\d*\\.?\\d*)/;\n/**\n * CSS to represent triangle with any pointing direction with an optional background color. Accepts number or px values for height and width.\n *\n * @example\n * // Styles as object usage\n *\n * const styles = {\n *   ...triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })\n * }\n *\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })}\n *\n *\n * // CSS as JS Output\n *\n * div: {\n *  'borderColor': 'transparent',\n *  'borderLeftColor': 'red !important',\n *  'borderStyle': 'solid',\n *  'borderWidth': '50px 0 50px 100px',\n *  'height': '0',\n *  'width': '0',\n * }\n */ function triangle(_ref) {\n    var pointingDirection = _ref.pointingDirection, height = _ref.height, width = _ref.width, foregroundColor = _ref.foregroundColor, _ref$backgroundColor = _ref.backgroundColor, backgroundColor = _ref$backgroundColor === void 0 ? \"transparent\" : _ref$backgroundColor;\n    var widthAndUnit = [\n        parseFloat(width),\n        String(width).replace(NUMBER_AND_FLOAT, \"\") || \"px\"\n    ];\n    var heightAndUnit = [\n        parseFloat(height),\n        String(height).replace(NUMBER_AND_FLOAT, \"\") || \"px\"\n    ];\n    if (isNaN(heightAndUnit[0]) || isNaN(widthAndUnit[0])) {\n        throw new PolishedError(60);\n    }\n    var reverseDirectionIndex = reverseDirection.indexOf(pointingDirection);\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        width: \"0\",\n        height: \"0\",\n        borderWidth: getBorderWidth(pointingDirection, heightAndUnit, widthAndUnit),\n        borderStyle: \"solid\"\n    }, borderColor.apply(void 0, Array.from({\n        length: 4\n    }).map(function(_, index) {\n        return index === reverseDirectionIndex ? foregroundColor : backgroundColor;\n    })));\n}\n/**\n * Provides an easy way to change the `wordWrap` property.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...wordWrap('break-word')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${wordWrap('break-word')}\n * `\n *\n * // CSS as JS Output\n *\n * const styles = {\n *   overflowWrap: 'break-word',\n *   wordWrap: 'break-word',\n *   wordBreak: 'break-all',\n * }\n */ function wordWrap(wrap) {\n    if (wrap === void 0) {\n        wrap = \"break-word\";\n    }\n    var wordBreak = wrap === \"break-word\" ? \"break-all\" : wrap;\n    return {\n        overflowWrap: wrap,\n        wordWrap: wrap,\n        wordBreak: wordBreak\n    };\n}\nfunction colorToInt(color) {\n    return Math.round(color * 255);\n}\nfunction convertToInt(red, green, blue) {\n    return colorToInt(red) + \",\" + colorToInt(green) + \",\" + colorToInt(blue);\n}\nfunction hslToRgb(hue, saturation, lightness, convert) {\n    if (convert === void 0) {\n        convert = convertToInt;\n    }\n    if (saturation === 0) {\n        // achromatic\n        return convert(lightness, lightness, lightness);\n    } // formular from https://en.wikipedia.org/wiki/HSL_and_HSV\n    var huePrime = hue % 360 / 60;\n    var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;\n    var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));\n    var red = 0;\n    var green = 0;\n    var blue = 0;\n    if (huePrime >= 0 && huePrime < 1) {\n        red = chroma;\n        green = secondComponent;\n    } else if (huePrime >= 1 && huePrime < 2) {\n        red = secondComponent;\n        green = chroma;\n    } else if (huePrime >= 2 && huePrime < 3) {\n        green = chroma;\n        blue = secondComponent;\n    } else if (huePrime >= 3 && huePrime < 4) {\n        green = secondComponent;\n        blue = chroma;\n    } else if (huePrime >= 4 && huePrime < 5) {\n        red = secondComponent;\n        blue = chroma;\n    } else if (huePrime >= 5 && huePrime < 6) {\n        red = chroma;\n        blue = secondComponent;\n    }\n    var lightnessModification = lightness - chroma / 2;\n    var finalRed = red + lightnessModification;\n    var finalGreen = green + lightnessModification;\n    var finalBlue = blue + lightnessModification;\n    return convert(finalRed, finalGreen, finalBlue);\n}\nvar namedColorMap = {\n    aliceblue: \"f0f8ff\",\n    antiquewhite: \"faebd7\",\n    aqua: \"00ffff\",\n    aquamarine: \"7fffd4\",\n    azure: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"000\",\n    blanchedalmond: \"ffebcd\",\n    blue: \"0000ff\",\n    blueviolet: \"8a2be2\",\n    brown: \"a52a2a\",\n    burlywood: \"deb887\",\n    cadetblue: \"5f9ea0\",\n    chartreuse: \"7fff00\",\n    chocolate: \"d2691e\",\n    coral: \"ff7f50\",\n    cornflowerblue: \"6495ed\",\n    cornsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"00ffff\",\n    darkblue: \"00008b\",\n    darkcyan: \"008b8b\",\n    darkgoldenrod: \"b8860b\",\n    darkgray: \"a9a9a9\",\n    darkgreen: \"006400\",\n    darkgrey: \"a9a9a9\",\n    darkkhaki: \"bdb76b\",\n    darkmagenta: \"8b008b\",\n    darkolivegreen: \"556b2f\",\n    darkorange: \"ff8c00\",\n    darkorchid: \"9932cc\",\n    darkred: \"8b0000\",\n    darksalmon: \"e9967a\",\n    darkseagreen: \"8fbc8f\",\n    darkslateblue: \"483d8b\",\n    darkslategray: \"2f4f4f\",\n    darkslategrey: \"2f4f4f\",\n    darkturquoise: \"00ced1\",\n    darkviolet: \"9400d3\",\n    deeppink: \"ff1493\",\n    deepskyblue: \"00bfff\",\n    dimgray: \"696969\",\n    dimgrey: \"696969\",\n    dodgerblue: \"1e90ff\",\n    firebrick: \"b22222\",\n    floralwhite: \"fffaf0\",\n    forestgreen: \"228b22\",\n    fuchsia: \"ff00ff\",\n    gainsboro: \"dcdcdc\",\n    ghostwhite: \"f8f8ff\",\n    gold: \"ffd700\",\n    goldenrod: \"daa520\",\n    gray: \"808080\",\n    green: \"008000\",\n    greenyellow: \"adff2f\",\n    grey: \"808080\",\n    honeydew: \"f0fff0\",\n    hotpink: \"ff69b4\",\n    indianred: \"cd5c5c\",\n    indigo: \"4b0082\",\n    ivory: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavender: \"e6e6fa\",\n    lavenderblush: \"fff0f5\",\n    lawngreen: \"7cfc00\",\n    lemonchiffon: \"fffacd\",\n    lightblue: \"add8e6\",\n    lightcoral: \"f08080\",\n    lightcyan: \"e0ffff\",\n    lightgoldenrodyellow: \"fafad2\",\n    lightgray: \"d3d3d3\",\n    lightgreen: \"90ee90\",\n    lightgrey: \"d3d3d3\",\n    lightpink: \"ffb6c1\",\n    lightsalmon: \"ffa07a\",\n    lightseagreen: \"20b2aa\",\n    lightskyblue: \"87cefa\",\n    lightslategray: \"789\",\n    lightslategrey: \"789\",\n    lightsteelblue: \"b0c4de\",\n    lightyellow: \"ffffe0\",\n    lime: \"0f0\",\n    limegreen: \"32cd32\",\n    linen: \"faf0e6\",\n    magenta: \"f0f\",\n    maroon: \"800000\",\n    mediumaquamarine: \"66cdaa\",\n    mediumblue: \"0000cd\",\n    mediumorchid: \"ba55d3\",\n    mediumpurple: \"9370db\",\n    mediumseagreen: \"3cb371\",\n    mediumslateblue: \"7b68ee\",\n    mediumspringgreen: \"00fa9a\",\n    mediumturquoise: \"48d1cc\",\n    mediumvioletred: \"c71585\",\n    midnightblue: \"191970\",\n    mintcream: \"f5fffa\",\n    mistyrose: \"ffe4e1\",\n    moccasin: \"ffe4b5\",\n    navajowhite: \"ffdead\",\n    navy: \"000080\",\n    oldlace: \"fdf5e6\",\n    olive: \"808000\",\n    olivedrab: \"6b8e23\",\n    orange: \"ffa500\",\n    orangered: \"ff4500\",\n    orchid: \"da70d6\",\n    palegoldenrod: \"eee8aa\",\n    palegreen: \"98fb98\",\n    paleturquoise: \"afeeee\",\n    palevioletred: \"db7093\",\n    papayawhip: \"ffefd5\",\n    peachpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pink: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powderblue: \"b0e0e6\",\n    purple: \"800080\",\n    rebeccapurple: \"639\",\n    red: \"f00\",\n    rosybrown: \"bc8f8f\",\n    royalblue: \"4169e1\",\n    saddlebrown: \"8b4513\",\n    salmon: \"fa8072\",\n    sandybrown: \"f4a460\",\n    seagreen: \"2e8b57\",\n    seashell: \"fff5ee\",\n    sienna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyblue: \"87ceeb\",\n    slateblue: \"6a5acd\",\n    slategray: \"708090\",\n    slategrey: \"708090\",\n    snow: \"fffafa\",\n    springgreen: \"00ff7f\",\n    steelblue: \"4682b4\",\n    tan: \"d2b48c\",\n    teal: \"008080\",\n    thistle: \"d8bfd8\",\n    tomato: \"ff6347\",\n    turquoise: \"40e0d0\",\n    violet: \"ee82ee\",\n    wheat: \"f5deb3\",\n    white: \"fff\",\n    whitesmoke: \"f5f5f5\",\n    yellow: \"ff0\",\n    yellowgreen: \"9acd32\"\n};\nfunction nameToHex(color) {\n    if (typeof color !== \"string\") return color;\n    var normalizedColorName = color.toLowerCase();\n    return namedColorMap[normalizedColorName] ? \"#\" + namedColorMap[normalizedColorName] : color;\n}\nvar hexRegex = /^#[a-fA-F0-9]{6}$/;\nvar hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;\nvar reducedHexRegex = /^#[a-fA-F0-9]{3}$/;\nvar reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;\nvar rgbRegex = /^rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)$/;\nvar rgbaRegex = /^rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*([-+]?[0-9]*[.]?[0-9]+)\\s*\\)$/;\nvar hslRegex = /^hsl\\(\\s*(\\d{0,3}[.]?[0-9]+)\\s*,\\s*(\\d{1,3})%\\s*,\\s*(\\d{1,3})%\\s*\\)$/;\nvar hslaRegex = /^hsla\\(\\s*(\\d{0,3}[.]?[0-9]+)\\s*,\\s*(\\d{1,3})%\\s*,\\s*(\\d{1,3})%\\s*,\\s*([-+]?[0-9]*[.]?[0-9]+)\\s*\\)$/;\n/**\n * Returns an RgbColor or RgbaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a RgbColor or RgbaColor object back to a string.\n *\n * @example\n * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1\n * const color1 = parseToRgb('rgb(255, 0, 0)');\n * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2\n * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');\n */ function parseToRgb(color) {\n    if (typeof color !== \"string\") {\n        throw new PolishedError(3);\n    }\n    var normalizedColor = nameToHex(color);\n    if (normalizedColor.match(hexRegex)) {\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n            green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n            blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16)\n        };\n    }\n    if (normalizedColor.match(hexRgbaRegex)) {\n        var alpha = parseFloat((parseInt(\"\" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n            green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n            blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16),\n            alpha: alpha\n        };\n    }\n    if (normalizedColor.match(reducedHexRegex)) {\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n            green: parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n            blue: parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16)\n        };\n    }\n    if (normalizedColor.match(reducedRgbaHexRegex)) {\n        var _alpha = parseFloat((parseInt(\"\" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n            green: parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n            blue: parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16),\n            alpha: _alpha\n        };\n    }\n    var rgbMatched = rgbRegex.exec(normalizedColor);\n    if (rgbMatched) {\n        return {\n            red: parseInt(\"\" + rgbMatched[1], 10),\n            green: parseInt(\"\" + rgbMatched[2], 10),\n            blue: parseInt(\"\" + rgbMatched[3], 10)\n        };\n    }\n    var rgbaMatched = rgbaRegex.exec(normalizedColor);\n    if (rgbaMatched) {\n        return {\n            red: parseInt(\"\" + rgbaMatched[1], 10),\n            green: parseInt(\"\" + rgbaMatched[2], 10),\n            blue: parseInt(\"\" + rgbaMatched[3], 10),\n            alpha: parseFloat(\"\" + rgbaMatched[4])\n        };\n    }\n    var hslMatched = hslRegex.exec(normalizedColor);\n    if (hslMatched) {\n        var hue = parseInt(\"\" + hslMatched[1], 10);\n        var saturation = parseInt(\"\" + hslMatched[2], 10) / 100;\n        var lightness = parseInt(\"\" + hslMatched[3], 10) / 100;\n        var rgbColorString = \"rgb(\" + hslToRgb(hue, saturation, lightness) + \")\";\n        var hslRgbMatched = rgbRegex.exec(rgbColorString);\n        if (!hslRgbMatched) {\n            throw new PolishedError(4, normalizedColor, rgbColorString);\n        }\n        return {\n            red: parseInt(\"\" + hslRgbMatched[1], 10),\n            green: parseInt(\"\" + hslRgbMatched[2], 10),\n            blue: parseInt(\"\" + hslRgbMatched[3], 10)\n        };\n    }\n    var hslaMatched = hslaRegex.exec(normalizedColor);\n    if (hslaMatched) {\n        var _hue = parseInt(\"\" + hslaMatched[1], 10);\n        var _saturation = parseInt(\"\" + hslaMatched[2], 10) / 100;\n        var _lightness = parseInt(\"\" + hslaMatched[3], 10) / 100;\n        var _rgbColorString = \"rgb(\" + hslToRgb(_hue, _saturation, _lightness) + \")\";\n        var _hslRgbMatched = rgbRegex.exec(_rgbColorString);\n        if (!_hslRgbMatched) {\n            throw new PolishedError(4, normalizedColor, _rgbColorString);\n        }\n        return {\n            red: parseInt(\"\" + _hslRgbMatched[1], 10),\n            green: parseInt(\"\" + _hslRgbMatched[2], 10),\n            blue: parseInt(\"\" + _hslRgbMatched[3], 10),\n            alpha: parseFloat(\"\" + hslaMatched[4])\n        };\n    }\n    throw new PolishedError(5);\n}\nfunction rgbToHsl(color) {\n    // make sure rgb are contained in a set of [0, 255]\n    var red = color.red / 255;\n    var green = color.green / 255;\n    var blue = color.blue / 255;\n    var max = Math.max(red, green, blue);\n    var min = Math.min(red, green, blue);\n    var lightness = (max + min) / 2;\n    if (max === min) {\n        // achromatic\n        if (color.alpha !== undefined) {\n            return {\n                hue: 0,\n                saturation: 0,\n                lightness: lightness,\n                alpha: color.alpha\n            };\n        } else {\n            return {\n                hue: 0,\n                saturation: 0,\n                lightness: lightness\n            };\n        }\n    }\n    var hue;\n    var delta = max - min;\n    var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n    switch(max){\n        case red:\n            hue = (green - blue) / delta + (green < blue ? 6 : 0);\n            break;\n        case green:\n            hue = (blue - red) / delta + 2;\n            break;\n        default:\n            // blue case\n            hue = (red - green) / delta + 4;\n            break;\n    }\n    hue *= 60;\n    if (color.alpha !== undefined) {\n        return {\n            hue: hue,\n            saturation: saturation,\n            lightness: lightness,\n            alpha: color.alpha\n        };\n    }\n    return {\n        hue: hue,\n        saturation: saturation,\n        lightness: lightness\n    };\n}\n/**\n * Returns an HslColor or HslaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a HslColor or HslaColor object back to a string.\n *\n * @example\n * // Assigns `{ hue: 0, saturation: 1, lightness: 0.5 }` to color1\n * const color1 = parseToHsl('rgb(255, 0, 0)');\n * // Assigns `{ hue: 128, saturation: 1, lightness: 0.5, alpha: 0.75 }` to color2\n * const color2 = parseToHsl('hsla(128, 100%, 50%, 0.75)');\n */ function parseToHsl(color) {\n    // Note: At a later stage we can optimize this function as right now a hsl\n    // color would be parsed converted to rgb values and converted back to hsl.\n    return rgbToHsl(parseToRgb(color));\n}\n/**\n * Reduces hex values if possible e.g. #ff8866 to #f86\n * @private\n */ var reduceHexValue = function reduceHexValue(value) {\n    if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {\n        return \"#\" + value[1] + value[3] + value[5];\n    }\n    return value;\n};\nfunction numberToHex(value) {\n    var hex = value.toString(16);\n    return hex.length === 1 ? \"0\" + hex : hex;\n}\nfunction colorToHex(color) {\n    return numberToHex(Math.round(color * 255));\n}\nfunction convertToHex(red, green, blue) {\n    return reduceHexValue(\"#\" + colorToHex(red) + colorToHex(green) + colorToHex(blue));\n}\nfunction hslToHex(hue, saturation, lightness) {\n    return hslToRgb(hue, saturation, lightness, convertToHex);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsl(359, 0.75, 0.4),\n *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsl(359, 0.75, 0.4)};\n *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#b3191c\";\n *   background: \"#b3191c\";\n * }\n */ function hsl(value, saturation, lightness) {\n    if (typeof value === \"number\" && typeof saturation === \"number\" && typeof lightness === \"number\") {\n        return hslToHex(value, saturation, lightness);\n    } else if (typeof value === \"object\" && saturation === undefined && lightness === undefined) {\n        return hslToHex(value.hue, value.saturation, value.lightness);\n    }\n    throw new PolishedError(1);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsla(359, 0.75, 0.4, 0.7),\n *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),\n *   background: hsla(359, 0.75, 0.4, 1),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsla(359, 0.75, 0.4, 0.7)};\n *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};\n *   background: ${hsla(359, 0.75, 0.4, 1)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"#b3191c\";\n * }\n */ function hsla(value, saturation, lightness, alpha) {\n    if (typeof value === \"number\" && typeof saturation === \"number\" && typeof lightness === \"number\" && typeof alpha === \"number\") {\n        return alpha >= 1 ? hslToHex(value, saturation, lightness) : \"rgba(\" + hslToRgb(value, saturation, lightness) + \",\" + alpha + \")\";\n    } else if (typeof value === \"object\" && saturation === undefined && lightness === undefined && alpha === undefined) {\n        return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : \"rgba(\" + hslToRgb(value.hue, value.saturation, value.lightness) + \",\" + value.alpha + \")\";\n    }\n    throw new PolishedError(2);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgb(255, 205, 100),\n *   background: rgb({ red: 255, green: 205, blue: 100 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgb(255, 205, 100)};\n *   background: ${rgb({ red: 255, green: 205, blue: 100 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffcd64\";\n *   background: \"#ffcd64\";\n * }\n */ function rgb(value, green, blue) {\n    if (typeof value === \"number\" && typeof green === \"number\" && typeof blue === \"number\") {\n        return reduceHexValue(\"#\" + numberToHex(value) + numberToHex(green) + numberToHex(blue));\n    } else if (typeof value === \"object\" && green === undefined && blue === undefined) {\n        return reduceHexValue(\"#\" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));\n    }\n    throw new PolishedError(6);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgba(255, 205, 100, 0.7),\n *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),\n *   background: rgba(255, 205, 100, 1),\n *   background: rgba('#ffffff', 0.4),\n *   background: rgba('black', 0.7),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgba(255, 205, 100, 0.7)};\n *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};\n *   background: ${rgba(255, 205, 100, 1)};\n *   background: ${rgba('#ffffff', 0.4)};\n *   background: ${rgba('black', 0.7)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,255,255,0.4)\";\n *   background: \"rgba(0,0,0,0.7)\";\n * }\n */ function rgba(firstValue, secondValue, thirdValue, fourthValue) {\n    if (typeof firstValue === \"string\" && typeof secondValue === \"number\") {\n        var rgbValue = parseToRgb(firstValue);\n        return \"rgba(\" + rgbValue.red + \",\" + rgbValue.green + \",\" + rgbValue.blue + \",\" + secondValue + \")\";\n    } else if (typeof firstValue === \"number\" && typeof secondValue === \"number\" && typeof thirdValue === \"number\" && typeof fourthValue === \"number\") {\n        return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : \"rgba(\" + firstValue + \",\" + secondValue + \",\" + thirdValue + \",\" + fourthValue + \")\";\n    } else if (typeof firstValue === \"object\" && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {\n        return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : \"rgba(\" + firstValue.red + \",\" + firstValue.green + \",\" + firstValue.blue + \",\" + firstValue.alpha + \")\";\n    }\n    throw new PolishedError(7);\n}\nvar isRgb = function isRgb(color) {\n    return typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\" && (typeof color.alpha !== \"number\" || typeof color.alpha === \"undefined\");\n};\nvar isRgba = function isRgba(color) {\n    return typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\" && typeof color.alpha === \"number\";\n};\nvar isHsl = function isHsl(color) {\n    return typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\" && (typeof color.alpha !== \"number\" || typeof color.alpha === \"undefined\");\n};\nvar isHsla = function isHsla(color) {\n    return typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\" && typeof color.alpha === \"number\";\n};\n/**\n * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: toColorString({ red: 255, green: 205, blue: 100 }),\n *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */ function toColorString(color) {\n    if (typeof color !== \"object\") throw new PolishedError(8);\n    if (isRgba(color)) return rgba(color);\n    if (isRgb(color)) return rgb(color);\n    if (isHsla(color)) return hsla(color);\n    if (isHsl(color)) return hsl(color);\n    throw new PolishedError(8);\n}\n// Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js\n// eslint-disable-next-line no-unused-vars\n// eslint-disable-next-line no-unused-vars\n// eslint-disable-next-line no-redeclare\nfunction curried(f, length, acc) {\n    return function fn() {\n        // eslint-disable-next-line prefer-rest-params\n        var combined = acc.concat(Array.prototype.slice.call(arguments));\n        return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);\n    };\n} // eslint-disable-next-line no-redeclare\nfunction curry(f) {\n    // eslint-disable-line no-redeclare\n    return curried(f, f.length, []);\n}\n/**\n * Changes the hue of the color. Hue is a number between 0 to 360. The first\n * argument for adjustHue is the amount of degrees the color is rotated along\n * the color wheel.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: adjustHue(180, '#448'),\n *   background: adjustHue('180', 'rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${adjustHue(180, '#448')};\n *   background: ${adjustHue('180', 'rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#888844\";\n *   background: \"rgba(136,136,68,0.7)\";\n * }\n */ function adjustHue(degree, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        hue: (hslColor.hue + parseFloat(degree)) % 360\n    }));\n} // prettier-ignore\nvar curriedAdjustHue = /*#__PURE__*/ curry(adjustHue);\n/**\n * Returns the complement of the provided color. This is identical to adjustHue(180, <color>).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: complement('#448'),\n *   background: complement('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${complement('#448')};\n *   background: ${complement('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#884\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */ function complement(color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        hue: (hslColor.hue + 180) % 360\n    }));\n}\nfunction guard(lowerBoundary, upperBoundary, value) {\n    return Math.max(lowerBoundary, Math.min(upperBoundary, value));\n}\n/**\n * Returns a string value for the darkened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: darken(0.2, '#FFCD64'),\n *   background: darken('0.2', 'rgba(255,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${darken(0.2, '#FFCD64')};\n *   background: ${darken('0.2', 'rgba(255,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffbd31\";\n *   background: \"rgba(255,189,49,0.7)\";\n * }\n */ function darken(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))\n    }));\n} // prettier-ignore\nvar curriedDarken = /*#__PURE__*/ curry(darken);\n/**\n * Decreases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the desaturate function is the amount by how much the color\n * intensity should be decreased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: desaturate(0.2, '#CCCD64'),\n *   background: desaturate('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${desaturate(0.2, '#CCCD64')};\n *   background: ${desaturate('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#b8b979\";\n *   background: \"rgba(184,185,121,0.7)\";\n * }\n */ function desaturate(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))\n    }));\n} // prettier-ignore\nvar curriedDesaturate = /*#__PURE__*/ curry(desaturate);\n/**\n * Returns a number (float) representing the luminance of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff',\n *   background: getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)',\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff'};\n *   background: ${getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)'};\n *\n * // CSS in JS Output\n *\n * div {\n *   background: \"#CCCD64\";\n *   background: \"rgba(58, 133, 255, 1)\";\n * }\n */ function getLuminance(color) {\n    if (color === \"transparent\") return 0;\n    var rgbColor = parseToRgb(color);\n    var _Object$keys$map = Object.keys(rgbColor).map(function(key) {\n        var channel = rgbColor[key] / 255;\n        return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);\n    }), r = _Object$keys$map[0], g = _Object$keys$map[1], b = _Object$keys$map[2];\n    return parseFloat((0.2126 * r + 0.7152 * g + 0.0722 * b).toFixed(3));\n}\n/**\n * Converts the color to a grayscale, by reducing its saturation to 0.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: grayscale('#CCCD64'),\n *   background: grayscale('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${grayscale('#CCCD64')};\n *   background: ${grayscale('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#999\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */ function grayscale(color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        saturation: 0\n    }));\n}\n/**\n * Converts a HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */ function hslToColorString(color) {\n    if (typeof color === \"object\" && typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\") {\n        if (color.alpha && typeof color.alpha === \"number\") {\n            return hsla({\n                hue: color.hue,\n                saturation: color.saturation,\n                lightness: color.lightness,\n                alpha: color.alpha\n            });\n        }\n        return hsl({\n            hue: color.hue,\n            saturation: color.saturation,\n            lightness: color.lightness\n        });\n    }\n    throw new PolishedError(45);\n}\n/**\n * Inverts the red, green and blue values of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: invert('#CCCD64'),\n *   background: invert('rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${invert('#CCCD64')};\n *   background: ${invert('rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#33329b\";\n *   background: \"rgba(154,155,50,0.7)\";\n * }\n */ function invert(color) {\n    if (color === \"transparent\") return color; // parse color string to rgb\n    var value = parseToRgb(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, value, {\n        red: 255 - value.red,\n        green: 255 - value.green,\n        blue: 255 - value.blue\n    }));\n}\n/**\n * Returns a string value for the lightened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: lighten(0.2, '#CCCD64'),\n *   background: lighten('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${lighten(0.2, '#FFCD64')};\n *   background: ${lighten('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e5e6b1\";\n *   background: \"rgba(229,230,177,0.7)\";\n * }\n */ function lighten(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))\n    }));\n} // prettier-ignore\nvar curriedLighten = /*#__PURE__*/ curry(lighten);\n/**\n * Mixes the two provided colors together by calculating the average of each of the RGB components weighted to the first color by the provided weight.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: mix(0.5, '#f00', '#00f')\n *   background: mix(0.25, '#f00', '#00f')\n *   background: mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${mix(0.5, '#f00', '#00f')};\n *   background: ${mix(0.25, '#f00', '#00f')};\n *   background: ${mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#7f007f\";\n *   background: \"#3f00bf\";\n *   background: \"rgba(63, 0, 191, 0.75)\";\n * }\n */ function mix(weight, color, otherColor) {\n    if (color === \"transparent\") return otherColor;\n    if (otherColor === \"transparent\") return color;\n    var parsedColor1 = parseToRgb(color);\n    var color1 = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor1, {\n        alpha: typeof parsedColor1.alpha === \"number\" ? parsedColor1.alpha : 1\n    });\n    var parsedColor2 = parseToRgb(otherColor);\n    var color2 = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor2, {\n        alpha: typeof parsedColor2.alpha === \"number\" ? parsedColor2.alpha : 1 // The formular is copied from the original Sass implementation:\n    });\n    var alphaDelta = color1.alpha - color2.alpha;\n    var x = parseFloat(weight) * 2 - 1;\n    var y = x * alphaDelta === -1 ? x : x + alphaDelta;\n    var z = 1 + x * alphaDelta;\n    var weight1 = (y / z + 1) / 2.0;\n    var weight2 = 1 - weight1;\n    var mixedColor = {\n        red: Math.floor(color1.red * weight1 + color2.red * weight2),\n        green: Math.floor(color1.green * weight1 + color2.green * weight2),\n        blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),\n        alpha: color1.alpha + (color2.alpha - color1.alpha) * (parseFloat(weight) / 1.0)\n    };\n    return rgba(mixedColor);\n} // prettier-ignore\nvar curriedMix = /*#__PURE__*/ curry(mix);\n/**\n * Increases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: opacify(0.1, 'rgba(255, 255, 255, 0.9)');\n *   background: opacify(0.2, 'hsla(0, 0%, 100%, 0.5)'),\n *   background: opacify('0.5', 'rgba(255, 0, 0, 0.2)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${opacify(0.1, 'rgba(255, 255, 255, 0.9)')};\n *   background: ${opacify(0.2, 'hsla(0, 0%, 100%, 0.5)')},\n *   background: ${opacify('0.5', 'rgba(255, 0, 0, 0.2)')},\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#fff\";\n *   background: \"rgba(255,255,255,0.7)\";\n *   background: \"rgba(255,0,0,0.7)\";\n * }\n */ function opacify(amount, color) {\n    if (color === \"transparent\") return color;\n    var parsedColor = parseToRgb(color);\n    var alpha = typeof parsedColor.alpha === \"number\" ? parsedColor.alpha : 1;\n    var colorWithAlpha = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor, {\n        alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)\n    });\n    return rgba(colorWithAlpha);\n} // prettier-ignore\nvar curriedOpacify = /*#__PURE__*/ curry(opacify);\n/**\n * Returns black or white (or optional light and dark return colors) for best contrast depending on the luminosity of the given color.\n * Follows [W3C specs for readability](https://www.w3.org/TR/WCAG20-TECHS/G18.html).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   color: readableColor('#000'),\n *   color: readableColor('black', '#001', '#ff8'),\n *   color: readableColor('white', '#001', '#ff8'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   color: ${readableColor('#000')};\n *   color: ${readableColor('black', '#001', '#ff8')};\n *   color: ${readableColor('white', '#001', '#ff8')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   color: \"#fff\";\n *   color: \"#ff8\";\n *   color: \"#001\";\n * }\n */ function readableColor(color, lightReturnColor, darkReturnColor) {\n    if (lightReturnColor === void 0) {\n        lightReturnColor = \"#000\";\n    }\n    if (darkReturnColor === void 0) {\n        darkReturnColor = \"#fff\";\n    }\n    return getLuminance(color) > 0.179 ? lightReturnColor : darkReturnColor;\n}\n/**\n * Converts a RgbColor or RgbaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb` or `rgba`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgbToColorString({ red: 255, green: 205, blue: 100 }),\n *   background: rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n * }\n */ function rgbToColorString(color) {\n    if (typeof color === \"object\" && typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\") {\n        if (color.alpha && typeof color.alpha === \"number\") {\n            return rgba({\n                red: color.red,\n                green: color.green,\n                blue: color.blue,\n                alpha: color.alpha\n            });\n        }\n        return rgb({\n            red: color.red,\n            green: color.green,\n            blue: color.blue\n        });\n    }\n    throw new PolishedError(46);\n}\n/**\n * Increases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the saturate function is the amount by how much the color\n * intensity should be increased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: saturate(0.2, '#CCCD64'),\n *   background: saturate('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${saturate(0.2, '#FFCD64')};\n *   background: ${saturate('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e0e250\";\n *   background: \"rgba(224,226,80,0.7)\";\n * }\n */ function saturate(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))\n    }));\n} // prettier-ignore\nvar curriedSaturate = /*#__PURE__*/ curry(saturate);\n/**\n * Sets the hue of a color to the provided value. The hue range can be\n * from 0 and 359.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setHue(42, '#CCCD64'),\n *   background: setHue('244', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setHue(42, '#CCCD64')};\n *   background: ${setHue('244', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#cdae64\";\n *   background: \"rgba(107,100,205,0.7)\";\n * }\n */ function setHue(hue, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        hue: parseFloat(hue)\n    }));\n} // prettier-ignore\nvar curriedSetHue = /*#__PURE__*/ curry(setHue);\n/**\n * Sets the lightness of a color to the provided value. The lightness range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setLightness(0.2, '#CCCD64'),\n *   background: setLightness('0.75', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setLightness(0.2, '#CCCD64')};\n *   background: ${setLightness('0.75', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#4d4d19\";\n *   background: \"rgba(223,224,159,0.7)\";\n * }\n */ function setLightness(lightness, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        lightness: parseFloat(lightness)\n    }));\n} // prettier-ignore\nvar curriedSetLightness = /*#__PURE__*/ curry(setLightness);\n/**\n * Sets the saturation of a color to the provided value. The saturation range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setSaturation(0.2, '#CCCD64'),\n *   background: setSaturation('0.75', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setSaturation(0.2, '#CCCD64')};\n *   background: ${setSaturation('0.75', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#adad84\";\n *   background: \"rgba(228,229,76,0.7)\";\n * }\n */ function setSaturation(saturation, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        saturation: parseFloat(saturation)\n    }));\n} // prettier-ignore\nvar curriedSetSaturation = /*#__PURE__*/ curry(setSaturation);\n/**\n * Shades a color by mixing it with black. `shade` can produce\n * hue shifts, where as `darken` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: shade(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${shade(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#00003f\";\n * }\n */ function shade(percentage, color) {\n    if (color === \"transparent\") return color;\n    return curriedMix(parseFloat(percentage), \"rgb(0, 0, 0)\", color);\n} // prettier-ignore\nvar curriedShade = /*#__PURE__*/ curry(shade);\n/**\n * Tints a color by mixing it with white. `tint` can produce\n * hue shifts, where as `lighten` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: tint(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${tint(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#bfbfff\";\n * }\n */ function tint(percentage, color) {\n    if (color === \"transparent\") return color;\n    return curriedMix(parseFloat(percentage), \"rgb(255, 255, 255)\", color);\n} // prettier-ignore\nvar curriedTint = /*#__PURE__*/ curry(tint);\n/**\n * Decreases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: transparentize(0.1, '#fff');\n *   background: transparentize(0.2, 'hsl(0, 0%, 100%)'),\n *   background: transparentize('0.5', 'rgba(255, 0, 0, 0.8)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${transparentize(0.1, '#fff')};\n *   background: ${transparentize(0.2, 'hsl(0, 0%, 100%)')},\n *   background: ${transparentize('0.5', 'rgba(255, 0, 0, 0.8)')},\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,255,255,0.9)\";\n *   background: \"rgba(255,255,255,0.8)\";\n *   background: \"rgba(255,0,0,0.3)\";\n * }\n */ function transparentize(amount, color) {\n    if (color === \"transparent\") return color;\n    var parsedColor = parseToRgb(color);\n    var alpha = typeof parsedColor.alpha === \"number\" ? parsedColor.alpha : 1;\n    var colorWithAlpha = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor, {\n        alpha: guard(0, 1, (alpha * 100 - parseFloat(amount) * 100) / 100)\n    });\n    return rgba(colorWithAlpha);\n} // prettier-ignore\nvar curriedTransparentize = /*#__PURE__*/ curry(transparentize);\n/**\n * Shorthand for easily setting the animation property. Allows either multiple arrays with animations\n * or a single animation spread over the arguments.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out, colorchange 2s'\n * }\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation('rotate', '1s', 'ease-in-out')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation('rotate', '1s', 'ease-in-out')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out'\n * }\n */ function animation() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    // Allow single or multiple animations passed\n    var multiMode = Array.isArray(args[0]);\n    if (!multiMode && args.length > 8) {\n        throw new PolishedError(64);\n    }\n    var code = args.map(function(arg) {\n        if (multiMode && !Array.isArray(arg) || !multiMode && Array.isArray(arg)) {\n            throw new PolishedError(65);\n        }\n        if (Array.isArray(arg) && arg.length > 8) {\n            throw new PolishedError(66);\n        }\n        return Array.isArray(arg) ? arg.join(\" \") : arg;\n    }).join(\", \");\n    return {\n        animation: code\n    };\n}\n/**\n * Shorthand that accepts any number of backgroundImage values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'backgroundImage': 'url(\"/image/background.jpg\"), linear-gradient(red, green)'\n * }\n */ function backgroundImages() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    return {\n        backgroundImage: properties.join(\", \")\n    };\n}\n/**\n * Shorthand that accepts any number of background values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'background': 'url(\"/image/background.jpg\"), linear-gradient(red, green), center no-repeat'\n * }\n */ function backgrounds() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    return {\n        background: properties.join(\", \")\n    };\n}\nvar sideMap = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\n/**\n * Shorthand for the border property that splits out individual properties for use with tools like Fela and Styletron. A side keyword can optionally be passed to target only one side's border properties.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...border('1px', 'solid', 'red')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${border('1px', 'solid', 'red')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderColor': 'red',\n *   'borderStyle': 'solid',\n *   'borderWidth': `1px`,\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...border('top', '1px', 'solid', 'red')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${border('top', '1px', 'solid', 'red')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderTopStyle': 'solid',\n *   'borderTopWidth': `1px`,\n * }\n */ function border(sideKeyword) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    if (typeof sideKeyword === \"string\" && sideMap.indexOf(sideKeyword) >= 0) {\n        var _ref;\n        return _ref = {}, _ref[\"border\" + capitalizeString(sideKeyword) + \"Width\"] = values[0], _ref[\"border\" + capitalizeString(sideKeyword) + \"Style\"] = values[1], _ref[\"border\" + capitalizeString(sideKeyword) + \"Color\"] = values[2], _ref;\n    } else {\n        values.unshift(sideKeyword);\n        return {\n            borderWidth: values[0],\n            borderStyle: values[1],\n            borderColor: values[2]\n        };\n    }\n}\n/**\n * Shorthand that accepts a value for side and a value for radius and applies the radius value to both corners of the side.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderRadius('top', '5px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderRadius('top', '5px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopRightRadius': '5px',\n *   'borderTopLeftRadius': '5px',\n * }\n */ function borderRadius(side, radius) {\n    var uppercaseSide = capitalizeString(side);\n    if (!radius && radius !== 0) {\n        throw new PolishedError(62);\n    }\n    if (uppercaseSide === \"Top\" || uppercaseSide === \"Bottom\") {\n        var _ref;\n        return _ref = {}, _ref[\"border\" + uppercaseSide + \"RightRadius\"] = radius, _ref[\"border\" + uppercaseSide + \"LeftRadius\"] = radius, _ref;\n    }\n    if (uppercaseSide === \"Left\" || uppercaseSide === \"Right\") {\n        var _ref2;\n        return _ref2 = {}, _ref2[\"borderTop\" + uppercaseSide + \"Radius\"] = radius, _ref2[\"borderBottom\" + uppercaseSide + \"Radius\"] = radius, _ref2;\n    }\n    throw new PolishedError(63);\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderStyle('solid', 'dashed', 'dotted', 'double')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderStyle('solid', 'dashed', 'dotted', 'double')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopStyle': 'solid',\n *   'borderRightStyle': 'dashed',\n *   'borderBottomStyle': 'dotted',\n *   'borderLeftStyle': 'double'\n * }\n */ function borderStyle() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderStyle\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderWidth('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderWidth('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopWidth': '12px',\n *   'borderRightWidth': '24px',\n *   'borderBottomWidth': '36px',\n *   'borderLeftWidth': '48px'\n * }\n */ function borderWidth() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderWidth\"\n    ].concat(values));\n}\nfunction generateSelectors(template, state) {\n    var stateSuffix = state ? \":\" + state : \"\";\n    return template(stateSuffix);\n}\n/**\n * Function helper that adds an array of states to a template of selectors. Used in textInputs and buttons.\n * @private\n */ function statefulSelectors(states, template, stateMap) {\n    if (!template) throw new PolishedError(67);\n    if (states.length === 0) return generateSelectors(template, null);\n    var selectors = [];\n    for(var i = 0; i < states.length; i += 1){\n        if (stateMap && stateMap.indexOf(states[i]) < 0) {\n            throw new PolishedError(68);\n        }\n        selectors.push(generateSelectors(template, states[i]));\n    }\n    selectors = selectors.join(\",\");\n    return selectors;\n}\nvar stateMap = [\n    undefined,\n    null,\n    \"active\",\n    \"focus\",\n    \"hover\"\n];\nfunction template(state) {\n    return \"button\" + state + ',\\n  input[type=\"button\"]' + state + ',\\n  input[type=\"reset\"]' + state + ',\\n  input[type=\"submit\"]' + state;\n}\n/**\n * Populates selectors that target all buttons. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [buttons('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${buttons('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'button:active,\n *  'input[type=\"button\"]:active,\n *  'input[type=\\\"reset\\\"]:active,\n *  'input[type=\\\"submit\\\"]:active: {\n *   'border': 'none'\n * }\n */ function buttons() {\n    for(var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++){\n        states[_key] = arguments[_key];\n    }\n    return statefulSelectors(states, template, stateMap);\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...margin('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${margin('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'marginTop': '12px',\n *   'marginRight': '24px',\n *   'marginBottom': '36px',\n *   'marginLeft': '48px'\n * }\n */ function margin() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"margin\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...padding('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${padding('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */ function padding() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"padding\"\n    ].concat(values));\n}\nvar positionMap$1 = [\n    \"absolute\",\n    \"fixed\",\n    \"relative\",\n    \"static\",\n    \"sticky\"\n];\n/**\n * Shorthand accepts up to five values, including null to skip a value, and maps them to their respective directions. The first value can optionally be a position keyword.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...position('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...position('absolute', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('absolute', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'position': 'absolute',\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n */ function position(positionKeyword) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    if (positionMap$1.indexOf(positionKeyword) >= 0) {\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            position: positionKeyword\n        }, directionalProperty.apply(void 0, [\n            \"\"\n        ].concat(values)));\n    } else {\n        var firstValue = positionKeyword; // in this case position is actually the first value\n        return directionalProperty.apply(void 0, [\n            \"\",\n            firstValue\n        ].concat(values));\n    }\n}\n/**\n * Shorthand to set the height and width properties in a single statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...size('300px', '250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${size('300px', '250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'height': '300px',\n *   'width': '250px',\n * }\n */ function size(height, width) {\n    if (width === void 0) {\n        width = height;\n    }\n    return {\n        height: height,\n        width: width\n    };\n}\nvar stateMap$1 = [\n    undefined,\n    null,\n    \"active\",\n    \"focus\",\n    \"hover\"\n];\nfunction template$1(state) {\n    return 'input[type=\"color\"]' + state + ',\\n    input[type=\"date\"]' + state + ',\\n    input[type=\"datetime\"]' + state + ',\\n    input[type=\"datetime-local\"]' + state + ',\\n    input[type=\"email\"]' + state + ',\\n    input[type=\"month\"]' + state + ',\\n    input[type=\"number\"]' + state + ',\\n    input[type=\"password\"]' + state + ',\\n    input[type=\"search\"]' + state + ',\\n    input[type=\"tel\"]' + state + ',\\n    input[type=\"text\"]' + state + ',\\n    input[type=\"time\"]' + state + ',\\n    input[type=\"url\"]' + state + ',\\n    input[type=\"week\"]' + state + \",\\n    input:not([type])\" + state + \",\\n    textarea\" + state;\n}\n/**\n * Populates selectors that target all text inputs. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [textInputs('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${textInputs('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'input[type=\"color\"]:active,\n *  input[type=\"date\"]:active,\n *  input[type=\"datetime\"]:active,\n *  input[type=\"datetime-local\"]:active,\n *  input[type=\"email\"]:active,\n *  input[type=\"month\"]:active,\n *  input[type=\"number\"]:active,\n *  input[type=\"password\"]:active,\n *  input[type=\"search\"]:active,\n *  input[type=\"tel\"]:active,\n *  input[type=\"text\"]:active,\n *  input[type=\"time\"]:active,\n *  input[type=\"url\"]:active,\n *  input[type=\"week\"]:active,\n *  input:not([type]):active,\n *  textarea:active': {\n *   'border': 'none'\n * }\n */ function textInputs() {\n    for(var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++){\n        states[_key] = arguments[_key];\n    }\n    return statefulSelectors(states, template$1, stateMap$1);\n}\n/**\n * Accepts any number of transition values as parameters for creating a single transition statement. You may also pass an array of properties as the first parameter that you would like to apply the same tranisition values to (second parameter).\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s'),\n *   ...transitions(['color', 'background-color'], '2.0s ease-in 2s')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s')};\n *   ${transitions(['color', 'background-color'], '2.0s ease-in 2s'),};\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'transition': 'opacity 1.0s ease-in 0s, width 2.0s ease-in 2s'\n *   'transition': 'color 2.0s ease-in 2s, background-color 2.0s ease-in 2s',\n * }\n */ function transitions() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    if (Array.isArray(properties[0]) && properties.length === 2) {\n        var value = properties[1];\n        if (typeof value !== \"string\") {\n            throw new PolishedError(61);\n        }\n        var transitionsString = properties[0].map(function(property) {\n            return property + \" \" + value;\n        }).join(\", \");\n        return {\n            transition: transitionsString\n        };\n    } else {\n        return {\n            transition: properties.join(\", \")\n        };\n    }\n}\n// Math\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG9saXNoZWQvZGlzdC9wb2xpc2hlZC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzRCO0FBQ2hCO0FBQ0k7QUFDc0I7QUFFaEcsU0FBU0s7SUFDUCxJQUFJQztJQUVKLE9BQU9BLE9BQU9DLFVBQVVDLE1BQU0sR0FBRyxHQUFHRixPQUFPLEtBQUtDLFVBQVVDLE1BQU0sSUFBSUYsT0FBT0csWUFBWUYsU0FBUyxDQUFDRCxLQUFLO0FBQ3hHO0FBRUEsU0FBU0ksU0FBU0MsQ0FBQztJQUNqQixPQUFPLENBQUNBO0FBQ1Y7QUFFQSxTQUFTQyxTQUFTRCxDQUFDLEVBQUVFLENBQUM7SUFDcEIsT0FBT0YsSUFBSUU7QUFDYjtBQUVBLFNBQVNDLFlBQVlILENBQUMsRUFBRUUsQ0FBQztJQUN2QixPQUFPRixJQUFJRTtBQUNiO0FBRUEsU0FBU0UsZUFBZUosQ0FBQyxFQUFFRSxDQUFDO0lBQzFCLE9BQU9GLElBQUlFO0FBQ2I7QUFFQSxTQUFTRyxTQUFTTCxDQUFDLEVBQUVFLENBQUM7SUFDcEIsT0FBT0YsSUFBSUU7QUFDYjtBQUVBLFNBQVNJLFVBQVVOLENBQUM7SUFDbEIsSUFBSUEsSUFBSSxLQUFLLENBQUUsRUFBQ0EsS0FBSyxJQUFJLE9BQU9PO0lBQ2hDLElBQUlQLElBQUksS0FBSyxPQUFPUTtTQUFjLElBQUlSLE1BQU0sR0FBRyxPQUFPO1NBQU87UUFDM0QsT0FBT0EsSUFBSU0sVUFBVU4sSUFBSTtJQUMzQjtBQUNGO0FBRUEsU0FBU1MsTUFBTVQsQ0FBQyxFQUFFRSxDQUFDO0lBQ2pCLE9BQU9RLEtBQUtDLEdBQUcsQ0FBQ1gsR0FBR0U7QUFDckI7QUFFQSxTQUFTVSxLQUFLWixDQUFDO0lBQ2IsT0FBT1UsS0FBS0UsSUFBSSxDQUFDWjtBQUNuQjtBQUVBLFNBQVNhO0lBQ1AsT0FBT0gs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R0EsT0FBT0YsTUFBTUUsT0FBUTtRQUN6RnVuQixNQUFNLENBQUN2bkIsS0FBSyxHQUFHeEMsU0FBUyxDQUFDd0MsS0FBSztJQUNoQztJQUVBLE9BQU9zbkIsa0JBQWtCQyxRQUFRUSxZQUFZRDtBQUMvQztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FFRCxTQUFTRztJQUNQLElBQUssSUFBSW5vQixPQUFPdEMsVUFBVUMsTUFBTSxFQUFFZ3BCLGFBQWEsSUFBSTVuQixNQUFNaUIsT0FBT0UsT0FBTyxHQUFHQSxPQUFPRixNQUFNRSxPQUFRO1FBQzdGeW1CLFVBQVUsQ0FBQ3ptQixLQUFLLEdBQUd4QyxTQUFTLENBQUN3QyxLQUFLO0lBQ3BDO0lBRUEsSUFBSW5CLE1BQU0rTCxPQUFPLENBQUM2YixVQUFVLENBQUMsRUFBRSxLQUFLQSxXQUFXaHBCLE1BQU0sS0FBSyxHQUFHO1FBQzNELElBQUlrSSxRQUFROGdCLFVBQVUsQ0FBQyxFQUFFO1FBRXpCLElBQUksT0FBTzlnQixVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJckYsY0FBYztRQUMxQjtRQUVBLElBQUk0bkIsb0JBQW9CekIsVUFBVSxDQUFDLEVBQUUsQ0FBQ3hrQixHQUFHLENBQUMsU0FBVWtDLFFBQVE7WUFDMUQsT0FBT0EsV0FBVyxNQUFNd0I7UUFDMUIsR0FBR3RELElBQUksQ0FBQztRQUNSLE9BQU87WUFDTDhsQixZQUFZRDtRQUNkO0lBQ0YsT0FBTztRQUNMLE9BQU87WUFDTEMsWUFBWTFCLFdBQVdwa0IsSUFBSSxDQUFDO1FBQzlCO0lBQ0Y7QUFDRjtBQUVBLE9BQU87QUFFdThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UvLi9ub2RlX21vZHVsZXMvcG9saXNoZWQvZGlzdC9wb2xpc2hlZC5lcy5qcz83MzM5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZCc7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgX3dyYXBOYXRpdmVTdXBlciBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS93cmFwTmF0aXZlU3VwZXInO1xuaW1wb3J0IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZSc7XG5cbmZ1bmN0aW9uIGxhc3QoKSB7XG4gIHZhciBfcmVmO1xuXG4gIHJldHVybiBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCAtIDEsIF9yZWYgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gX3JlZiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tfcmVmXTtcbn1cblxuZnVuY3Rpb24gbmVnYXRpb24oYSkge1xuICByZXR1cm4gLWE7XG59XG5cbmZ1bmN0aW9uIGFkZGl0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgKyBiO1xufVxuXG5mdW5jdGlvbiBzdWJ0cmFjdGlvbihhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGljYXRpb24oYSwgYikge1xuICByZXR1cm4gYSAqIGI7XG59XG5cbmZ1bmN0aW9uIGRpdmlzaW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgLyBiO1xufVxuXG5mdW5jdGlvbiBmYWN0b3JpYWwoYSkge1xuICBpZiAoYSAlIDEgfHwgISgrYSA+PSAwKSkgcmV0dXJuIE5hTjtcbiAgaWYgKGEgPiAxNzApIHJldHVybiBJbmZpbml0eTtlbHNlIGlmIChhID09PSAwKSByZXR1cm4gMTtlbHNlIHtcbiAgICByZXR1cm4gYSAqIGZhY3RvcmlhbChhIC0gMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG93ZXIoYSwgYikge1xuICByZXR1cm4gTWF0aC5wb3coYSwgYik7XG59XG5cbmZ1bmN0aW9uIHNxcnQoYSkge1xuICByZXR1cm4gTWF0aC5zcXJ0KGEpO1xufVxuXG5mdW5jdGlvbiBtYXgoKSB7XG4gIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBtaW4oKSB7XG4gIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBjb21tYSgpIHtcbiAgcmV0dXJuIEFycmF5Lm9mLmFwcGx5KEFycmF5LCBhcmd1bWVudHMpO1xufVxuXG52YXIgZGVmYXVsdE1hdGhTeW1ib2xzID0ge1xuICBzeW1ib2xzOiB7XG4gICAgJyEnOiB7XG4gICAgICBwb3N0Zml4OiB7XG4gICAgICAgIHN5bWJvbDogJyEnLFxuICAgICAgICBmOiBmYWN0b3JpYWwsXG4gICAgICAgIG5vdGF0aW9uOiAncG9zdGZpeCcsXG4gICAgICAgIHByZWNlZGVuY2U6IDYsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJyEnLFxuICAgICAgcmVnU3ltYm9sOiAnISdcbiAgICB9LFxuICAgICdeJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnXicsXG4gICAgICAgIGY6IHBvd2VyLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogNSxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDEsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnXicsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcXidcbiAgICB9LFxuICAgICcqJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKicsXG4gICAgICAgIGY6IG11bHRpcGxpY2F0aW9uLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogNCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKicsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKidcbiAgICB9LFxuICAgICcvJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnLycsXG4gICAgICAgIGY6IGRpdmlzaW9uLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogNCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnLycsXG4gICAgICByZWdTeW1ib2w6ICcvJ1xuICAgIH0sXG4gICAgJysnOiB7XG4gICAgICBpbmZpeDoge1xuICAgICAgICBzeW1ib2w6ICcrJyxcbiAgICAgICAgZjogYWRkaXRpb24sXG4gICAgICAgIG5vdGF0aW9uOiAnaW5maXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiAyLFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDJcbiAgICAgIH0sXG4gICAgICBwcmVmaXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKycsXG4gICAgICAgIGY6IGxhc3QsXG4gICAgICAgIG5vdGF0aW9uOiAncHJlZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMyxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAxXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKycsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKydcbiAgICB9LFxuICAgICctJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnLScsXG4gICAgICAgIGY6IHN1YnRyYWN0aW9uLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMixcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgcHJlZml4OiB7XG4gICAgICAgIHN5bWJvbDogJy0nLFxuICAgICAgICBmOiBuZWdhdGlvbixcbiAgICAgICAgbm90YXRpb246ICdwcmVmaXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiAzLFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDFcbiAgICAgIH0sXG4gICAgICBzeW1ib2w6ICctJyxcbiAgICAgIHJlZ1N5bWJvbDogJy0nXG4gICAgfSxcbiAgICAnLCc6IHtcbiAgICAgIGluZml4OiB7XG4gICAgICAgIHN5bWJvbDogJywnLFxuICAgICAgICBmOiBjb21tYSxcbiAgICAgICAgbm90YXRpb246ICdpbmZpeCcsXG4gICAgICAgIHByZWNlZGVuY2U6IDEsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMlxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJywnLFxuICAgICAgcmVnU3ltYm9sOiAnLCdcbiAgICB9LFxuICAgICcoJzoge1xuICAgICAgcHJlZml4OiB7XG4gICAgICAgIHN5bWJvbDogJygnLFxuICAgICAgICBmOiBsYXN0LFxuICAgICAgICBub3RhdGlvbjogJ3ByZWZpeCcsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJygnLFxuICAgICAgcmVnU3ltYm9sOiAnXFxcXCgnXG4gICAgfSxcbiAgICAnKSc6IHtcbiAgICAgIHBvc3RmaXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKScsXG4gICAgICAgIGY6IHVuZGVmaW5lZCxcbiAgICAgICAgbm90YXRpb246ICdwb3N0Zml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAxXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKScsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKSdcbiAgICB9LFxuICAgIG1pbjoge1xuICAgICAgZnVuYzoge1xuICAgICAgICBzeW1ib2w6ICdtaW4nLFxuICAgICAgICBmOiBtaW4sXG4gICAgICAgIG5vdGF0aW9uOiAnZnVuYycsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJ21pbicsXG4gICAgICByZWdTeW1ib2w6ICdtaW5cXFxcYidcbiAgICB9LFxuICAgIG1heDoge1xuICAgICAgZnVuYzoge1xuICAgICAgICBzeW1ib2w6ICdtYXgnLFxuICAgICAgICBmOiBtYXgsXG4gICAgICAgIG5vdGF0aW9uOiAnZnVuYycsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJ21heCcsXG4gICAgICByZWdTeW1ib2w6ICdtYXhcXFxcYidcbiAgICB9LFxuICAgIHNxcnQ6IHtcbiAgICAgIGZ1bmM6IHtcbiAgICAgICAgc3ltYm9sOiAnc3FydCcsXG4gICAgICAgIGY6IHNxcnQsXG4gICAgICAgIG5vdGF0aW9uOiAnZnVuYycsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJ3NxcnQnLFxuICAgICAgcmVnU3ltYm9sOiAnc3FydFxcXFxiJ1xuICAgIH1cbiAgfVxufTtcblxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3N0eWxlZC1jb21wb25lbnRzL3N0eWxlZC1jb21wb25lbnRzL2Jsb2IvZmNmNmYzODA0YzU3YTE0ZGQ3OTg0ZGZhYjdiYzA2ZWUyZWRjYTA0NC9zcmMvdXRpbHMvZXJyb3IuanNcblxuLyoqXG4gKiBQYXJzZSBlcnJvcnMubWQgYW5kIHR1cm4gaXQgaW50byBhIHNpbXBsZSBoYXNoIG9mIGNvZGU6IG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBFUlJPUlMgPSB7XG4gIFwiMVwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50cyB0byBoc2wsIHBsZWFzZSBwYXNzIG11bHRpcGxlIG51bWJlcnMgZS5nLiBoc2woMzYwLCAwLjc1LCAwLjQpIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IGh1ZTogMjU1LCBzYXR1cmF0aW9uOiAwLjQsIGxpZ2h0bmVzczogMC43NSB9KS5cXG5cXG5cIixcbiAgXCIyXCI6IFwiUGFzc2VkIGludmFsaWQgYXJndW1lbnRzIHRvIGhzbGEsIHBsZWFzZSBwYXNzIG11bHRpcGxlIG51bWJlcnMgZS5nLiBoc2xhKDM2MCwgMC43NSwgMC40LCAwLjcpIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IGh1ZTogMjU1LCBzYXR1cmF0aW9uOiAwLjQsIGxpZ2h0bmVzczogMC43NSwgYWxwaGE6IDAuNyB9KS5cXG5cXG5cIixcbiAgXCIzXCI6IFwiUGFzc2VkIGFuIGluY29ycmVjdCBhcmd1bWVudCB0byBhIGNvbG9yIGZ1bmN0aW9uLCBwbGVhc2UgcGFzcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxcblxcblwiLFxuICBcIjRcIjogXCJDb3VsZG4ndCBnZW5lcmF0ZSB2YWxpZCByZ2Igc3RyaW5nIGZyb20gJXMsIGl0IHJldHVybmVkICVzLlxcblxcblwiLFxuICBcIjVcIjogXCJDb3VsZG4ndCBwYXJzZSB0aGUgY29sb3Igc3RyaW5nLiBQbGVhc2UgcHJvdmlkZSB0aGUgY29sb3IgYXMgYSBzdHJpbmcgaW4gaGV4LCByZ2IsIHJnYmEsIGhzbCBvciBoc2xhIG5vdGF0aW9uLlxcblxcblwiLFxuICBcIjZcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudHMgdG8gcmdiLCBwbGVhc2UgcGFzcyBtdWx0aXBsZSBudW1iZXJzIGUuZy4gcmdiKDI1NSwgMjA1LCAxMDApIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAgfSkuXFxuXFxuXCIsXG4gIFwiN1wiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50cyB0byByZ2JhLCBwbGVhc2UgcGFzcyBtdWx0aXBsZSBudW1iZXJzIGUuZy4gcmdiKDI1NSwgMjA1LCAxMDAsIDAuNzUpIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjc1IH0pLlxcblxcblwiLFxuICBcIjhcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudCB0byB0b0NvbG9yU3RyaW5nLCBwbGVhc2UgcGFzcyBhIFJnYkNvbG9yLCBSZ2JhQ29sb3IsIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QuXFxuXFxuXCIsXG4gIFwiOVwiOiBcIlBsZWFzZSBwcm92aWRlIGEgbnVtYmVyIG9mIHN0ZXBzIHRvIHRoZSBtb2R1bGFyU2NhbGUgaGVscGVyLlxcblxcblwiLFxuICBcIjEwXCI6IFwiUGxlYXNlIHBhc3MgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBwcmVkZWZpbmVkIHNjYWxlcyB0byB0aGUgbW9kdWxhclNjYWxlIGhlbHBlciBhcyB0aGUgcmF0aW8uXFxuXFxuXCIsXG4gIFwiMTFcIjogXCJJbnZhbGlkIHZhbHVlIHBhc3NlZCBhcyBiYXNlIHRvIG1vZHVsYXJTY2FsZSwgZXhwZWN0ZWQgbnVtYmVyIG9yIGVtIHN0cmluZyBidXQgZ290IFxcXCIlc1xcXCJcXG5cXG5cIixcbiAgXCIxMlwiOiBcIkV4cGVjdGVkIGEgc3RyaW5nIGVuZGluZyBpbiBcXFwicHhcXFwiIG9yIGEgbnVtYmVyIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gJXMoKSwgZ290IFxcXCIlc1xcXCIgaW5zdGVhZC5cXG5cXG5cIixcbiAgXCIxM1wiOiBcIkV4cGVjdGVkIGEgc3RyaW5nIGVuZGluZyBpbiBcXFwicHhcXFwiIG9yIGEgbnVtYmVyIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvICVzKCksIGdvdCBcXFwiJXNcXFwiIGluc3RlYWQuXFxuXFxuXCIsXG4gIFwiMTRcIjogXCJQYXNzZWQgaW52YWxpZCBwaXhlbCB2YWx1ZSAoXFxcIiVzXFxcIikgdG8gJXMoKSwgcGxlYXNlIHBhc3MgYSB2YWx1ZSBsaWtlIFxcXCIxMnB4XFxcIiBvciAxMi5cXG5cXG5cIixcbiAgXCIxNVwiOiBcIlBhc3NlZCBpbnZhbGlkIGJhc2UgdmFsdWUgKFxcXCIlc1xcXCIpIHRvICVzKCksIHBsZWFzZSBwYXNzIGEgdmFsdWUgbGlrZSBcXFwiMTJweFxcXCIgb3IgMTIuXFxuXFxuXCIsXG4gIFwiMTZcIjogXCJZb3UgbXVzdCBwcm92aWRlIGEgdGVtcGxhdGUgdG8gdGhpcyBtZXRob2QuXFxuXFxuXCIsXG4gIFwiMTdcIjogXCJZb3UgcGFzc2VkIGFuIHVuc3VwcG9ydGVkIHNlbGVjdG9yIHN0YXRlIHRvIHRoaXMgbWV0aG9kLlxcblxcblwiLFxuICBcIjE4XCI6IFwibWluU2NyZWVuIGFuZCBtYXhTY3JlZW4gbXVzdCBiZSBwcm92aWRlZCBhcyBzdHJpbmdpZmllZCBudW1iZXJzIHdpdGggdGhlIHNhbWUgdW5pdHMuXFxuXFxuXCIsXG4gIFwiMTlcIjogXCJmcm9tU2l6ZSBhbmQgdG9TaXplIG11c3QgYmUgcHJvdmlkZWQgYXMgc3RyaW5naWZpZWQgbnVtYmVycyB3aXRoIHRoZSBzYW1lIHVuaXRzLlxcblxcblwiLFxuICBcIjIwXCI6IFwiZXhwZWN0cyBlaXRoZXIgYW4gYXJyYXkgb2Ygb2JqZWN0cyBvciBhIHNpbmdsZSBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBwcm9wLCBmcm9tU2l6ZSwgYW5kIHRvU2l6ZS5cXG5cXG5cIixcbiAgXCIyMVwiOiBcImV4cGVjdHMgdGhlIG9iamVjdHMgaW4gdGhlIGZpcnN0IGFyZ3VtZW50IGFycmF5IHRvIGhhdmUgdGhlIHByb3BlcnRpZXMgYHByb3BgLCBgZnJvbVNpemVgLCBhbmQgYHRvU2l6ZWAuXFxuXFxuXCIsXG4gIFwiMjJcIjogXCJleHBlY3RzIHRoZSBmaXJzdCBhcmd1bWVudCBvYmplY3QgdG8gaGF2ZSB0aGUgcHJvcGVydGllcyBgcHJvcGAsIGBmcm9tU2l6ZWAsIGFuZCBgdG9TaXplYC5cXG5cXG5cIixcbiAgXCIyM1wiOiBcImZvbnRGYWNlIGV4cGVjdHMgYSBuYW1lIG9mIGEgZm9udC1mYW1pbHkuXFxuXFxuXCIsXG4gIFwiMjRcIjogXCJmb250RmFjZSBleHBlY3RzIGVpdGhlciB0aGUgcGF0aCB0byB0aGUgZm9udCBmaWxlKHMpIG9yIGEgbmFtZSBvZiBhIGxvY2FsIGNvcHkuXFxuXFxuXCIsXG4gIFwiMjVcIjogXCJmb250RmFjZSBleHBlY3RzIGxvY2FsRm9udHMgdG8gYmUgYW4gYXJyYXkuXFxuXFxuXCIsXG4gIFwiMjZcIjogXCJmb250RmFjZSBleHBlY3RzIGZpbGVGb3JtYXRzIHRvIGJlIGFuIGFycmF5LlxcblxcblwiLFxuICBcIjI3XCI6IFwicmFkaWFsR3JhZGllbnQgcmVxdXJpZXMgYXQgbGVhc3QgMiBjb2xvci1zdG9wcyB0byBwcm9wZXJseSByZW5kZXIuXFxuXFxuXCIsXG4gIFwiMjhcIjogXCJQbGVhc2Ugc3VwcGx5IGEgZmlsZW5hbWUgdG8gcmV0aW5hSW1hZ2UoKSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiMjlcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudCB0byB0cmlhbmdsZSwgcGxlYXNlIHBhc3MgY29ycmVjdCBwb2ludGluZ0RpcmVjdGlvbiBlLmcuICdyaWdodCcuXFxuXFxuXCIsXG4gIFwiMzBcIjogXCJQYXNzZWQgYW4gaW52YWxpZCB2YWx1ZSB0byBgaGVpZ2h0YCBvciBgd2lkdGhgLiBQbGVhc2UgcHJvdmlkZSBhIHBpeGVsIGJhc2VkIHVuaXQuXFxuXFxuXCIsXG4gIFwiMzFcIjogXCJUaGUgYW5pbWF0aW9uIHNob3J0aGFuZCBvbmx5IHRha2VzIDggYXJndW1lbnRzLiBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9tZG4uaW8vYW5pbWF0aW9uXFxuXFxuXCIsXG4gIFwiMzJcIjogXCJUbyBwYXNzIG11bHRpcGxlIGFuaW1hdGlvbnMgcGxlYXNlIHN1cHBseSB0aGVtIGluIGFycmF5cywgZS5nLiBhbmltYXRpb24oWydyb3RhdGUnLCAnMnMnXSwgWydtb3ZlJywgJzFzJ10pXFxuVG8gcGFzcyBhIHNpbmdsZSBhbmltYXRpb24gcGxlYXNlIHN1cHBseSB0aGVtIGluIHNpbXBsZSB2YWx1ZXMsIGUuZy4gYW5pbWF0aW9uKCdyb3RhdGUnLCAnMnMnKVxcblxcblwiLFxuICBcIjMzXCI6IFwiVGhlIGFuaW1hdGlvbiBzaG9ydGhhbmQgYXJyYXlzIGNhbiBvbmx5IGhhdmUgOCBlbGVtZW50cy4gU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwOi8vbWRuLmlvL2FuaW1hdGlvblxcblxcblwiLFxuICBcIjM0XCI6IFwiYm9yZGVyUmFkaXVzIGV4cGVjdHMgYSByYWRpdXMgdmFsdWUgYXMgYSBzdHJpbmcgb3IgbnVtYmVyIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiMzVcIjogXCJib3JkZXJSYWRpdXMgZXhwZWN0cyBvbmUgb2YgXFxcInRvcFxcXCIsIFxcXCJib3R0b21cXFwiLCBcXFwibGVmdFxcXCIgb3IgXFxcInJpZ2h0XFxcIiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiMzZcIjogXCJQcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nIHZhbHVlLlxcblxcblwiLFxuICBcIjM3XCI6IFwiU3ludGF4IEVycm9yIGF0ICVzLlxcblxcblwiLFxuICBcIjM4XCI6IFwiRm9ybXVsYSBjb250YWlucyBhIGZ1bmN0aW9uIHRoYXQgbmVlZHMgcGFyZW50aGVzZXMgYXQgJXMuXFxuXFxuXCIsXG4gIFwiMzlcIjogXCJGb3JtdWxhIGlzIG1pc3NpbmcgY2xvc2luZyBwYXJlbnRoZXNpcyBhdCAlcy5cXG5cXG5cIixcbiAgXCI0MFwiOiBcIkZvcm11bGEgaGFzIHRvbyBtYW55IGNsb3NpbmcgcGFyZW50aGVzZXMgYXQgJXMuXFxuXFxuXCIsXG4gIFwiNDFcIjogXCJBbGwgdmFsdWVzIGluIGEgZm9ybXVsYSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdCBvciBiZSB1bml0bGVzcy5cXG5cXG5cIixcbiAgXCI0MlwiOiBcIlBsZWFzZSBwcm92aWRlIGEgbnVtYmVyIG9mIHN0ZXBzIHRvIHRoZSBtb2R1bGFyU2NhbGUgaGVscGVyLlxcblxcblwiLFxuICBcIjQzXCI6IFwiUGxlYXNlIHBhc3MgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBwcmVkZWZpbmVkIHNjYWxlcyB0byB0aGUgbW9kdWxhclNjYWxlIGhlbHBlciBhcyB0aGUgcmF0aW8uXFxuXFxuXCIsXG4gIFwiNDRcIjogXCJJbnZhbGlkIHZhbHVlIHBhc3NlZCBhcyBiYXNlIHRvIG1vZHVsYXJTY2FsZSwgZXhwZWN0ZWQgbnVtYmVyIG9yIGVtL3JlbSBzdHJpbmcgYnV0IGdvdCAlcy5cXG5cXG5cIixcbiAgXCI0NVwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIGhzbFRvQ29sb3JTdHJpbmcsIHBsZWFzZSBwYXNzIGEgSHNsQ29sb3Igb3IgSHNsYUNvbG9yIG9iamVjdC5cXG5cXG5cIixcbiAgXCI0NlwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIHJnYlRvQ29sb3JTdHJpbmcsIHBsZWFzZSBwYXNzIGEgUmdiQ29sb3Igb3IgUmdiYUNvbG9yIG9iamVjdC5cXG5cXG5cIixcbiAgXCI0N1wiOiBcIm1pblNjcmVlbiBhbmQgbWF4U2NyZWVuIG11c3QgYmUgcHJvdmlkZWQgYXMgc3RyaW5naWZpZWQgbnVtYmVycyB3aXRoIHRoZSBzYW1lIHVuaXRzLlxcblxcblwiLFxuICBcIjQ4XCI6IFwiZnJvbVNpemUgYW5kIHRvU2l6ZSBtdXN0IGJlIHByb3ZpZGVkIGFzIHN0cmluZ2lmaWVkIG51bWJlcnMgd2l0aCB0aGUgc2FtZSB1bml0cy5cXG5cXG5cIixcbiAgXCI0OVwiOiBcIkV4cGVjdHMgZWl0aGVyIGFuIGFycmF5IG9mIG9iamVjdHMgb3IgYSBzaW5nbGUgb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgcHJvcCwgZnJvbVNpemUsIGFuZCB0b1NpemUuXFxuXFxuXCIsXG4gIFwiNTBcIjogXCJFeHBlY3RzIHRoZSBvYmplY3RzIGluIHRoZSBmaXJzdCBhcmd1bWVudCBhcnJheSB0byBoYXZlIHRoZSBwcm9wZXJ0aWVzIHByb3AsIGZyb21TaXplLCBhbmQgdG9TaXplLlxcblxcblwiLFxuICBcIjUxXCI6IFwiRXhwZWN0cyB0aGUgZmlyc3QgYXJndW1lbnQgb2JqZWN0IHRvIGhhdmUgdGhlIHByb3BlcnRpZXMgcHJvcCwgZnJvbVNpemUsIGFuZCB0b1NpemUuXFxuXFxuXCIsXG4gIFwiNTJcIjogXCJmb250RmFjZSBleHBlY3RzIGVpdGhlciB0aGUgcGF0aCB0byB0aGUgZm9udCBmaWxlKHMpIG9yIGEgbmFtZSBvZiBhIGxvY2FsIGNvcHkuXFxuXFxuXCIsXG4gIFwiNTNcIjogXCJmb250RmFjZSBleHBlY3RzIGxvY2FsRm9udHMgdG8gYmUgYW4gYXJyYXkuXFxuXFxuXCIsXG4gIFwiNTRcIjogXCJmb250RmFjZSBleHBlY3RzIGZpbGVGb3JtYXRzIHRvIGJlIGFuIGFycmF5LlxcblxcblwiLFxuICBcIjU1XCI6IFwiZm9udEZhY2UgZXhwZWN0cyBhIG5hbWUgb2YgYSBmb250LWZhbWlseS5cXG5cXG5cIixcbiAgXCI1NlwiOiBcImxpbmVhckdyYWRpZW50IHJlcXVyaWVzIGF0IGxlYXN0IDIgY29sb3Itc3RvcHMgdG8gcHJvcGVybHkgcmVuZGVyLlxcblxcblwiLFxuICBcIjU3XCI6IFwicmFkaWFsR3JhZGllbnQgcmVxdXJpZXMgYXQgbGVhc3QgMiBjb2xvci1zdG9wcyB0byBwcm9wZXJseSByZW5kZXIuXFxuXFxuXCIsXG4gIFwiNThcIjogXCJQbGVhc2Ugc3VwcGx5IGEgZmlsZW5hbWUgdG8gcmV0aW5hSW1hZ2UoKSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiNTlcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudCB0byB0cmlhbmdsZSwgcGxlYXNlIHBhc3MgY29ycmVjdCBwb2ludGluZ0RpcmVjdGlvbiBlLmcuICdyaWdodCcuXFxuXFxuXCIsXG4gIFwiNjBcIjogXCJQYXNzZWQgYW4gaW52YWxpZCB2YWx1ZSB0byBgaGVpZ2h0YCBvciBgd2lkdGhgLiBQbGVhc2UgcHJvdmlkZSBhIHBpeGVsIGJhc2VkIHVuaXQuXFxuXFxuXCIsXG4gIFwiNjFcIjogXCJQcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nIHZhbHVlLlxcblxcblwiLFxuICBcIjYyXCI6IFwiYm9yZGVyUmFkaXVzIGV4cGVjdHMgYSByYWRpdXMgdmFsdWUgYXMgYSBzdHJpbmcgb3IgbnVtYmVyIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiNjNcIjogXCJib3JkZXJSYWRpdXMgZXhwZWN0cyBvbmUgb2YgXFxcInRvcFxcXCIsIFxcXCJib3R0b21cXFwiLCBcXFwibGVmdFxcXCIgb3IgXFxcInJpZ2h0XFxcIiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiNjRcIjogXCJUaGUgYW5pbWF0aW9uIHNob3J0aGFuZCBvbmx5IHRha2VzIDggYXJndW1lbnRzLiBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9tZG4uaW8vYW5pbWF0aW9uLlxcblxcblwiLFxuICBcIjY1XCI6IFwiVG8gcGFzcyBtdWx0aXBsZSBhbmltYXRpb25zIHBsZWFzZSBzdXBwbHkgdGhlbSBpbiBhcnJheXMsIGUuZy4gYW5pbWF0aW9uKFsncm90YXRlJywgJzJzJ10sIFsnbW92ZScsICcxcyddKVxcXFxuVG8gcGFzcyBhIHNpbmdsZSBhbmltYXRpb24gcGxlYXNlIHN1cHBseSB0aGVtIGluIHNpbXBsZSB2YWx1ZXMsIGUuZy4gYW5pbWF0aW9uKCdyb3RhdGUnLCAnMnMnKS5cXG5cXG5cIixcbiAgXCI2NlwiOiBcIlRoZSBhbmltYXRpb24gc2hvcnRoYW5kIGFycmF5cyBjYW4gb25seSBoYXZlIDggZWxlbWVudHMuIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cDovL21kbi5pby9hbmltYXRpb24uXFxuXFxuXCIsXG4gIFwiNjdcIjogXCJZb3UgbXVzdCBwcm92aWRlIGEgdGVtcGxhdGUgdG8gdGhpcyBtZXRob2QuXFxuXFxuXCIsXG4gIFwiNjhcIjogXCJZb3UgcGFzc2VkIGFuIHVuc3VwcG9ydGVkIHNlbGVjdG9yIHN0YXRlIHRvIHRoaXMgbWV0aG9kLlxcblxcblwiLFxuICBcIjY5XCI6IFwiRXhwZWN0ZWQgYSBzdHJpbmcgZW5kaW5nIGluIFxcXCJweFxcXCIgb3IgYSBudW1iZXIgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byAlcygpLCBnb3QgJXMgaW5zdGVhZC5cXG5cXG5cIixcbiAgXCI3MFwiOiBcIkV4cGVjdGVkIGEgc3RyaW5nIGVuZGluZyBpbiBcXFwicHhcXFwiIG9yIGEgbnVtYmVyIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvICVzKCksIGdvdCAlcyBpbnN0ZWFkLlxcblxcblwiLFxuICBcIjcxXCI6IFwiUGFzc2VkIGludmFsaWQgcGl4ZWwgdmFsdWUgJXMgdG8gJXMoKSwgcGxlYXNlIHBhc3MgYSB2YWx1ZSBsaWtlIFxcXCIxMnB4XFxcIiBvciAxMi5cXG5cXG5cIixcbiAgXCI3MlwiOiBcIlBhc3NlZCBpbnZhbGlkIGJhc2UgdmFsdWUgJXMgdG8gJXMoKSwgcGxlYXNlIHBhc3MgYSB2YWx1ZSBsaWtlIFxcXCIxMnB4XFxcIiBvciAxMi5cXG5cIlxufTtcbi8qKlxuICogc3VwZXIgYmFzaWMgdmVyc2lvbiBvZiBzcHJpbnRmXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdCgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBhID0gYXJnc1swXTtcbiAgdmFyIGIgPSBbXTtcbiAgdmFyIGM7XG5cbiAgZm9yIChjID0gMTsgYyA8IGFyZ3MubGVuZ3RoOyBjICs9IDEpIHtcbiAgICBiLnB1c2goYXJnc1tjXSk7XG4gIH1cblxuICBiLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBhID0gYS5yZXBsYWNlKC8lW2Etel0vLCBkKTtcbiAgfSk7XG4gIHJldHVybiBhO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gZXJyb3IgZmlsZSBvdXQgb2YgZXJyb3JzLm1kIGZvciBkZXZlbG9wbWVudCBhbmQgYSBzaW1wbGUgd2ViIGxpbmsgdG8gdGhlIGZ1bGwgZXJyb3JzXG4gKiBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIFBvbGlzaGVkRXJyb3IgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShQb2xpc2hlZEVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFBvbGlzaGVkRXJyb3IoY29kZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBfdGhpcyA9IF9FcnJvci5jYWxsKHRoaXMsIFwiQW4gZXJyb3Igb2NjdXJyZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3R5bGVkLWNvbXBvbmVudHMvcG9saXNoZWQvYmxvYi9tYXN0ZXIvc3JjL2Vycm9yL2Vycm9ycy5tZCNcIiArIGNvZGUgKyBcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIikgfHwgdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMgPSBfRXJyb3IuY2FsbCh0aGlzLCBmb3JtYXQuYXBwbHkodm9pZCAwLCBbRVJST1JTW2NvZGVdXS5jb25jYXQoYXJncykpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgfVxuXG4gIHJldHVybiBQb2xpc2hlZEVycm9yO1xufShcbi8qI19fUFVSRV9fKi9cbl93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxudmFyIHVuaXRSZWdFeHAgPSAvKCg/IVxcdylhfG5hfGhjfG1jfGRnfG1lW3JdP3x4ZXxuaSg/IVthLXpBLVpdKXxtbXxjcHx0cHx4cHxxKD8hcyl8aHZ8eGFtdnxuaW12fHd2fHNtfHMoPyFcXER8JCl8Z2VkfGRhcmc/fG5ydXQpL2c7IC8vIE1lcmdlcyBhZGRpdGlvbmFsIG1hdGggZnVuY3Rpb25hbGl0eSBpbnRvIHRoZSBkZWZhdWx0cy5cblxuZnVuY3Rpb24gbWVyZ2VTeW1ib2xNYXBzKGFkZGl0aW9uYWxTeW1ib2xzKSB7XG4gIHZhciBzeW1ib2xNYXAgPSB7fTtcbiAgc3ltYm9sTWFwLnN5bWJvbHMgPSBhZGRpdGlvbmFsU3ltYm9scyA/IF9leHRlbmRzKHt9LCBkZWZhdWx0TWF0aFN5bWJvbHMuc3ltYm9scywgYWRkaXRpb25hbFN5bWJvbHMuc3ltYm9scykgOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdE1hdGhTeW1ib2xzLnN5bWJvbHMpO1xuICByZXR1cm4gc3ltYm9sTWFwO1xufVxuXG5mdW5jdGlvbiBleGVjKG9wZXJhdG9ycywgdmFsdWVzKSB7XG4gIHZhciBfcmVmO1xuXG4gIHZhciBvcCA9IG9wZXJhdG9ycy5wb3AoKTtcbiAgdmFsdWVzLnB1c2gob3AuZi5hcHBseShvcCwgKF9yZWYgPSBbXSkuY29uY2F0LmFwcGx5KF9yZWYsIHZhbHVlcy5zcGxpY2UoLW9wLmFyZ0NvdW50KSkpKTtcbiAgcmV0dXJuIG9wLnByZWNlZGVuY2U7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZShleHByZXNzaW9uLCBhZGRpdGlvbmFsU3ltYm9scykge1xuICB2YXIgc3ltYm9sTWFwID0gbWVyZ2VTeW1ib2xNYXBzKGFkZGl0aW9uYWxTeW1ib2xzKTtcbiAgdmFyIG1hdGNoO1xuICB2YXIgb3BlcmF0b3JzID0gW3N5bWJvbE1hcC5zeW1ib2xzWycoJ10ucHJlZml4XTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgcGF0dGVybiA9IG5ldyBSZWdFeHAoIC8vIFBhdHRlcm4gZm9yIG51bWJlcnNcbiAgXCJcXFxcZCsoPzpcXFxcLlxcXFxkKyk/fFwiICsgLy8gLi4uYW5kIHBhdHRlcm5zIGZvciBpbmRpdmlkdWFsIG9wZXJhdG9ycy9mdW5jdGlvbiBuYW1lc1xuICBPYmplY3Qua2V5cyhzeW1ib2xNYXAuc3ltYm9scykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gc3ltYm9sTWFwLnN5bWJvbHNba2V5XTtcbiAgfSkgLy8gbG9uZ2VyIHN5bWJvbHMgc2hvdWxkIGJlIGxpc3RlZCBmaXJzdFxuICAvLyAkRmxvd0ZpeE1lXG4gIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuc3ltYm9sLmxlbmd0aCAtIGEuc3ltYm9sLmxlbmd0aDtcbiAgfSkgLy8gJEZsb3dGaXhNZVxuICAubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsLnJlZ1N5bWJvbDtcbiAgfSkuam9pbignfCcpICsgXCJ8KFxcXFxTKVwiLCAnZycpO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7IC8vIFJlc2V0IHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3RcblxuICB2YXIgYWZ0ZXJWYWx1ZSA9IGZhbHNlO1xuXG4gIGRvIHtcbiAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhleHByZXNzaW9uKTtcblxuICAgIHZhciBfcmVmMiA9IG1hdGNoIHx8IFsnKScsIHVuZGVmaW5lZF0sXG4gICAgICAgIHRva2VuID0gX3JlZjJbMF0sXG4gICAgICAgIGJhZCA9IF9yZWYyWzFdO1xuXG4gICAgdmFyIG5vdE51bWJlciA9IHN5bWJvbE1hcC5zeW1ib2xzW3Rva2VuXTtcbiAgICB2YXIgbm90TmV3VmFsdWUgPSBub3ROdW1iZXIgJiYgIW5vdE51bWJlci5wcmVmaXggJiYgIW5vdE51bWJlci5mdW5jO1xuICAgIHZhciBub3RBZnRlclZhbHVlID0gIW5vdE51bWJlciB8fCAhbm90TnVtYmVyLnBvc3RmaXggJiYgIW5vdE51bWJlci5pbmZpeDsgLy8gQ2hlY2sgZm9yIHN5bnRheCBlcnJvcnM6XG5cbiAgICBpZiAoYmFkIHx8IChhZnRlclZhbHVlID8gbm90QWZ0ZXJWYWx1ZSA6IG5vdE5ld1ZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoMzcsIG1hdGNoID8gbWF0Y2guaW5kZXggOiBleHByZXNzaW9uLmxlbmd0aCwgZXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgaWYgKGFmdGVyVmFsdWUpIHtcbiAgICAgIC8vIFdlIGVpdGhlciBoYXZlIGFuIGluZml4IG9yIHBvc3RmaXggb3BlcmF0b3IgKHRoZXkgc2hvdWxkIGJlIG11dHVhbGx5IGV4Y2x1c2l2ZSlcbiAgICAgIHZhciBjdXJyID0gbm90TnVtYmVyLnBvc3RmaXggfHwgbm90TnVtYmVyLmluZml4O1xuXG4gICAgICBkbyB7XG4gICAgICAgIHZhciBwcmV2ID0gb3BlcmF0b3JzW29wZXJhdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKChjdXJyLnByZWNlZGVuY2UgLSBwcmV2LnByZWNlZGVuY2UgfHwgcHJldi5yaWdodFRvTGVmdCkgPiAwKSBicmVhazsgLy8gQXBwbHkgcHJldmlvdXMgb3BlcmF0b3IsIHNpbmNlIGl0IGhhcyBwcmVjZWRlbmNlIG92ZXIgY3VycmVudCBvbmVcbiAgICAgIH0gd2hpbGUgKGV4ZWMob3BlcmF0b3JzLCB2YWx1ZXMpKTsgLy8gRXhpdCBsb29wIGFmdGVyIGV4ZWN1dGluZyBhbiBvcGVuaW5nIHBhcmVudGhlc2lzIG9yIGZ1bmN0aW9uXG5cblxuICAgICAgYWZ0ZXJWYWx1ZSA9IGN1cnIubm90YXRpb24gPT09ICdwb3N0Zml4JztcblxuICAgICAgaWYgKGN1cnIuc3ltYm9sICE9PSAnKScpIHtcbiAgICAgICAgb3BlcmF0b3JzLnB1c2goY3Vycik7IC8vIFBvc3RmaXggYWx3YXlzIGhhcyBwcmVjZWRlbmNlIG92ZXIgYW55IG9wZXJhdG9yIHRoYXQgZm9sbG93cyBhZnRlciBpdFxuXG4gICAgICAgIGlmIChhZnRlclZhbHVlKSBleGVjKG9wZXJhdG9ycywgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vdE51bWJlcikge1xuICAgICAgLy8gcHJlZml4IG9wZXJhdG9yIG9yIGZ1bmN0aW9uXG4gICAgICBvcGVyYXRvcnMucHVzaChub3ROdW1iZXIucHJlZml4IHx8IG5vdE51bWJlci5mdW5jKTtcblxuICAgICAgaWYgKG5vdE51bWJlci5mdW5jKSB7XG4gICAgICAgIC8vIFJlcXVpcmUgYW4gb3BlbmluZyBwYXJlbnRoZXNpc1xuICAgICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhleHByZXNzaW9uKTtcblxuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoWzBdICE9PSAnKCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcigzOCwgbWF0Y2ggPyBtYXRjaC5pbmRleCA6IGV4cHJlc3Npb24ubGVuZ3RoLCBleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBudW1iZXJcbiAgICAgIHZhbHVlcy5wdXNoKCt0b2tlbik7XG4gICAgICBhZnRlclZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0gd2hpbGUgKG1hdGNoICYmIG9wZXJhdG9ycy5sZW5ndGgpO1xuXG4gIGlmIChvcGVyYXRvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoMzksIG1hdGNoID8gbWF0Y2guaW5kZXggOiBleHByZXNzaW9uLmxlbmd0aCwgZXhwcmVzc2lvbik7XG4gIH0gZWxzZSBpZiAobWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0MCwgbWF0Y2ggPyBtYXRjaC5pbmRleCA6IGV4cHJlc3Npb24ubGVuZ3RoLCBleHByZXNzaW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWVzLnBvcCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbn1cbi8qKlxuICogSGVscGVyIGZvciBkb2luZyBtYXRoIHdpdGggQ1NTIFVuaXRzLiBBY2NlcHRzIGEgZm9ybXVsYSBhcyBhIHN0cmluZy4gQWxsIHZhbHVlcyBpbiB0aGUgZm9ybXVsYSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdCAob3IgYmUgdW5pdGxlc3MpLiBTdXBwb3J0cyBjb21wbGV4IGZvcm11bGFzIHV0bGl6aWluZyBhZGRpdGlvbiwgc3VidHJhY3Rpb24sIG11bHRpcGxpY2F0aW9uLCBkaXZpc2lvbiwgc3F1YXJlIHJvb3QsIHBvd2VycywgZmFjdG9yaWFsLCBtaW4sIG1heCwgYXMgd2VsbCBhcyBwYXJlbnRoZXNlcyBmb3Igb3JkZXIgb2Ygb3BlcmF0aW9uLlxuICpcbiAqSW4gY2FzZXMgd2hlcmUgeW91IG5lZWQgdG8gZG8gY2FsY3VsYXRpb25zIHdpdGggbWl4ZWQgdW5pdHMgd2hlcmUgb25lIHVuaXQgaXMgYSBbcmVsYXRpdmUgbGVuZ3RoIHVuaXRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9sZW5ndGgjUmVsYXRpdmVfbGVuZ3RoX3VuaXRzKSwgeW91IHdpbGwgd2FudCB0byB1c2UgW0NTUyBDYWxjXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY2FsYykuXG4gKlxuICogKndhcm5pbmcqIFdoaWxlIHdlJ3ZlIGRvbmUgZXZlcnl0aGluZyBwb3NzaWJsZSB0byBlbnN1cmUgbWF0aCBzYWZlbHkgZXZhbHV0ZXMgZm9ybXVsYXMgZXhwcmVzc2VkIGFzIHN0cmluZ3MsIHlvdSBzaG91bGQgYWx3YXlzIHVzZSBleHRyZW1lIGNhdXRpb24gd2hlbiBwYXNzaW5nIGBtYXRoYCB1c2VyIHByb3ZpZGVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGZvbnRTaXplOiBtYXRoKCcxMnJlbSArIDhyZW0nKSxcbiAqICAgZm9udFNpemU6IG1hdGgoJygxMnB4ICsgMnB4KSAqIDMnKSxcbiAqICAgZm9udFNpemU6IG1hdGgoJzNweF4yICsgc3FydCg0KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBmb250U2l6ZTogJHttYXRoKCcxMnJlbSArIDhyZW0nKX07XG4gKiAgIGZvbnRTaXplOiAke21hdGgoJygxMnB4ICsgMnB4KSAqIDMnKX07XG4gKiAgIGZvbnRTaXplOiAke21hdGgoJzNweF4yICsgc3FydCg0KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgIGZvbnRTaXplOiAnMjByZW0nLFxuICogICBmb250U2l6ZTogJzQycHgnLFxuICogICBmb250U2l6ZTogJzExcHgnLFxuICogfVxuICovXG5cblxuZnVuY3Rpb24gbWF0aChmb3JtdWxhLCBhZGRpdGlvbmFsU3ltYm9scykge1xuICB2YXIgcmV2ZXJzZWRGb3JtdWxhID0gcmV2ZXJzZVN0cmluZyhmb3JtdWxhKTtcbiAgdmFyIGZvcm11bGFNYXRjaCA9IHJldmVyc2VkRm9ybXVsYS5tYXRjaCh1bml0UmVnRXhwKTsgLy8gQ2hlY2sgdGhhdCBhbGwgdW5pdHMgYXJlIHRoZSBzYW1lXG5cbiAgaWYgKGZvcm11bGFNYXRjaCAmJiAhZm9ybXVsYU1hdGNoLmV2ZXJ5KGZ1bmN0aW9uICh1bml0KSB7XG4gICAgcmV0dXJuIHVuaXQgPT09IGZvcm11bGFNYXRjaFswXTtcbiAgfSkpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0MSk7XG4gIH1cblxuICB2YXIgY2xlYW5Gb3JtdWxhID0gcmV2ZXJzZVN0cmluZyhyZXZlcnNlZEZvcm11bGEucmVwbGFjZSh1bml0UmVnRXhwLCAnJykpO1xuICByZXR1cm4gXCJcIiArIGNhbGN1bGF0ZShjbGVhbkZvcm11bGEsIGFkZGl0aW9uYWxTeW1ib2xzKSArIChmb3JtdWxhTWF0Y2ggPyByZXZlcnNlU3RyaW5nKGZvcm11bGFNYXRjaFswXSkgOiAnJyk7XG59XG5cbi8vIEBwcml2YXRlXG5mdW5jdGlvbiBjYXBpdGFsaXplU3RyaW5nKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG52YXIgcG9zaXRpb25NYXAgPSBbJ1RvcCcsICdSaWdodCcsICdCb3R0b20nLCAnTGVmdCddO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVByb3BlcnR5KHByb3BlcnR5LCBwb3NpdGlvbikge1xuICBpZiAoIXByb3BlcnR5KSByZXR1cm4gcG9zaXRpb24udG9Mb3dlckNhc2UoKTtcbiAgdmFyIHNwbGl0UHJvcGVydHkgPSBwcm9wZXJ0eS5zcGxpdCgnLScpO1xuXG4gIGlmIChzcGxpdFByb3BlcnR5Lmxlbmd0aCA+IDEpIHtcbiAgICBzcGxpdFByb3BlcnR5LnNwbGljZSgxLCAwLCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIHNwbGl0UHJvcGVydHkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBhY2MgKyBjYXBpdGFsaXplU3RyaW5nKHZhbCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgam9pbmVkUHJvcGVydHkgPSBwcm9wZXJ0eS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxXCIgKyBwb3NpdGlvbiArIFwiJDJcIik7XG4gIHJldHVybiBwcm9wZXJ0eSA9PT0gam9pbmVkUHJvcGVydHkgPyBcIlwiICsgcHJvcGVydHkgKyBwb3NpdGlvbiA6IGpvaW5lZFByb3BlcnR5O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVN0eWxlcyhwcm9wZXJ0eSwgdmFsdWVzV2l0aERlZmF1bHRzKSB7XG4gIHZhciBzdHlsZXMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlc1dpdGhEZWZhdWx0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmICh2YWx1ZXNXaXRoRGVmYXVsdHNbaV0gfHwgdmFsdWVzV2l0aERlZmF1bHRzW2ldID09PSAwKSB7XG4gICAgICBzdHlsZXNbZ2VuZXJhdGVQcm9wZXJ0eShwcm9wZXJ0eSwgcG9zaXRpb25NYXBbaV0pXSA9IHZhbHVlc1dpdGhEZWZhdWx0c1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGVzO1xufVxuLyoqXG4gKiBFbmFibGVzIHNob3J0aGFuZCBmb3IgZGlyZWN0aW9uLWJhc2VkIHByb3BlcnRpZXMuIEl0IGFjY2VwdHMgYSBwcm9wZXJ0eSAoaHlwaGVuYXRlZCBvciBjYW1lbENhc2VkKSBhbmQgdXAgdG8gZm91ciB2YWx1ZXMgdGhhdCBtYXAgdG8gdG9wLCByaWdodCwgYm90dG9tLCBhbmQgbGVmdCwgcmVzcGVjdGl2ZWx5LiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhbiBlbXB0eSBzdHJpbmcgdG8gZ2V0IG9ubHkgdGhlIGRpcmVjdGlvbmFsIHZhbHVlcyBhcyBwcm9wZXJ0aWVzLiBZb3UgY2FuIGFsc28gb3B0aW9uYWxseSBwYXNzIGEgbnVsbCBhcmd1bWVudCBmb3IgYSBkaXJlY3Rpb25hbCB2YWx1ZSB0byBpZ25vcmUgaXQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5kaXJlY3Rpb25hbFByb3BlcnR5KCdwYWRkaW5nJywgJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2RpcmVjdGlvbmFsUHJvcGVydHkoJ3BhZGRpbmcnLCAnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAncGFkZGluZ1RvcCc6ICcxMnB4JyxcbiAqICAgJ3BhZGRpbmdSaWdodCc6ICcyNHB4JyxcbiAqICAgJ3BhZGRpbmdCb3R0b20nOiAnMzZweCcsXG4gKiAgICdwYWRkaW5nTGVmdCc6ICc0OHB4J1xuICogfVxuICovXG5cblxuZnVuY3Rpb24gZGlyZWN0aW9uYWxQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgLy8gIHByZXR0aWVyLWlnbm9yZVxuICB2YXIgZmlyc3RWYWx1ZSA9IHZhbHVlc1swXSxcbiAgICAgIF92YWx1ZXMkID0gdmFsdWVzWzFdLFxuICAgICAgc2Vjb25kVmFsdWUgPSBfdmFsdWVzJCA9PT0gdm9pZCAwID8gZmlyc3RWYWx1ZSA6IF92YWx1ZXMkLFxuICAgICAgX3ZhbHVlcyQyID0gdmFsdWVzWzJdLFxuICAgICAgdGhpcmRWYWx1ZSA9IF92YWx1ZXMkMiA9PT0gdm9pZCAwID8gZmlyc3RWYWx1ZSA6IF92YWx1ZXMkMixcbiAgICAgIF92YWx1ZXMkMyA9IHZhbHVlc1szXSxcbiAgICAgIGZvdXJ0aFZhbHVlID0gX3ZhbHVlcyQzID09PSB2b2lkIDAgPyBzZWNvbmRWYWx1ZSA6IF92YWx1ZXMkMztcbiAgdmFyIHZhbHVlc1dpdGhEZWZhdWx0cyA9IFtmaXJzdFZhbHVlLCBzZWNvbmRWYWx1ZSwgdGhpcmRWYWx1ZSwgZm91cnRoVmFsdWVdO1xuICByZXR1cm4gZ2VuZXJhdGVTdHlsZXMocHJvcGVydHksIHZhbHVlc1dpdGhEZWZhdWx0cyk7XG59XG5cbmZ1bmN0aW9uIGVuZHNXaXRoIChzdHJpbmcsIHN1ZmZpeCkge1xuICByZXR1cm4gc3RyaW5nLnN1YnN0cigtc3VmZml4Lmxlbmd0aCkgPT09IHN1ZmZpeDtcbn1cblxudmFyIGNzc1JlZ2V4ID0gL14oWystXT8oPzpcXGQrfFxcZCpcXC5cXGQrKSkoW2Etel0qfCUpJC87XG4vKipcbiAqIFJldHVybnMgYSBnaXZlbiBDU1MgdmFsdWUgbWludXMgaXRzIHVuaXQgKG9yIHRoZSBvcmlnaW5hbCB2YWx1ZSBpZiBhbiBpbnZhbGlkIHN0cmluZyBpcyBwYXNzZWQpLiBPcHRpb25hbGx5IHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgc3RyaXBwZWQgdmFsdWUgYW5kIHRoZSBvcmlnaW5hbCB1bml0IG9mIG1lYXN1cmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJy0tZGltZW5zaW9uJzogc3RyaXBVbml0KCcxMDBweCcpLFxuICogICAnLS11bml0Jzogc3RyaXBVbml0KCcxMDBweCcpWzFdLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAtLWRpbWVuc2lvbjogJHtzdHJpcFVuaXQoJzEwMHB4Jyl9O1xuICogICAtLXVuaXQ6ICR7c3RyaXBVbml0KCcxMDBweCcpWzFdfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICctLWRpbWVuc2lvbic6IDEwMCxcbiAqICAgJy0tdW5pdCc6ICdweCcsXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gc3RyaXBVbml0KHZhbHVlLCB1bml0UmV0dXJuKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm4gdW5pdFJldHVybiA/IFt2YWx1ZSwgdW5kZWZpbmVkXSA6IHZhbHVlO1xuICB2YXIgbWF0Y2hlZFZhbHVlID0gdmFsdWUubWF0Y2goY3NzUmVnZXgpO1xuXG4gIGlmICh1bml0UmV0dXJuKSB7XG4gICAgaWYgKG1hdGNoZWRWYWx1ZSkgcmV0dXJuIFtwYXJzZUZsb2F0KHZhbHVlKSwgbWF0Y2hlZFZhbHVlWzJdXTtcbiAgICByZXR1cm4gW3ZhbHVlLCB1bmRlZmluZWRdO1xuICB9XG5cbiAgaWYgKG1hdGNoZWRWYWx1ZSkgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgcGl4ZWwtdG8teCBjb252ZXJ0ZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBweHRvRmFjdG9yeSA9IGZ1bmN0aW9uIHB4dG9GYWN0b3J5KHRvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocHh2YWwsIGJhc2UpIHtcbiAgICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgICBiYXNlID0gJzE2cHgnO1xuICAgIH1cblxuICAgIHZhciBuZXdQeHZhbCA9IHB4dmFsO1xuICAgIHZhciBuZXdCYXNlID0gYmFzZTtcblxuICAgIGlmICh0eXBlb2YgcHh2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoIWVuZHNXaXRoKHB4dmFsLCAncHgnKSkge1xuICAgICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2OSwgdG8sIHB4dmFsKTtcbiAgICAgIH1cblxuICAgICAgbmV3UHh2YWwgPSBzdHJpcFVuaXQocHh2YWwpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghZW5kc1dpdGgoYmFzZSwgJ3B4JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzAsIHRvLCBiYXNlKTtcbiAgICAgIH1cblxuICAgICAgbmV3QmFzZSA9IHN0cmlwVW5pdChiYXNlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld1B4dmFsID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzEsIHB4dmFsLCB0byk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdCYXNlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzIsIGJhc2UsIHRvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIiArIG5ld1B4dmFsIC8gbmV3QmFzZSArIHRvO1xuICB9O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHBpeGVsIHZhbHVlIHRvIGVtcy4gVGhlIGRlZmF1bHQgYmFzZSB2YWx1ZSBpcyAxNnB4LCBidXQgY2FuIGJlIGNoYW5nZWQgYnkgcGFzc2luZyBhXG4gKiBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHB4dmFsXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtiYXNlPScxNnB4J11cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICdoZWlnaHQnOiBlbSgnMTZweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGhlaWdodDogJHtlbSgnMTZweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgJ2hlaWdodCc6ICcxZW0nXG4gKiB9XG4gKi9cblxudmFyIGVtID1cbi8qI19fUFVSRV9fKi9cbnB4dG9GYWN0b3J5KCdlbScpO1xuXG52YXIgY3NzUmVnZXgkMSA9IC9eKFsrLV0/KD86XFxkK3xcXGQqXFwuXFxkKykpKFthLXpdKnwlKSQvO1xuLyoqXG4gKiBSZXR1cm5zIGEgZ2l2ZW4gQ1NTIHZhbHVlIGFuZCBpdHMgdW5pdCBhcyBlbGVtZW50cyBvZiBhbiBhcnJheS5cbiAqXG4gKiBAZGVwcmVjYXRlZCAtIGdldFZhbHVlQW5kVW5pdCBoYXMgYmVlbiBtYXJrZWQgZm9yIGRlcHJlY2F0aW9uIGluIHBvbGlzaGVkIDMuMCBhbmQgd2lsbCBiZSBmdWxseSBkZXByZWNhdGVkIGluIDQuMC4gSXQncyBmdW5jdGlvbmFsaXR5IGhhcyBiZWVuIGJlZW4gbW92ZWQgdG8gc3RyaXBVbml0IGFzIGFuIG9wdGlvbmFsIHJldHVybi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAnLS1kaW1lbnNpb24nOiBnZXRWYWx1ZUFuZFVuaXQoJzEwMHB4JylbMF0sXG4gKiAgICctLXVuaXQnOiBnZXRWYWx1ZUFuZFVuaXQoJzEwMHB4JylbMV0sXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIC0tZGltZW5zaW9uOiAke2dldFZhbHVlQW5kVW5pdCgnMTAwcHgnKVswXX07XG4gKiAgIC0tdW5pdDogJHtnZXRWYWx1ZUFuZFVuaXQoJzEwMHB4JylbMV19O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgJy0tZGltZW5zaW9uJzogMTAwLFxuICogICAnLS11bml0JzogJ3B4JyxcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRWYWx1ZUFuZFVuaXQodmFsdWUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS53YXJuKFwiZ2V0VmFsdWVBbmRVbml0IGhhcyBiZWVuIG1hcmtlZCBmb3IgZGVwcmVjYXRpb24gaW4gcG9saXNoZWQgMy4wIGFuZCB3aWxsIGJlIGZ1bGx5IGRlcHJlY2F0ZWQgaW4gNC4wLiBJdCdzIGZ1bmN0aW9uYWxpdHkgaGFzIGJlZW4gYmVlbiBtb3ZlZCB0byBzdHJpcFVuaXQgYXMgYW4gb3B0aW9uYWwgcmV0dXJuLlwiKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHJldHVybiBbdmFsdWUsICcnXTtcbiAgdmFyIG1hdGNoZWRWYWx1ZSA9IHZhbHVlLm1hdGNoKGNzc1JlZ2V4JDEpO1xuICBpZiAobWF0Y2hlZFZhbHVlKSByZXR1cm4gW3BhcnNlRmxvYXQodmFsdWUpLCBtYXRjaGVkVmFsdWVbMl1dO1xuICByZXR1cm4gW3ZhbHVlLCB1bmRlZmluZWRdO1xufVxuXG52YXIgcmF0aW9OYW1lcyA9IHtcbiAgbWlub3JTZWNvbmQ6IDEuMDY3LFxuICBtYWpvclNlY29uZDogMS4xMjUsXG4gIG1pbm9yVGhpcmQ6IDEuMixcbiAgbWFqb3JUaGlyZDogMS4yNSxcbiAgcGVyZmVjdEZvdXJ0aDogMS4zMzMsXG4gIGF1Z0ZvdXJ0aDogMS40MTQsXG4gIHBlcmZlY3RGaWZ0aDogMS41LFxuICBtaW5vclNpeHRoOiAxLjYsXG4gIGdvbGRlblNlY3Rpb246IDEuNjE4LFxuICBtYWpvclNpeHRoOiAxLjY2NyxcbiAgbWlub3JTZXZlbnRoOiAxLjc3OCxcbiAgbWFqb3JTZXZlbnRoOiAxLjg3NSxcbiAgb2N0YXZlOiAyLFxuICBtYWpvclRlbnRoOiAyLjUsXG4gIG1ham9yRWxldmVudGg6IDIuNjY3LFxuICBtYWpvclR3ZWxmdGg6IDMsXG4gIGRvdWJsZU9jdGF2ZTogNFxufTtcblxuZnVuY3Rpb24gZ2V0UmF0aW8ocmF0aW9OYW1lKSB7XG4gIHJldHVybiByYXRpb05hbWVzW3JhdGlvTmFtZV07XG59XG4vKipcbiAqIEVzdGFibGlzaCBjb25zaXN0ZW50IG1lYXN1cmVtZW50cyBhbmQgc3BhY2lhbCByZWxhdGlvbnNoaXBzIHRocm91Z2hvdXQgeW91ciBwcm9qZWN0cyBieSBpbmNyZW1lbnRpbmcgYW4gZW0gb3IgcmVtIHZhbHVlIHVwIG9yIGRvd24gYSBkZWZpbmVkIHNjYWxlLiBXZSBwcm92aWRlIGEgbGlzdCBvZiBjb21tb25seSB1c2VkIHNjYWxlcyBhcyBwcmUtZGVmaW5lZCB2YXJpYWJsZXMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAgLy8gSW5jcmVtZW50IHR3byBzdGVwcyB1cCB0aGUgZGVmYXVsdCBzY2FsZVxuICogICAnZm9udFNpemUnOiBtb2R1bGFyU2NhbGUoMilcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgIC8vIEluY3JlbWVudCB0d28gc3RlcHMgdXAgdGhlIGRlZmF1bHQgc2NhbGVcbiAqICAgZm9udFNpemU6ICR7bW9kdWxhclNjYWxlKDIpfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgJ2ZvbnRTaXplJzogJzEuNzc2ODllbSdcbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1vZHVsYXJTY2FsZShzdGVwcywgYmFzZSwgcmF0aW8pIHtcbiAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xuICAgIGJhc2UgPSAnMWVtJztcbiAgfVxuXG4gIGlmIChyYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgcmF0aW8gPSAncGVyZmVjdEZvdXJ0aCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHN0ZXBzICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQyKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmF0aW8gPT09ICdzdHJpbmcnICYmICFyYXRpb05hbWVzW3JhdGlvXSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQzKTtcbiAgfVxuXG4gIHZhciBfcmVmID0gdHlwZW9mIGJhc2UgPT09ICdzdHJpbmcnID8gc3RyaXBVbml0KGJhc2UsIHRydWUpIDogW2Jhc2UsICcnXSxcbiAgICAgIHJlYWxCYXNlID0gX3JlZlswXSxcbiAgICAgIHVuaXQgPSBfcmVmWzFdO1xuXG4gIHZhciByZWFsUmF0aW8gPSB0eXBlb2YgcmF0aW8gPT09ICdzdHJpbmcnID8gZ2V0UmF0aW8ocmF0aW8pIDogcmF0aW87XG5cbiAgaWYgKHR5cGVvZiByZWFsQmFzZSA9PT0gJ3N0cmluZycgfHwgdW5pdCAhPT0gJ2VtJyAmJiB1bml0ICE9PSAncmVtJykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ0LCBiYXNlKTtcbiAgfVxuXG4gIHJldHVybiBcIlwiICsgcmVhbEJhc2UgKiBNYXRoLnBvdyhyZWFsUmF0aW8sIHN0ZXBzKSArIHVuaXQ7XG59XG5cbi8qKlxuICogQ29udmVydCBwaXhlbCB2YWx1ZSB0byByZW1zLiBUaGUgZGVmYXVsdCBiYXNlIHZhbHVlIGlzIDE2cHgsIGJ1dCBjYW4gYmUgY2hhbmdlZCBieSBwYXNzaW5nIGFcbiAqIHNlY29uZCBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gcHh2YWxcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2Jhc2U9JzE2cHgnXVxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJ2hlaWdodCc6IHJlbSgnMTZweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGhlaWdodDogJHtyZW0oJzE2cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICdoZWlnaHQnOiAnMXJlbSdcbiAqIH1cbiAqL1xuXG52YXIgcmVtID1cbi8qI19fUFVSRV9fKi9cbnB4dG9GYWN0b3J5KCdyZW0nKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgQ1NTIGNhbGMgZm9ybXVsYSBmb3IgbGluZWFyIGludGVycG9sYXRpb24gb2YgYSBwcm9wZXJ0eSBiZXR3ZWVuIHR3byB2YWx1ZXMuIEFjY2VwdHMgb3B0aW9uYWwgbWluU2NyZWVuIChkZWZhdWx0cyB0byAnMzIwcHgnKSBhbmQgbWF4U2NyZWVuIChkZWZhdWx0cyB0byAnMTIwMHB4JykuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgZm9udFNpemU6IGJldHdlZW4oJzIwcHgnLCAnMTAwcHgnLCAnNDAwcHgnLCAnMTAwMHB4JyksXG4gKiAgIGZvbnRTaXplOiBiZXR3ZWVuKCcyMHB4JywgJzEwMHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgZm9udFNpemU6ICR7YmV0d2VlbignMjBweCcsICcxMDBweCcsICc0MDBweCcsICcxMDAwcHgnKX07XG4gKiAgIGZvbnRTaXplOiAke2JldHdlZW4oJzIwcHgnLCAnMTAwcHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogaDE6IHtcbiAqICAgJ2ZvbnRTaXplJzogJ2NhbGMoLTMzLjMzMzMzMzMzMzMzMzM0cHggKyAxMy4zMzMzMzMzMzMzMzMzMzR2dyknLFxuICogICAnZm9udFNpemUnOiAnY2FsYygtOS4wOTA5MDkwOTA5MDkwOTNweCArIDkuMDkwOTA5MDkwOTA5MDkydncpJ1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGJldHdlZW4oZnJvbVNpemUsIHRvU2l6ZSwgbWluU2NyZWVuLCBtYXhTY3JlZW4pIHtcbiAgaWYgKG1pblNjcmVlbiA9PT0gdm9pZCAwKSB7XG4gICAgbWluU2NyZWVuID0gJzMyMHB4JztcbiAgfVxuXG4gIGlmIChtYXhTY3JlZW4gPT09IHZvaWQgMCkge1xuICAgIG1heFNjcmVlbiA9ICcxMjAwcHgnO1xuICB9XG5cbiAgdmFyIF9zdHJpcFVuaXQgPSBzdHJpcFVuaXQoZnJvbVNpemUsIHRydWUpLFxuICAgICAgdW5pdGxlc3NGcm9tU2l6ZSA9IF9zdHJpcFVuaXRbMF0sXG4gICAgICBmcm9tU2l6ZVVuaXQgPSBfc3RyaXBVbml0WzFdO1xuXG4gIHZhciBfc3RyaXBVbml0MiA9IHN0cmlwVW5pdCh0b1NpemUsIHRydWUpLFxuICAgICAgdW5pdGxlc3NUb1NpemUgPSBfc3RyaXBVbml0MlswXSxcbiAgICAgIHRvU2l6ZVVuaXQgPSBfc3RyaXBVbml0MlsxXTtcblxuICB2YXIgX3N0cmlwVW5pdDMgPSBzdHJpcFVuaXQobWluU2NyZWVuLCB0cnVlKSxcbiAgICAgIHVuaXRsZXNzTWluU2NyZWVuID0gX3N0cmlwVW5pdDNbMF0sXG4gICAgICBtaW5TY3JlZW5Vbml0ID0gX3N0cmlwVW5pdDNbMV07XG5cbiAgdmFyIF9zdHJpcFVuaXQ0ID0gc3RyaXBVbml0KG1heFNjcmVlbiwgdHJ1ZSksXG4gICAgICB1bml0bGVzc01heFNjcmVlbiA9IF9zdHJpcFVuaXQ0WzBdLFxuICAgICAgbWF4U2NyZWVuVW5pdCA9IF9zdHJpcFVuaXQ0WzFdO1xuXG4gIGlmICh0eXBlb2YgdW5pdGxlc3NNaW5TY3JlZW4gIT09ICdudW1iZXInIHx8IHR5cGVvZiB1bml0bGVzc01heFNjcmVlbiAhPT0gJ251bWJlcicgfHwgIW1pblNjcmVlblVuaXQgfHwgIW1heFNjcmVlblVuaXQgfHwgbWluU2NyZWVuVW5pdCAhPT0gbWF4U2NyZWVuVW5pdCkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ3KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdW5pdGxlc3NGcm9tU2l6ZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHVuaXRsZXNzVG9TaXplICE9PSAnbnVtYmVyJyB8fCAhZnJvbVNpemVVbml0IHx8ICF0b1NpemVVbml0IHx8IGZyb21TaXplVW5pdCAhPT0gdG9TaXplVW5pdCkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ4KTtcbiAgfVxuXG4gIHZhciBzbG9wZSA9ICh1bml0bGVzc0Zyb21TaXplIC0gdW5pdGxlc3NUb1NpemUpIC8gKHVuaXRsZXNzTWluU2NyZWVuIC0gdW5pdGxlc3NNYXhTY3JlZW4pO1xuICB2YXIgYmFzZSA9IHVuaXRsZXNzVG9TaXplIC0gc2xvcGUgKiB1bml0bGVzc01heFNjcmVlbjtcbiAgcmV0dXJuIFwiY2FsYyhcIiArIGJhc2UudG9GaXhlZCgyKSArIGZyb21TaXplVW5pdCArIFwiICsgXCIgKyAoMTAwICogc2xvcGUpLnRvRml4ZWQoMikgKyBcInZ3KVwiO1xufVxuXG4vKipcbiAqIENTUyB0byBjb250YWluIGEgZmxvYXQgKGNyZWRpdCB0byBDU1NNb2pvKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAgLi4uY2xlYXJGaXgoKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtjbGVhckZpeCgpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnJjo6YWZ0ZXInOiB7XG4gKiAgICdjbGVhcic6ICdib3RoJyxcbiAqICAgJ2NvbnRlbnQnOiAnXCJcIicsXG4gKiAgICdkaXNwbGF5JzogJ3RhYmxlJ1xuICogfVxuICovXG5mdW5jdGlvbiBjbGVhckZpeChwYXJlbnQpIHtcbiAgdmFyIF9yZWY7XG5cbiAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50ID0gJyYnO1xuICB9XG5cbiAgdmFyIHBzZXVkb1NlbGVjdG9yID0gcGFyZW50ICsgXCI6OmFmdGVyXCI7XG4gIHJldHVybiBfcmVmID0ge30sIF9yZWZbcHNldWRvU2VsZWN0b3JdID0ge1xuICAgIGNsZWFyOiAnYm90aCcsXG4gICAgY29udGVudDogJ1wiXCInLFxuICAgIGRpc3BsYXk6ICd0YWJsZSdcbiAgfSwgX3JlZjtcbn1cblxuLyoqXG4gKiBDU1MgdG8gZnVsbHkgY292ZXIgYW4gYXJlYS4gQ2FuIG9wdGlvbmFsbHkgYmUgcGFzc2VkIGFuIG9mZnNldCB0byBhY3QgYXMgYSBcInBhZGRpbmdcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5jb3ZlcigpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Y292ZXIoKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gKiAgICd0b3AnOiAnMCcsXG4gKiAgICdyaWdodDogJzAnLFxuICogICAnYm90dG9tJzogJzAnLFxuICogICAnbGVmdDogJzAnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNvdmVyKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHtcbiAgICBvZmZzZXQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IG9mZnNldCxcbiAgICByaWdodDogb2Zmc2V0LFxuICAgIGJvdHRvbTogb2Zmc2V0LFxuICAgIGxlZnQ6IG9mZnNldFxuICB9O1xufVxuXG4vKipcbiAqIENTUyB0byByZXByZXNlbnQgdHJ1bmNhdGVkIHRleHQgd2l0aCBhbiBlbGxpcHNpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5lbGxpcHNpcygnMjUwcHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2VsbGlwc2lzKCcyNTBweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXY6IHtcbiAqICAgJ2Rpc3BsYXknOiAnaW5saW5lLWJsb2NrJyxcbiAqICAgJ21heFdpZHRoJzogJzI1MHB4JyxcbiAqICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gKiAgICd0ZXh0T3ZlcmZsb3cnOiAnZWxsaXBzaXMnLFxuICogICAnd2hpdGVTcGFjZSc6ICdub3dyYXAnLFxuICogICAnd29yZFdyYXAnOiAnbm9ybWFsJ1xuICogfVxuICovXG5mdW5jdGlvbiBlbGxpcHNpcyh3aWR0aCkge1xuICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xuICAgIHdpZHRoID0gJzEwMCUnO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICBtYXhXaWR0aDogd2lkdGgsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICB3b3JkV3JhcDogJ25vcm1hbCdcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2V0IG9mIG1lZGlhIHF1ZXJpZXMgdGhhdCByZXNpemVzIGEgcHJvcGVydHkgKG9yIHNldCBvZiBwcm9wZXJ0aWVzKSBiZXR3ZWVuIGEgcHJvdmlkZWQgZnJvbVNpemUgYW5kIHRvU2l6ZS4gQWNjZXB0cyBvcHRpb25hbCBtaW5TY3JlZW4gKGRlZmF1bHRzIHRvICczMjBweCcpIGFuZCBtYXhTY3JlZW4gKGRlZmF1bHRzIHRvICcxMjAwcHgnKSB0byBjb25zdHJhaW4gdGhlIGludGVycG9sYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uZmx1aWRSYW5nZShcbiAqICAgIHtcbiAqICAgICAgICBwcm9wOiAncGFkZGluZycsXG4gKiAgICAgICAgZnJvbVNpemU6ICcyMHB4JyxcbiAqICAgICAgICB0b1NpemU6ICcxMDBweCcsXG4gKiAgICAgIH0sXG4gKiAgICAgICc0MDBweCcsXG4gKiAgICAgICcxMDAwcHgnLFxuICogICAgKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2ZsdWlkUmFuZ2UoXG4gKiAgICAgIHtcbiAqICAgICAgICBwcm9wOiAncGFkZGluZycsXG4gKiAgICAgICAgZnJvbVNpemU6ICcyMHB4JyxcbiAqICAgICAgICB0b1NpemU6ICcxMDBweCcsXG4gKiAgICAgIH0sXG4gKiAgICAgICc0MDBweCcsXG4gKiAgICAgICcxMDAwcHgnLFxuICogICAgKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgIFwiQG1lZGlhIChtaW4td2lkdGg6IDEwMDBweClcIjogT2JqZWN0IHtcbiAqICAgICBcInBhZGRpbmdcIjogXCIxMDBweFwiLFxuICogICB9LFxuICogICBcIkBtZWRpYSAobWluLXdpZHRoOiA0MDBweClcIjogT2JqZWN0IHtcbiAqICAgICBcInBhZGRpbmdcIjogXCJjYWxjKC0zMy4zMzMzMzMzMzMzMzMzNHB4ICsgMTMuMzMzMzMzMzMzMzMzMzM0dncpXCIsXG4gKiAgIH0sXG4gKiAgIFwicGFkZGluZ1wiOiBcIjIwcHhcIixcbiAqIH1cbiAqL1xuZnVuY3Rpb24gZmx1aWRSYW5nZShjc3NQcm9wLCBtaW5TY3JlZW4sIG1heFNjcmVlbikge1xuICBpZiAobWluU2NyZWVuID09PSB2b2lkIDApIHtcbiAgICBtaW5TY3JlZW4gPSAnMzIwcHgnO1xuICB9XG5cbiAgaWYgKG1heFNjcmVlbiA9PT0gdm9pZCAwKSB7XG4gICAgbWF4U2NyZWVuID0gJzEyMDBweCc7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoY3NzUHJvcCkgJiYgdHlwZW9mIGNzc1Byb3AgIT09ICdvYmplY3QnIHx8IGNzc1Byb3AgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0OSk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShjc3NQcm9wKSkge1xuICAgIHZhciBtZWRpYVF1ZXJpZXMgPSB7fTtcbiAgICB2YXIgZmFsbGJhY2tzID0ge307XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBjc3NQcm9wLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgdmFyIF9leHRlbmRzMiwgX2V4dGVuZHMzO1xuXG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmogPSBfcmVmO1xuXG4gICAgICBpZiAoIW9iai5wcm9wIHx8ICFvYmouZnJvbVNpemUgfHwgIW9iai50b1NpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTApO1xuICAgICAgfVxuXG4gICAgICBmYWxsYmFja3Nbb2JqLnByb3BdID0gb2JqLmZyb21TaXplO1xuICAgICAgbWVkaWFRdWVyaWVzW1wiQG1lZGlhIChtaW4td2lkdGg6IFwiICsgbWluU2NyZWVuICsgXCIpXCJdID0gX2V4dGVuZHMoe30sIG1lZGlhUXVlcmllc1tcIkBtZWRpYSAobWluLXdpZHRoOiBcIiArIG1pblNjcmVlbiArIFwiKVwiXSwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbb2JqLnByb3BdID0gYmV0d2VlbihvYmouZnJvbVNpemUsIG9iai50b1NpemUsIG1pblNjcmVlbiwgbWF4U2NyZWVuKSwgX2V4dGVuZHMyKSk7XG4gICAgICBtZWRpYVF1ZXJpZXNbXCJAbWVkaWEgKG1pbi13aWR0aDogXCIgKyBtYXhTY3JlZW4gKyBcIilcIl0gPSBfZXh0ZW5kcyh7fSwgbWVkaWFRdWVyaWVzW1wiQG1lZGlhIChtaW4td2lkdGg6IFwiICsgbWF4U2NyZWVuICsgXCIpXCJdLCAoX2V4dGVuZHMzID0ge30sIF9leHRlbmRzM1tvYmoucHJvcF0gPSBvYmoudG9TaXplLCBfZXh0ZW5kczMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGZhbGxiYWNrcywgbWVkaWFRdWVyaWVzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3JlZjIsIF9yZWYzLCBfcmVmNDtcblxuICAgIGlmICghY3NzUHJvcC5wcm9wIHx8ICFjc3NQcm9wLmZyb21TaXplIHx8ICFjc3NQcm9wLnRvU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTEpO1xuICAgIH1cblxuICAgIHJldHVybiBfcmVmNCA9IHt9LCBfcmVmNFtjc3NQcm9wLnByb3BdID0gY3NzUHJvcC5mcm9tU2l6ZSwgX3JlZjRbXCJAbWVkaWEgKG1pbi13aWR0aDogXCIgKyBtaW5TY3JlZW4gKyBcIilcIl0gPSAoX3JlZjIgPSB7fSwgX3JlZjJbY3NzUHJvcC5wcm9wXSA9IGJldHdlZW4oY3NzUHJvcC5mcm9tU2l6ZSwgY3NzUHJvcC50b1NpemUsIG1pblNjcmVlbiwgbWF4U2NyZWVuKSwgX3JlZjIpLCBfcmVmNFtcIkBtZWRpYSAobWluLXdpZHRoOiBcIiArIG1heFNjcmVlbiArIFwiKVwiXSA9IChfcmVmMyA9IHt9LCBfcmVmM1tjc3NQcm9wLnByb3BdID0gY3NzUHJvcC50b1NpemUsIF9yZWYzKSwgX3JlZjQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVGaWxlUmVmZXJlbmNlcyhmb250RmlsZVBhdGgsIGZpbGVGb3JtYXRzKSB7XG4gIHZhciBmaWxlRm9udFJlZmVyZW5jZXMgPSBmaWxlRm9ybWF0cy5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiBcInVybChcXFwiXCIgKyBmb250RmlsZVBhdGggKyBcIi5cIiArIGZvcm1hdCArIFwiXFxcIilcIjtcbiAgfSk7XG4gIHJldHVybiBmaWxlRm9udFJlZmVyZW5jZXMuam9pbignLCAnKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVMb2NhbFJlZmVyZW5jZXMobG9jYWxGb250cykge1xuICB2YXIgbG9jYWxGb250UmVmZXJlbmNlcyA9IGxvY2FsRm9udHMubWFwKGZ1bmN0aW9uIChmb250KSB7XG4gICAgcmV0dXJuIFwibG9jYWwoXFxcIlwiICsgZm9udCArIFwiXFxcIilcIjtcbiAgfSk7XG4gIHJldHVybiBsb2NhbEZvbnRSZWZlcmVuY2VzLmpvaW4oJywgJyk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU291cmNlcyhmb250RmlsZVBhdGgsIGxvY2FsRm9udHMsIGZpbGVGb3JtYXRzKSB7XG4gIHZhciBmb250UmVmZXJlbmNlcyA9IFtdO1xuICBpZiAobG9jYWxGb250cykgZm9udFJlZmVyZW5jZXMucHVzaChnZW5lcmF0ZUxvY2FsUmVmZXJlbmNlcyhsb2NhbEZvbnRzKSk7XG5cbiAgaWYgKGZvbnRGaWxlUGF0aCkge1xuICAgIGZvbnRSZWZlcmVuY2VzLnB1c2goZ2VuZXJhdGVGaWxlUmVmZXJlbmNlcyhmb250RmlsZVBhdGgsIGZpbGVGb3JtYXRzKSk7XG4gIH1cblxuICByZXR1cm4gZm9udFJlZmVyZW5jZXMuam9pbignLCAnKTtcbn1cbi8qKlxuICogQ1NTIGZvciBhIEBmb250LWZhY2UgZGVjbGFyYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgYmFzaWMgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgIC4uLmZvbnRGYWNlKHtcbiAqICAgICAgJ2ZvbnRGYW1pbHknOiAnU2Fucy1Qcm8nLFxuICogICAgICAnZm9udEZpbGVQYXRoJzogJ3BhdGgvdG8vZmlsZSdcbiAqICAgIH0pXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgYmFzaWMgdXNhZ2VcbiAqIGNvbnN0IEdsb2JhbFN0eWxlID0gY3JlYXRlR2xvYmFsU3R5bGVgJHtcbiAqICAgZm9udEZhY2Uoe1xuICogICAgICdmb250RmFtaWx5JzogJ1NhbnMtUHJvJyxcbiAqICAgICAnZm9udEZpbGVQYXRoJzogJ3BhdGgvdG8vZmlsZSdcbiAqICAgfVxuICogKX1gXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICdAZm9udC1mYWNlJzoge1xuICogICAnZm9udEZhbWlseSc6ICdTYW5zLVBybycsXG4gKiAgICdzcmMnOiAndXJsKFwicGF0aC90by9maWxlLmVvdFwiKSwgdXJsKFwicGF0aC90by9maWxlLndvZmYyXCIpLCB1cmwoXCJwYXRoL3RvL2ZpbGUud29mZlwiKSwgdXJsKFwicGF0aC90by9maWxlLnR0ZlwiKSwgdXJsKFwicGF0aC90by9maWxlLnN2Z1wiKScsXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiBmb250RmFjZShfcmVmKSB7XG4gIHZhciBmb250RmFtaWx5ID0gX3JlZi5mb250RmFtaWx5LFxuICAgICAgZm9udEZpbGVQYXRoID0gX3JlZi5mb250RmlsZVBhdGgsXG4gICAgICBmb250U3RyZXRjaCA9IF9yZWYuZm9udFN0cmV0Y2gsXG4gICAgICBmb250U3R5bGUgPSBfcmVmLmZvbnRTdHlsZSxcbiAgICAgIGZvbnRWYXJpYW50ID0gX3JlZi5mb250VmFyaWFudCxcbiAgICAgIGZvbnRXZWlnaHQgPSBfcmVmLmZvbnRXZWlnaHQsXG4gICAgICBfcmVmJGZpbGVGb3JtYXRzID0gX3JlZi5maWxlRm9ybWF0cyxcbiAgICAgIGZpbGVGb3JtYXRzID0gX3JlZiRmaWxlRm9ybWF0cyA9PT0gdm9pZCAwID8gWydlb3QnLCAnd29mZjInLCAnd29mZicsICd0dGYnLCAnc3ZnJ10gOiBfcmVmJGZpbGVGb3JtYXRzLFxuICAgICAgbG9jYWxGb250cyA9IF9yZWYubG9jYWxGb250cyxcbiAgICAgIHVuaWNvZGVSYW5nZSA9IF9yZWYudW5pY29kZVJhbmdlLFxuICAgICAgZm9udERpc3BsYXkgPSBfcmVmLmZvbnREaXNwbGF5LFxuICAgICAgZm9udFZhcmlhdGlvblNldHRpbmdzID0gX3JlZi5mb250VmFyaWF0aW9uU2V0dGluZ3MsXG4gICAgICBmb250RmVhdHVyZVNldHRpbmdzID0gX3JlZi5mb250RmVhdHVyZVNldHRpbmdzO1xuICAvLyBFcnJvciBIYW5kbGluZ1xuICBpZiAoIWZvbnRGYW1pbHkpIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU1KTtcblxuICBpZiAoIWZvbnRGaWxlUGF0aCAmJiAhbG9jYWxGb250cykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDUyKTtcbiAgfVxuXG4gIGlmIChsb2NhbEZvbnRzICYmICFBcnJheS5pc0FycmF5KGxvY2FsRm9udHMpKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTMpO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGZpbGVGb3JtYXRzKSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU0KTtcbiAgfVxuXG4gIHZhciBmb250RmFjZURlY2xhcmF0aW9uID0ge1xuICAgICdAZm9udC1mYWNlJzoge1xuICAgICAgZm9udEZhbWlseTogZm9udEZhbWlseSxcbiAgICAgIHNyYzogZ2VuZXJhdGVTb3VyY2VzKGZvbnRGaWxlUGF0aCwgbG9jYWxGb250cywgZmlsZUZvcm1hdHMpLFxuICAgICAgdW5pY29kZVJhbmdlOiB1bmljb2RlUmFuZ2UsXG4gICAgICBmb250U3RyZXRjaDogZm9udFN0cmV0Y2gsXG4gICAgICBmb250U3R5bGU6IGZvbnRTdHlsZSxcbiAgICAgIGZvbnRWYXJpYW50OiBmb250VmFyaWFudCxcbiAgICAgIGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQsXG4gICAgICBmb250RGlzcGxheTogZm9udERpc3BsYXksXG4gICAgICBmb250VmFyaWF0aW9uU2V0dGluZ3M6IGZvbnRWYXJpYXRpb25TZXR0aW5ncyxcbiAgICAgIGZvbnRGZWF0dXJlU2V0dGluZ3M6IGZvbnRGZWF0dXJlU2V0dGluZ3NcbiAgICB9IC8vIFJlbW92ZXMgdW5kZWZpbmVkIGZpZWxkcyBmb3IgY2xlYW5lciBjc3Mgb2JqZWN0LlxuXG4gIH07XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGZvbnRGYWNlRGVjbGFyYXRpb24pKTtcbn1cblxuLyoqXG4gKiBDU1MgdG8gaGlkZSB0ZXh0IHRvIHNob3cgYSBiYWNrZ3JvdW5kIGltYWdlIGluIGEgU0VPLWZyaWVuZGx5IHdheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAnYmFja2dyb3VuZEltYWdlJzogJ3VybChsb2dvLnBuZyknLFxuICogICAuLi5oaWRlVGV4dCgpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kSW1hZ2U6IHVybChsb2dvLnBuZyk7XG4gKiAgICR7aGlkZVRleHQoKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICdkaXYnOiB7XG4gKiAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAndXJsKGxvZ28ucG5nKScsXG4gKiAgICd0ZXh0SW5kZW50JzogJzEwMSUnLFxuICogICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcbiAqICAgJ3doaXRlU3BhY2UnOiAnbm93cmFwJyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gaGlkZVRleHQoKSB7XG4gIHJldHVybiB7XG4gICAgdGV4dEluZGVudDogJzEwMSUnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJ1xuICB9O1xufVxuXG4vKipcbiAqIENTUyB0byBoaWRlIGNvbnRlbnQgdmlzdWFsbHkgYnV0IHJlbWFpbiBhY2Nlc3NpYmxlIHRvIHNjcmVlbiByZWFkZXJzLlxuICogZnJvbSBbSFRNTDUgQm9pbGVycGxhdGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9oNWJwL2h0bWw1LWJvaWxlcnBsYXRlL2Jsb2IvOWExNzZmNTdhZjFjZmU4ZWM3MDMwMGRhNDYyMWZiOWIwN2U1ZmEzMS9zcmMvY3NzL21haW4uY3NzI0wxMjEpXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uaGlkZVZpc3VhbGx5KCksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7aGlkZVZpc3VhbGx5KCl9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnZGl2Jzoge1xuICogICAnYm9yZGVyJzogJzAnLFxuICogICAnY2xpcCc6ICdyZWN0KDAgMCAwIDApJyxcbiAqICAgJ2NsaXBQYXRoJzogJ2luc2V0KDUwJSknLFxuICogICAnaGVpZ2h0JzogJzFweCcsXG4gKiAgICdtYXJnaW4nOiAnLTFweCcsXG4gKiAgICdvdmVyZmxvdyc6ICdoaWRkZW4nLFxuICogICAncGFkZGluZyc6ICcwJyxcbiAqICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcbiAqICAgJ3doaXRlU3BhY2UnOiAnbm93cmFwJyxcbiAqICAgJ3dpZHRoJzogJzFweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhpZGVWaXN1YWxseSgpIHtcbiAgcmV0dXJuIHtcbiAgICBib3JkZXI6ICcwJyxcbiAgICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gICAgY2xpcFBhdGg6ICdpbnNldCg1MCUpJyxcbiAgICBoZWlnaHQ6ICcxcHgnLFxuICAgIG1hcmdpbjogJy0xcHgnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBwYWRkaW5nOiAnMCcsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgd2lkdGg6ICcxcHgnXG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWVkaWEgcXVlcnkgdG8gdGFyZ2V0IEhpRFBJIGRldmljZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICBbaGlEUEkoMS41KV06IHtcbiAqICAgIHdpZHRoOiAyMDBweDtcbiAqICB9XG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7aGlEUEkoMS41KX0ge1xuICogICAgIHdpZHRoOiAyMDBweDtcbiAqICAgfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjUpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjUpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMS41LzEpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE0NGRwaSksXG4gKiAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMS41ZHBweCknOiB7XG4gKiAgICd3aWR0aCc6ICcyMDBweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhpRFBJKHJhdGlvKSB7XG4gIGlmIChyYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgcmF0aW8gPSAxLjM7XG4gIH1cblxuICByZXR1cm4gXCJcXG4gICAgQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiBcIiArIHJhdGlvICsgXCIpLFxcbiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogXCIgKyByYXRpbyArIFwiKSxcXG4gICAgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiBcIiArIHJhdGlvICsgXCIvMSksXFxuICAgIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IFwiICsgTWF0aC5yb3VuZChyYXRpbyAqIDk2KSArIFwiZHBpKSxcXG4gICAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogXCIgKyByYXRpbyArIFwiZHBweClcXG4gIFwiO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RHcmFkaWVudFZhbHVlKGxpdGVyYWxzKSB7XG4gIHZhciB0ZW1wbGF0ZSA9ICcnO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdWJzdGl0dXRpb25zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdWJzdGl0dXRpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGl0ZXJhbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0ZW1wbGF0ZSArPSBsaXRlcmFsc1tpXTtcblxuICAgIGlmIChpID09PSBzdWJzdGl0dXRpb25zLmxlbmd0aCAtIDEgJiYgc3Vic3RpdHV0aW9uc1tpXSkge1xuICAgICAgdmFyIGRlZmluZWRWYWx1ZXMgPSBzdWJzdGl0dXRpb25zLmZpbHRlcihmdW5jdGlvbiAoc3Vic3RpdHV0ZSkge1xuICAgICAgICByZXR1cm4gISFzdWJzdGl0dXRlO1xuICAgICAgfSk7IC8vIEFkZHMgbGVhZGluZyBjb21hIGlmIHByb3BlcnRpZXMgcHJlY2VlZCBjb2xvci1zdG9wc1xuXG4gICAgICBpZiAoZGVmaW5lZFZhbHVlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuc2xpY2UoMCwgLTEpO1xuICAgICAgICB0ZW1wbGF0ZSArPSBcIiwgXCIgKyBzdWJzdGl0dXRpb25zW2ldOyAvLyBObyB0cmFpbGluZyBzcGFjZSBpZiBjb2xvci1zdG9wcyBpcyB0aGUgb25seSBwYXJhbSBwcm92aWRlZFxuICAgICAgfSBlbHNlIGlmIChkZWZpbmVkVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBcIlwiICsgc3Vic3RpdHV0aW9uc1tpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN1YnN0aXR1dGlvbnNbaV0pIHtcbiAgICAgIHRlbXBsYXRlICs9IHN1YnN0aXR1dGlvbnNbaV0gKyBcIiBcIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGVtcGxhdGUudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QoKSB7XG4gIHZhciBkYXRhID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFtcImxpbmVhci1ncmFkaWVudChcIiwgXCJcIiwgXCIpXCJdKTtcblxuICBfdGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ1NTIGZvciBkZWNsYXJpbmcgYSBsaW5lYXIgZ3JhZGllbnQsIGluY2x1ZGluZyBhIGZhbGxiYWNrIGJhY2tncm91bmQtY29sb3IuIFRoZSBmYWxsYmFjayBpcyBlaXRoZXIgdGhlIGZpcnN0IGNvbG9yLXN0b3Agb3IgYW4gZXhwbGljaXRseSBwYXNzZWQgZmFsbGJhY2sgY29sb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ubGluZWFyR3JhZGllbnQoe1xuICAgICAgICBjb2xvclN0b3BzOiBbJyMwMEZGRkYgMCUnLCAncmdiYSgwLCAwLCAyNTUsIDApIDUwJScsICcjMDAwMEZGIDk1JSddLFxuICAgICAgICB0b0RpcmVjdGlvbjogJ3RvIHRvcCByaWdodCcsXG4gICAgICAgIGZhbGxiYWNrOiAnI0ZGRicsXG4gICAgICB9KVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2xpbmVhckdyYWRpZW50KHtcbiAgICAgICAgY29sb3JTdG9wczogWycjMDBGRkZGIDAlJywgJ3JnYmEoMCwgMCwgMjU1LCAwKSA1MCUnLCAnIzAwMDBGRiA5NSUnXSxcbiAgICAgICAgdG9EaXJlY3Rpb246ICd0byB0b3AgcmlnaHQnLFxuICAgICAgICBmYWxsYmFjazogJyNGRkYnLFxuICAgICAgfSl9XG4gKmBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgICdiYWNrZ3JvdW5kQ29sb3InOiAnI0ZGRicsXG4gKiAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAnbGluZWFyLWdyYWRpZW50KHRvIHRvcCByaWdodCwgIzAwRkZGRiAwJSwgcmdiYSgwLCAwLCAyNTUsIDApIDUwJSwgIzAwMDBGRiA5NSUpJyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gbGluZWFyR3JhZGllbnQoX3JlZikge1xuICB2YXIgY29sb3JTdG9wcyA9IF9yZWYuY29sb3JTdG9wcyxcbiAgICAgIGZhbGxiYWNrID0gX3JlZi5mYWxsYmFjayxcbiAgICAgIF9yZWYkdG9EaXJlY3Rpb24gPSBfcmVmLnRvRGlyZWN0aW9uLFxuICAgICAgdG9EaXJlY3Rpb24gPSBfcmVmJHRvRGlyZWN0aW9uID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkdG9EaXJlY3Rpb247XG5cbiAgaWYgKCFjb2xvclN0b3BzIHx8IGNvbG9yU3RvcHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU2KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBmYWxsYmFjayB8fCBjb2xvclN0b3BzWzBdLnNwbGl0KCcgJylbMF0sXG4gICAgYmFja2dyb3VuZEltYWdlOiBjb25zdHJ1Y3RHcmFkaWVudFZhbHVlKF90ZW1wbGF0ZU9iamVjdCgpLCB0b0RpcmVjdGlvbiwgY29sb3JTdG9wcy5qb2luKCcsICcpKVxuICB9O1xufVxuXG4vKipcbiAqIENTUyB0byBub3JtYWxpemUgYWJub3JtYWxpdGllcyBhY3Jvc3MgYnJvd3NlcnMgKG5vcm1hbGl6ZS5jc3MgdjguMC4wIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcylcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAgLi4ubm9ybWFsaXplKCksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IEdsb2JhbFN0eWxlID0gY3JlYXRlR2xvYmFsU3R5bGVgJHtub3JtYWxpemUoKX1gXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGh0bWwge1xuICogICBsaW5lSGVpZ2h0OiAxLjE1LFxuICogICB0ZXh0U2l6ZUFkanVzdDogMTAwJSxcbiAqIH0gLi4uXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgdmFyIF9yZWY7XG5cbiAgcmV0dXJuIFsoX3JlZiA9IHtcbiAgICBodG1sOiB7XG4gICAgICBsaW5lSGVpZ2h0OiAnMS4xNScsXG4gICAgICB0ZXh0U2l6ZUFkanVzdDogJzEwMCUnXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgaDE6IHtcbiAgICAgIGZvbnRTaXplOiAnMmVtJyxcbiAgICAgIG1hcmdpbjogJzAuNjdlbSAwJ1xuICAgIH0sXG4gICAgaHI6IHtcbiAgICAgIGJveFNpemluZzogJ2NvbnRlbnQtYm94JyxcbiAgICAgIGhlaWdodDogJzAnLFxuICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJ1xuICAgIH0sXG4gICAgcHJlOiB7XG4gICAgICBmb250RmFtaWx5OiAnbW9ub3NwYWNlLCBtb25vc3BhY2UnLFxuICAgICAgZm9udFNpemU6ICcxZW0nXG4gICAgfSxcbiAgICBhOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICB9LFxuICAgICdhYmJyW3RpdGxlXSc6IHtcbiAgICAgIGJvcmRlckJvdHRvbTogJ25vbmUnLFxuICAgICAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnXG4gICAgfVxuICB9LCBfcmVmW1wiYixcXG4gICAgc3Ryb25nXCJdID0ge1xuICAgIGZvbnRXZWlnaHQ6ICdib2xkZXInXG4gIH0sIF9yZWZbXCJjb2RlLFxcbiAgICBrYmQsXFxuICAgIHNhbXBcIl0gPSB7XG4gICAgZm9udEZhbWlseTogJ21vbm9zcGFjZSwgbW9ub3NwYWNlJyxcbiAgICBmb250U2l6ZTogJzFlbSdcbiAgfSwgX3JlZi5zbWFsbCA9IHtcbiAgICBmb250U2l6ZTogJzgwJSdcbiAgfSwgX3JlZltcInN1YixcXG4gICAgc3VwXCJdID0ge1xuICAgIGZvbnRTaXplOiAnNzUlJyxcbiAgICBsaW5lSGVpZ2h0OiAnMCcsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgdmVydGljYWxBbGlnbjogJ2Jhc2VsaW5lJ1xuICB9LCBfcmVmLnN1YiA9IHtcbiAgICBib3R0b206ICctMC4yNWVtJ1xuICB9LCBfcmVmLnN1cCA9IHtcbiAgICB0b3A6ICctMC41ZW0nXG4gIH0sIF9yZWYuaW1nID0ge1xuICAgIGJvcmRlclN0eWxlOiAnbm9uZSdcbiAgfSwgX3JlZltcImJ1dHRvbixcXG4gICAgaW5wdXQsXFxuICAgIG9wdGdyb3VwLFxcbiAgICBzZWxlY3QsXFxuICAgIHRleHRhcmVhXCJdID0ge1xuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogJzEwMCUnLFxuICAgIGxpbmVIZWlnaHQ6ICcxLjE1JyxcbiAgICBtYXJnaW46ICcwJ1xuICB9LCBfcmVmW1wiYnV0dG9uLFxcbiAgICBpbnB1dFwiXSA9IHtcbiAgICBvdmVyZmxvdzogJ3Zpc2libGUnXG4gIH0sIF9yZWZbXCJidXR0b24sXFxuICAgIHNlbGVjdFwiXSA9IHtcbiAgICB0ZXh0VHJhbnNmb3JtOiAnbm9uZSdcbiAgfSwgX3JlZltcImJ1dHRvbixcXG4gICAgaHRtbCBbdHlwZT1cXFwiYnV0dG9uXFxcIl0sXFxuICAgIFt0eXBlPVxcXCJyZXNldFxcXCJdLFxcbiAgICBbdHlwZT1cXFwic3VibWl0XFxcIl1cIl0gPSB7XG4gICAgV2Via2l0QXBwZWFyYW5jZTogJ2J1dHRvbidcbiAgfSwgX3JlZltcImJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgW3R5cGU9XFxcImJ1dHRvblxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcbiAgICBbdHlwZT1cXFwicmVzZXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgW3R5cGU9XFxcInN1Ym1pdFxcXCJdOjotbW96LWZvY3VzLWlubmVyXCJdID0ge1xuICAgIGJvcmRlclN0eWxlOiAnbm9uZScsXG4gICAgcGFkZGluZzogJzAnXG4gIH0sIF9yZWZbXCJidXR0b246LW1vei1mb2N1c3JpbmcsXFxuICAgIFt0eXBlPVxcXCJidXR0b25cXFwiXTotbW96LWZvY3VzcmluZyxcXG4gICAgW3R5cGU9XFxcInJlc2V0XFxcIl06LW1vei1mb2N1c3JpbmcsXFxuICAgIFt0eXBlPVxcXCJzdWJtaXRcXFwiXTotbW96LWZvY3VzcmluZ1wiXSA9IHtcbiAgICBvdXRsaW5lOiAnMXB4IGRvdHRlZCBCdXR0b25UZXh0J1xuICB9LCBfcmVmLmZpZWxkc2V0ID0ge1xuICAgIHBhZGRpbmc6ICcwLjM1ZW0gMC42MjVlbSAwLjc1ZW0nXG4gIH0sIF9yZWYubGVnZW5kID0ge1xuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIGNvbG9yOiAnaW5oZXJpdCcsXG4gICAgZGlzcGxheTogJ3RhYmxlJyxcbiAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgIHBhZGRpbmc6ICcwJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm9ybWFsJ1xuICB9LCBfcmVmLnByb2dyZXNzID0ge1xuICAgIHZlcnRpY2FsQWxpZ246ICdiYXNlbGluZSdcbiAgfSwgX3JlZi50ZXh0YXJlYSA9IHtcbiAgICBvdmVyZmxvdzogJ2F1dG8nXG4gIH0sIF9yZWZbXCJbdHlwZT1cXFwiY2hlY2tib3hcXFwiXSxcXG4gICAgW3R5cGU9XFxcInJhZGlvXFxcIl1cIl0gPSB7XG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgcGFkZGluZzogJzAnXG4gIH0sIF9yZWZbXCJbdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuICAgIFt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvblwiXSA9IHtcbiAgICBoZWlnaHQ6ICdhdXRvJ1xuICB9LCBfcmVmWydbdHlwZT1cInNlYXJjaFwiXSddID0ge1xuICAgIFdlYmtpdEFwcGVhcmFuY2U6ICd0ZXh0ZmllbGQnLFxuICAgIG91dGxpbmVPZmZzZXQ6ICctMnB4J1xuICB9LCBfcmVmWydbdHlwZT1cInNlYXJjaFwiXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiddID0ge1xuICAgIFdlYmtpdEFwcGVhcmFuY2U6ICdub25lJ1xuICB9LCBfcmVmWyc6Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uJ10gPSB7XG4gICAgV2Via2l0QXBwZWFyYW5jZTogJ2J1dHRvbicsXG4gICAgZm9udDogJ2luaGVyaXQnXG4gIH0sIF9yZWYuZGV0YWlscyA9IHtcbiAgICBkaXNwbGF5OiAnYmxvY2snXG4gIH0sIF9yZWYuc3VtbWFyeSA9IHtcbiAgICBkaXNwbGF5OiAnbGlzdC1pdGVtJ1xuICB9LCBfcmVmLnRlbXBsYXRlID0ge1xuICAgIGRpc3BsYXk6ICdub25lJ1xuICB9LCBfcmVmWydbaGlkZGVuXSddID0ge1xuICAgIGRpc3BsYXk6ICdub25lJ1xuICB9LCBfcmVmKSwge1xuICAgICdhYmJyW3RpdGxlXSc6IHtcbiAgICAgIHRleHREZWNvcmF0aW9uOiAndW5kZXJsaW5lIGRvdHRlZCdcbiAgICB9XG4gIH1dO1xufVxuXG5mdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QkMSgpIHtcbiAgdmFyIGRhdGEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoW1wicmFkaWFsLWdyYWRpZW50KFwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIilcIl0pO1xuXG4gIF90ZW1wbGF0ZU9iamVjdCQxID0gZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0KCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENTUyBmb3IgZGVjbGFyaW5nIGEgcmFkaWFsIGdyYWRpZW50LCBpbmNsdWRpbmcgYSBmYWxsYmFjayBiYWNrZ3JvdW5kLWNvbG9yLiBUaGUgZmFsbGJhY2sgaXMgZWl0aGVyIHRoZSBmaXJzdCBjb2xvci1zdG9wIG9yIGFuIGV4cGxpY2l0bHkgcGFzc2VkIGZhbGxiYWNrIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnJhZGlhbEdyYWRpZW50KHtcbiAqICAgICBjb2xvclN0b3BzOiBbJyMwMEZGRkYgMCUnLCAncmdiYSgwLCAwLCAyNTUsIDApIDUwJScsICcjMDAwMEZGIDk1JSddLFxuICogICAgIGV4dGVudDogJ2ZhcnRoZXN0LWNvcm5lciBhdCA0NXB4IDQ1cHgnLFxuICogICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAqICAgICBzaGFwZTogJ2VsbGlwc2UnLFxuICogICB9KVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3JhZGlhbEdyYWRpZW50KHtcbiAqICAgICBjb2xvclN0b3BzOiBbJyMwMEZGRkYgMCUnLCAncmdiYSgwLCAwLCAyNTUsIDApIDUwJScsICcjMDAwMEZGIDk1JSddLFxuICogICAgIGV4dGVudDogJ2ZhcnRoZXN0LWNvcm5lciBhdCA0NXB4IDQ1cHgnLFxuICogICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAqICAgICBzaGFwZTogJ2VsbGlwc2UnLFxuICogICB9KX1cbiAqYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXY6IHtcbiAqICAgJ2JhY2tncm91bmRDb2xvcic6ICcjMDBGRkZGJyxcbiAqICAgJ2JhY2tncm91bmRJbWFnZSc6ICdyYWRpYWwtZ3JhZGllbnQoY2VudGVyIGVsbGlwc2UgZmFydGhlc3QtY29ybmVyIGF0IDQ1cHggNDVweCwgIzAwRkZGRiAwJSwgcmdiYSgwLCAwLCAyNTUsIDApIDUwJSwgIzAwMDBGRiA5NSUpJyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmFkaWFsR3JhZGllbnQoX3JlZikge1xuICB2YXIgY29sb3JTdG9wcyA9IF9yZWYuY29sb3JTdG9wcyxcbiAgICAgIF9yZWYkZXh0ZW50ID0gX3JlZi5leHRlbnQsXG4gICAgICBleHRlbnQgPSBfcmVmJGV4dGVudCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJGV4dGVudCxcbiAgICAgIGZhbGxiYWNrID0gX3JlZi5mYWxsYmFjayxcbiAgICAgIF9yZWYkcG9zaXRpb24gPSBfcmVmLnBvc2l0aW9uLFxuICAgICAgcG9zaXRpb24gPSBfcmVmJHBvc2l0aW9uID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkcG9zaXRpb24sXG4gICAgICBfcmVmJHNoYXBlID0gX3JlZi5zaGFwZSxcbiAgICAgIHNoYXBlID0gX3JlZiRzaGFwZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHNoYXBlO1xuXG4gIGlmICghY29sb3JTdG9wcyB8fCBjb2xvclN0b3BzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1Nyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogZmFsbGJhY2sgfHwgY29sb3JTdG9wc1swXS5zcGxpdCgnICcpWzBdLFxuICAgIGJhY2tncm91bmRJbWFnZTogY29uc3RydWN0R3JhZGllbnRWYWx1ZShfdGVtcGxhdGVPYmplY3QkMSgpLCBwb3NpdGlvbiwgc2hhcGUsIGV4dGVudCwgY29sb3JTdG9wcy5qb2luKCcsICcpKVxuICB9O1xufVxuXG4vKipcbiAqIEEgaGVscGVyIHRvIGdlbmVyYXRlIGEgcmV0aW5hIGJhY2tncm91bmQgaW1hZ2UgYW5kIG5vbi1yZXRpbmFcbiAqIGJhY2tncm91bmQgaW1hZ2UuIFRoZSByZXRpbmEgYmFja2dyb3VuZCBpbWFnZSB3aWxsIG91dHB1dCB0byBhIEhpRFBJIG1lZGlhIHF1ZXJ5LiBUaGUgbWl4aW4gdXNlc1xuICogYSBfMngucG5nIGZpbGVuYW1lIHN1ZmZpeCBieSBkZWZhdWx0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgLi4ucmV0aW5hSW1hZ2UoJ215LWltZycpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7cmV0aW5hSW1hZ2UoJ215LWltZycpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqIGRpdiB7XG4gKiAgIGJhY2tncm91bmRJbWFnZTogJ3VybChteS1pbWcucG5nKScsXG4gKiAgICdAbWVkaWEgb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDEuMyksXG4gKiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMS4zKSxcbiAqICAgIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMS4zLzEpLFxuICogICAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTQ0ZHBpKSxcbiAqICAgIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDEuNWRwcHgpJzoge1xuICogICAgIGJhY2tncm91bmRJbWFnZTogJ3VybChteS1pbWdfMngucG5nKScsXG4gKiAgIH1cbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmV0aW5hSW1hZ2UoZmlsZW5hbWUsIGJhY2tncm91bmRTaXplLCBleHRlbnNpb24sIHJldGluYUZpbGVuYW1lLCByZXRpbmFTdWZmaXgpIHtcbiAgdmFyIF9yZWY7XG5cbiAgaWYgKGV4dGVuc2lvbiA9PT0gdm9pZCAwKSB7XG4gICAgZXh0ZW5zaW9uID0gJ3BuZyc7XG4gIH1cblxuICBpZiAocmV0aW5hU3VmZml4ID09PSB2b2lkIDApIHtcbiAgICByZXRpbmFTdWZmaXggPSAnXzJ4JztcbiAgfVxuXG4gIGlmICghZmlsZW5hbWUpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1OCk7XG4gIH0gLy8gUmVwbGFjZSB0aGUgZG90IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhc3NlZCBleHRlbnNpb24gaWYgb25lIGV4aXN0c1xuXG5cbiAgdmFyIGV4dCA9IGV4dGVuc2lvbi5yZXBsYWNlKC9eXFwuLywgJycpO1xuICB2YXIgckZpbGVuYW1lID0gcmV0aW5hRmlsZW5hbWUgPyByZXRpbmFGaWxlbmFtZSArIFwiLlwiICsgZXh0IDogXCJcIiArIGZpbGVuYW1lICsgcmV0aW5hU3VmZml4ICsgXCIuXCIgKyBleHQ7XG4gIHJldHVybiBfcmVmID0ge1xuICAgIGJhY2tncm91bmRJbWFnZTogXCJ1cmwoXCIgKyBmaWxlbmFtZSArIFwiLlwiICsgZXh0ICsgXCIpXCJcbiAgfSwgX3JlZltoaURQSSgpXSA9IF9leHRlbmRzKHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwidXJsKFwiICsgckZpbGVuYW1lICsgXCIpXCJcbiAgfSwgYmFja2dyb3VuZFNpemUgPyB7XG4gICAgYmFja2dyb3VuZFNpemU6IGJhY2tncm91bmRTaXplXG4gIH0gOiB7fSksIF9yZWY7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG52YXIgZnVuY3Rpb25zTWFwID0ge1xuICBlYXNlSW5CYWNrOiAnY3ViaWMtYmV6aWVyKDAuNjAwLCAtMC4yODAsIDAuNzM1LCAwLjA0NSknLFxuICBlYXNlSW5DaXJjOiAnY3ViaWMtYmV6aWVyKDAuNjAwLCAgMC4wNDAsIDAuOTgwLCAwLjMzNSknLFxuICBlYXNlSW5DdWJpYzogJ2N1YmljLWJlemllcigwLjU1MCwgIDAuMDU1LCAwLjY3NSwgMC4xOTApJyxcbiAgZWFzZUluRXhwbzogJ2N1YmljLWJlemllcigwLjk1MCwgIDAuMDUwLCAwLjc5NSwgMC4wMzUpJyxcbiAgZWFzZUluUXVhZDogJ2N1YmljLWJlemllcigwLjU1MCwgIDAuMDg1LCAwLjY4MCwgMC41MzApJyxcbiAgZWFzZUluUXVhcnQ6ICdjdWJpYy1iZXppZXIoMC44OTUsICAwLjAzMCwgMC42ODUsIDAuMjIwKScsXG4gIGVhc2VJblF1aW50OiAnY3ViaWMtYmV6aWVyKDAuNzU1LCAgMC4wNTAsIDAuODU1LCAwLjA2MCknLFxuICBlYXNlSW5TaW5lOiAnY3ViaWMtYmV6aWVyKDAuNDcwLCAgMC4wMDAsIDAuNzQ1LCAwLjcxNSknLFxuICBlYXNlT3V0QmFjazogJ2N1YmljLWJlemllcigwLjE3NSwgIDAuODg1LCAwLjMyMCwgMS4yNzUpJyxcbiAgZWFzZU91dEN1YmljOiAnY3ViaWMtYmV6aWVyKDAuMjE1LCAgMC42MTAsIDAuMzU1LCAxLjAwMCknLFxuICBlYXNlT3V0Q2lyYzogJ2N1YmljLWJlemllcigwLjA3NSwgIDAuODIwLCAwLjE2NSwgMS4wMDApJyxcbiAgZWFzZU91dEV4cG86ICdjdWJpYy1iZXppZXIoMC4xOTAsICAxLjAwMCwgMC4yMjAsIDEuMDAwKScsXG4gIGVhc2VPdXRRdWFkOiAnY3ViaWMtYmV6aWVyKDAuMjUwLCAgMC40NjAsIDAuNDUwLCAwLjk0MCknLFxuICBlYXNlT3V0UXVhcnQ6ICdjdWJpYy1iZXppZXIoMC4xNjUsICAwLjg0MCwgMC40NDAsIDEuMDAwKScsXG4gIGVhc2VPdXRRdWludDogJ2N1YmljLWJlemllcigwLjIzMCwgIDEuMDAwLCAwLjMyMCwgMS4wMDApJyxcbiAgZWFzZU91dFNpbmU6ICdjdWJpYy1iZXppZXIoMC4zOTAsICAwLjU3NSwgMC41NjUsIDEuMDAwKScsXG4gIGVhc2VJbk91dEJhY2s6ICdjdWJpYy1iZXppZXIoMC42ODAsIC0wLjU1MCwgMC4yNjUsIDEuNTUwKScsXG4gIGVhc2VJbk91dENpcmM6ICdjdWJpYy1iZXppZXIoMC43ODUsICAwLjEzNSwgMC4xNTAsIDAuODYwKScsXG4gIGVhc2VJbk91dEN1YmljOiAnY3ViaWMtYmV6aWVyKDAuNjQ1LCAgMC4wNDUsIDAuMzU1LCAxLjAwMCknLFxuICBlYXNlSW5PdXRFeHBvOiAnY3ViaWMtYmV6aWVyKDEuMDAwLCAgMC4wMDAsIDAuMDAwLCAxLjAwMCknLFxuICBlYXNlSW5PdXRRdWFkOiAnY3ViaWMtYmV6aWVyKDAuNDU1LCAgMC4wMzAsIDAuNTE1LCAwLjk1NSknLFxuICBlYXNlSW5PdXRRdWFydDogJ2N1YmljLWJlemllcigwLjc3MCwgIDAuMDAwLCAwLjE3NSwgMS4wMDApJyxcbiAgZWFzZUluT3V0UXVpbnQ6ICdjdWJpYy1iZXppZXIoMC44NjAsICAwLjAwMCwgMC4wNzAsIDEuMDAwKScsXG4gIGVhc2VJbk91dFNpbmU6ICdjdWJpYy1iZXppZXIoMC40NDUsICAwLjA1MCwgMC41NTAsIDAuOTUwKSdcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuXG59O1xuXG5mdW5jdGlvbiBnZXRUaW1pbmdGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uc01hcFtmdW5jdGlvbk5hbWVdO1xufVxuLyoqXG4gKiBTdHJpbmcgdG8gcmVwcmVzZW50IGNvbW1vbiBlYXNpbmcgZnVuY3Rpb25zIGFzIGRlbW9uc3RyYXRlZCBoZXJlOiAoZ2l0aHViLmNvbS9qYXVraWEvZWFzaWUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiB0aW1pbmdGdW5jdGlvbnMoJ2Vhc2VJblF1YWQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiAgY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAke3RpbWluZ0Z1bmN0aW9ucygnZWFzZUluUXVhZCcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbic6ICdjdWJpYy1iZXppZXIoMC41NTAsICAwLjA4NSwgMC42ODAsIDAuNTMwKScsXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiB0aW1pbmdGdW5jdGlvbnModGltaW5nRnVuY3Rpb24pIHtcbiAgcmV0dXJuIGdldFRpbWluZ0Z1bmN0aW9uKHRpbWluZ0Z1bmN0aW9uKTtcbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYm9yZGVyQ29sb3IoJ3JlZCcsICdncmVlbicsICdibHVlJywgJ3llbGxvdycpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Ym9yZGVyQ29sb3IoJ3JlZCcsICdncmVlbicsICdibHVlJywgJ3llbGxvdycpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wQ29sb3InOiAncmVkJyxcbiAqICAgJ2JvcmRlclJpZ2h0Q29sb3InOiAnZ3JlZW4nLFxuICogICAnYm9yZGVyQm90dG9tQ29sb3InOiAnYmx1ZScsXG4gKiAgICdib3JkZXJMZWZ0Q29sb3InOiAneWVsbG93J1xuICogfVxuICovXG5mdW5jdGlvbiBib3JkZXJDb2xvcigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnYm9yZGVyQ29sb3InXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbnZhciBnZXRCb3JkZXJXaWR0aCA9IGZ1bmN0aW9uIGdldEJvcmRlcldpZHRoKHBvaW50aW5nRGlyZWN0aW9uLCBoZWlnaHQsIHdpZHRoKSB7XG4gIHN3aXRjaCAocG9pbnRpbmdEaXJlY3Rpb24pIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgcmV0dXJuIFwiMCBcIiArIHdpZHRoWzBdIC8gMiArIHdpZHRoWzFdICsgXCIgXCIgKyBoZWlnaHRbMF0gKyBoZWlnaHRbMV0gKyBcIiBcIiArIHdpZHRoWzBdIC8gMiArIHdpZHRoWzFdO1xuXG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4gXCJcIiArIGhlaWdodFswXSAvIDIgKyBoZWlnaHRbMV0gKyBcIiBcIiArIHdpZHRoWzBdICsgd2lkdGhbMV0gKyBcIiBcIiArIGhlaWdodFswXSAvIDIgKyBoZWlnaHRbMV0gKyBcIiAwXCI7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgcmV0dXJuIFwiXCIgKyBoZWlnaHRbMF0gKyBoZWlnaHRbMV0gKyBcIiBcIiArIHdpZHRoWzBdIC8gMiArIHdpZHRoWzFdICsgXCIgMCBcIiArIHdpZHRoWzBdIC8gMiArIHdpZHRoWzFdO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgcmV0dXJuIFwiXCIgKyBoZWlnaHRbMF0gLyAyICsgaGVpZ2h0WzFdICsgXCIgMCBcIiArIGhlaWdodFswXSAvIDIgKyBoZWlnaHRbMV0gKyBcIiBcIiArIHdpZHRoWzBdICsgd2lkdGhbMV07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTkpO1xuICB9XG59OyAvLyBuZWVkZWQgZm9yIGJvcmRlci1jb2xvclxuXG5cbnZhciByZXZlcnNlRGlyZWN0aW9uID0gWydib3R0b20nLCAnbGVmdCcsICd0b3AnLCAncmlnaHQnXTtcbnZhciBOVU1CRVJfQU5EX0ZMT0FUID0gLyhcXGQqXFwuP1xcZCopLztcbi8qKlxuICogQ1NTIHRvIHJlcHJlc2VudCB0cmlhbmdsZSB3aXRoIGFueSBwb2ludGluZyBkaXJlY3Rpb24gd2l0aCBhbiBvcHRpb25hbCBiYWNrZ3JvdW5kIGNvbG9yLiBBY2NlcHRzIG51bWJlciBvciBweCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGguXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnRyaWFuZ2xlKHsgcG9pbnRpbmdEaXJlY3Rpb246ICdyaWdodCcsIHdpZHRoOiAnMTAwcHgnLCBoZWlnaHQ6ICcxMDBweCcsIGZvcmVncm91bmRDb2xvcjogJ3JlZCcgfSlcbiAqIH1cbiAqXG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7dHJpYW5nbGUoeyBwb2ludGluZ0RpcmVjdGlvbjogJ3JpZ2h0Jywgd2lkdGg6ICcxMDBweCcsIGhlaWdodDogJzEwMHB4JywgZm9yZWdyb3VuZENvbG9yOiAncmVkJyB9KX1cbiAqXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdjoge1xuICogICdib3JkZXJDb2xvcic6ICd0cmFuc3BhcmVudCcsXG4gKiAgJ2JvcmRlckxlZnRDb2xvcic6ICdyZWQgIWltcG9ydGFudCcsXG4gKiAgJ2JvcmRlclN0eWxlJzogJ3NvbGlkJyxcbiAqICAnYm9yZGVyV2lkdGgnOiAnNTBweCAwIDUwcHggMTAwcHgnLFxuICogICdoZWlnaHQnOiAnMCcsXG4gKiAgJ3dpZHRoJzogJzAnLFxuICogfVxuICovXG5cbmZ1bmN0aW9uIHRyaWFuZ2xlKF9yZWYpIHtcbiAgdmFyIHBvaW50aW5nRGlyZWN0aW9uID0gX3JlZi5wb2ludGluZ0RpcmVjdGlvbixcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgZm9yZWdyb3VuZENvbG9yID0gX3JlZi5mb3JlZ3JvdW5kQ29sb3IsXG4gICAgICBfcmVmJGJhY2tncm91bmRDb2xvciA9IF9yZWYuYmFja2dyb3VuZENvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yID0gX3JlZiRiYWNrZ3JvdW5kQ29sb3IgPT09IHZvaWQgMCA/ICd0cmFuc3BhcmVudCcgOiBfcmVmJGJhY2tncm91bmRDb2xvcjtcbiAgdmFyIHdpZHRoQW5kVW5pdCA9IFtwYXJzZUZsb2F0KHdpZHRoKSwgU3RyaW5nKHdpZHRoKS5yZXBsYWNlKE5VTUJFUl9BTkRfRkxPQVQsICcnKSB8fCAncHgnXTtcbiAgdmFyIGhlaWdodEFuZFVuaXQgPSBbcGFyc2VGbG9hdChoZWlnaHQpLCBTdHJpbmcoaGVpZ2h0KS5yZXBsYWNlKE5VTUJFUl9BTkRfRkxPQVQsICcnKSB8fCAncHgnXTtcblxuICBpZiAoaXNOYU4oaGVpZ2h0QW5kVW5pdFswXSkgfHwgaXNOYU4od2lkdGhBbmRVbml0WzBdKSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDYwKTtcbiAgfVxuXG4gIHZhciByZXZlcnNlRGlyZWN0aW9uSW5kZXggPSByZXZlcnNlRGlyZWN0aW9uLmluZGV4T2YocG9pbnRpbmdEaXJlY3Rpb24pO1xuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIHdpZHRoOiAnMCcsXG4gICAgaGVpZ2h0OiAnMCcsXG4gICAgYm9yZGVyV2lkdGg6IGdldEJvcmRlcldpZHRoKHBvaW50aW5nRGlyZWN0aW9uLCBoZWlnaHRBbmRVbml0LCB3aWR0aEFuZFVuaXQpLFxuICAgIGJvcmRlclN0eWxlOiAnc29saWQnXG4gIH0sIGJvcmRlckNvbG9yLmFwcGx5KHZvaWQgMCwgQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiA0XG4gIH0pLm1hcChmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPT09IHJldmVyc2VEaXJlY3Rpb25JbmRleCA/IGZvcmVncm91bmRDb2xvciA6IGJhY2tncm91bmRDb2xvcjtcbiAgfSkpKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhbiBlYXN5IHdheSB0byBjaGFuZ2UgdGhlIGB3b3JkV3JhcGAgcHJvcGVydHkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ud29yZFdyYXAoJ2JyZWFrLXdvcmQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3dvcmRXcmFwKCdicmVhay13b3JkJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgb3ZlcmZsb3dXcmFwOiAnYnJlYWstd29yZCcsXG4gKiAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCcsXG4gKiAgIHdvcmRCcmVhazogJ2JyZWFrLWFsbCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHdvcmRXcmFwKHdyYXApIHtcbiAgaWYgKHdyYXAgPT09IHZvaWQgMCkge1xuICAgIHdyYXAgPSAnYnJlYWstd29yZCc7XG4gIH1cblxuICB2YXIgd29yZEJyZWFrID0gd3JhcCA9PT0gJ2JyZWFrLXdvcmQnID8gJ2JyZWFrLWFsbCcgOiB3cmFwO1xuICByZXR1cm4ge1xuICAgIG92ZXJmbG93V3JhcDogd3JhcCxcbiAgICB3b3JkV3JhcDogd3JhcCxcbiAgICB3b3JkQnJlYWs6IHdvcmRCcmVha1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb2xvclRvSW50KGNvbG9yKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGNvbG9yICogMjU1KTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRvSW50KHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmV0dXJuIGNvbG9yVG9JbnQocmVkKSArIFwiLFwiICsgY29sb3JUb0ludChncmVlbikgKyBcIixcIiArIGNvbG9yVG9JbnQoYmx1ZSk7XG59XG5cbmZ1bmN0aW9uIGhzbFRvUmdiKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBjb252ZXJ0KSB7XG4gIGlmIChjb252ZXJ0ID09PSB2b2lkIDApIHtcbiAgICBjb252ZXJ0ID0gY29udmVydFRvSW50O1xuICB9XG5cbiAgaWYgKHNhdHVyYXRpb24gPT09IDApIHtcbiAgICAvLyBhY2hyb21hdGljXG4gICAgcmV0dXJuIGNvbnZlcnQobGlnaHRuZXNzLCBsaWdodG5lc3MsIGxpZ2h0bmVzcyk7XG4gIH0gLy8gZm9ybXVsYXIgZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfYW5kX0hTVlxuXG5cbiAgdmFyIGh1ZVByaW1lID0gaHVlICUgMzYwIC8gNjA7XG4gIHZhciBjaHJvbWEgPSAoMSAtIE1hdGguYWJzKDIgKiBsaWdodG5lc3MgLSAxKSkgKiBzYXR1cmF0aW9uO1xuICB2YXIgc2Vjb25kQ29tcG9uZW50ID0gY2hyb21hICogKDEgLSBNYXRoLmFicyhodWVQcmltZSAlIDIgLSAxKSk7XG4gIHZhciByZWQgPSAwO1xuICB2YXIgZ3JlZW4gPSAwO1xuICB2YXIgYmx1ZSA9IDA7XG5cbiAgaWYgKGh1ZVByaW1lID49IDAgJiYgaHVlUHJpbWUgPCAxKSB7XG4gICAgcmVkID0gY2hyb21hO1xuICAgIGdyZWVuID0gc2Vjb25kQ29tcG9uZW50O1xuICB9IGVsc2UgaWYgKGh1ZVByaW1lID49IDEgJiYgaHVlUHJpbWUgPCAyKSB7XG4gICAgcmVkID0gc2Vjb25kQ29tcG9uZW50O1xuICAgIGdyZWVuID0gY2hyb21hO1xuICB9IGVsc2UgaWYgKGh1ZVByaW1lID49IDIgJiYgaHVlUHJpbWUgPCAzKSB7XG4gICAgZ3JlZW4gPSBjaHJvbWE7XG4gICAgYmx1ZSA9IHNlY29uZENvbXBvbmVudDtcbiAgfSBlbHNlIGlmIChodWVQcmltZSA+PSAzICYmIGh1ZVByaW1lIDwgNCkge1xuICAgIGdyZWVuID0gc2Vjb25kQ29tcG9uZW50O1xuICAgIGJsdWUgPSBjaHJvbWE7XG4gIH0gZWxzZSBpZiAoaHVlUHJpbWUgPj0gNCAmJiBodWVQcmltZSA8IDUpIHtcbiAgICByZWQgPSBzZWNvbmRDb21wb25lbnQ7XG4gICAgYmx1ZSA9IGNocm9tYTtcbiAgfSBlbHNlIGlmIChodWVQcmltZSA+PSA1ICYmIGh1ZVByaW1lIDwgNikge1xuICAgIHJlZCA9IGNocm9tYTtcbiAgICBibHVlID0gc2Vjb25kQ29tcG9uZW50O1xuICB9XG5cbiAgdmFyIGxpZ2h0bmVzc01vZGlmaWNhdGlvbiA9IGxpZ2h0bmVzcyAtIGNocm9tYSAvIDI7XG4gIHZhciBmaW5hbFJlZCA9IHJlZCArIGxpZ2h0bmVzc01vZGlmaWNhdGlvbjtcbiAgdmFyIGZpbmFsR3JlZW4gPSBncmVlbiArIGxpZ2h0bmVzc01vZGlmaWNhdGlvbjtcbiAgdmFyIGZpbmFsQmx1ZSA9IGJsdWUgKyBsaWdodG5lc3NNb2RpZmljYXRpb247XG4gIHJldHVybiBjb252ZXJ0KGZpbmFsUmVkLCBmaW5hbEdyZWVuLCBmaW5hbEJsdWUpO1xufVxuXG52YXIgbmFtZWRDb2xvck1hcCA9IHtcbiAgYWxpY2VibHVlOiAnZjBmOGZmJyxcbiAgYW50aXF1ZXdoaXRlOiAnZmFlYmQ3JyxcbiAgYXF1YTogJzAwZmZmZicsXG4gIGFxdWFtYXJpbmU6ICc3ZmZmZDQnLFxuICBhenVyZTogJ2YwZmZmZicsXG4gIGJlaWdlOiAnZjVmNWRjJyxcbiAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgYmxhY2s6ICcwMDAnLFxuICBibGFuY2hlZGFsbW9uZDogJ2ZmZWJjZCcsXG4gIGJsdWU6ICcwMDAwZmYnLFxuICBibHVldmlvbGV0OiAnOGEyYmUyJyxcbiAgYnJvd246ICdhNTJhMmEnLFxuICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICBjYWRldGJsdWU6ICc1ZjllYTAnLFxuICBjaGFydHJldXNlOiAnN2ZmZjAwJyxcbiAgY2hvY29sYXRlOiAnZDI2OTFlJyxcbiAgY29yYWw6ICdmZjdmNTAnLFxuICBjb3JuZmxvd2VyYmx1ZTogJzY0OTVlZCcsXG4gIGNvcm5zaWxrOiAnZmZmOGRjJyxcbiAgY3JpbXNvbjogJ2RjMTQzYycsXG4gIGN5YW46ICcwMGZmZmYnLFxuICBkYXJrYmx1ZTogJzAwMDA4YicsXG4gIGRhcmtjeWFuOiAnMDA4YjhiJyxcbiAgZGFya2dvbGRlbnJvZDogJ2I4ODYwYicsXG4gIGRhcmtncmF5OiAnYTlhOWE5JyxcbiAgZGFya2dyZWVuOiAnMDA2NDAwJyxcbiAgZGFya2dyZXk6ICdhOWE5YTknLFxuICBkYXJra2hha2k6ICdiZGI3NmInLFxuICBkYXJrbWFnZW50YTogJzhiMDA4YicsXG4gIGRhcmtvbGl2ZWdyZWVuOiAnNTU2YjJmJyxcbiAgZGFya29yYW5nZTogJ2ZmOGMwMCcsXG4gIGRhcmtvcmNoaWQ6ICc5OTMyY2MnLFxuICBkYXJrcmVkOiAnOGIwMDAwJyxcbiAgZGFya3NhbG1vbjogJ2U5OTY3YScsXG4gIGRhcmtzZWFncmVlbjogJzhmYmM4ZicsXG4gIGRhcmtzbGF0ZWJsdWU6ICc0ODNkOGInLFxuICBkYXJrc2xhdGVncmF5OiAnMmY0ZjRmJyxcbiAgZGFya3NsYXRlZ3JleTogJzJmNGY0ZicsXG4gIGRhcmt0dXJxdW9pc2U6ICcwMGNlZDEnLFxuICBkYXJrdmlvbGV0OiAnOTQwMGQzJyxcbiAgZGVlcHBpbms6ICdmZjE0OTMnLFxuICBkZWVwc2t5Ymx1ZTogJzAwYmZmZicsXG4gIGRpbWdyYXk6ICc2OTY5NjknLFxuICBkaW1ncmV5OiAnNjk2OTY5JyxcbiAgZG9kZ2VyYmx1ZTogJzFlOTBmZicsXG4gIGZpcmVicmljazogJ2IyMjIyMicsXG4gIGZsb3JhbHdoaXRlOiAnZmZmYWYwJyxcbiAgZm9yZXN0Z3JlZW46ICcyMjhiMjInLFxuICBmdWNoc2lhOiAnZmYwMGZmJyxcbiAgZ2FpbnNib3JvOiAnZGNkY2RjJyxcbiAgZ2hvc3R3aGl0ZTogJ2Y4ZjhmZicsXG4gIGdvbGQ6ICdmZmQ3MDAnLFxuICBnb2xkZW5yb2Q6ICdkYWE1MjAnLFxuICBncmF5OiAnODA4MDgwJyxcbiAgZ3JlZW46ICcwMDgwMDAnLFxuICBncmVlbnllbGxvdzogJ2FkZmYyZicsXG4gIGdyZXk6ICc4MDgwODAnLFxuICBob25leWRldzogJ2YwZmZmMCcsXG4gIGhvdHBpbms6ICdmZjY5YjQnLFxuICBpbmRpYW5yZWQ6ICdjZDVjNWMnLFxuICBpbmRpZ286ICc0YjAwODInLFxuICBpdm9yeTogJ2ZmZmZmMCcsXG4gIGtoYWtpOiAnZjBlNjhjJyxcbiAgbGF2ZW5kZXI6ICdlNmU2ZmEnLFxuICBsYXZlbmRlcmJsdXNoOiAnZmZmMGY1JyxcbiAgbGF3bmdyZWVuOiAnN2NmYzAwJyxcbiAgbGVtb25jaGlmZm9uOiAnZmZmYWNkJyxcbiAgbGlnaHRibHVlOiAnYWRkOGU2JyxcbiAgbGlnaHRjb3JhbDogJ2YwODA4MCcsXG4gIGxpZ2h0Y3lhbjogJ2UwZmZmZicsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnZmFmYWQyJyxcbiAgbGlnaHRncmF5OiAnZDNkM2QzJyxcbiAgbGlnaHRncmVlbjogJzkwZWU5MCcsXG4gIGxpZ2h0Z3JleTogJ2QzZDNkMycsXG4gIGxpZ2h0cGluazogJ2ZmYjZjMScsXG4gIGxpZ2h0c2FsbW9uOiAnZmZhMDdhJyxcbiAgbGlnaHRzZWFncmVlbjogJzIwYjJhYScsXG4gIGxpZ2h0c2t5Ymx1ZTogJzg3Y2VmYScsXG4gIGxpZ2h0c2xhdGVncmF5OiAnNzg5JyxcbiAgbGlnaHRzbGF0ZWdyZXk6ICc3ODknLFxuICBsaWdodHN0ZWVsYmx1ZTogJ2IwYzRkZScsXG4gIGxpZ2h0eWVsbG93OiAnZmZmZmUwJyxcbiAgbGltZTogJzBmMCcsXG4gIGxpbWVncmVlbjogJzMyY2QzMicsXG4gIGxpbmVuOiAnZmFmMGU2JyxcbiAgbWFnZW50YTogJ2YwZicsXG4gIG1hcm9vbjogJzgwMDAwMCcsXG4gIG1lZGl1bWFxdWFtYXJpbmU6ICc2NmNkYWEnLFxuICBtZWRpdW1ibHVlOiAnMDAwMGNkJyxcbiAgbWVkaXVtb3JjaGlkOiAnYmE1NWQzJyxcbiAgbWVkaXVtcHVycGxlOiAnOTM3MGRiJyxcbiAgbWVkaXVtc2VhZ3JlZW46ICczY2IzNzEnLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICc3YjY4ZWUnLFxuICBtZWRpdW1zcHJpbmdncmVlbjogJzAwZmE5YScsXG4gIG1lZGl1bXR1cnF1b2lzZTogJzQ4ZDFjYycsXG4gIG1lZGl1bXZpb2xldHJlZDogJ2M3MTU4NScsXG4gIG1pZG5pZ2h0Ymx1ZTogJzE5MTk3MCcsXG4gIG1pbnRjcmVhbTogJ2Y1ZmZmYScsXG4gIG1pc3R5cm9zZTogJ2ZmZTRlMScsXG4gIG1vY2Nhc2luOiAnZmZlNGI1JyxcbiAgbmF2YWpvd2hpdGU6ICdmZmRlYWQnLFxuICBuYXZ5OiAnMDAwMDgwJyxcbiAgb2xkbGFjZTogJ2ZkZjVlNicsXG4gIG9saXZlOiAnODA4MDAwJyxcbiAgb2xpdmVkcmFiOiAnNmI4ZTIzJyxcbiAgb3JhbmdlOiAnZmZhNTAwJyxcbiAgb3JhbmdlcmVkOiAnZmY0NTAwJyxcbiAgb3JjaGlkOiAnZGE3MGQ2JyxcbiAgcGFsZWdvbGRlbnJvZDogJ2VlZThhYScsXG4gIHBhbGVncmVlbjogJzk4ZmI5OCcsXG4gIHBhbGV0dXJxdW9pc2U6ICdhZmVlZWUnLFxuICBwYWxldmlvbGV0cmVkOiAnZGI3MDkzJyxcbiAgcGFwYXlhd2hpcDogJ2ZmZWZkNScsXG4gIHBlYWNocHVmZjogJ2ZmZGFiOScsXG4gIHBlcnU6ICdjZDg1M2YnLFxuICBwaW5rOiAnZmZjMGNiJyxcbiAgcGx1bTogJ2RkYTBkZCcsXG4gIHBvd2RlcmJsdWU6ICdiMGUwZTYnLFxuICBwdXJwbGU6ICc4MDAwODAnLFxuICByZWJlY2NhcHVycGxlOiAnNjM5JyxcbiAgcmVkOiAnZjAwJyxcbiAgcm9zeWJyb3duOiAnYmM4ZjhmJyxcbiAgcm95YWxibHVlOiAnNDE2OWUxJyxcbiAgc2FkZGxlYnJvd246ICc4YjQ1MTMnLFxuICBzYWxtb246ICdmYTgwNzInLFxuICBzYW5keWJyb3duOiAnZjRhNDYwJyxcbiAgc2VhZ3JlZW46ICcyZThiNTcnLFxuICBzZWFzaGVsbDogJ2ZmZjVlZScsXG4gIHNpZW5uYTogJ2EwNTIyZCcsXG4gIHNpbHZlcjogJ2MwYzBjMCcsXG4gIHNreWJsdWU6ICc4N2NlZWInLFxuICBzbGF0ZWJsdWU6ICc2YTVhY2QnLFxuICBzbGF0ZWdyYXk6ICc3MDgwOTAnLFxuICBzbGF0ZWdyZXk6ICc3MDgwOTAnLFxuICBzbm93OiAnZmZmYWZhJyxcbiAgc3ByaW5nZ3JlZW46ICcwMGZmN2YnLFxuICBzdGVlbGJsdWU6ICc0NjgyYjQnLFxuICB0YW46ICdkMmI0OGMnLFxuICB0ZWFsOiAnMDA4MDgwJyxcbiAgdGhpc3RsZTogJ2Q4YmZkOCcsXG4gIHRvbWF0bzogJ2ZmNjM0NycsXG4gIHR1cnF1b2lzZTogJzQwZTBkMCcsXG4gIHZpb2xldDogJ2VlODJlZScsXG4gIHdoZWF0OiAnZjVkZWIzJyxcbiAgd2hpdGU6ICdmZmYnLFxuICB3aGl0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgeWVsbG93OiAnZmYwJyxcbiAgeWVsbG93Z3JlZW46ICc5YWNkMzInXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgYSBDU1MgbmFtZWQgY29sb3IgYW5kIHJldHVybnMgaXRzIGVxdWl2YWxlbnQgaGV4IHZhbHVlLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgb3JpZ2luYWwgY29sb3IuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG59O1xuXG5mdW5jdGlvbiBuYW1lVG9IZXgoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycpIHJldHVybiBjb2xvcjtcbiAgdmFyIG5vcm1hbGl6ZWRDb2xvck5hbWUgPSBjb2xvci50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbmFtZWRDb2xvck1hcFtub3JtYWxpemVkQ29sb3JOYW1lXSA/IFwiI1wiICsgbmFtZWRDb2xvck1hcFtub3JtYWxpemVkQ29sb3JOYW1lXSA6IGNvbG9yO1xufVxuXG52YXIgaGV4UmVnZXggPSAvXiNbYS1mQS1GMC05XXs2fSQvO1xudmFyIGhleFJnYmFSZWdleCA9IC9eI1thLWZBLUYwLTldezh9JC87XG52YXIgcmVkdWNlZEhleFJlZ2V4ID0gL14jW2EtZkEtRjAtOV17M30kLztcbnZhciByZWR1Y2VkUmdiYUhleFJlZ2V4ID0gL14jW2EtZkEtRjAtOV17NH0kLztcbnZhciByZ2JSZWdleCA9IC9ecmdiXFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccypcXCkkLztcbnZhciByZ2JhUmVnZXggPSAvXnJnYmFcXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFstK10/WzAtOV0qWy5dP1swLTldKylcXHMqXFwpJC87XG52YXIgaHNsUmVnZXggPSAvXmhzbFxcKFxccyooXFxkezAsM31bLl0/WzAtOV0rKVxccyosXFxzKihcXGR7MSwzfSklXFxzKixcXHMqKFxcZHsxLDN9KSVcXHMqXFwpJC87XG52YXIgaHNsYVJlZ2V4ID0gL15oc2xhXFwoXFxzKihcXGR7MCwzfVsuXT9bMC05XSspXFxzKixcXHMqKFxcZHsxLDN9KSVcXHMqLFxccyooXFxkezEsM30pJVxccyosXFxzKihbLStdP1swLTldKlsuXT9bMC05XSspXFxzKlxcKSQvO1xuLyoqXG4gKiBSZXR1cm5zIGFuIFJnYkNvbG9yIG9yIFJnYmFDb2xvciBvYmplY3QuIFRoaXMgdXRpbGl0eSBmdW5jdGlvbiBpcyBvbmx5IHVzZWZ1bFxuICogaWYgd2FudCB0byBleHRyYWN0IGEgY29sb3IgY29tcG9uZW50LiBXaXRoIHRoZSBjb2xvciB1dGlsIGB0b0NvbG9yU3RyaW5nYCB5b3VcbiAqIGNhbiBjb252ZXJ0IGEgUmdiQ29sb3Igb3IgUmdiYUNvbG9yIG9iamVjdCBiYWNrIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBc3NpZ25zIGB7IHJlZDogMjU1LCBncmVlbjogMCwgYmx1ZTogMCB9YCB0byBjb2xvcjFcbiAqIGNvbnN0IGNvbG9yMSA9IHBhcnNlVG9SZ2IoJ3JnYigyNTUsIDAsIDApJyk7XG4gKiAvLyBBc3NpZ25zIGB7IHJlZDogOTIsIGdyZWVuOiAxMDIsIGJsdWU6IDExMiwgYWxwaGE6IDAuNzUgfWAgdG8gY29sb3IyXG4gKiBjb25zdCBjb2xvcjIgPSBwYXJzZVRvUmdiKCdoc2xhKDIxMCwgMTAlLCA0MCUsIDAuNzUpJyk7XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUb1JnYihjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDMpO1xuICB9XG5cbiAgdmFyIG5vcm1hbGl6ZWRDb2xvciA9IG5hbWVUb0hleChjb2xvcik7XG5cbiAgaWYgKG5vcm1hbGl6ZWRDb2xvci5tYXRjaChoZXhSZWdleCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzFdICsgbm9ybWFsaXplZENvbG9yWzJdLCAxNiksXG4gICAgICBncmVlbjogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclszXSArIG5vcm1hbGl6ZWRDb2xvcls0XSwgMTYpLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvcls1XSArIG5vcm1hbGl6ZWRDb2xvcls2XSwgMTYpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChub3JtYWxpemVkQ29sb3IubWF0Y2goaGV4UmdiYVJlZ2V4KSkge1xuICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQoKHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbN10gKyBub3JtYWxpemVkQ29sb3JbOF0sIDE2KSAvIDI1NSkudG9GaXhlZCgyKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclsxXSArIG5vcm1hbGl6ZWRDb2xvclsyXSwgMTYpLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbM10gKyBub3JtYWxpemVkQ29sb3JbNF0sIDE2KSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbNV0gKyBub3JtYWxpemVkQ29sb3JbNl0sIDE2KSxcbiAgICAgIGFscGhhOiBhbHBoYVxuICAgIH07XG4gIH1cblxuICBpZiAobm9ybWFsaXplZENvbG9yLm1hdGNoKHJlZHVjZWRIZXhSZWdleCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzFdICsgbm9ybWFsaXplZENvbG9yWzFdLCAxNiksXG4gICAgICBncmVlbjogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclsyXSArIG5vcm1hbGl6ZWRDb2xvclsyXSwgMTYpLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclszXSArIG5vcm1hbGl6ZWRDb2xvclszXSwgMTYpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChub3JtYWxpemVkQ29sb3IubWF0Y2gocmVkdWNlZFJnYmFIZXhSZWdleCkpIHtcbiAgICB2YXIgX2FscGhhID0gcGFyc2VGbG9hdCgocGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvcls0XSArIG5vcm1hbGl6ZWRDb2xvcls0XSwgMTYpIC8gMjU1KS50b0ZpeGVkKDIpKTtcblxuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbMV0gKyBub3JtYWxpemVkQ29sb3JbMV0sIDE2KSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzJdICsgbm9ybWFsaXplZENvbG9yWzJdLCAxNiksXG4gICAgICBibHVlOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzNdICsgbm9ybWFsaXplZENvbG9yWzNdLCAxNiksXG4gICAgICBhbHBoYTogX2FscGhhXG4gICAgfTtcbiAgfVxuXG4gIHZhciByZ2JNYXRjaGVkID0gcmdiUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3IpO1xuXG4gIGlmIChyZ2JNYXRjaGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIHJnYk1hdGNoZWRbMV0sIDEwKSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgcmdiTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIHJnYk1hdGNoZWRbM10sIDEwKVxuICAgIH07XG4gIH1cblxuICB2YXIgcmdiYU1hdGNoZWQgPSByZ2JhUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3IpO1xuXG4gIGlmIChyZ2JhTWF0Y2hlZCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KFwiXCIgKyByZ2JhTWF0Y2hlZFsxXSwgMTApLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyByZ2JhTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIHJnYmFNYXRjaGVkWzNdLCAxMCksXG4gICAgICBhbHBoYTogcGFyc2VGbG9hdChcIlwiICsgcmdiYU1hdGNoZWRbNF0pXG4gICAgfTtcbiAgfVxuXG4gIHZhciBoc2xNYXRjaGVkID0gaHNsUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3IpO1xuXG4gIGlmIChoc2xNYXRjaGVkKSB7XG4gICAgdmFyIGh1ZSA9IHBhcnNlSW50KFwiXCIgKyBoc2xNYXRjaGVkWzFdLCAxMCk7XG4gICAgdmFyIHNhdHVyYXRpb24gPSBwYXJzZUludChcIlwiICsgaHNsTWF0Y2hlZFsyXSwgMTApIC8gMTAwO1xuICAgIHZhciBsaWdodG5lc3MgPSBwYXJzZUludChcIlwiICsgaHNsTWF0Y2hlZFszXSwgMTApIC8gMTAwO1xuICAgIHZhciByZ2JDb2xvclN0cmluZyA9IFwicmdiKFwiICsgaHNsVG9SZ2IoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpICsgXCIpXCI7XG4gICAgdmFyIGhzbFJnYk1hdGNoZWQgPSByZ2JSZWdleC5leGVjKHJnYkNvbG9yU3RyaW5nKTtcblxuICAgIGlmICghaHNsUmdiTWF0Y2hlZCkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNCwgbm9ybWFsaXplZENvbG9yLCByZ2JDb2xvclN0cmluZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIGhzbFJnYk1hdGNoZWRbMV0sIDEwKSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgaHNsUmdiTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIGhzbFJnYk1hdGNoZWRbM10sIDEwKVxuICAgIH07XG4gIH1cblxuICB2YXIgaHNsYU1hdGNoZWQgPSBoc2xhUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3IpO1xuXG4gIGlmIChoc2xhTWF0Y2hlZCkge1xuICAgIHZhciBfaHVlID0gcGFyc2VJbnQoXCJcIiArIGhzbGFNYXRjaGVkWzFdLCAxMCk7XG5cbiAgICB2YXIgX3NhdHVyYXRpb24gPSBwYXJzZUludChcIlwiICsgaHNsYU1hdGNoZWRbMl0sIDEwKSAvIDEwMDtcblxuICAgIHZhciBfbGlnaHRuZXNzID0gcGFyc2VJbnQoXCJcIiArIGhzbGFNYXRjaGVkWzNdLCAxMCkgLyAxMDA7XG5cbiAgICB2YXIgX3JnYkNvbG9yU3RyaW5nID0gXCJyZ2IoXCIgKyBoc2xUb1JnYihfaHVlLCBfc2F0dXJhdGlvbiwgX2xpZ2h0bmVzcykgKyBcIilcIjtcblxuICAgIHZhciBfaHNsUmdiTWF0Y2hlZCA9IHJnYlJlZ2V4LmV4ZWMoX3JnYkNvbG9yU3RyaW5nKTtcblxuICAgIGlmICghX2hzbFJnYk1hdGNoZWQpIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQsIG5vcm1hbGl6ZWRDb2xvciwgX3JnYkNvbG9yU3RyaW5nKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgX2hzbFJnYk1hdGNoZWRbMV0sIDEwKSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgX2hzbFJnYk1hdGNoZWRbMl0sIDEwKSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KFwiXCIgKyBfaHNsUmdiTWF0Y2hlZFszXSwgMTApLFxuICAgICAgYWxwaGE6IHBhcnNlRmxvYXQoXCJcIiArIGhzbGFNYXRjaGVkWzRdKVxuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1KTtcbn1cblxuZnVuY3Rpb24gcmdiVG9Ic2woY29sb3IpIHtcbiAgLy8gbWFrZSBzdXJlIHJnYiBhcmUgY29udGFpbmVkIGluIGEgc2V0IG9mIFswLCAyNTVdXG4gIHZhciByZWQgPSBjb2xvci5yZWQgLyAyNTU7XG4gIHZhciBncmVlbiA9IGNvbG9yLmdyZWVuIC8gMjU1O1xuICB2YXIgYmx1ZSA9IGNvbG9yLmJsdWUgLyAyNTU7XG4gIHZhciBtYXggPSBNYXRoLm1heChyZWQsIGdyZWVuLCBibHVlKTtcbiAgdmFyIG1pbiA9IE1hdGgubWluKHJlZCwgZ3JlZW4sIGJsdWUpO1xuICB2YXIgbGlnaHRuZXNzID0gKG1heCArIG1pbikgLyAyO1xuXG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIC8vIGFjaHJvbWF0aWNcbiAgICBpZiAoY29sb3IuYWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHVlOiAwLFxuICAgICAgICBzYXR1cmF0aW9uOiAwLFxuICAgICAgICBsaWdodG5lc3M6IGxpZ2h0bmVzcyxcbiAgICAgICAgYWxwaGE6IGNvbG9yLmFscGhhXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBodWU6IDAsXG4gICAgICAgIHNhdHVyYXRpb246IDAsXG4gICAgICAgIGxpZ2h0bmVzczogbGlnaHRuZXNzXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBodWU7XG4gIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcbiAgdmFyIHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPiAwLjUgPyBkZWx0YSAvICgyIC0gbWF4IC0gbWluKSA6IGRlbHRhIC8gKG1heCArIG1pbik7XG5cbiAgc3dpdGNoIChtYXgpIHtcbiAgICBjYXNlIHJlZDpcbiAgICAgIGh1ZSA9IChncmVlbiAtIGJsdWUpIC8gZGVsdGEgKyAoZ3JlZW4gPCBibHVlID8gNiA6IDApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGdyZWVuOlxuICAgICAgaHVlID0gKGJsdWUgLSByZWQpIC8gZGVsdGEgKyAyO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gYmx1ZSBjYXNlXG4gICAgICBodWUgPSAocmVkIC0gZ3JlZW4pIC8gZGVsdGEgKyA0O1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBodWUgKj0gNjA7XG5cbiAgaWYgKGNvbG9yLmFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHVlOiBodWUsXG4gICAgICBzYXR1cmF0aW9uOiBzYXR1cmF0aW9uLFxuICAgICAgbGlnaHRuZXNzOiBsaWdodG5lc3MsXG4gICAgICBhbHBoYTogY29sb3IuYWxwaGFcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBodWU6IGh1ZSxcbiAgICBzYXR1cmF0aW9uOiBzYXR1cmF0aW9uLFxuICAgIGxpZ2h0bmVzczogbGlnaHRuZXNzXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBIc2xDb2xvciBvciBIc2xhQ29sb3Igb2JqZWN0LiBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgb25seSB1c2VmdWxcbiAqIGlmIHdhbnQgdG8gZXh0cmFjdCBhIGNvbG9yIGNvbXBvbmVudC4gV2l0aCB0aGUgY29sb3IgdXRpbCBgdG9Db2xvclN0cmluZ2AgeW91XG4gKiBjYW4gY29udmVydCBhIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QgYmFjayB0byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXNzaWducyBgeyBodWU6IDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH1gIHRvIGNvbG9yMVxuICogY29uc3QgY29sb3IxID0gcGFyc2VUb0hzbCgncmdiKDI1NSwgMCwgMCknKTtcbiAqIC8vIEFzc2lnbnMgYHsgaHVlOiAxMjgsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41LCBhbHBoYTogMC43NSB9YCB0byBjb2xvcjJcbiAqIGNvbnN0IGNvbG9yMiA9IHBhcnNlVG9Ic2woJ2hzbGEoMTI4LCAxMDAlLCA1MCUsIDAuNzUpJyk7XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVG9Ic2woY29sb3IpIHtcbiAgLy8gTm90ZTogQXQgYSBsYXRlciBzdGFnZSB3ZSBjYW4gb3B0aW1pemUgdGhpcyBmdW5jdGlvbiBhcyByaWdodCBub3cgYSBoc2xcbiAgLy8gY29sb3Igd291bGQgYmUgcGFyc2VkIGNvbnZlcnRlZCB0byByZ2IgdmFsdWVzIGFuZCBjb252ZXJ0ZWQgYmFjayB0byBoc2wuXG4gIHJldHVybiByZ2JUb0hzbChwYXJzZVRvUmdiKGNvbG9yKSk7XG59XG5cbi8qKlxuICogUmVkdWNlcyBoZXggdmFsdWVzIGlmIHBvc3NpYmxlIGUuZy4gI2ZmODg2NiB0byAjZjg2XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgcmVkdWNlSGV4VmFsdWUgPSBmdW5jdGlvbiByZWR1Y2VIZXhWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSA3ICYmIHZhbHVlWzFdID09PSB2YWx1ZVsyXSAmJiB2YWx1ZVszXSA9PT0gdmFsdWVbNF0gJiYgdmFsdWVbNV0gPT09IHZhbHVlWzZdKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgdmFsdWVbMV0gKyB2YWx1ZVszXSArIHZhbHVlWzVdO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZnVuY3Rpb24gbnVtYmVyVG9IZXgodmFsdWUpIHtcbiAgdmFyIGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyBcIjBcIiArIGhleCA6IGhleDtcbn1cblxuZnVuY3Rpb24gY29sb3JUb0hleChjb2xvcikge1xuICByZXR1cm4gbnVtYmVyVG9IZXgoTWF0aC5yb3VuZChjb2xvciAqIDI1NSkpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9IZXgocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZXR1cm4gcmVkdWNlSGV4VmFsdWUoXCIjXCIgKyBjb2xvclRvSGV4KHJlZCkgKyBjb2xvclRvSGV4KGdyZWVuKSArIGNvbG9yVG9IZXgoYmx1ZSkpO1xufVxuXG5mdW5jdGlvbiBoc2xUb0hleChodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykge1xuICByZXR1cm4gaHNsVG9SZ2IoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGNvbnZlcnRUb0hleCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB2YWx1ZSBmb3IgdGhlIGNvbG9yLiBUaGUgcmV0dXJuZWQgcmVzdWx0IGlzIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBoZXggbm90YXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogaHNsKDM1OSwgMC43NSwgMC40KSxcbiAqICAgYmFja2dyb3VuZDogaHNsKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40IH0pLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2hzbCgzNTksIDAuNzUsIDAuNCl9O1xuICogICBiYWNrZ3JvdW5kOiAke2hzbCh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNiMzE5MWNcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjYjMxOTFjXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhzbCh2YWx1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBzYXR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGlnaHRuZXNzID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBoc2xUb0hleCh2YWx1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHNhdHVyYXRpb24gPT09IHVuZGVmaW5lZCAmJiBsaWdodG5lc3MgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoc2xUb0hleCh2YWx1ZS5odWUsIHZhbHVlLnNhdHVyYXRpb24sIHZhbHVlLmxpZ2h0bmVzcyk7XG4gIH1cblxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcigxKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgY29sb3IuIFRoZSByZXR1cm5lZCByZXN1bHQgaXMgdGhlIHNtYWxsZXN0IHBvc3NpYmxlIHJnYmEgb3IgaGV4IG5vdGF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGhzbGEoMzU5LCAwLjc1LCAwLjQsIDAuNyksXG4gKiAgIGJhY2tncm91bmQ6IGhzbGEoeyBodWU6IDM2MCwgc2F0dXJhdGlvbjogMC43NSwgbGlnaHRuZXNzOiAwLjQsIGFscGhhOiAwLDcgfSksXG4gKiAgIGJhY2tncm91bmQ6IGhzbGEoMzU5LCAwLjc1LCAwLjQsIDEpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2hzbGEoMzU5LCAwLjc1LCAwLjQsIDAuNyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2hzbGEoeyBodWU6IDM2MCwgc2F0dXJhdGlvbjogMC43NSwgbGlnaHRuZXNzOiAwLjQsIGFscGhhOiAwLDcgfSl9O1xuICogICBiYWNrZ3JvdW5kOiAke2hzbGEoMzU5LCAwLjc1LCAwLjQsIDEpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNzksMjUsMjgsMC43KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTc5LDI1LDI4LDAuNylcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjYjMxOTFjXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhzbGEodmFsdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgYWxwaGEpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHNhdHVyYXRpb24gPT09ICdudW1iZXInICYmIHR5cGVvZiBsaWdodG5lc3MgPT09ICdudW1iZXInICYmIHR5cGVvZiBhbHBoYSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gYWxwaGEgPj0gMSA/IGhzbFRvSGV4KHZhbHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpIDogXCJyZ2JhKFwiICsgaHNsVG9SZ2IodmFsdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykgKyBcIixcIiArIGFscGhhICsgXCIpXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBzYXR1cmF0aW9uID09PSB1bmRlZmluZWQgJiYgbGlnaHRuZXNzID09PSB1bmRlZmluZWQgJiYgYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZS5hbHBoYSA+PSAxID8gaHNsVG9IZXgodmFsdWUuaHVlLCB2YWx1ZS5zYXR1cmF0aW9uLCB2YWx1ZS5saWdodG5lc3MpIDogXCJyZ2JhKFwiICsgaHNsVG9SZ2IodmFsdWUuaHVlLCB2YWx1ZS5zYXR1cmF0aW9uLCB2YWx1ZS5saWdodG5lc3MpICsgXCIsXCIgKyB2YWx1ZS5hbHBoYSArIFwiKVwiO1xuICB9XG5cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoMik7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB2YWx1ZSBmb3IgdGhlIGNvbG9yLiBUaGUgcmV0dXJuZWQgcmVzdWx0IGlzIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBoZXggbm90YXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogcmdiKDI1NSwgMjA1LCAxMDApLFxuICogICBiYWNrZ3JvdW5kOiByZ2IoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3JnYigyNTUsIDIwNSwgMTAwKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmNkNjRcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjZmZjZDY0XCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHJnYih2YWx1ZSwgZ3JlZW4sIGJsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGdyZWVuID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYmx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gcmVkdWNlSGV4VmFsdWUoXCIjXCIgKyBudW1iZXJUb0hleCh2YWx1ZSkgKyBudW1iZXJUb0hleChncmVlbikgKyBudW1iZXJUb0hleChibHVlKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBncmVlbiA9PT0gdW5kZWZpbmVkICYmIGJsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZWR1Y2VIZXhWYWx1ZShcIiNcIiArIG51bWJlclRvSGV4KHZhbHVlLnJlZCkgKyBudW1iZXJUb0hleCh2YWx1ZS5ncmVlbikgKyBudW1iZXJUb0hleCh2YWx1ZS5ibHVlKSk7XG4gIH1cblxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgY29sb3IuIFRoZSByZXR1cm5lZCByZXN1bHQgaXMgdGhlIHNtYWxsZXN0IHBvc3NpYmxlIHJnYmEgb3IgaGV4IG5vdGF0aW9uLlxuICpcbiAqIENhbiBhbHNvIGJlIHVzZWQgdG8gZmFkZSBhIGNvbG9yIGJ5IHBhc3NpbmcgYSBoZXggdmFsdWUgb3IgbmFtZWQgQ1NTIGNvbG9yIGFsb25nIHdpdGggYW4gYWxwaGEgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDIwNSwgMTAwLCAwLjcpLFxuICogICBiYWNrZ3JvdW5kOiByZ2JhKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCwgYWxwaGE6IDAuNyB9KSxcbiAqICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDIwNSwgMTAwLCAxKSxcbiAqICAgYmFja2dyb3VuZDogcmdiYSgnI2ZmZmZmZicsIDAuNCksXG4gKiAgIGJhY2tncm91bmQ6IHJnYmEoJ2JsYWNrJywgMC43KSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JhKDI1NSwgMjA1LCAxMDAsIDAuNyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3JnYmEoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwLCBhbHBoYTogMC43IH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JhKDI1NSwgMjA1LCAxMDAsIDEpfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JhKCcjZmZmZmZmJywgMC40KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiYSgnYmxhY2snLCAwLjcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjA1LDEwMCwwLjcpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjA1LDEwMCwwLjcpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDI1NSwyNTUsMC40KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMCwwLDAsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiByZ2JhKGZpcnN0VmFsdWUsIHNlY29uZFZhbHVlLCB0aGlyZFZhbHVlLCBmb3VydGhWYWx1ZSkge1xuICBpZiAodHlwZW9mIGZpcnN0VmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzZWNvbmRWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgcmdiVmFsdWUgPSBwYXJzZVRvUmdiKGZpcnN0VmFsdWUpO1xuICAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JWYWx1ZS5yZWQgKyBcIixcIiArIHJnYlZhbHVlLmdyZWVuICsgXCIsXCIgKyByZ2JWYWx1ZS5ibHVlICsgXCIsXCIgKyBzZWNvbmRWYWx1ZSArIFwiKVwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmaXJzdFZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2Vjb25kVmFsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiB0aGlyZFZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZm91cnRoVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZvdXJ0aFZhbHVlID49IDEgPyByZ2IoZmlyc3RWYWx1ZSwgc2Vjb25kVmFsdWUsIHRoaXJkVmFsdWUpIDogXCJyZ2JhKFwiICsgZmlyc3RWYWx1ZSArIFwiLFwiICsgc2Vjb25kVmFsdWUgKyBcIixcIiArIHRoaXJkVmFsdWUgKyBcIixcIiArIGZvdXJ0aFZhbHVlICsgXCIpXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0VmFsdWUgPT09ICdvYmplY3QnICYmIHNlY29uZFZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcmRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIGZvdXJ0aFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmlyc3RWYWx1ZS5hbHBoYSA+PSAxID8gcmdiKGZpcnN0VmFsdWUucmVkLCBmaXJzdFZhbHVlLmdyZWVuLCBmaXJzdFZhbHVlLmJsdWUpIDogXCJyZ2JhKFwiICsgZmlyc3RWYWx1ZS5yZWQgKyBcIixcIiArIGZpcnN0VmFsdWUuZ3JlZW4gKyBcIixcIiArIGZpcnN0VmFsdWUuYmx1ZSArIFwiLFwiICsgZmlyc3RWYWx1ZS5hbHBoYSArIFwiKVwiO1xuICB9XG5cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNyk7XG59XG5cbnZhciBpc1JnYiA9IGZ1bmN0aW9uIGlzUmdiKGNvbG9yKSB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IucmVkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuZ3JlZW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ibHVlID09PSAnbnVtYmVyJyAmJiAodHlwZW9mIGNvbG9yLmFscGhhICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICd1bmRlZmluZWQnKTtcbn07XG5cbnZhciBpc1JnYmEgPSBmdW5jdGlvbiBpc1JnYmEoY29sb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb2xvci5yZWQgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ncmVlbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmJsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ251bWJlcic7XG59O1xuXG52YXIgaXNIc2wgPSBmdW5jdGlvbiBpc0hzbChjb2xvcikge1xuICByZXR1cm4gdHlwZW9mIGNvbG9yLmh1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLnNhdHVyYXRpb24gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5saWdodG5lc3MgPT09ICdudW1iZXInICYmICh0eXBlb2YgY29sb3IuYWxwaGEgIT09ICdudW1iZXInIHx8IHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ3VuZGVmaW5lZCcpO1xufTtcblxudmFyIGlzSHNsYSA9IGZ1bmN0aW9uIGlzSHNsYShjb2xvcikge1xuICByZXR1cm4gdHlwZW9mIGNvbG9yLmh1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLnNhdHVyYXRpb24gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5saWdodG5lc3MgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ251bWJlcic7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIFJnYkNvbG9yLCBSZ2JhQ29sb3IsIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QgdG8gYSBjb2xvciBzdHJpbmcuXG4gKiBUaGlzIHV0aWwgaXMgdXNlZnVsIGluIGNhc2UgeW91IG9ubHkga25vdyBvbiBydW50aW1lIHdoaWNoIGNvbG9yIG9iamVjdCBpc1xuICogdXNlZC4gT3RoZXJ3aXNlIHdlIHJlY29tbWVuZCB0byByZWx5IG9uIGByZ2JgLCBgcmdiYWAsIGBoc2xgIG9yIGBoc2xhYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KSxcbiAqICAgYmFja2dyb3VuZDogdG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcyIH0pLFxuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgaHVlOiAyNDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH0pLFxuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40LCBhbHBoYTogMC43MiB9KSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7dG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcyIH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgaHVlOiAyNDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40LCBhbHBoYTogMC43MiB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDIwNSwxMDAsMC43MilcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjMDBmXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNzksMjUsMjUsMC43MilcIjtcbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQ29sb3JTdHJpbmcoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDgpO1xuICBpZiAoaXNSZ2JhKGNvbG9yKSkgcmV0dXJuIHJnYmEoY29sb3IpO1xuICBpZiAoaXNSZ2IoY29sb3IpKSByZXR1cm4gcmdiKGNvbG9yKTtcbiAgaWYgKGlzSHNsYShjb2xvcikpIHJldHVybiBoc2xhKGNvbG9yKTtcbiAgaWYgKGlzSHNsKGNvbG9yKSkgcmV0dXJuIGhzbChjb2xvcik7XG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDgpO1xufVxuXG4vLyBUeXBlIGRlZmluaXRpb25zIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2djYW50aS9mbG93LXN0YXRpYy1sYW5kL2Jsb2IvbWFzdGVyL3NyYy9GdW4uanNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5mdW5jdGlvbiBjdXJyaWVkKGYsIGxlbmd0aCwgYWNjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmbigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgdmFyIGNvbWJpbmVkID0gYWNjLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gY29tYmluZWQubGVuZ3RoID49IGxlbmd0aCA/IGYuYXBwbHkodGhpcywgY29tYmluZWQpIDogY3VycmllZChmLCBsZW5ndGgsIGNvbWJpbmVkKTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5cbmZ1bmN0aW9uIGN1cnJ5KGYpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZWRlY2xhcmVcbiAgcmV0dXJuIGN1cnJpZWQoZiwgZi5sZW5ndGgsIFtdKTtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBodWUgb2YgdGhlIGNvbG9yLiBIdWUgaXMgYSBudW1iZXIgYmV0d2VlbiAwIHRvIDM2MC4gVGhlIGZpcnN0XG4gKiBhcmd1bWVudCBmb3IgYWRqdXN0SHVlIGlzIHRoZSBhbW91bnQgb2YgZGVncmVlcyB0aGUgY29sb3IgaXMgcm90YXRlZCBhbG9uZ1xuICogdGhlIGNvbG9yIHdoZWVsLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGFkanVzdEh1ZSgxODAsICcjNDQ4JyksXG4gKiAgIGJhY2tncm91bmQ6IGFkanVzdEh1ZSgnMTgwJywgJ3JnYmEoMTAxLDEwMCwyMDUsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2FkanVzdEh1ZSgxODAsICcjNDQ4Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2FkanVzdEh1ZSgnMTgwJywgJ3JnYmEoMTAxLDEwMCwyMDUsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjODg4ODQ0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxMzYsMTM2LDY4LDAuNylcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBhZGp1c3RIdWUoZGVncmVlLCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIGh1ZTogKGhzbENvbG9yLmh1ZSArIHBhcnNlRmxvYXQoZGVncmVlKSkgJSAzNjBcbiAgfSkpO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG52YXIgY3VycmllZEFkanVzdEh1ZSA9XG4vKiNfX1BVUkVfXyovXG5jdXJyeVxuLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi9cbihhZGp1c3RIdWUpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbXBsZW1lbnQgb2YgdGhlIHByb3ZpZGVkIGNvbG9yLiBUaGlzIGlzIGlkZW50aWNhbCB0byBhZGp1c3RIdWUoMTgwLCA8Y29sb3I+KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBjb21wbGVtZW50KCcjNDQ4JyksXG4gKiAgIGJhY2tncm91bmQ6IGNvbXBsZW1lbnQoJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2NvbXBsZW1lbnQoJyM0NDgnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7Y29tcGxlbWVudCgncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiM4ODRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE1MywxNTMsMTUzLDAuNylcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBjb21wbGVtZW50KGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgaHVlOiAoaHNsQ29sb3IuaHVlICsgMTgwKSAlIDM2MFxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIGd1YXJkKGxvd2VyQm91bmRhcnksIHVwcGVyQm91bmRhcnksIHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heChsb3dlckJvdW5kYXJ5LCBNYXRoLm1pbih1cHBlckJvdW5kYXJ5LCB2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBkYXJrZW5lZCBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBkYXJrZW4oMC4yLCAnI0ZGQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBkYXJrZW4oJzAuMicsICdyZ2JhKDI1NSwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtkYXJrZW4oMC4yLCAnI0ZGQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtkYXJrZW4oJzAuMicsICdyZ2JhKDI1NSwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmJkMzFcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwxODksNDksMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGRhcmtlbihhbW91bnQsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgbGlnaHRuZXNzOiBndWFyZCgwLCAxLCBoc2xDb2xvci5saWdodG5lc3MgLSBwYXJzZUZsb2F0KGFtb3VudCkpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWREYXJrZW4gPVxuLyojX19QVVJFX18qL1xuY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4oZGFya2VuKTtcblxuLyoqXG4gKiBEZWNyZWFzZXMgdGhlIGludGVuc2l0eSBvZiBhIGNvbG9yLiBJdHMgcmFuZ2UgaXMgYmV0d2VlbiAwIHRvIDEuIFRoZSBmaXJzdFxuICogYXJndW1lbnQgb2YgdGhlIGRlc2F0dXJhdGUgZnVuY3Rpb24gaXMgdGhlIGFtb3VudCBieSBob3cgbXVjaCB0aGUgY29sb3JcbiAqIGludGVuc2l0eSBzaG91bGQgYmUgZGVjcmVhc2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGRlc2F0dXJhdGUoMC4yLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBkZXNhdHVyYXRlKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7ZGVzYXR1cmF0ZSgwLjIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2Rlc2F0dXJhdGUoJzAuMicsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2I4Yjk3OVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTg0LDE4NSwxMjEsMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGRlc2F0dXJhdGUoYW1vdW50LCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIHNhdHVyYXRpb246IGd1YXJkKDAsIDEsIGhzbENvbG9yLnNhdHVyYXRpb24gLSBwYXJzZUZsb2F0KGFtb3VudCkpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWREZXNhdHVyYXRlID1cbi8qI19fUFVSRV9fKi9cbmN1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKGRlc2F0dXJhdGUpO1xuXG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgKGZsb2F0KSByZXByZXNlbnRpbmcgdGhlIGx1bWluYW5jZSBvZiBhIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGdldEx1bWluYW5jZSgnI0NDQ0Q2NCcpID49IGdldEx1bWluYW5jZSgnIzAwMDBmZicpID8gJyNDQ0NENjQnIDogJyMwMDAwZmYnLFxuICogICBiYWNrZ3JvdW5kOiBnZXRMdW1pbmFuY2UoJ3JnYmEoNTgsIDEzMywgMjU1LCAxKScpID49IGdldEx1bWluYW5jZSgncmdiYSgyNTUsIDU3LCAxNDksIDEpJykgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZ2JhKDU4LCAxMzMsIDI1NSwgMSknIDpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmdiYSgyNTUsIDU3LCAxNDksIDEpJyxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtnZXRMdW1pbmFuY2UoJyNDQ0NENjQnKSA+PSBnZXRMdW1pbmFuY2UoJyMwMDAwZmYnKSA/ICcjQ0NDRDY0JyA6ICcjMDAwMGZmJ307XG4gKiAgIGJhY2tncm91bmQ6ICR7Z2V0THVtaW5hbmNlKCdyZ2JhKDU4LCAxMzMsIDI1NSwgMSknKSA+PSBnZXRMdW1pbmFuY2UoJ3JnYmEoMjU1LCA1NywgMTQ5LCAxKScpID9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmdiYSg1OCwgMTMzLCAyNTUsIDEpJyA6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JnYmEoMjU1LCA1NywgMTQ5LCAxKSd9O1xuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICBiYWNrZ3JvdW5kOiBcIiNDQ0NENjRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDU4LCAxMzMsIDI1NSwgMSlcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRMdW1pbmFuY2UoY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gMDtcbiAgdmFyIHJnYkNvbG9yID0gcGFyc2VUb1JnYihjb2xvcik7XG5cbiAgdmFyIF9PYmplY3Qka2V5cyRtYXAgPSBPYmplY3Qua2V5cyhyZ2JDb2xvcikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY2hhbm5lbCA9IHJnYkNvbG9yW2tleV0gLyAyNTU7XG4gICAgcmV0dXJuIGNoYW5uZWwgPD0gMC4wMzkyOCA/IGNoYW5uZWwgLyAxMi45MiA6IE1hdGgucG93KChjaGFubmVsICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gIH0pLFxuICAgICAgciA9IF9PYmplY3Qka2V5cyRtYXBbMF0sXG4gICAgICBnID0gX09iamVjdCRrZXlzJG1hcFsxXSxcbiAgICAgIGIgPSBfT2JqZWN0JGtleXMkbWFwWzJdO1xuXG4gIHJldHVybiBwYXJzZUZsb2F0KCgwLjIxMjYgKiByICsgMC43MTUyICogZyArIDAuMDcyMiAqIGIpLnRvRml4ZWQoMykpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjb2xvciB0byBhIGdyYXlzY2FsZSwgYnkgcmVkdWNpbmcgaXRzIHNhdHVyYXRpb24gdG8gMC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBncmF5c2NhbGUoJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogZ3JheXNjYWxlKCdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtncmF5c2NhbGUoJyNDQ0NENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7Z3JheXNjYWxlKCdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzk5OVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTUzLDE1MywxNTMsMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGdyYXlzY2FsZShjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIHBhcnNlVG9Ic2woY29sb3IpLCB7XG4gICAgc2F0dXJhdGlvbjogMFxuICB9KSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBIc2xDb2xvciBvciBIc2xhQ29sb3Igb2JqZWN0IHRvIGEgY29sb3Igc3RyaW5nLlxuICogVGhpcyB1dGlsIGlzIHVzZWZ1bCBpbiBjYXNlIHlvdSBvbmx5IGtub3cgb24gcnVudGltZSB3aGljaCBjb2xvciBvYmplY3QgaXNcbiAqIHVzZWQuIE90aGVyd2lzZSB3ZSByZWNvbW1lbmQgdG8gcmVseSBvbiBgaHNsYCBvciBgaHNsYWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogaHNsVG9Db2xvclN0cmluZyh7IGh1ZTogMjQwLCBzYXR1cmF0aW9uOiAxLCBsaWdodG5lc3M6IDAuNSB9KSxcbiAqICAgYmFja2dyb3VuZDogaHNsVG9Db2xvclN0cmluZyh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAuNzIgfSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsVG9Db2xvclN0cmluZyh7IGh1ZTogMjQwLCBzYXR1cmF0aW9uOiAxLCBsaWdodG5lc3M6IDAuNSB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsVG9Db2xvclN0cmluZyh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAuNzIgfSl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiMwMGZcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE3OSwyNSwyNSwwLjcyKVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBoc2xUb0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gIGlmICh0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb2xvci5odWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5zYXR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IubGlnaHRuZXNzID09PSAnbnVtYmVyJykge1xuICAgIGlmIChjb2xvci5hbHBoYSAmJiB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gaHNsYSh7XG4gICAgICAgIGh1ZTogY29sb3IuaHVlLFxuICAgICAgICBzYXR1cmF0aW9uOiBjb2xvci5zYXR1cmF0aW9uLFxuICAgICAgICBsaWdodG5lc3M6IGNvbG9yLmxpZ2h0bmVzcyxcbiAgICAgICAgYWxwaGE6IGNvbG9yLmFscGhhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHNsKHtcbiAgICAgIGh1ZTogY29sb3IuaHVlLFxuICAgICAgc2F0dXJhdGlvbjogY29sb3Iuc2F0dXJhdGlvbixcbiAgICAgIGxpZ2h0bmVzczogY29sb3IubGlnaHRuZXNzXG4gICAgfSk7XG4gIH1cblxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0NSk7XG59XG5cbi8qKlxuICogSW52ZXJ0cyB0aGUgcmVkLCBncmVlbiBhbmQgYmx1ZSB2YWx1ZXMgb2YgYSBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBpbnZlcnQoJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogaW52ZXJ0KCdyZ2JhKDEwMSwxMDAsMjA1LDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtpbnZlcnQoJyNDQ0NENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aW52ZXJ0KCdyZ2JhKDEwMSwxMDAsMjA1LDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiMzMzMyOWJcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE1NCwxNTUsNTAsMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGludmVydChjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjsgLy8gcGFyc2UgY29sb3Igc3RyaW5nIHRvIHJnYlxuXG4gIHZhciB2YWx1ZSA9IHBhcnNlVG9SZ2IoY29sb3IpO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgdmFsdWUsIHtcbiAgICByZWQ6IDI1NSAtIHZhbHVlLnJlZCxcbiAgICBncmVlbjogMjU1IC0gdmFsdWUuZ3JlZW4sXG4gICAgYmx1ZTogMjU1IC0gdmFsdWUuYmx1ZVxuICB9KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB2YWx1ZSBmb3IgdGhlIGxpZ2h0ZW5lZCBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBsaWdodGVuKDAuMiwgJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogbGlnaHRlbignMC4yJywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2xpZ2h0ZW4oMC4yLCAnI0ZGQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtsaWdodGVuKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjZTVlNmIxXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyMjksMjMwLDE3NywwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gbGlnaHRlbihhbW91bnQsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgbGlnaHRuZXNzOiBndWFyZCgwLCAxLCBoc2xDb2xvci5saWdodG5lc3MgKyBwYXJzZUZsb2F0KGFtb3VudCkpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRMaWdodGVuID1cbi8qI19fUFVSRV9fKi9cbmN1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKGxpZ2h0ZW4pO1xuXG4vKipcbiAqIE1peGVzIHRoZSB0d28gcHJvdmlkZWQgY29sb3JzIHRvZ2V0aGVyIGJ5IGNhbGN1bGF0aW5nIHRoZSBhdmVyYWdlIG9mIGVhY2ggb2YgdGhlIFJHQiBjb21wb25lbnRzIHdlaWdodGVkIHRvIHRoZSBmaXJzdCBjb2xvciBieSB0aGUgcHJvdmlkZWQgd2VpZ2h0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IG1peCgwLjUsICcjZjAwJywgJyMwMGYnKVxuICogICBiYWNrZ3JvdW5kOiBtaXgoMC4yNSwgJyNmMDAnLCAnIzAwZicpXG4gKiAgIGJhY2tncm91bmQ6IG1peCgnMC41JywgJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJywgJyMwMGYnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke21peCgwLjUsICcjZjAwJywgJyMwMGYnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7bWl4KDAuMjUsICcjZjAwJywgJyMwMGYnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7bWl4KCcwLjUnLCAncmdiYSgyNTUsIDAsIDAsIDAuNSknLCAnIzAwZicpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzdmMDA3ZlwiO1xuICogICBiYWNrZ3JvdW5kOiBcIiMzZjAwYmZcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDYzLCAwLCAxOTEsIDAuNzUpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gbWl4KHdlaWdodCwgY29sb3IsIG90aGVyQ29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gb3RoZXJDb2xvcjtcbiAgaWYgKG90aGVyQ29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIHBhcnNlZENvbG9yMSA9IHBhcnNlVG9SZ2IoY29sb3IpO1xuXG4gIHZhciBjb2xvcjEgPSBfZXh0ZW5kcyh7fSwgcGFyc2VkQ29sb3IxLCB7XG4gICAgYWxwaGE6IHR5cGVvZiBwYXJzZWRDb2xvcjEuYWxwaGEgPT09ICdudW1iZXInID8gcGFyc2VkQ29sb3IxLmFscGhhIDogMVxuICB9KTtcblxuICB2YXIgcGFyc2VkQ29sb3IyID0gcGFyc2VUb1JnYihvdGhlckNvbG9yKTtcblxuICB2YXIgY29sb3IyID0gX2V4dGVuZHMoe30sIHBhcnNlZENvbG9yMiwge1xuICAgIGFscGhhOiB0eXBlb2YgcGFyc2VkQ29sb3IyLmFscGhhID09PSAnbnVtYmVyJyA/IHBhcnNlZENvbG9yMi5hbHBoYSA6IDEgLy8gVGhlIGZvcm11bGFyIGlzIGNvcGllZCBmcm9tIHRoZSBvcmlnaW5hbCBTYXNzIGltcGxlbWVudGF0aW9uOlxuICAgIC8vIGh0dHA6Ly9zYXNzLWxhbmcuY29tL2RvY3VtZW50YXRpb24vU2Fzcy9TY3JpcHQvRnVuY3Rpb25zLmh0bWwjbWl4LWluc3RhbmNlX21ldGhvZFxuXG4gIH0pO1xuXG4gIHZhciBhbHBoYURlbHRhID0gY29sb3IxLmFscGhhIC0gY29sb3IyLmFscGhhO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQod2VpZ2h0KSAqIDIgLSAxO1xuICB2YXIgeSA9IHggKiBhbHBoYURlbHRhID09PSAtMSA/IHggOiB4ICsgYWxwaGFEZWx0YTtcbiAgdmFyIHogPSAxICsgeCAqIGFscGhhRGVsdGE7XG4gIHZhciB3ZWlnaHQxID0gKHkgLyB6ICsgMSkgLyAyLjA7XG4gIHZhciB3ZWlnaHQyID0gMSAtIHdlaWdodDE7XG4gIHZhciBtaXhlZENvbG9yID0ge1xuICAgIHJlZDogTWF0aC5mbG9vcihjb2xvcjEucmVkICogd2VpZ2h0MSArIGNvbG9yMi5yZWQgKiB3ZWlnaHQyKSxcbiAgICBncmVlbjogTWF0aC5mbG9vcihjb2xvcjEuZ3JlZW4gKiB3ZWlnaHQxICsgY29sb3IyLmdyZWVuICogd2VpZ2h0MiksXG4gICAgYmx1ZTogTWF0aC5mbG9vcihjb2xvcjEuYmx1ZSAqIHdlaWdodDEgKyBjb2xvcjIuYmx1ZSAqIHdlaWdodDIpLFxuICAgIGFscGhhOiBjb2xvcjEuYWxwaGEgKyAoY29sb3IyLmFscGhhIC0gY29sb3IxLmFscGhhKSAqIChwYXJzZUZsb2F0KHdlaWdodCkgLyAxLjApXG4gIH07XG4gIHJldHVybiByZ2JhKG1peGVkQ29sb3IpO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG52YXIgY3VycmllZE1peCA9XG4vKiNfX1BVUkVfXyovXG5jdXJyeVxuLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKG1peCk7XG5cbi8qKlxuICogSW5jcmVhc2VzIHRoZSBvcGFjaXR5IG9mIGEgY29sb3IuIEl0cyByYW5nZSBmb3IgdGhlIGFtb3VudCBpcyBiZXR3ZWVuIDAgdG8gMS5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogb3BhY2lmeSgwLjEsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSknKTtcbiAqICAgYmFja2dyb3VuZDogb3BhY2lmeSgwLjIsICdoc2xhKDAsIDAlLCAxMDAlLCAwLjUpJyksXG4gKiAgIGJhY2tncm91bmQ6IG9wYWNpZnkoJzAuNScsICdyZ2JhKDI1NSwgMCwgMCwgMC4yKScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke29wYWNpZnkoMC4xLCAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpJyl9O1xuICogICBiYWNrZ3JvdW5kOiAke29wYWNpZnkoMC4yLCAnaHNsYSgwLCAwJSwgMTAwJSwgMC41KScpfSxcbiAqICAgYmFja2dyb3VuZDogJHtvcGFjaWZ5KCcwLjUnLCAncmdiYSgyNTUsIDAsIDAsIDAuMiknKX0sXG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmZcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyNTUsMjU1LDAuNylcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwwLDAsMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIG9wYWNpZnkoYW1vdW50LCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIHBhcnNlZENvbG9yID0gcGFyc2VUb1JnYihjb2xvcik7XG4gIHZhciBhbHBoYSA9IHR5cGVvZiBwYXJzZWRDb2xvci5hbHBoYSA9PT0gJ251bWJlcicgPyBwYXJzZWRDb2xvci5hbHBoYSA6IDE7XG5cbiAgdmFyIGNvbG9yV2l0aEFscGhhID0gX2V4dGVuZHMoe30sIHBhcnNlZENvbG9yLCB7XG4gICAgYWxwaGE6IGd1YXJkKDAsIDEsIChhbHBoYSAqIDEwMCArIHBhcnNlRmxvYXQoYW1vdW50KSAqIDEwMCkgLyAxMDApXG4gIH0pO1xuXG4gIHJldHVybiByZ2JhKGNvbG9yV2l0aEFscGhhKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRPcGFjaWZ5ID1cbi8qI19fUFVSRV9fKi9cbmN1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKG9wYWNpZnkpO1xuXG4vKipcbiAqIFJldHVybnMgYmxhY2sgb3Igd2hpdGUgKG9yIG9wdGlvbmFsIGxpZ2h0IGFuZCBkYXJrIHJldHVybiBjb2xvcnMpIGZvciBiZXN0IGNvbnRyYXN0IGRlcGVuZGluZyBvbiB0aGUgbHVtaW5vc2l0eSBvZiB0aGUgZ2l2ZW4gY29sb3IuXG4gKiBGb2xsb3dzIFtXM0Mgc3BlY3MgZm9yIHJlYWRhYmlsaXR5XShodHRwczovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0cxOC5odG1sKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBjb2xvcjogcmVhZGFibGVDb2xvcignIzAwMCcpLFxuICogICBjb2xvcjogcmVhZGFibGVDb2xvcignYmxhY2snLCAnIzAwMScsICcjZmY4JyksXG4gKiAgIGNvbG9yOiByZWFkYWJsZUNvbG9yKCd3aGl0ZScsICcjMDAxJywgJyNmZjgnKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgY29sb3I6ICR7cmVhZGFibGVDb2xvcignIzAwMCcpfTtcbiAqICAgY29sb3I6ICR7cmVhZGFibGVDb2xvcignYmxhY2snLCAnIzAwMScsICcjZmY4Jyl9O1xuICogICBjb2xvcjogJHtyZWFkYWJsZUNvbG9yKCd3aGl0ZScsICcjMDAxJywgJyNmZjgnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBjb2xvcjogXCIjZmZmXCI7XG4gKiAgIGNvbG9yOiBcIiNmZjhcIjtcbiAqICAgY29sb3I6IFwiIzAwMVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHJlYWRhYmxlQ29sb3IoY29sb3IsIGxpZ2h0UmV0dXJuQ29sb3IsIGRhcmtSZXR1cm5Db2xvcikge1xuICBpZiAobGlnaHRSZXR1cm5Db2xvciA9PT0gdm9pZCAwKSB7XG4gICAgbGlnaHRSZXR1cm5Db2xvciA9ICcjMDAwJztcbiAgfVxuXG4gIGlmIChkYXJrUmV0dXJuQ29sb3IgPT09IHZvaWQgMCkge1xuICAgIGRhcmtSZXR1cm5Db2xvciA9ICcjZmZmJztcbiAgfVxuXG4gIHJldHVybiBnZXRMdW1pbmFuY2UoY29sb3IpID4gMC4xNzkgPyBsaWdodFJldHVybkNvbG9yIDogZGFya1JldHVybkNvbG9yO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgUmdiQ29sb3Igb3IgUmdiYUNvbG9yIG9iamVjdCB0byBhIGNvbG9yIHN0cmluZy5cbiAqIFRoaXMgdXRpbCBpcyB1c2VmdWwgaW4gY2FzZSB5b3Ugb25seSBrbm93IG9uIHJ1bnRpbWUgd2hpY2ggY29sb3Igb2JqZWN0IGlzXG4gKiB1c2VkLiBPdGhlcndpc2Ugd2UgcmVjb21tZW5kIHRvIHJlbHkgb24gYHJnYmAgb3IgYHJnYmFgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHJnYlRvQ29sb3JTdHJpbmcoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pLFxuICogICBiYWNrZ3JvdW5kOiByZ2JUb0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCwgYWxwaGE6IDAuNzIgfSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiVG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAgfSl9O1xuICogICBiYWNrZ3JvdW5kOiAke3JnYlRvQ29sb3JTdHJpbmcoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwLCBhbHBoYTogMC43MiB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDIwNSwxMDAsMC43MilcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmdiVG9Db2xvclN0cmluZyhjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29sb3IucmVkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuZ3JlZW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ibHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmIChjb2xvci5hbHBoYSAmJiB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcmdiYSh7XG4gICAgICAgIHJlZDogY29sb3IucmVkLFxuICAgICAgICBncmVlbjogY29sb3IuZ3JlZW4sXG4gICAgICAgIGJsdWU6IGNvbG9yLmJsdWUsXG4gICAgICAgIGFscGhhOiBjb2xvci5hbHBoYVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJnYih7XG4gICAgICByZWQ6IGNvbG9yLnJlZCxcbiAgICAgIGdyZWVuOiBjb2xvci5ncmVlbixcbiAgICAgIGJsdWU6IGNvbG9yLmJsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ2KTtcbn1cblxuLyoqXG4gKiBJbmNyZWFzZXMgdGhlIGludGVuc2l0eSBvZiBhIGNvbG9yLiBJdHMgcmFuZ2UgaXMgYmV0d2VlbiAwIHRvIDEuIFRoZSBmaXJzdFxuICogYXJndW1lbnQgb2YgdGhlIHNhdHVyYXRlIGZ1bmN0aW9uIGlzIHRoZSBhbW91bnQgYnkgaG93IG11Y2ggdGhlIGNvbG9yXG4gKiBpbnRlbnNpdHkgc2hvdWxkIGJlIGluY3JlYXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBzYXR1cmF0ZSgwLjIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IHNhdHVyYXRlKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7c2F0dXJhdGUoMC4yLCAnI0ZGQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtzYXR1cmF0ZSgnMC4yJywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2UwZTI1MFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjI0LDIyNiw4MCwwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gc2F0dXJhdGUoYW1vdW50LCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIHNhdHVyYXRpb246IGd1YXJkKDAsIDEsIGhzbENvbG9yLnNhdHVyYXRpb24gKyBwYXJzZUZsb2F0KGFtb3VudCkpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRTYXR1cmF0ZSA9XG4vKiNfX1BVUkVfXyovXG5jdXJyeVxuLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi9cbihzYXR1cmF0ZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgaHVlIG9mIGEgY29sb3IgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLiBUaGUgaHVlIHJhbmdlIGNhbiBiZVxuICogZnJvbSAwIGFuZCAzNTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogc2V0SHVlKDQyLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBzZXRIdWUoJzI0NCcsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtzZXRIdWUoNDIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3NldEh1ZSgnMjQ0JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjY2RhZTY0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxMDcsMTAwLDIwNSwwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gc2V0SHVlKGh1ZSwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBwYXJzZVRvSHNsKGNvbG9yKSwge1xuICAgIGh1ZTogcGFyc2VGbG9hdChodWUpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRTZXRIdWUgPVxuLyojX19QVVJFX18qL1xuY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4oc2V0SHVlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaWdodG5lc3Mgb2YgYSBjb2xvciB0byB0aGUgcHJvdmlkZWQgdmFsdWUuIFRoZSBsaWdodG5lc3MgcmFuZ2UgY2FuIGJlXG4gKiBmcm9tIDAgYW5kIDEuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogc2V0TGlnaHRuZXNzKDAuMiwgJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogc2V0TGlnaHRuZXNzKCcwLjc1JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3NldExpZ2h0bmVzcygwLjIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3NldExpZ2h0bmVzcygnMC43NScsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzRkNGQxOVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjIzLDIyNCwxNTksMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHNldExpZ2h0bmVzcyhsaWdodG5lc3MsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgcGFyc2VUb0hzbChjb2xvciksIHtcbiAgICBsaWdodG5lc3M6IHBhcnNlRmxvYXQobGlnaHRuZXNzKVxuICB9KSk7XG59IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbnZhciBjdXJyaWVkU2V0TGlnaHRuZXNzID1cbi8qI19fUFVSRV9fKi9cbmN1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKHNldExpZ2h0bmVzcyk7XG5cbi8qKlxuICogU2V0cyB0aGUgc2F0dXJhdGlvbiBvZiBhIGNvbG9yIHRvIHRoZSBwcm92aWRlZCB2YWx1ZS4gVGhlIHNhdHVyYXRpb24gcmFuZ2UgY2FuIGJlXG4gKiBmcm9tIDAgYW5kIDEuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogc2V0U2F0dXJhdGlvbigwLjIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IHNldFNhdHVyYXRpb24oJzAuNzUnLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7c2V0U2F0dXJhdGlvbigwLjIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3NldFNhdHVyYXRpb24oJzAuNzUnLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNhZGFkODRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDIyOCwyMjksNzYsMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHNldFNhdHVyYXRpb24oc2F0dXJhdGlvbiwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBwYXJzZVRvSHNsKGNvbG9yKSwge1xuICAgIHNhdHVyYXRpb246IHBhcnNlRmxvYXQoc2F0dXJhdGlvbilcbiAgfSkpO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG52YXIgY3VycmllZFNldFNhdHVyYXRpb24gPVxuLyojX19QVVJFX18qL1xuY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4oc2V0U2F0dXJhdGlvbik7XG5cbi8qKlxuICogU2hhZGVzIGEgY29sb3IgYnkgbWl4aW5nIGl0IHdpdGggYmxhY2suIGBzaGFkZWAgY2FuIHByb2R1Y2VcbiAqIGh1ZSBzaGlmdHMsIHdoZXJlIGFzIGBkYXJrZW5gIG1hbmlwdWxhdGVzIHRoZSBsdW1pbmFuY2UgY2hhbm5lbCBhbmQgdGhlcmVmb3JlXG4gKiBkb2Vzbid0IHByb2R1Y2UgaHVlIHNoaWZ0cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBzaGFkZSgwLjI1LCAnIzAwZicpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7c2hhZGUoMC4yNSwgJyMwMGYnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiMwMDAwM2ZcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBzaGFkZShwZXJjZW50YWdlLCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgcmV0dXJuIGN1cnJpZWRNaXgocGFyc2VGbG9hdChwZXJjZW50YWdlKSwgJ3JnYigwLCAwLCAwKScsIGNvbG9yKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRTaGFkZSA9XG4vKiNfX1BVUkVfXyovXG5jdXJyeVxuLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi9cbihzaGFkZSk7XG5cbi8qKlxuICogVGludHMgYSBjb2xvciBieSBtaXhpbmcgaXQgd2l0aCB3aGl0ZS4gYHRpbnRgIGNhbiBwcm9kdWNlXG4gKiBodWUgc2hpZnRzLCB3aGVyZSBhcyBgbGlnaHRlbmAgbWFuaXB1bGF0ZXMgdGhlIGx1bWluYW5jZSBjaGFubmVsIGFuZCB0aGVyZWZvcmVcbiAqIGRvZXNuJ3QgcHJvZHVjZSBodWUgc2hpZnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHRpbnQoMC4yNSwgJyMwMGYnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3RpbnQoMC4yNSwgJyMwMGYnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNiZmJmZmZcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiB0aW50KHBlcmNlbnRhZ2UsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gY3VycmllZE1peChwYXJzZUZsb2F0KHBlcmNlbnRhZ2UpLCAncmdiKDI1NSwgMjU1LCAyNTUpJywgY29sb3IpO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG52YXIgY3VycmllZFRpbnQgPVxuLyojX19QVVJFX18qL1xuY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4odGludCk7XG5cbi8qKlxuICogRGVjcmVhc2VzIHRoZSBvcGFjaXR5IG9mIGEgY29sb3IuIEl0cyByYW5nZSBmb3IgdGhlIGFtb3VudCBpcyBiZXR3ZWVuIDAgdG8gMS5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnRpemUoMC4xLCAnI2ZmZicpO1xuICogICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudGl6ZSgwLjIsICdoc2woMCwgMCUsIDEwMCUpJyksXG4gKiAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50aXplKCcwLjUnLCAncmdiYSgyNTUsIDAsIDAsIDAuOCknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHt0cmFuc3BhcmVudGl6ZSgwLjEsICcjZmZmJyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3RyYW5zcGFyZW50aXplKDAuMiwgJ2hzbCgwLCAwJSwgMTAwJSknKX0sXG4gKiAgIGJhY2tncm91bmQ6ICR7dHJhbnNwYXJlbnRpemUoJzAuNScsICdyZ2JhKDI1NSwgMCwgMCwgMC44KScpfSxcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjkpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjgpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMCwwLDAuMylcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc3BhcmVudGl6ZShhbW91bnQsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgcGFyc2VkQ29sb3IgPSBwYXJzZVRvUmdiKGNvbG9yKTtcbiAgdmFyIGFscGhhID0gdHlwZW9mIHBhcnNlZENvbG9yLmFscGhhID09PSAnbnVtYmVyJyA/IHBhcnNlZENvbG9yLmFscGhhIDogMTtcblxuICB2YXIgY29sb3JXaXRoQWxwaGEgPSBfZXh0ZW5kcyh7fSwgcGFyc2VkQ29sb3IsIHtcbiAgICBhbHBoYTogZ3VhcmQoMCwgMSwgKGFscGhhICogMTAwIC0gcGFyc2VGbG9hdChhbW91bnQpICogMTAwKSAvIDEwMClcbiAgfSk7XG5cbiAgcmV0dXJuIHJnYmEoY29sb3JXaXRoQWxwaGEpO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG52YXIgY3VycmllZFRyYW5zcGFyZW50aXplID1cbi8qI19fUFVSRV9fKi9cbmN1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKHRyYW5zcGFyZW50aXplKTtcblxuLyoqXG4gKiBTaG9ydGhhbmQgZm9yIGVhc2lseSBzZXR0aW5nIHRoZSBhbmltYXRpb24gcHJvcGVydHkuIEFsbG93cyBlaXRoZXIgbXVsdGlwbGUgYXJyYXlzIHdpdGggYW5pbWF0aW9uc1xuICogb3IgYSBzaW5nbGUgYW5pbWF0aW9uIHNwcmVhZCBvdmVyIHRoZSBhcmd1bWVudHMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5hbmltYXRpb24oWydyb3RhdGUnLCAnMXMnLCAnZWFzZS1pbi1vdXQnXSwgWydjb2xvcmNoYW5nZScsICcycyddKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2FuaW1hdGlvbihbJ3JvdGF0ZScsICcxcycsICdlYXNlLWluLW91dCddLCBbJ2NvbG9yY2hhbmdlJywgJzJzJ10pfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYW5pbWF0aW9uJzogJ3JvdGF0ZSAxcyBlYXNlLWluLW91dCwgY29sb3JjaGFuZ2UgMnMnXG4gKiB9XG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5hbmltYXRpb24oJ3JvdGF0ZScsICcxcycsICdlYXNlLWluLW91dCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7YW5pbWF0aW9uKCdyb3RhdGUnLCAnMXMnLCAnZWFzZS1pbi1vdXQnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2FuaW1hdGlvbic6ICdyb3RhdGUgMXMgZWFzZS1pbi1vdXQnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGlvbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIC8vIEFsbG93IHNpbmdsZSBvciBtdWx0aXBsZSBhbmltYXRpb25zIHBhc3NlZFxuICB2YXIgbXVsdGlNb2RlID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKTtcblxuICBpZiAoIW11bHRpTW9kZSAmJiBhcmdzLmxlbmd0aCA+IDgpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2NCk7XG4gIH1cblxuICB2YXIgY29kZSA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAobXVsdGlNb2RlICYmICFBcnJheS5pc0FycmF5KGFyZykgfHwgIW11bHRpTW9kZSAmJiBBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDY1KTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGggPiA4KSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2Nik7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZy5qb2luKCcgJykgOiBhcmc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIHJldHVybiB7XG4gICAgYW5pbWF0aW9uOiBjb2RlXG4gIH07XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyBhbnkgbnVtYmVyIG9mIGJhY2tncm91bmRJbWFnZSB2YWx1ZXMgYXMgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBzaW5nbGUgYmFja2dyb3VuZCBzdGF0ZW1lbnQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5iYWNrZ3JvdW5kSW1hZ2VzKCd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiknLCAnbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtiYWNrZ3JvdW5kSW1hZ2VzKCd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiknLCAnbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAndXJsKFwiL2ltYWdlL2JhY2tncm91bmQuanBnXCIpLCBsaW5lYXItZ3JhZGllbnQocmVkLCBncmVlbiknXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGJhY2tncm91bmRJbWFnZXMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wZXJ0aWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHByb3BlcnRpZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRJbWFnZTogcHJvcGVydGllcy5qb2luKCcsICcpXG4gIH07XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyBhbnkgbnVtYmVyIG9mIGJhY2tncm91bmQgdmFsdWVzIGFzIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIGEgc2luZ2xlIGJhY2tncm91bmQgc3RhdGVtZW50LlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYmFja2dyb3VuZHMoJ3VybChcIi9pbWFnZS9iYWNrZ3JvdW5kLmpwZ1wiKScsICdsaW5lYXItZ3JhZGllbnQocmVkLCBncmVlbiknLCAnY2VudGVyIG5vLXJlcGVhdCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7YmFja2dyb3VuZHMoJ3VybChcIi9pbWFnZS9iYWNrZ3JvdW5kLmpwZ1wiKScsICdsaW5lYXItZ3JhZGllbnQocmVkLCBncmVlbiknLCAnY2VudGVyIG5vLXJlcGVhdCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYmFja2dyb3VuZCc6ICd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiksIGxpbmVhci1ncmFkaWVudChyZWQsIGdyZWVuKSwgY2VudGVyIG5vLXJlcGVhdCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYmFja2dyb3VuZHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wZXJ0aWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHByb3BlcnRpZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmQ6IHByb3BlcnRpZXMuam9pbignLCAnKVxuICB9O1xufVxuXG52YXIgc2lkZU1hcCA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG4vKipcbiAqIFNob3J0aGFuZCBmb3IgdGhlIGJvcmRlciBwcm9wZXJ0eSB0aGF0IHNwbGl0cyBvdXQgaW5kaXZpZHVhbCBwcm9wZXJ0aWVzIGZvciB1c2Ugd2l0aCB0b29scyBsaWtlIEZlbGEgYW5kIFN0eWxldHJvbi4gQSBzaWRlIGtleXdvcmQgY2FuIG9wdGlvbmFsbHkgYmUgcGFzc2VkIHRvIHRhcmdldCBvbmx5IG9uZSBzaWRlJ3MgYm9yZGVyIHByb3BlcnRpZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYm9yZGVyKCcxcHgnLCAnc29saWQnLCAncmVkJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXIoJzFweCcsICdzb2xpZCcsICdyZWQnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JvcmRlckNvbG9yJzogJ3JlZCcsXG4gKiAgICdib3JkZXJTdHlsZSc6ICdzb2xpZCcsXG4gKiAgICdib3JkZXJXaWR0aCc6IGAxcHhgLFxuICogfVxuICpcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYm9yZGVyKCd0b3AnLCAnMXB4JywgJ3NvbGlkJywgJ3JlZCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Ym9yZGVyKCd0b3AnLCAnMXB4JywgJ3NvbGlkJywgJ3JlZCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wQ29sb3InOiAncmVkJyxcbiAqICAgJ2JvcmRlclRvcFN0eWxlJzogJ3NvbGlkJyxcbiAqICAgJ2JvcmRlclRvcFdpZHRoJzogYDFweGAsXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gYm9yZGVyKHNpZGVLZXl3b3JkKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAodHlwZW9mIHNpZGVLZXl3b3JkID09PSAnc3RyaW5nJyAmJiBzaWRlTWFwLmluZGV4T2Yoc2lkZUtleXdvcmQpID49IDApIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbXCJib3JkZXJcIiArIGNhcGl0YWxpemVTdHJpbmcoc2lkZUtleXdvcmQpICsgXCJXaWR0aFwiXSA9IHZhbHVlc1swXSwgX3JlZltcImJvcmRlclwiICsgY2FwaXRhbGl6ZVN0cmluZyhzaWRlS2V5d29yZCkgKyBcIlN0eWxlXCJdID0gdmFsdWVzWzFdLCBfcmVmW1wiYm9yZGVyXCIgKyBjYXBpdGFsaXplU3RyaW5nKHNpZGVLZXl3b3JkKSArIFwiQ29sb3JcIl0gPSB2YWx1ZXNbMl0sIF9yZWY7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVzLnVuc2hpZnQoc2lkZUtleXdvcmQpO1xuICAgIHJldHVybiB7XG4gICAgICBib3JkZXJXaWR0aDogdmFsdWVzWzBdLFxuICAgICAgYm9yZGVyU3R5bGU6IHZhbHVlc1sxXSxcbiAgICAgIGJvcmRlckNvbG9yOiB2YWx1ZXNbMl1cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyBhIHZhbHVlIGZvciBzaWRlIGFuZCBhIHZhbHVlIGZvciByYWRpdXMgYW5kIGFwcGxpZXMgdGhlIHJhZGl1cyB2YWx1ZSB0byBib3RoIGNvcm5lcnMgb2YgdGhlIHNpZGUuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXJSYWRpdXMoJ3RvcCcsICc1cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JvcmRlclJhZGl1cygndG9wJywgJzVweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wUmlnaHRSYWRpdXMnOiAnNXB4JyxcbiAqICAgJ2JvcmRlclRvcExlZnRSYWRpdXMnOiAnNXB4JyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYm9yZGVyUmFkaXVzKHNpZGUsIHJhZGl1cykge1xuICB2YXIgdXBwZXJjYXNlU2lkZSA9IGNhcGl0YWxpemVTdHJpbmcoc2lkZSk7XG5cbiAgaWYgKCFyYWRpdXMgJiYgcmFkaXVzICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjIpO1xuICB9XG5cbiAgaWYgKHVwcGVyY2FzZVNpZGUgPT09ICdUb3AnIHx8IHVwcGVyY2FzZVNpZGUgPT09ICdCb3R0b20nKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW1wiYm9yZGVyXCIgKyB1cHBlcmNhc2VTaWRlICsgXCJSaWdodFJhZGl1c1wiXSA9IHJhZGl1cywgX3JlZltcImJvcmRlclwiICsgdXBwZXJjYXNlU2lkZSArIFwiTGVmdFJhZGl1c1wiXSA9IHJhZGl1cywgX3JlZjtcbiAgfVxuXG4gIGlmICh1cHBlcmNhc2VTaWRlID09PSAnTGVmdCcgfHwgdXBwZXJjYXNlU2lkZSA9PT0gJ1JpZ2h0Jykge1xuICAgIHZhciBfcmVmMjtcblxuICAgIHJldHVybiBfcmVmMiA9IHt9LCBfcmVmMltcImJvcmRlclRvcFwiICsgdXBwZXJjYXNlU2lkZSArIFwiUmFkaXVzXCJdID0gcmFkaXVzLCBfcmVmMltcImJvcmRlckJvdHRvbVwiICsgdXBwZXJjYXNlU2lkZSArIFwiUmFkaXVzXCJdID0gcmFkaXVzLCBfcmVmMjtcbiAgfVxuXG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDYzKTtcbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYm9yZGVyU3R5bGUoJ3NvbGlkJywgJ2Rhc2hlZCcsICdkb3R0ZWQnLCAnZG91YmxlJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXJTdHlsZSgnc29saWQnLCAnZGFzaGVkJywgJ2RvdHRlZCcsICdkb3VibGUnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JvcmRlclRvcFN0eWxlJzogJ3NvbGlkJyxcbiAqICAgJ2JvcmRlclJpZ2h0U3R5bGUnOiAnZGFzaGVkJyxcbiAqICAgJ2JvcmRlckJvdHRvbVN0eWxlJzogJ2RvdHRlZCcsXG4gKiAgICdib3JkZXJMZWZ0U3R5bGUnOiAnZG91YmxlJ1xuICogfVxuICovXG5mdW5jdGlvbiBib3JkZXJTdHlsZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnYm9yZGVyU3R5bGUnXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIHZhbHVlcywgaW5jbHVkaW5nIG51bGwgdG8gc2tpcCBhIHZhbHVlLCBhbmQgbWFwcyB0aGVtIHRvIHRoZWlyIHJlc3BlY3RpdmUgZGlyZWN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmJvcmRlcldpZHRoKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXJXaWR0aCgnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wV2lkdGgnOiAnMTJweCcsXG4gKiAgICdib3JkZXJSaWdodFdpZHRoJzogJzI0cHgnLFxuICogICAnYm9yZGVyQm90dG9tV2lkdGgnOiAnMzZweCcsXG4gKiAgICdib3JkZXJMZWZ0V2lkdGgnOiAnNDhweCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYm9yZGVyV2lkdGgoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodm9pZCAwLCBbJ2JvcmRlcldpZHRoJ10uY29uY2F0KHZhbHVlcykpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNlbGVjdG9ycyh0ZW1wbGF0ZSwgc3RhdGUpIHtcbiAgdmFyIHN0YXRlU3VmZml4ID0gc3RhdGUgPyBcIjpcIiArIHN0YXRlIDogJyc7XG4gIHJldHVybiB0ZW1wbGF0ZShzdGF0ZVN1ZmZpeCk7XG59XG4vKipcbiAqIEZ1bmN0aW9uIGhlbHBlciB0aGF0IGFkZHMgYW4gYXJyYXkgb2Ygc3RhdGVzIHRvIGEgdGVtcGxhdGUgb2Ygc2VsZWN0b3JzLiBVc2VkIGluIHRleHRJbnB1dHMgYW5kIGJ1dHRvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc3RhdGVmdWxTZWxlY3RvcnMoc3RhdGVzLCB0ZW1wbGF0ZSwgc3RhdGVNYXApIHtcbiAgaWYgKCF0ZW1wbGF0ZSkgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjcpO1xuICBpZiAoc3RhdGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGdlbmVyYXRlU2VsZWN0b3JzKHRlbXBsYXRlLCBudWxsKTtcbiAgdmFyIHNlbGVjdG9ycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHN0YXRlTWFwICYmIHN0YXRlTWFwLmluZGV4T2Yoc3RhdGVzW2ldKSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDY4KTtcbiAgICB9XG5cbiAgICBzZWxlY3RvcnMucHVzaChnZW5lcmF0ZVNlbGVjdG9ycyh0ZW1wbGF0ZSwgc3RhdGVzW2ldKSk7XG4gIH1cblxuICBzZWxlY3RvcnMgPSBzZWxlY3RvcnMuam9pbignLCcpO1xuICByZXR1cm4gc2VsZWN0b3JzO1xufVxuXG52YXIgc3RhdGVNYXAgPSBbdW5kZWZpbmVkLCBudWxsLCAnYWN0aXZlJywgJ2ZvY3VzJywgJ2hvdmVyJ107XG5cbmZ1bmN0aW9uIHRlbXBsYXRlKHN0YXRlKSB7XG4gIHJldHVybiBcImJ1dHRvblwiICsgc3RhdGUgKyBcIixcXG4gIGlucHV0W3R5cGU9XFxcImJ1dHRvblxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgaW5wdXRbdHlwZT1cXFwicmVzZXRcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gIGlucHV0W3R5cGU9XFxcInN1Ym1pdFxcXCJdXCIgKyBzdGF0ZTtcbn1cbi8qKlxuICogUG9wdWxhdGVzIHNlbGVjdG9ycyB0aGF0IHRhcmdldCBhbGwgYnV0dG9ucy4gWW91IGNhbiBwYXNzIG9wdGlvbmFsIHN0YXRlcyB0byBhcHBlbmQgdG8gdGhlIHNlbGVjdG9ycy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIFtidXR0b25zKCdhY3RpdmUnKV06IHtcbiAqICAgICAnYm9yZGVyJzogJ25vbmUnXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgPiAke2J1dHRvbnMoJ2FjdGl2ZScpfSB7XG4gKiAgICAgYm9yZGVyOiBub25lO1xuICogICB9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqICAnYnV0dG9uOmFjdGl2ZSxcbiAqICAnaW5wdXRbdHlwZT1cImJ1dHRvblwiXTphY3RpdmUsXG4gKiAgJ2lucHV0W3R5cGU9XFxcInJlc2V0XFxcIl06YWN0aXZlLFxuICogICdpbnB1dFt0eXBlPVxcXCJzdWJtaXRcXFwiXTphY3RpdmU6IHtcbiAqICAgJ2JvcmRlcic6ICdub25lJ1xuICogfVxuICovXG5cblxuZnVuY3Rpb24gYnV0dG9ucygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0YXRlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdGF0ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gc3RhdGVmdWxTZWxlY3RvcnMoc3RhdGVzLCB0ZW1wbGF0ZSwgc3RhdGVNYXApO1xufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgdXAgdG8gZm91ciB2YWx1ZXMsIGluY2x1ZGluZyBudWxsIHRvIHNraXAgYSB2YWx1ZSwgYW5kIG1hcHMgdGhlbSB0byB0aGVpciByZXNwZWN0aXZlIGRpcmVjdGlvbnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5tYXJnaW4oJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke21hcmdpbignMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnbWFyZ2luVG9wJzogJzEycHgnLFxuICogICAnbWFyZ2luUmlnaHQnOiAnMjRweCcsXG4gKiAgICdtYXJnaW5Cb3R0b20nOiAnMzZweCcsXG4gKiAgICdtYXJnaW5MZWZ0JzogJzQ4cHgnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIG1hcmdpbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnbWFyZ2luJ10uY29uY2F0KHZhbHVlcykpO1xufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgdXAgdG8gZm91ciB2YWx1ZXMsIGluY2x1ZGluZyBudWxsIHRvIHNraXAgYSB2YWx1ZSwgYW5kIG1hcHMgdGhlbSB0byB0aGVpciByZXNwZWN0aXZlIGRpcmVjdGlvbnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5wYWRkaW5nKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtwYWRkaW5nKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdwYWRkaW5nVG9wJzogJzEycHgnLFxuICogICAncGFkZGluZ1JpZ2h0JzogJzI0cHgnLFxuICogICAncGFkZGluZ0JvdHRvbSc6ICczNnB4JyxcbiAqICAgJ3BhZGRpbmdMZWZ0JzogJzQ4cHgnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHBhZGRpbmcoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodm9pZCAwLCBbJ3BhZGRpbmcnXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbnZhciBwb3NpdGlvbk1hcCQxID0gWydhYnNvbHV0ZScsICdmaXhlZCcsICdyZWxhdGl2ZScsICdzdGF0aWMnLCAnc3RpY2t5J107XG4vKipcbiAqIFNob3J0aGFuZCBhY2NlcHRzIHVwIHRvIGZpdmUgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLiBUaGUgZmlyc3QgdmFsdWUgY2FuIG9wdGlvbmFsbHkgYmUgYSBwb3NpdGlvbiBrZXl3b3JkLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ucG9zaXRpb24oJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3Bvc2l0aW9uKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICd0b3AnOiAnMTJweCcsXG4gKiAgICdyaWdodCc6ICcyNHB4JyxcbiAqICAgJ2JvdHRvbSc6ICczNnB4JyxcbiAqICAgJ2xlZnQnOiAnNDhweCdcbiAqIH1cbiAqXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnBvc2l0aW9uKCdhYnNvbHV0ZScsICcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtwb3NpdGlvbignYWJzb2x1dGUnLCAnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxuICogICAndG9wJzogJzEycHgnLFxuICogICAncmlnaHQnOiAnMjRweCcsXG4gKiAgICdib3R0b20nOiAnMzZweCcsXG4gKiAgICdsZWZ0JzogJzQ4cHgnXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gcG9zaXRpb24ocG9zaXRpb25LZXl3b3JkKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAocG9zaXRpb25NYXAkMS5pbmRleE9mKHBvc2l0aW9uS2V5d29yZCkgPj0gMCkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBwb3NpdGlvbjogcG9zaXRpb25LZXl3b3JkXG4gICAgfSwgZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnJ10uY29uY2F0KHZhbHVlcykpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmlyc3RWYWx1ZSA9IHBvc2l0aW9uS2V5d29yZDsgLy8gaW4gdGhpcyBjYXNlIHBvc2l0aW9uIGlzIGFjdHVhbGx5IHRoZSBmaXJzdCB2YWx1ZVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodm9pZCAwLCBbJycsIGZpcnN0VmFsdWVdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0byBzZXQgdGhlIGhlaWdodCBhbmQgd2lkdGggcHJvcGVydGllcyBpbiBhIHNpbmdsZSBzdGF0ZW1lbnQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5zaXplKCczMDBweCcsICcyNTBweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7c2l6ZSgnMzAwcHgnLCAnMjUwcHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2hlaWdodCc6ICczMDBweCcsXG4gKiAgICd3aWR0aCc6ICcyNTBweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHNpemUoaGVpZ2h0LCB3aWR0aCkge1xuICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xuICAgIHdpZHRoID0gaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB3aWR0aDogd2lkdGhcbiAgfTtcbn1cblxudmFyIHN0YXRlTWFwJDEgPSBbdW5kZWZpbmVkLCBudWxsLCAnYWN0aXZlJywgJ2ZvY3VzJywgJ2hvdmVyJ107XG5cbmZ1bmN0aW9uIHRlbXBsYXRlJDEoc3RhdGUpIHtcbiAgcmV0dXJuIFwiaW5wdXRbdHlwZT1cXFwiY29sb3JcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwiZGF0ZVxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJkYXRldGltZVxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJkYXRldGltZS1sb2NhbFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJlbWFpbFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJtb250aFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJudW1iZXJcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwicGFzc3dvcmRcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwic2VhcmNoXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcInRlbFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcInRpbWVcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwidXJsXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcIndlZWtcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXQ6bm90KFt0eXBlXSlcIiArIHN0YXRlICsgXCIsXFxuICAgIHRleHRhcmVhXCIgKyBzdGF0ZTtcbn1cbi8qKlxuICogUG9wdWxhdGVzIHNlbGVjdG9ycyB0aGF0IHRhcmdldCBhbGwgdGV4dCBpbnB1dHMuIFlvdSBjYW4gcGFzcyBvcHRpb25hbCBzdGF0ZXMgdG8gYXBwZW5kIHRvIHRoZSBzZWxlY3RvcnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBbdGV4dElucHV0cygnYWN0aXZlJyldOiB7XG4gKiAgICAgJ2JvcmRlcic6ICdub25lJ1xuICogICB9XG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgID4gJHt0ZXh0SW5wdXRzKCdhY3RpdmUnKX0ge1xuICogICAgIGJvcmRlcjogbm9uZTtcbiAqICAgfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiAgJ2lucHV0W3R5cGU9XCJjb2xvclwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cImRhdGVcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJkYXRldGltZVwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cImRhdGV0aW1lLWxvY2FsXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwiZW1haWxcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJtb250aFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cIm51bWJlclwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cInBhc3N3b3JkXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwic2VhcmNoXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwidGVsXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwidGV4dFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cInRpbWVcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJ1cmxcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJ3ZWVrXCJdOmFjdGl2ZSxcbiAqICBpbnB1dDpub3QoW3R5cGVdKTphY3RpdmUsXG4gKiAgdGV4dGFyZWE6YWN0aXZlJzoge1xuICogICAnYm9yZGVyJzogJ25vbmUnXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiB0ZXh0SW5wdXRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RhdGVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0YXRlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZWZ1bFNlbGVjdG9ycyhzdGF0ZXMsIHRlbXBsYXRlJDEsIHN0YXRlTWFwJDEpO1xufVxuXG4vKipcbiAqIEFjY2VwdHMgYW55IG51bWJlciBvZiB0cmFuc2l0aW9uIHZhbHVlcyBhcyBwYXJhbWV0ZXJzIGZvciBjcmVhdGluZyBhIHNpbmdsZSB0cmFuc2l0aW9uIHN0YXRlbWVudC4gWW91IG1heSBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgcHJvcGVydGllcyBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHRoYXQgeW91IHdvdWxkIGxpa2UgdG8gYXBwbHkgdGhlIHNhbWUgdHJhbmlzaXRpb24gdmFsdWVzIHRvIChzZWNvbmQgcGFyYW1ldGVyKS5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnRyYW5zaXRpb25zKCdvcGFjaXR5IDEuMHMgZWFzZS1pbiAwcycsICd3aWR0aCAyLjBzIGVhc2UtaW4gMnMnKSxcbiAqICAgLi4udHJhbnNpdGlvbnMoWydjb2xvcicsICdiYWNrZ3JvdW5kLWNvbG9yJ10sICcyLjBzIGVhc2UtaW4gMnMnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3RyYW5zaXRpb25zKCdvcGFjaXR5IDEuMHMgZWFzZS1pbiAwcycsICd3aWR0aCAyLjBzIGVhc2UtaW4gMnMnKX07XG4gKiAgICR7dHJhbnNpdGlvbnMoWydjb2xvcicsICdiYWNrZ3JvdW5kLWNvbG9yJ10sICcyLjBzIGVhc2UtaW4gMnMnKSx9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAndHJhbnNpdGlvbic6ICdvcGFjaXR5IDEuMHMgZWFzZS1pbiAwcywgd2lkdGggMi4wcyBlYXNlLWluIDJzJ1xuICogICAndHJhbnNpdGlvbic6ICdjb2xvciAyLjBzIGVhc2UtaW4gMnMsIGJhY2tncm91bmQtY29sb3IgMi4wcyBlYXNlLWluIDJzJyxcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2l0aW9ucygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHByb3BlcnRpZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcHJvcGVydGllc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnRpZXNbMF0pICYmIHByb3BlcnRpZXMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvcGVydGllc1sxXTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2MSk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb25zU3RyaW5nID0gcHJvcGVydGllc1swXS5tYXAoZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gcHJvcGVydHkgKyBcIiBcIiArIHZhbHVlO1xuICAgIH0pLmpvaW4oJywgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25zU3RyaW5nXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNpdGlvbjogcHJvcGVydGllcy5qb2luKCcsICcpXG4gICAgfTtcbiAgfVxufVxuXG4vLyBNYXRoXG5cbmV4cG9ydCB7IGN1cnJpZWRBZGp1c3RIdWUgYXMgYWRqdXN0SHVlLCBhbmltYXRpb24sIGJhY2tncm91bmRJbWFnZXMsIGJhY2tncm91bmRzLCBiZXR3ZWVuLCBib3JkZXIsIGJvcmRlckNvbG9yLCBib3JkZXJSYWRpdXMsIGJvcmRlclN0eWxlLCBib3JkZXJXaWR0aCwgYnV0dG9ucywgY2xlYXJGaXgsIGNvbXBsZW1lbnQsIGNvdmVyLCBjdXJyaWVkRGFya2VuIGFzIGRhcmtlbiwgY3VycmllZERlc2F0dXJhdGUgYXMgZGVzYXR1cmF0ZSwgZGlyZWN0aW9uYWxQcm9wZXJ0eSwgZWxsaXBzaXMsIGVtLCBmbHVpZFJhbmdlLCBmb250RmFjZSwgZ2V0THVtaW5hbmNlLCBnZXRWYWx1ZUFuZFVuaXQsIGdyYXlzY2FsZSwgaW52ZXJ0LCBoaWRlVGV4dCwgaGlkZVZpc3VhbGx5LCBoaURQSSwgaHNsLCBoc2xhLCBoc2xUb0NvbG9yU3RyaW5nLCBjdXJyaWVkTGlnaHRlbiBhcyBsaWdodGVuLCBsaW5lYXJHcmFkaWVudCwgbWFyZ2luLCBtYXRoLCBjdXJyaWVkTWl4IGFzIG1peCwgbW9kdWxhclNjYWxlLCBub3JtYWxpemUsIGN1cnJpZWRPcGFjaWZ5IGFzIG9wYWNpZnksIHBhZGRpbmcsIHBhcnNlVG9Ic2wsIHBhcnNlVG9SZ2IsIHBvc2l0aW9uLCByYWRpYWxHcmFkaWVudCwgcmVhZGFibGVDb2xvciwgcmVtLCByZXRpbmFJbWFnZSwgcmdiLCByZ2JhLCByZ2JUb0NvbG9yU3RyaW5nLCBjdXJyaWVkU2F0dXJhdGUgYXMgc2F0dXJhdGUsIGN1cnJpZWRTZXRIdWUgYXMgc2V0SHVlLCBjdXJyaWVkU2V0TGlnaHRuZXNzIGFzIHNldExpZ2h0bmVzcywgY3VycmllZFNldFNhdHVyYXRpb24gYXMgc2V0U2F0dXJhdGlvbiwgY3VycmllZFNoYWRlIGFzIHNoYWRlLCBzaXplLCBzdHJpcFVuaXQsIHRleHRJbnB1dHMsIHRpbWluZ0Z1bmN0aW9ucywgY3VycmllZFRpbnQgYXMgdGludCwgdG9Db2xvclN0cmluZywgdHJhbnNpdGlvbnMsIGN1cnJpZWRUcmFuc3BhcmVudGl6ZSBhcyB0cmFuc3BhcmVudGl6ZSwgdHJpYW5nbGUsIHdvcmRXcmFwIH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiX2luaGVyaXRzTG9vc2UiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlIiwibGFzdCIsIl9yZWYiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJuZWdhdGlvbiIsImEiLCJhZGRpdGlvbiIsImIiLCJzdWJ0cmFjdGlvbiIsIm11bHRpcGxpY2F0aW9uIiwiZGl2aXNpb24iLCJmYWN0b3JpYWwiLCJOYU4iLCJJbmZpbml0eSIsInBvd2VyIiwiTWF0aCIsInBvdyIsInNxcnQiLCJtYXgiLCJhcHBseSIsIm1pbiIsImNvbW1hIiwiQXJyYXkiLCJvZiIsImRlZmF1bHRNYXRoU3ltYm9scyIsInN5bWJvbHMiLCJwb3N0Zml4Iiwic3ltYm9sIiwiZiIsIm5vdGF0aW9uIiwicHJlY2VkZW5jZSIsInJpZ2h0VG9MZWZ0IiwiYXJnQ291bnQiLCJyZWdTeW1ib2wiLCJpbmZpeCIsInByZWZpeCIsImZ1bmMiLCJFUlJPUlMiLCJmb3JtYXQiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJjIiwicHVzaCIsImZvckVhY2giLCJkIiwicmVwbGFjZSIsIlBvbGlzaGVkRXJyb3IiLCJfRXJyb3IiLCJjb2RlIiwiX3RoaXMiLCJwcm9jZXNzIiwiY2FsbCIsIl9sZW4yIiwiX2tleTIiLCJjb25jYXQiLCJFcnJvciIsInVuaXRSZWdFeHAiLCJtZXJnZVN5bWJvbE1hcHMiLCJhZGRpdGlvbmFsU3ltYm9scyIsInN5bWJvbE1hcCIsImV4ZWMiLCJvcGVyYXRvcnMiLCJ2YWx1ZXMiLCJvcCIsInBvcCIsInNwbGljZSIsImNhbGN1bGF0ZSIsImV4cHJlc3Npb24iLCJtYXRjaCIsInBhdHRlcm4iLCJSZWdFeHAiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwia2V5Iiwic29ydCIsInZhbCIsImpvaW4iLCJsYXN0SW5kZXgiLCJhZnRlclZhbHVlIiwiX3JlZjIiLCJ0b2tlbiIsImJhZCIsIm5vdE51bWJlciIsIm5vdE5ld1ZhbHVlIiwibm90QWZ0ZXJWYWx1ZSIsImluZGV4IiwiY3VyciIsInByZXYiLCJyZXZlcnNlU3RyaW5nIiwic3RyIiwic3BsaXQiLCJyZXZlcnNlIiwibWF0aCIsImZvcm11bGEiLCJyZXZlcnNlZEZvcm11bGEiLCJmb3JtdWxhTWF0Y2giLCJldmVyeSIsInVuaXQiLCJjbGVhbkZvcm11bGEiLCJjYXBpdGFsaXplU3RyaW5nIiwic3RyaW5nIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsInBvc2l0aW9uTWFwIiwiZ2VuZXJhdGVQcm9wZXJ0eSIsInByb3BlcnR5IiwicG9zaXRpb24iLCJ0b0xvd2VyQ2FzZSIsInNwbGl0UHJvcGVydHkiLCJyZWR1Y2UiLCJhY2MiLCJqb2luZWRQcm9wZXJ0eSIsImdlbmVyYXRlU3R5bGVzIiwidmFsdWVzV2l0aERlZmF1bHRzIiwic3R5bGVzIiwiaSIsImRpcmVjdGlvbmFsUHJvcGVydHkiLCJmaXJzdFZhbHVlIiwiX3ZhbHVlcyQiLCJzZWNvbmRWYWx1ZSIsIl92YWx1ZXMkMiIsInRoaXJkVmFsdWUiLCJfdmFsdWVzJDMiLCJmb3VydGhWYWx1ZSIsImVuZHNXaXRoIiwic3VmZml4Iiwic3Vic3RyIiwiY3NzUmVnZXgiLCJzdHJpcFVuaXQiLCJ2YWx1ZSIsInVuaXRSZXR1cm4iLCJtYXRjaGVkVmFsdWUiLCJwYXJzZUZsb2F0IiwicHh0b0ZhY3RvcnkiLCJ0byIsInB4dmFsIiwiYmFzZSIsIm5ld1B4dmFsIiwibmV3QmFzZSIsImVtIiwiY3NzUmVnZXgkMSIsImdldFZhbHVlQW5kVW5pdCIsImNvbnNvbGUiLCJ3YXJuIiwicmF0aW9OYW1lcyIsIm1pbm9yU2Vjb25kIiwibWFqb3JTZWNvbmQiLCJtaW5vclRoaXJkIiwibWFqb3JUaGlyZCIsInBlcmZlY3RGb3VydGgiLCJhdWdGb3VydGgiLCJwZXJmZWN0RmlmdGgiLCJtaW5vclNpeHRoIiwiZ29sZGVuU2VjdGlvbiIsIm1ham9yU2l4dGgiLCJtaW5vclNldmVudGgiLCJtYWpvclNldmVudGgiLCJvY3RhdmUiLCJtYWpvclRlbnRoIiwibWFqb3JFbGV2ZW50aCIsIm1ham9yVHdlbGZ0aCIsImRvdWJsZU9jdGF2ZSIsImdldFJhdGlvIiwicmF0aW9OYW1lIiwibW9kdWxhclNjYWxlIiwic3RlcHMiLCJyYXRpbyIsInJlYWxCYXNlIiwicmVhbFJhdGlvIiwicmVtIiwiYmV0d2VlbiIsImZyb21TaXplIiwidG9TaXplIiwibWluU2NyZWVuIiwibWF4U2NyZWVuIiwiX3N0cmlwVW5pdCIsInVuaXRsZXNzRnJvbVNpemUiLCJmcm9tU2l6ZVVuaXQiLCJfc3RyaXBVbml0MiIsInVuaXRsZXNzVG9TaXplIiwidG9TaXplVW5pdCIsIl9zdHJpcFVuaXQzIiwidW5pdGxlc3NNaW5TY3JlZW4iLCJtaW5TY3JlZW5Vbml0IiwiX3N0cmlwVW5pdDQiLCJ1bml0bGVzc01heFNjcmVlbiIsIm1heFNjcmVlblVuaXQiLCJzbG9wZSIsInRvRml4ZWQiLCJjbGVhckZpeCIsInBhcmVudCIsInBzZXVkb1NlbGVjdG9yIiwiY2xlYXIiLCJjb250ZW50IiwiZGlzcGxheSIsImNvdmVyIiwib2Zmc2V0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiZWxsaXBzaXMiLCJ3aWR0aCIsIm1heFdpZHRoIiwib3ZlcmZsb3ciLCJ0ZXh0T3ZlcmZsb3ciLCJ3aGl0ZVNwYWNlIiwid29yZFdyYXAiLCJmbHVpZFJhbmdlIiwiY3NzUHJvcCIsImlzQXJyYXkiLCJtZWRpYVF1ZXJpZXMiLCJmYWxsYmFja3MiLCJfaXRlcmF0b3IiLCJfaXNBcnJheSIsIl9pIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfZXh0ZW5kczIiLCJfZXh0ZW5kczMiLCJuZXh0IiwiZG9uZSIsIm9iaiIsInByb3AiLCJfcmVmMyIsIl9yZWY0IiwiZ2VuZXJhdGVGaWxlUmVmZXJlbmNlcyIsImZvbnRGaWxlUGF0aCIsImZpbGVGb3JtYXRzIiwiZmlsZUZvbnRSZWZlcmVuY2VzIiwiZ2VuZXJhdGVMb2NhbFJlZmVyZW5jZXMiLCJsb2NhbEZvbnRzIiwibG9jYWxGb250UmVmZXJlbmNlcyIsImZvbnQiLCJnZW5lcmF0ZVNvdXJjZXMiLCJmb250UmVmZXJlbmNlcyIsImZvbnRGYWNlIiwiZm9udEZhbWlseSIsImZvbnRTdHJldGNoIiwiZm9udFN0eWxlIiwiZm9udFZhcmlhbnQiLCJmb250V2VpZ2h0IiwiX3JlZiRmaWxlRm9ybWF0cyIsInVuaWNvZGVSYW5nZSIsImZvbnREaXNwbGF5IiwiZm9udFZhcmlhdGlvblNldHRpbmdzIiwiZm9udEZlYXR1cmVTZXR0aW5ncyIsImZvbnRGYWNlRGVjbGFyYXRpb24iLCJzcmMiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJoaWRlVGV4dCIsInRleHRJbmRlbnQiLCJoaWRlVmlzdWFsbHkiLCJib3JkZXIiLCJjbGlwIiwiY2xpcFBhdGgiLCJoZWlnaHQiLCJtYXJnaW4iLCJwYWRkaW5nIiwiaGlEUEkiLCJyb3VuZCIsImNvbnN0cnVjdEdyYWRpZW50VmFsdWUiLCJsaXRlcmFscyIsInRlbXBsYXRlIiwic3Vic3RpdHV0aW9ucyIsImRlZmluZWRWYWx1ZXMiLCJmaWx0ZXIiLCJzdWJzdGl0dXRlIiwidHJpbSIsIl90ZW1wbGF0ZU9iamVjdCIsImRhdGEiLCJsaW5lYXJHcmFkaWVudCIsImNvbG9yU3RvcHMiLCJmYWxsYmFjayIsIl9yZWYkdG9EaXJlY3Rpb24iLCJ0b0RpcmVjdGlvbiIsImJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRJbWFnZSIsIm5vcm1hbGl6ZSIsImh0bWwiLCJsaW5lSGVpZ2h0IiwidGV4dFNpemVBZGp1c3QiLCJib2R5IiwiaDEiLCJmb250U2l6ZSIsImhyIiwiYm94U2l6aW5nIiwicHJlIiwiYm9yZGVyQm90dG9tIiwidGV4dERlY29yYXRpb24iLCJzbWFsbCIsInZlcnRpY2FsQWxpZ24iLCJzdWIiLCJzdXAiLCJpbWciLCJib3JkZXJTdHlsZSIsInRleHRUcmFuc2Zvcm0iLCJXZWJraXRBcHBlYXJhbmNlIiwib3V0bGluZSIsImZpZWxkc2V0IiwibGVnZW5kIiwiY29sb3IiLCJwcm9ncmVzcyIsInRleHRhcmVhIiwib3V0bGluZU9mZnNldCIsImRldGFpbHMiLCJzdW1tYXJ5IiwiX3RlbXBsYXRlT2JqZWN0JDEiLCJyYWRpYWxHcmFkaWVudCIsIl9yZWYkZXh0ZW50IiwiZXh0ZW50IiwiX3JlZiRwb3NpdGlvbiIsIl9yZWYkc2hhcGUiLCJzaGFwZSIsInJldGluYUltYWdlIiwiZmlsZW5hbWUiLCJiYWNrZ3JvdW5kU2l6ZSIsImV4dGVuc2lvbiIsInJldGluYUZpbGVuYW1lIiwicmV0aW5hU3VmZml4IiwiZXh0IiwickZpbGVuYW1lIiwiZnVuY3Rpb25zTWFwIiwiZWFzZUluQmFjayIsImVhc2VJbkNpcmMiLCJlYXNlSW5DdWJpYyIsImVhc2VJbkV4cG8iLCJlYXNlSW5RdWFkIiwiZWFzZUluUXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VJblNpbmUiLCJlYXNlT3V0QmFjayIsImVhc2VPdXRDdWJpYyIsImVhc2VPdXRDaXJjIiwiZWFzZU91dEV4cG8iLCJlYXNlT3V0UXVhZCIsImVhc2VPdXRRdWFydCIsImVhc2VPdXRRdWludCIsImVhc2VPdXRTaW5lIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJbk91dEV4cG8iLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJbk91dFNpbmUiLCJnZXRUaW1pbmdGdW5jdGlvbiIsImZ1bmN0aW9uTmFtZSIsInRpbWluZ0Z1bmN0aW9ucyIsInRpbWluZ0Z1bmN0aW9uIiwiYm9yZGVyQ29sb3IiLCJnZXRCb3JkZXJXaWR0aCIsInBvaW50aW5nRGlyZWN0aW9uIiwicmV2ZXJzZURpcmVjdGlvbiIsIk5VTUJFUl9BTkRfRkxPQVQiLCJ0cmlhbmdsZSIsImZvcmVncm91bmRDb2xvciIsIl9yZWYkYmFja2dyb3VuZENvbG9yIiwid2lkdGhBbmRVbml0IiwiU3RyaW5nIiwiaGVpZ2h0QW5kVW5pdCIsImlzTmFOIiwicmV2ZXJzZURpcmVjdGlvbkluZGV4IiwiaW5kZXhPZiIsImJvcmRlcldpZHRoIiwiZnJvbSIsIl8iLCJ3cmFwIiwid29yZEJyZWFrIiwib3ZlcmZsb3dXcmFwIiwiY29sb3JUb0ludCIsImNvbnZlcnRUb0ludCIsInJlZCIsImdyZWVuIiwiYmx1ZSIsImhzbFRvUmdiIiwiaHVlIiwic2F0dXJhdGlvbiIsImxpZ2h0bmVzcyIsImNvbnZlcnQiLCJodWVQcmltZSIsImNocm9tYSIsImFicyIsInNlY29uZENvbXBvbmVudCIsImxpZ2h0bmVzc01vZGlmaWNhdGlvbiIsImZpbmFsUmVkIiwiZmluYWxHcmVlbiIsImZpbmFsQmx1ZSIsIm5hbWVkQ29sb3JNYXAiLCJhbGljZWJsdWUiLCJhbnRpcXVld2hpdGUiLCJhcXVhIiwiYXF1YW1hcmluZSIsImF6dXJlIiwiYmVpZ2UiLCJiaXNxdWUiLCJibGFjayIsImJsYW5jaGVkYWxtb25kIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiY2FkZXRibHVlIiwiY2hhcnRyZXVzZSIsImNob2NvbGF0ZSIsImNvcmFsIiwiY29ybmZsb3dlcmJsdWUiLCJjb3Juc2lsayIsImNyaW1zb24iLCJjeWFuIiwiZGFya2JsdWUiLCJkYXJrY3lhbiIsImRhcmtnb2xkZW5yb2QiLCJkYXJrZ3JheSIsImRhcmtncmVlbiIsImRhcmtncmV5IiwiZGFya2toYWtpIiwiZGFya21hZ2VudGEiLCJkYXJrb2xpdmVncmVlbiIsImRhcmtvcmFuZ2UiLCJkYXJrb3JjaGlkIiwiZGFya3JlZCIsImRhcmtzYWxtb24iLCJkYXJrc2VhZ3JlZW4iLCJkYXJrc2xhdGVibHVlIiwiZGFya3NsYXRlZ3JheSIsImRhcmtzbGF0ZWdyZXkiLCJkYXJrdHVycXVvaXNlIiwiZGFya3Zpb2xldCIsImRlZXBwaW5rIiwiZGVlcHNreWJsdWUiLCJkaW1ncmF5IiwiZGltZ3JleSIsImRvZGdlcmJsdWUiLCJmaXJlYnJpY2siLCJmbG9yYWx3aGl0ZSIsImZvcmVzdGdyZWVuIiwiZnVjaHNpYSIsImdhaW5zYm9ybyIsImdob3N0d2hpdGUiLCJnb2xkIiwiZ29sZGVucm9kIiwiZ3JheSIsImdyZWVueWVsbG93IiwiZ3JleSIsImhvbmV5ZGV3IiwiaG90cGluayIsImluZGlhbnJlZCIsImluZGlnbyIsIml2b3J5Iiwia2hha2kiLCJsYXZlbmRlciIsImxhdmVuZGVyYmx1c2giLCJsYXduZ3JlZW4iLCJsZW1vbmNoaWZmb24iLCJsaWdodGJsdWUiLCJsaWdodGNvcmFsIiwibGlnaHRjeWFuIiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaWdodGdyYXkiLCJsaWdodGdyZWVuIiwibGlnaHRncmV5IiwibGlnaHRwaW5rIiwibGlnaHRzYWxtb24iLCJsaWdodHNlYWdyZWVuIiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlZ3JleSIsImxpZ2h0c3RlZWxibHVlIiwibGlnaHR5ZWxsb3ciLCJsaW1lIiwibGltZWdyZWVuIiwibGluZW4iLCJtYWdlbnRhIiwibWFyb29uIiwibWVkaXVtYXF1YW1hcmluZSIsIm1lZGl1bWJsdWUiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW1wdXJwbGUiLCJtZWRpdW1zZWFncmVlbiIsIm1lZGl1bXNsYXRlYmx1ZSIsIm1lZGl1bXNwcmluZ2dyZWVuIiwibWVkaXVtdHVycXVvaXNlIiwibWVkaXVtdmlvbGV0cmVkIiwibWlkbmlnaHRibHVlIiwibWludGNyZWFtIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJuYXZham93aGl0ZSIsIm5hdnkiLCJvbGRsYWNlIiwib2xpdmUiLCJvbGl2ZWRyYWIiLCJvcmFuZ2UiLCJvcmFuZ2VyZWQiLCJvcmNoaWQiLCJwYWxlZ29sZGVucm9kIiwicGFsZWdyZWVuIiwicGFsZXR1cnF1b2lzZSIsInBhbGV2aW9sZXRyZWQiLCJwYXBheWF3aGlwIiwicGVhY2hwdWZmIiwicGVydSIsInBpbmsiLCJwbHVtIiwicG93ZGVyYmx1ZSIsInB1cnBsZSIsInJlYmVjY2FwdXJwbGUiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRhbiIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsIm5hbWVUb0hleCIsIm5vcm1hbGl6ZWRDb2xvck5hbWUiLCJoZXhSZWdleCIsImhleFJnYmFSZWdleCIsInJlZHVjZWRIZXhSZWdleCIsInJlZHVjZWRSZ2JhSGV4UmVnZXgiLCJyZ2JSZWdleCIsInJnYmFSZWdleCIsImhzbFJlZ2V4IiwiaHNsYVJlZ2V4IiwicGFyc2VUb1JnYiIsIm5vcm1hbGl6ZWRDb2xvciIsInBhcnNlSW50IiwiYWxwaGEiLCJfYWxwaGEiLCJyZ2JNYXRjaGVkIiwicmdiYU1hdGNoZWQiLCJoc2xNYXRjaGVkIiwicmdiQ29sb3JTdHJpbmciLCJoc2xSZ2JNYXRjaGVkIiwiaHNsYU1hdGNoZWQiLCJfaHVlIiwiX3NhdHVyYXRpb24iLCJfbGlnaHRuZXNzIiwiX3JnYkNvbG9yU3RyaW5nIiwiX2hzbFJnYk1hdGNoZWQiLCJyZ2JUb0hzbCIsImRlbHRhIiwicGFyc2VUb0hzbCIsInJlZHVjZUhleFZhbHVlIiwibnVtYmVyVG9IZXgiLCJoZXgiLCJ0b1N0cmluZyIsImNvbG9yVG9IZXgiLCJjb252ZXJ0VG9IZXgiLCJoc2xUb0hleCIsImhzbCIsImhzbGEiLCJyZ2IiLCJyZ2JhIiwicmdiVmFsdWUiLCJpc1JnYiIsImlzUmdiYSIsImlzSHNsIiwiaXNIc2xhIiwidG9Db2xvclN0cmluZyIsImN1cnJpZWQiLCJmbiIsImNvbWJpbmVkIiwicHJvdG90eXBlIiwiY3VycnkiLCJhZGp1c3RIdWUiLCJkZWdyZWUiLCJoc2xDb2xvciIsImN1cnJpZWRBZGp1c3RIdWUiLCJjb21wbGVtZW50IiwiZ3VhcmQiLCJsb3dlckJvdW5kYXJ5IiwidXBwZXJCb3VuZGFyeSIsImRhcmtlbiIsImFtb3VudCIsImN1cnJpZWREYXJrZW4iLCJkZXNhdHVyYXRlIiwiY3VycmllZERlc2F0dXJhdGUiLCJnZXRMdW1pbmFuY2UiLCJyZ2JDb2xvciIsIl9PYmplY3Qka2V5cyRtYXAiLCJjaGFubmVsIiwiciIsImciLCJncmF5c2NhbGUiLCJoc2xUb0NvbG9yU3RyaW5nIiwiaW52ZXJ0IiwibGlnaHRlbiIsImN1cnJpZWRMaWdodGVuIiwibWl4Iiwid2VpZ2h0Iiwib3RoZXJDb2xvciIsInBhcnNlZENvbG9yMSIsImNvbG9yMSIsInBhcnNlZENvbG9yMiIsImNvbG9yMiIsImFscGhhRGVsdGEiLCJ4IiwieSIsInoiLCJ3ZWlnaHQxIiwid2VpZ2h0MiIsIm1peGVkQ29sb3IiLCJmbG9vciIsImN1cnJpZWRNaXgiLCJvcGFjaWZ5IiwicGFyc2VkQ29sb3IiLCJjb2xvcldpdGhBbHBoYSIsImN1cnJpZWRPcGFjaWZ5IiwicmVhZGFibGVDb2xvciIsImxpZ2h0UmV0dXJuQ29sb3IiLCJkYXJrUmV0dXJuQ29sb3IiLCJyZ2JUb0NvbG9yU3RyaW5nIiwic2F0dXJhdGUiLCJjdXJyaWVkU2F0dXJhdGUiLCJzZXRIdWUiLCJjdXJyaWVkU2V0SHVlIiwic2V0TGlnaHRuZXNzIiwiY3VycmllZFNldExpZ2h0bmVzcyIsInNldFNhdHVyYXRpb24iLCJjdXJyaWVkU2V0U2F0dXJhdGlvbiIsInNoYWRlIiwicGVyY2VudGFnZSIsImN1cnJpZWRTaGFkZSIsInRpbnQiLCJjdXJyaWVkVGludCIsInRyYW5zcGFyZW50aXplIiwiY3VycmllZFRyYW5zcGFyZW50aXplIiwiYW5pbWF0aW9uIiwibXVsdGlNb2RlIiwiYXJnIiwiYmFja2dyb3VuZEltYWdlcyIsInByb3BlcnRpZXMiLCJiYWNrZ3JvdW5kcyIsImJhY2tncm91bmQiLCJzaWRlTWFwIiwic2lkZUtleXdvcmQiLCJ1bnNoaWZ0IiwiYm9yZGVyUmFkaXVzIiwic2lkZSIsInJhZGl1cyIsInVwcGVyY2FzZVNpZGUiLCJnZW5lcmF0ZVNlbGVjdG9ycyIsInN0YXRlIiwic3RhdGVTdWZmaXgiLCJzdGF0ZWZ1bFNlbGVjdG9ycyIsInN0YXRlcyIsInN0YXRlTWFwIiwic2VsZWN0b3JzIiwiYnV0dG9ucyIsInBvc2l0aW9uTWFwJDEiLCJwb3NpdGlvbktleXdvcmQiLCJzaXplIiwic3RhdGVNYXAkMSIsInRlbXBsYXRlJDEiLCJ0ZXh0SW5wdXRzIiwidHJhbnNpdGlvbnMiLCJ0cmFuc2l0aW9uc1N0cmluZyIsInRyYW5zaXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/polished/dist/polished.es.js\n");

/***/ })

};
;